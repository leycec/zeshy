#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *interactive input testers* (i.e., functions testing such input).
/---

# ....................{ TESTERS ~ character                }....................
:func.document <<'/---'
[status: boolean] is_input_character_yes()

Return success if a single character interactively entered by the current user
is the default affirmative answer for the current locale (e.g., `y` or `Y`,
assuming English) or failure otherwise, blocking until a character is entered.
/---
function is_input_character_yes() {
    # Validate sanity.
    die_if_args
    die_unless_stdin_terminal

    # Test such answer. Since such answer has (usually) been output to the
    # current terminal as "y" or "Y", avoid outputting such answer again.
    run_code_silent read -eq
}

#FIXME: Rename to is_queried_character_yes:() and similarly elsewhere. While a
#minor nomenclature change, it does wonders for improving readability.
:func.document <<'/---'
[stdout: string, status: boolean] is_query_character_yes(string query)

Return success if the next character interactively input by the current user is
the default positive response to yes/no questions for the current locale (e.g.,
`y` or `Y`, assuming English) or failure otherwise. Print the passed query
before requesting such input. Block until a character is input.
/---
function is_query_character_yes() {
    # Validate sanity.
    die_unless_arg 'Expected one query.'
    string query="${1}" response
    list characters_yes characters_no

    # Lists of positive and negative responses to such query.
    set_list_to_locale_characters_yes characters_yes
    set_list_to_locale_characters_no  characters_no

    # Print such query and set such string to the current user's response.
    set_string_to_query_character_for_choices_default_and_nondefault\
        response "${query}" characters_no characters_yes

    # Test such answer.
    is_string_matches_pcre "${response}" "$(get_locale_pcre_yes)"
}

# ....................{ TESTERS ~ line                     }....................
#FIXME: Rename to is_query_line_YES() and create a new is_query_line_yes()
#function merely requiring "yes" rather than "YES". For safety, all existing
#calls to is_query_line_yes() should be shifted to is_query_line_YES().
#FIXME: This clearly requires use of an approach as above. The line:
#    set_string_to_query_line answer "${question}${answers}"
#...is the problem below. The list of possible answers needs to be passed as a
#list of string arguments rather than coerced into the query string.
#FIXME: "[YES/no]" is locale-specific and hence requires localization.

:func.document <<'/---'
[status: boolean] is_query_line_yes(
    string query,
    string answers = " [YES/no] ",
    string answer_yes = "YES")

Return success if a *single line* (i.e., newline-delimited string otherwise
containing no newlines) interactively entered by the current user is the default
affirmative answer for the current locale (e.g., `YES`, assuming English) or
failure otherwise, printing the passed question before receiving such input and
blocking until the first newline is entered.

This stronger alternative to is_query_character_yes() is
intended for questions whose confirmation carries permanent potentially harmful
consequences (e.g., data loss).
/---
function is_query_line_yes() {
    # Validate sanity.
    die_unless_args_1_to_3\
        'Expected one query, optional answers, and optional yes answer.'
    die_unless_stdin_terminal
    string\
        question="${1}"\
        answers\
        answer_yes="${3:-YES}"\
        answer

    #FIXME: Hack! Shift such functionality to set_string_to_query_line().
    list list_choice_default__sstqc list_choice_nondefault__sstqc
    list_choice_default__sstqc=( 'no' )
    list_choice_nondefault__sstqc=( 'YES' )
    string\
        list_name_choice_default__sstqc='list_choice_default__sstqc'\
        list_name_choice_nondefault__sstqc='list_choice_nondefault__sstqc'\
        style_prefix__sstqc='set_string_to_query_line.prompt.'\
        border_left__sstqc\
        parens_left__sstqc\
        parens_right__sstqc\
        choice_default__sstqc\
        choice_nondefault__sstqc\
        choice_delimiter__sstqc\
        input__sstqc

    # Prompt substrings to be printed.
    border_left__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}border_left]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstqc}border_left]-}"
    parens_left__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}parens_left]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstqc}parens_left]-[}"
    parens_right__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}parens_right]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstqc}parens_right]-] }"
    choice_default__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}choice_default]-}$(join_list "${list_name_choice_default__sstqc}")"
    choice_nondefault__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}choice_nondefault]-}$(join_list "${list_name_choice_nondefault__sstqc}")"
    choice_delimiter__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}choice_delimiter]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstqc}choice_delimiter]-/}"
    input__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}input]-}"

    if { is_args_2 } {
        answers="${2}"
    } else {
        answers="${border_left__sstqc}${parens_left__sstqc}${choice_default__sstqc}${choice_delimiter__sstqc}${choice_nondefault__sstqc}${parens_right__sstqc}${input__sstqc}"
#       answers=' '${ZESHY_COLOR[color.grey]-}'['${ZESHY_COLOR[color.blue]-}'YES'${ZESHY_COLOR[color.grey]-}'/'${ZESHY_COLOR[color.blue]-}'no'${ZESHY_COLOR[color.grey]-}'] '
    }

    # Print such question and get such answer.
    set_string_to_query_line answer "${question} ${answers}"

    # Test such answer.
    is_string_equals "${answer}" "${answer_yes}"
}

#FIXME: In lieu of unit tests...
#function queo() {
#    is_query_character_yes 'Really, whombolo?'
#   is_query_line_yes 'Really, whombolo?'
#}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Awkward nomenclature. The "yes" is the crux of it, really. How about
#is_input_character_positive() or is_input_character_affirmative() instead? I
#rather prefer the former, I think.
#FUXME: Rename to is_input_character_ok:()! Yea.

#FUXME: "[yn]" is locale-specific and hence requires localization.
#FUXME: Improve documentation, including styles referenced by this function.
#   print_query_prompt\
#       "${list_name_choice_default__sstqc}"\
#       "${list_name_choice_nondefault__sstqc}"
#* `set_string_to_query_character.prompt.border_left`, styling the *left prompt
#  border* (i.e., the first substring to be printed), defaulting to the empty
#  string.
#* `set_string_to_query_character.prompt.${style_prefix}border_continued_left` and
#  `${style_prefix}border_continued_right`, styling the left and right borders of
#  all lines wrapped from such string except the first such line, defaulting to
#  the values of `${style_prefix}border_left` and `${style_prefix}border_right`.
#* `set_string_to_query_character.prompt.input`, styling the input character.

    # Validate sanity.
#   die_unless_args_1_to_3\
#       'expected one question, optional answers, and optional yes answer'
#   die_unless_stdin_terminal
#   string\
#       question="${1}"\
#       answer\
#       style_prefix\
#       choice_parens_left\
#       choice_parens_right\
#       choice_default\
#       choice_nondefault

    #FUXME: This is terrible. Embed such characters into the current function.
    #Incidentally, I recall a builtin zsh mechanism for obtaining such
    #characters from "glibc". Grep through "io/locale" a bit, eh? It'd be nice
    #to get such functionality up. Ah, yes! I dimly recall. We use the same
    #mechanism for obtaining the character used to delimit thousand places in
    #sufficiently long integers.

    # Characters to be input.
#   answer_yes='y'
#   answer_no='n'

    #FUXME: Not quite right. The " [yn] " should be shifted to the following input line,
    #immediately preceding the character to be input. We'll probably need to extend
    #set_string_to_query_character() into a new function
    #set_string_to_query_character_and_choices(). The choices
    #passed to such function should be simple uncolored strings (e.g., "y",
    #"n"). I suppose the first such passed string could be taken to be the
    #default and all subsequent such passed strings non-default alternatives.
    #Such function should delimit such alternatives with a new style
    #"${style_prefix}choice_delimiter", defaulting to the empty string.

    # Substrings to be printed.
#   choice_parens_left="${ZESHY_STYLE_TO_COLOR[${style_prefix}choice_parens_left]-}${ZESHY_STYLE_TO_TEXT[${style_prefix}choice_parens_left]- [}"
#   choice_parens_right="${ZESHY_STYLE_TO_COLOR[${style_prefix}choice_parens_right]-}${ZESHY_STYLE_TO_TEXT[${style_prefix}choice_parens_right]-] }"
#   choice_default="${ZESHY_STYLE_TO_COLOR[${style_prefix}choice_default]-}${answer_no}"
#   choice_nondefault="${ZESHY_STYLE_TO_COLOR[${style_prefix}choice_nondefault]-}${answer_yes}"

    # Print such question and get such answer.
#   set_string_to_query_character answer\
#       "${question}${choice_parens_left}${choice_nondefault}${choice_default}${choice_parens_right}"

    # Test such answer.
#   is_string_equals_caseless "${answer}" "${answer_yes}"
#}

#   answer_yes="${ZESHY_STYLE_TO_TEXT[${style_prefix}choice_nondefault]-y}"
#   answer_no="${ZESHY_STYLE_TO_TEXT[${style_prefix}choice_default]-n}"

#FUXME: Rename to is_query_character_yes().
#FUXME: Rename to is_query_line_yes().

#FUXME: Not fond of default values. Extract the main implementation into a new
#is_input_character_for_question_equals().
#   string answers = " [yn] ",
#   character answer_yes = "y")

#function is_query_character_yes() {
#    # Validate sanity.
#    die_unless_args_1_to_3\
#        'expected one question, optional answers, and optional yes answer'
#    die_unless_stdin_terminal
#    string\
#        question="${1}"\
#        answers="${2:- ${ZESHY_COLOR[is_query_character_yes.parens_left]}[${ZESHY_COLOR[blue]}y${ZESHY_COLOR[blue_bold]}n${ZESHY_COLOR[grey]}] }"\
#        answer_yes="${3:-y}"\
#        answer
#
#    # Print such question and get such answer.
#    set_string_to_query_character answer "${question}${answers}"
#
#    # Test such answer.
#    is_string_equals_caseless "${answer}" "${answer_yes}"
#}

#FUXME: Rename "answer" to "answer" everywhere below.
