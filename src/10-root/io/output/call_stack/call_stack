#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *call stack outputters* (i.e., functions printing the current call stack,
typically employed for printing exception stack traces).
/---

#FIXME: We *REALLY* want a new function die_unless_style_prefix() throwing an
#exception unless the passed style prefix "exists" in the loosest sense of that
#verb (i.e., unless such string prefixes at least one key of either
#${ZY_STYLE_TO_COLOR} or ${ZY_STYLE_TO_TEXT} -- or perhaps simply the
#former, which should invariably be the case for *ANY* defined style).
#FIXME: Hmm; or perhaps merely a function warn_unless_style_prefix(). Throwing
#an exception seems fairly heavy- handed, but a warning would be welcome.
#FIXME: Actually, this is complete nonsense. If the codebase is sufficiently
#robust, this is a non-issue. And it should be. Hence, a non-issue. This
#directly implies *ALL* such functionality should be refactored to actually
#call existing zeshy functionality. *sigh*

# For fault tolerance in exception handlers, avoid calling other functions in
# such functions unless explicitly preceding such calls with tests of whether
# such functions are still defined or not.

# ....................{ PRINTERS                           }....................
#FIXME: Shift elsewhere. *shrug*
:func.doc <<'/---'
string print_call_stack()

Print a trace of the current call stack to standard output. See
output_call_stack_lists_in_style() for further details.
/---
function print_call_stack() {
    # Validate sanity.
    die_if_args

    # Print such stack.
    :print_stdout_separated_start
    output_call_stack_lists_in_style\
        funcstack funcfiletrace funcsourcetrace "${0}."
    :print_stdout_separated_stop
}

# ....................{ OUTPUTTERS                         }....................
#FIXME: There appears to be a very curious oddity in zsh; sourcing a zsh script
#containing the line "return 1" produces the expected call stack, resembling:
#
#./tmpy.zsh: failed with exit status 1
#    \_ curse_call_stack() { /home/leycec/zsh/zeshy/src/main: 418 }
#     \_ handle_exception() { /home/leycec/zsh/zeshy/src/main: 8458093679346917924 }
#      \_ TRAPZERR() { ./tmpy.zsh: 2 }
#       \_ ./tmpy.zsh { zsh: 32 }
#
#Running a zsh script containing the line "exit 1" as a command, however,
#produces call stacks resembling:
#
#TRAPZERR: failed with exit status 20
#    \_ curse_call_stack() { /home/leycec/zsh/zeshy/src/main: 418 }
#     \_ handle_exception() { /home/leycec/zsh/zeshy/src/main: 7955925549229362501 }
#      \_ TRAPZERR() { /bin/zsh: 31 }
#
#In the latter case, zsh reports the call stack to contain no such command. But
#it gets worse! zsh fails to include commands in *ALL* call stacks; try
#"command ls zzmmmm", for example. This tends to produce inherently senseless
#error output. I suggest one of two solutions:
#
#* If "TRAPZERR" is the top of the call stack, print no call stack. (It's
#  meaningless, so don't even bother.) This is most certainly the simplest
#  solution. (Actually, I tried this. It blatantly sucks.)
#* Forcefully add the expected command to the top of the call stack. This is
#  much better, since the prior solution still crudely reports
#  "TRAPZERR: failed with exit status 20" when in fact we expect
#  "./tmpy.zsh: failed with exit status 1". Just not sure how to *GET* the
#  expected command name or exit status.

#FIXME: Documentation requires slight revision. This function actually omits all
#leading stack frames matching glob
#('output_call_stack'|'print_exception')(|'_'*). (Actually, even this glob is
#now outdated. Probably best just to qualitatively describe such glob.)
#FIXME: Document styles.

:func.doc <<'/---'
string output_call_stack_lists_in_style_caller(
    string funcstack_list_name,
    string funcfiletrace_list_name,
    string funcsourcetrace_list_name)

Output a trace of the call stack encapsulated by the passed instances of
canonical list globals ${funcstack}, ${funcfiletrace}, and ${funcsourcetrace} to
standard output, using user-configurable styles prefixed by the dot-suffixed
caller's name followed by `.stack` (i.e., `$(:caller.get).stack.`). See
output_call_stack_lists() for further details.
/---
function output_call_stack_lists_in_style_caller() {
    # Validate sanity.
    die_unless_args_3\
        'Expected one ${funcstack} list name, one ${funcfiletrace} list name, and one ${funcsourcetrace} list name.'
    :str caller

    # Caller name.
    :set_string_to_caller caller

    # Output such title.
    output_call_stack_lists_in_style\
        "${@}" "${caller}.stack."
}

#FIXME: While the output is significantly more aesthetic than previously, it
#still suffers a critical defect: line wrapping. Due to our horizontal
#alignment of caller metadata, we now output long lines resembling:
#
#┖┰┈┈┈┈┈• :die() ≪⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯· “/home/leycec/.zeshy/cache/digest/debug.zwc/die_unless_symlink” • 5
# ┖┰┈┈┈┈• die_unless_symlink() ≪⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯· “/home/leycec/.zeshy/cache/digest/debug.zwc/:is_symlink_broken” • 4
#
#This isn't terribly readable or aesthetic. Such lines should be wrapped: e.g.,
#
#┖┰┈┈┈┈┈• :die() •┈┒
# ┋ “/home/leycec/.zeshy/cache/digest/debug.zwc/die_unless_symlink” • 5
# ┖┰┈┈┈┈• die_unless_symlink() •┈┒
#  ┋ “/home/leycec/.zeshy/cache/digest/debug.zwc/:is_symlink_broken” • 4
#
#Considerably better, wouldn't you say? Revising such output *WILL* be a bit of
#an effort, but (hopefully) nowhere near as painful as the prior revision.
#FIXME: Incidentally, there's little to no reason to output the *ENTIRE*
#absolute path of the current digest file for each function call of such stack.
#Instead, simply output such digest file's basename -- or perhaps just the
#absolute path of a *THEORETICAL* symbolic link to such file with the current ${HOME}
#prefixing such path replaced by "~/" (e.g., "~/.zeshy/cache/digest/current").
#(Obviously, we can't actually create such link, but... hey. Why not just print
#it as if such link existed?)

:func.doc <<'/---'
string output_call_stack_lists_in_style(
    string funcstack_list_name,
    string funcfiletrace_list_name,
    string funcsourcetrace_list_name,
    string style_prefix)

Output a trace of the call stack encapsulated by the passed instances of
canonical list globals ${funcstack}, ${funcfiletrace}, and ${funcsourcetrace} to
standard output, using user-configurable styles prefixed by the passed prefix.
Such trace consists of all previously called functions, sourced scripts, and
eval() statements in the current call path, excluding only the stack frame of
the caller's call to this function.

If ::exception.print_uncaught() called this function (the typical case), both
the call to this function by ::exception.print_uncaught() _and_ the call to
::exception.print_uncaught() will be omitted from the output. As implementation
details of `zeshy`-specific exception handling, such calls convey no meaningful
context to end consumers of exception stack traces.

== Call Stack Globals ==

Module `zsh/parameter` exports four call stack-centric list globals:
${funcfiletrace}, ${funcsourcetrace}, ${funcstack}, and ${functrace}.

=== ${funcfiletrace} and ${funcsourcetrace} ===

Each element of ${funcfiletrace} and ${funcsourcetrace} provides the `:`-
delimited line number and filename of the corresponding runnable in the call
stack. In the case of ${funcfiletrace}, such line numbers and filenames specify
the *point of call* of such runnables (i.e., the line at which such runnable was
called in such file); in the case of ${funcsourcetrace}, such line numbers and
filenames specify the *point of definition* of such runnables (i.e., the line at
which such runnable was defined in such file).

For most purposes (including outputting call stacks), points of call are more
helpful than points of definition. However, the latter do provide unique
metadata _not_ provided by any other such list: namely, the capacity to
distinguish whether a runnable was a called function or sourced file. Since
function names may contain arbitrary characters and filenames arbitrary
characters excluding `/` and `\0`, there exists no general-purpose means of
distinguishing between the two merely on the basis of name alone.

Happily, ${funcsourcetrace} circuitously corrects this issue. If a runnable was
a sourced file, the corresponding element of ${funcsourcetrace} is suffixed by
`:0`; else, such element is suffixed by `:${line_number}`, where
`${line_number}` is a strictly positive integer.

Hence, this function requires both lists.

=== ${funcstack} ===

Each element of ${funcstack} provides the name of the corresponding runnable in
the call stack. Since neither ${funcfiletrace} or ${funcsourcetrace} provide
such metadata, this function also requires the ${funcstack} for such call stack.

=== ${functrace} ===

Each element of ${functrace} provides the `:`-delimited line number and filename
of the point of call for the corresponding runnable in the call stack. Since
such line number is relative to the start of the runnable rather than file
containing such call _and_ since ${funcfiletrace} already provides such line
number and filename in *absolute form* (i.e., relative to the file rather than
runnable containing such call), this function does _not_ require such list.

== Caveats ==

*Consider redirecting such output to standard error*, especially when
accompanying such stack with error or warning messages. Doing so ensures that
calling this function from process substitutions (e.g., `$(get_zsh_version)`)
implicitly outputs to the terminal device attached to the current shell rather
than into a string captured by such shell.
/---
function output_call_stack_lists_in_style() {
    # Validate sanity. For safety, avoid calling other functions both here and
    # below that might conceivably throw exceptions or no longer exist. On the
    # other hand, since zsh expands aliases at function definition time,
    # expanding aliases is quite safe.
    die_unless_args_4\
        'Expected one ${funcstack} list name, one ${funcfiletrace} list name, one ${funcsourcetrace} list name, and one style prefix.'
    string\
        funcstack_name__ocsl="${1}"\
        funcfiletrace_name__ocsl="${2}"\
        funcsourcetrace_name__ocsl="${3}"\
        style_prefix="${4}"\
        frame_first_style_prefix\
        frame_midst_style_prefix\
        frame_last_style_prefix\
        callee_style_prefix\
        caller_style_prefix\
        indentation__ocsl\
        first_frame_corner_left__ocsl\
        first_frame_forker_left__ocsl\
        first_frame_border_left__ocsl\
        first_frame_joiner_left__ocsl\
        midst_frame_corner_left__ocsl\
        midst_frame_forker_left__ocsl\
        midst_frame_border_left__ocsl\
        midst_frame_joiner_left__ocsl\
        last_frame_corner_left__ocsl\
        last_frame_forker_left__ocsl\
        last_frame_border_left__ocsl\
        last_frame_joiner_left__ocsl\
        callee_name__ocsl\
        caller_corner_left__ocsl\
        caller_border_left__ocsl\
        caller_border_left_repeated__ocsl\
        caller_joiner_left__ocsl\
        caller_filename_prefix__ocsl\
        caller_filename__ocsl\
        caller_filename_suffix__ocsl\
        caller_line_prefix__ocsl\
        caller_line_suffix__ocsl
    integer\
        count__ocsl\
        index__ocsl\
        first_frame_forker_left_length__ocsl\
        callee_name_length__ocsl\
        callee_name_length_max__ocsl\
        caller_line__ocsl
    list callee_names__ocsl callee_name_lengths__ocsl
#   print "style prefix: ${style_prefix}"

    # Styles for the first, last, and all intervening stack frames.
    frame_first_style_prefix="${style_prefix}frame_first."
    frame_midst_style_prefix="${style_prefix}frame_midst."
    frame_last_style_prefix="${style_prefix}frame_last."
    callee_style_prefix="${style_prefix}callee."
    caller_style_prefix="${style_prefix}caller."

    # If any such list is undefined or not a list, fail. See :List.is() for
    # further details.
    is "${(tP)funcstack_name__ocsl-}~~~${(tP)funcfiletrace_name__ocsl-}~~~${(tP)funcsourcetrace_name__ocsl-}" ==\
       'array'*'~~~array'*'~~~array'* si or :die\
        "\${${funcstack_name__ocsl}}, \${${funcfiletrace_name__ocsl}}, and/or \${${funcsourcetrace_name__ocsl}} undefined or not lists."

    # Size of the first such list computed *BEFORE* possibly truncating such
    # list below. See get_list_size() for further details.
    count__ocsl="${#${(@P)funcstack_name__ocsl}}"

    # If such lists are of unequal size, throw an exception.
    (( count__ocsl == ${#${(@P)funcfiletrace_name__ocsl}} &&\
       count__ocsl == ${#${(@P)funcsourcetrace_name__ocsl}} )) or :die\
       "List \${${funcstack_name__ocsl}\} size ${count__ocsl} unequal to list \${${funcfiletrace_name__ocsl}\} size ${#${(@P)funcfiletrace_name__ocsl}} and/or list \${${funcfiletrace_name__ocsl}\} size ${#${(@P)funcfiletrace_name__ocsl}}."

    # If the desired call stack is the current call stack, ignore the current
    # function and all directly preceding such call stack functions *BEFORE*
    # performing further validation. See
    # output_call_stack_index_lists_and_style_prefix() for further details.
    if is "${funcstack_name__ocsl}" == 'funcstack' si {
        # For obvious reasons, skip the first such index. Since this guarantees
        # such index to exceed 1, a list copy is *ALWAYS* required.
        integer  index_first__ocsl=2
        while (( index_first__ocsl <= count__ocsl )) and
            is "${${(@P)funcstack_name__ocsl}[${index_first__ocsl}]}" ==\
                ('output'|'print')'_call_stack'(|'_'*) si {
#           print "funcstack_name__ocsl[${index_first__ocsl}]: ${${(@P)funcstack_name__ocsl}[${index_first__ocsl}]}; indices: ${index_first__ocsl} / ${count__ocsl}"
            index_first__ocsl+=1
        }

        # Do *NOT* quote list slices, as that merely concatenates elements.
        #
        # If such index exceeds the last valid index, zsh will clear all
        # lists below without error, resulting in a zero count and this function
        # silently reporting success below. Since this is exactly as expected,
        # such index need *NOT* be validated here.
        list funcstack__ocsl funcfiletrace__ocsl funcsourcetrace__ocsl
        funcstack__ocsl=(       ${funcstack[${index_first__ocsl},-1]} )
        funcfiletrace__ocsl=(   ${funcfiletrace[${index_first__ocsl},-1]} )
        funcsourcetrace__ocsl=( ${funcsourcetrace[${index_first__ocsl},-1]} )
        funcstack_name__ocsl='funcstack__ocsl'
        funcfiletrace_name__ocsl='funcfiletrace__ocsl'
        funcsourcetrace_name__ocsl='funcsourcetrace__ocsl'

        # Recompute such list size *AFTER* truncating such list above.
        count__ocsl="${#${(@P)funcstack_name__ocsl}}"
    }

    # If there are no stack frames to be printed, silently report success.
    (( count__ocsl )) or :success.report

    # Substrings to be measured (but not repeated) below and hence *NOT* yet
    # injected with color.
    first_frame_forker_left__ocsl="${ZY_STYLE_TO_TEXT[${frame_first_style_prefix}forker_left]-\\}"

    # Lengths of such substrings computed *BEFORE* injecting colors into such
    # substrings below. See get_string_ansiless_length_printable() for further
    # details.
    first_frame_forker_left_length__ocsl="${(m)#first_frame_forker_left__ocsl}"

    # Substrings to be repeated below and hence never injected with color. Since
    # :set_string_to_string_ansiless_repeated_to_length() requires strings *NOT*
    # containing colors, shift such colors to preceding substrings.
    first_frame_border_left__ocsl="${ZY_STYLE_TO_TEXT[${frame_first_style_prefix}border_left]-_}"
    midst_frame_border_left__ocsl="${ZY_STYLE_TO_TEXT[${frame_midst_style_prefix}border_left]-_}"
    last_frame_border_left__ocsl="${ZY_STYLE_TO_TEXT[${frame_last_style_prefix}border_left]-_}"
    caller_border_left__ocsl="${ZY_STYLE_TO_TEXT[${caller_style_prefix}border_left]--}"

    # Substrings prefixing each line printed below.
    first_frame_corner_left__ocsl="${ZY_STYLE_TO_COLOR[${frame_first_style_prefix}corner_left]-}${ZY_STYLE_TO_TEXT[${frame_first_style_prefix}corner_left]-}"
    first_frame_forker_left__ocsl="${ZY_STYLE_TO_COLOR[${frame_first_style_prefix}forker_left]-}${first_frame_forker_left__ocsl}${ZY_STYLE_TO_COLOR[${frame_first_style_prefix}border_left]-}"
    first_frame_joiner_left__ocsl="${ZY_STYLE_TO_COLOR[${frame_first_style_prefix}joiner_left]-}${ZY_STYLE_TO_TEXT[${frame_first_style_prefix}joiner_left]- }"
    midst_frame_corner_left__ocsl="${ZY_STYLE_TO_COLOR[${frame_midst_style_prefix}corner_left]-}${ZY_STYLE_TO_TEXT[${frame_midst_style_prefix}corner_left]-}"
    midst_frame_forker_left__ocsl="${ZY_STYLE_TO_COLOR[${frame_midst_style_prefix}forker_left]-}${ZY_STYLE_TO_TEXT[${frame_midst_style_prefix}forker_left]-\\}${ZY_STYLE_TO_COLOR[${frame_midst_style_prefix}border_left]-}"
    midst_frame_joiner_left__ocsl="${ZY_STYLE_TO_COLOR[${frame_midst_style_prefix}joiner_left]-}${ZY_STYLE_TO_TEXT[${frame_midst_style_prefix}joiner_left]- }"
    last_frame_corner_left__ocsl="${ZY_STYLE_TO_COLOR[${frame_last_style_prefix}corner_left]-}${ZY_STYLE_TO_TEXT[${frame_last_style_prefix}corner_left]-}"
    last_frame_forker_left__ocsl="${ZY_STYLE_TO_COLOR[${frame_last_style_prefix}forker_left]-}${ZY_STYLE_TO_TEXT[${frame_last_style_prefix}forker_left]-\\}${ZY_STYLE_TO_COLOR[${frame_last_style_prefix}border_left]-}"
    last_frame_joiner_left__ocsl="${ZY_STYLE_TO_COLOR[${frame_last_style_prefix}joiner_left]-}${ZY_STYLE_TO_TEXT[${frame_last_style_prefix}joiner_left]- }"
#   print "corner left first: ${first_frame_corner_left__ocsl}"

    # All other substrings printed below.
    caller_corner_left__ocsl="${ZY_STYLE_TO_COLOR[${caller_style_prefix}corner_left]-}${ZY_STYLE_TO_TEXT[${caller_style_prefix}corner_left]-< }${ZY_STYLE_TO_COLOR[${caller_style_prefix}border_left]-}"
    caller_joiner_left__ocsl="${ZY_STYLE_TO_COLOR[${caller_style_prefix}joiner_left]-}${ZY_STYLE_TO_TEXT[${caller_style_prefix}joiner_left]-- }"
    caller_filename_prefix__ocsl="${ZY_STYLE_TO_COLOR[${caller_style_prefix}filename_prefix]-}${ZY_STYLE_TO_TEXT[${caller_style_prefix}filename_prefix]-\"}${ZY_STYLE_TO_COLOR[${caller_style_prefix}filename]-}"
    caller_filename_suffix__ocsl="${ZY_STYLE_TO_COLOR[${caller_style_prefix}filename_suffix]-}${ZY_STYLE_TO_TEXT[${caller_style_prefix}filename_suffix]-\"}"
    caller_line_prefix__ocsl="${ZY_STYLE_TO_COLOR[${caller_style_prefix}line_prefix]-}${ZY_STYLE_TO_TEXT[${caller_style_prefix}line_prefix]-: }${ZY_STYLE_TO_COLOR[${caller_style_prefix}line]-}"
    caller_line_suffix__ocsl="${ZY_STYLE_TO_COLOR[${caller_style_prefix}line_suffix]-}${ZY_STYLE_TO_TEXT[${caller_style_prefix}line_suffix]-}"

    # Repeat each border substring sufficiently many times to ensure vertical
    # alignment of the callee name following such border. For generality,
    # implement the fallback rather than optimized logic of repeat_string(). See
    # such function for further details.
    #
    # Under default zeshy styles, two common alignment schemes are as follows:
    #
    #    ┎┈┈┈•
    #    ┖┰┈┈•
    #     ┖┰┈•
    #      ┖┈•
    #
    #    ┖┰┈┈•
    #     ┖┰┈•
    #      ┖┈•
    #
    # As prior examples demonstrates, the first frame requires one substring
    # less than the frame count of such border, the last frame exactly one
    # such substring, and every other frame one less such substring than the
    # prior frame. Since the last frame requires only one substring, such
    # substring need not be repeated here.
    :set_string_to_string_ansiless_repeated_to_length\
        first_frame_border_left__ocsl\
        "${first_frame_border_left__ocsl}"\
        $(( count__ocsl - 1 ))
    :set_string_to_string_ansiless_repeated_to_length\
        midst_frame_border_left__ocsl\
        "${midst_frame_border_left__ocsl}"\
        $(( count__ocsl - 1 ))

    #FIXME: Sufficiently long caller runnable names *AND* callee filenames
    #should be truncated to avoid exceeding line length. To best preserve
    #information despite truncation, replace the middle rather than beginning or
    #end of such names with a single Unicode ellipsis. While a bit non-trivial,
    #it would be particularly nice to define a new utility function -- say,
    #"string :output_string_truncated_to_length(string text, integer length)"
    #doing so. Note: finding the "middle" of the string to be replace should
    #prove interesting!

    # Find the length of the longest callee runnable, used by iteration below to
    # add sufficient padding between callee and caller metadata to horizontally
    # align the latter into a proper column. In other words, purely aesthetic.
    #
    # To reduce the cost of such iteration, cache the callee names and lengths
    # of such names produced by such iteration to the corresponding elements of
    # local lists. Subsequent iteration reuses such caches rather than
    # reproducing such values.
    callee_name_length_max__ocsl=0
    for (( index__ocsl  = 1;
           index__ocsl <= count__ocsl;
           index__ocsl++ )) {
        # Callee name for the current stack frame.
        set_string_to_call_stack_lists_index_in_style\
            callee_name__ocsl\
            "${funcstack_name__ocsl}"\
            "${funcsourcetrace_name__ocsl}"\
            "${index__ocsl}"\
            "${style_prefix}callee."

        # Length of such name excluding ANSI escape sequences.
        :set_int_to_string_length_printable\
            callee_name_length__ocsl "${callee_name__ocsl}"

        # Cache such values for reuse in subsequent iteration.
        callee_names__ocsl[${index__ocsl}]="${callee_name__ocsl}"
        callee_name_lengths__ocsl[${index__ocsl}]="${callee_name_length__ocsl}"

        # If such length exceeds the current maximum, replace such maximum.
        if (( callee_name_length__ocsl > callee_name_length_max__ocsl )) {
              callee_name_length_max__ocsl="${callee_name_length__ocsl}"
        }
    }
#   print "callee name length max: ${callee_name_length_max__ocsl}"

    # Print such stack, excluding the call to this function.
    for (( index__ocsl  = 1;
           index__ocsl <= count__ocsl;
           index__ocsl++ )) {
        # If this is the last stack frame to be printed, prefix such frame with
        # adornment specific to such frame.
        #
        # However, an edge case question arises: should traces consisting of
        # only one frame prefix such frame as though it were the first or last
        # such frame? Since the latter choice provides marginally better output
        # under default styles, this function privelages such output.
        # Specifically, test whether this frame is the last *BEFORE* testing
        # whether this frame is the first.
        if (( index__ocsl == count__ocsl )) {
            :str.output_sans_newline\
                "${indentation__ocsl}${last_frame_corner_left__ocsl}${last_frame_forker_left__ocsl}${last_frame_border_left__ocsl}${last_frame_joiner_left__ocsl}"
        # If this is the first stack frame to be printed, prefix such frame with
        # adornment specific to such frame.
        } elif (( index__ocsl == 1 )) {
            :str.output_sans_newline\
                "${first_frame_corner_left__ocsl}${first_frame_forker_left__ocsl}${first_frame_border_left__ocsl}${first_frame_joiner_left__ocsl}"

            # If the forker for such prefix is nonempty, indent the next frame
            # to the right, ensuring the first but *NOT* second of the following
            # two example styles to be indented (as expected):
            if (( first_frame_forker_left_length__ocsl )) {
                indentation__ocsl+=' '
            }
        # Else, prefix such frame with customary adornment.
        } else {
            # Truncate such border by one arbitrary character. For simplicity,
            # snip off the rightmost character.
            midst_frame_border_left__ocsl="${midst_frame_border_left__ocsl[1,-2]}"

            # Output such prefix.
            :str.output_sans_newline\
                "${indentation__ocsl}${midst_frame_corner_left__ocsl}${midst_frame_forker_left__ocsl}${midst_frame_border_left__ocsl}${midst_frame_joiner_left__ocsl}"

            # Indent the next frame to the right *AFTER* printing the prefix for
            # the current frame. See prior output examples.
            indentation__ocsl+=' '
        }

        # Repeat the intra-border substring sufficiently many times to
        # vertically align the caller filename following such border: e.g.,
        #
        #    01234567890
        #    anaximander() ≪⋯·
        #    diogenes() ≪⋯⋯⋯⋯·
        #    hegel() ≪⋯⋯⋯⋯⋯⋯⋯·
        #    marx() ≪⋯⋯⋯⋯⋯⋯⋯⋯·
        #            76543210
        #
        # Given the prior example, the following computation crudely follows.
        :set_string_to_string_ansiless_repeated_to_length\
            caller_border_left_repeated__ocsl\
            "${caller_border_left__ocsl}"\
            $(( callee_name_length_max__ocsl -\
                callee_name_lengths__ocsl[${index__ocsl}] + 1 ))

        # File line and filename at which the caller of the prior stack frame
        # called the current stack frame. Split such ${funcfiletrace} element on
        # the last colon into such file line and filename, thus accounting for
        # possible colons in filenames (e.g., from "colon:blow:7" to filename
        # "colon:blow" and line number 7).
        caller_line__ocsl="${${(@P)funcfiletrace_name__ocsl}[${index__ocsl}]##*:}"
        caller_filename__ocsl="${${(@P)funcfiletrace_name__ocsl}[${index__ocsl}]%:*}"

        # Output such frame.
        :str.output\
            "${callee_names__ocsl[${index__ocsl}]}${caller_corner_left__ocsl}${caller_border_left_repeated__ocsl}${caller_joiner_left__ocsl}${caller_filename_prefix__ocsl}${caller_filename__ocsl}${caller_filename_suffix__ocsl}${caller_line_prefix__ocsl}${caller_line__ocsl}${caller_line_suffix__ocsl}"
    }
}

#FIXME: In lieu of unit tests...
#function yaso() {
#    print 'calling output_call_stack_title_in_style_caller()...'
#    output_call_stack_title_in_style_caller
#
#    print
#    print 'calling output_call_stack_lists_title_in_style()...'
#    print "$(\
#        output_call_stack_lists_title_in_style\
#        funcstack\
#        funcsourcetrace\
#        'print_exception.heading.') Huzzah!"
#
#    print
#    print 'calling print_call_stack()...'
#    function yasoyaso() { yasoyasoyaso }
#    function yasoyasoyaso() { yasoyasoyasoyaso }
#    function yasoyasoyasoyaso() {
#        print_call_stack
#    }
#    yasoyaso
#}

# --------------------( WASTELANDS                         )--------------------
            # If the corner for such prefix exceeds a single character, indent
            # the next frame to the right. Doing so ensures indentation under
            # the first but *NOT* second of the following two example styles:
            #
            #    ┖┰┈┈•
            #     ┖┰┈•
            #
            #    ┎┈┈┈•
            #    ┖┰┈┈•

#   function yasoyaso() { print_call_stack }
    # If any function called below is undefined, throw an exception. For
    # resilience, minimize the set of such functions.
#    { typeset -f\
#        :set_string_to_string_ansiless_repeated_to_length\
#        set_string_to_call_stack_lists_index_in_style } silent or :die\
#       ':set_string_to_string_ansiless_repeated_to_length() and/or :set_string_to_string_ansiless_repeated_to_length() undefined.'

#    first_frame_border_left__ocsl="$(printf -- "${first_frame_border_left__ocsl//\%/%%}%.0s" {1..$(( count__ocsl - 1 ))})"
#    midst_frame_border_left__ocsl="$(printf -- "${midst_frame_border_left__ocsl//\%/%%}%.0s" {1..$(( count__ocsl - 2 ))})"
    #FUXME: Such calculation assumes each border substring to be a single
    #character. Fine for now, of course, but contemplate generalization.
#    first_frame_border_left__ocsl="$(printf -- "${first_frame_border_left__ocsl//\%/%%}%.0s" {1..$(( count__ocsl - 1 ))})"
#    midst_frame_border_left__ocsl="$(printf -- "${midst_frame_border_left__ocsl//\%/%%}%.0s" {1..$(( count__ocsl - 2 ))})"

#       caller_border_left_repeated__ocsl="$(printf -- "${caller_border_left__ocsl//\%/%%}%.0s" {1..$(( callee_name_length_max__ocsl - callee_name_length__ocsl + 1 ))})"
        # Set and output the name of the current stack frame's runnable.
#        set_string_to_call_stack_lists_index_in_style\
#            callee_name__ocsl\
#            "${funcstack_name__ocsl}"\
#            "${funcsourcetrace_name__ocsl}"\
#            "${index__ocsl}"\
#            "${style_prefix}callee."
#
#        # Length of the current callee name excluding ANSI escape sequences.
#        :set_int_to_string_length_printable\
#            callee_name_length__ocsl "${callee_name__ocsl}"

        #FUXME: Replace with a call to :set_string_to_string_repeated_to_length().
        #Note, however, that such function takes the length of such string as
        #is (i.e., including ANSI escape sequences). Hence, the passed string
        #should *EXCLUDE* such sequences. This is certainly feasible. We could,
        #of course, also generalize a new function
        #:set_string_to_string_repeated_sans_ansi_to_length() or some such handling
        #this internally. The disadvantage in such a function is inefficiency --
        #quite a bit, if you consider the recomputation involved on each call to
        #such function. I'm inclined to shift the burden into this function, for
        #both efficiency and simplicity. Right!
        #:set_string_to_string_repeated_to_length() she is, then.
#       callee_names__ocsl[${index__ocsl}]="${callee_name__ocsl}"
#       callee_name_lengths__ocsl[${index__ocsl}]

#    for callee_name__ocsl ("${${(@P)funcstack_name__ocsl}[@]}") {
#        # Set and output the name of the current stack frame's runnable.
#        set_string_to_call_stack_lists_index_in_style\
#            callee_name__ocsl\
#            "${funcstack_name__ocsl}"\
#            "${funcsourcetrace_name__ocsl}"\
#            "${index__ocsl}"\
#            "${style_prefix}callee."
#
#        # Length of the current callee name excluding ANSI escape sequences.
#        :set_int_to_string_length_printable\
#            callee_name_length__ocsl "${callee_name__ocsl}"
#
#        #
#        # Length of the current runnable name. See get_string_ansiless_length_printable()
#        # for further details.
#        callee_name_length__ocsl="${(m)#callee_name__ocsl}"
#
#        # If such length exceeds the current maximum, replace such maximum.
#        if (( callee_name_length__ocsl > callee_name_length_max__ocsl )) {
#              callee_name_length_max__ocsl="${callee_name_length__ocsl}"
#        }
#    }

        #FUXME: Also, as always, the padding solution below *ONLY* behaves
        #properly if such substring is a single character. Here's what we really
        #need: a new setter sufficiently efficient that we can call it from
        #loops such as this without discernable penalty, setting a caller-
        #provided string to a passed string repeated sufficiently many times to
        #produce a string of a passed exact length -- say,
        #"void :set_string_to_string_repeated_to_length(
        #   string string_name,
        #   string padding,
        #   integer length)".
        #This should be quite doable. In fact, it's basically become necessary.
        #The current approach is suckage incarnate and plainly fails to scale.
        #FUXME: This implies such function must be moved under @{20-function},
        #along with all globals such function requires. *sigh*
        #FUXME: Comment this and uncomment the next command after such command
        #is working reasonably.
#        output_call_stack_lists_index_in_style\
#            "${funcstack_name__ocsl}"\
#            "${funcsourcetrace_name__ocsl}"\
#            "${index__ocsl}"\
#            "${style_prefix}callee."
#        callee_name__ocsl="${${(@P)funcstack_name__ocsl}[${index__ocsl}]}"

#FUXME: Such calculation assumes all callee runnable names to be printed
        #by the prior call to output_call_stack_lists_index_in_style()
        #such that the length of the printed output is greater than the length
        #of such names by the exact same amount. While this is the case with
        #default zeshy styles (i.e., "()"-suffixed function names, '"'-delimited
        #filenames, and "("- and ")"-delimited evaluations), this is *NOT*
        #necessarily the case with custom user-defined styles. Correcting this
        #is feasible but annoying. Contemplate!
        #FUXME: To do so, we'll need to extract the core of
        #output_call_stack_lists_index_in_style() into a new function
        #set_string_to_call_stack_lists_index_in_style(), called above
        #in place of the former as well as farther above in the loop calculating
        #${callee_name_length_max__ocsl}.
        #FUXME: Hm; this is slightly more important than I thought, as some but
        #not all runnable names in ${funcstack} contain such delimiters (namely,
        #filenames and evaluations but not function names). As currently
        #defined, the solution below is almost certainly inadequate for most
        #call stacks.

# See
        # prior substring repetition for further details.
#        caller_border_left_repeated__ocsl="$(printf -- "${caller_border_left__ocsl//\%/%%}%.0s" {1..$(( callee_name_length_max__ocsl - callee_name_length__ocsl + 1 ))})"

# See get_string_ansiless_length_printable()
        # for further details.
#       callee_name_length__ocsl="${(m)#callee_name__ocsl}"
        # Output such intra-border.
#        :str.output_sans_newline\
#            "${callee_name__ocsl}${caller_corner_left__ocsl}${caller_border_left_repeated__ocsl}${caller_joiner_left__ocsl}"
#
#        # Output such frame's caller metadata.
#        :str.output\
#            "${caller_filename_prefix__ocsl}${caller_filename__ocsl}${caller_filename_suffix__ocsl}${caller_line_prefix__ocsl}${caller_line__ocsl}${caller_line_suffix__ocsl}"

    # If such index exceeds the last valid index, no stack frames remain to
    # be printed, so report success silently.
    #    ┠┈┈┈•
    #    ┖┰┈┈•
    #     ┖┰┈•
    #      ┖┈•

#Helpful strings include: #◦‣╶
#   caller_parens_left__ocsl="${ZY_STYLE_TO_COLOR[${style_prefix}caller.parens_left]-}${ZY_STYLE_TO_TEXT[${style_prefix}caller.parens_left]-\{ }"
#   caller_parens_right__ocsl="${ZY_STYLE_TO_COLOR[${style_prefix}caller.parens_right]-}${ZY_STYLE_TO_TEXT[${style_prefix}caller.parens_right]-\{ }"
        #FUXME: Such color scheme is rather harsh, although appropriate for
        #exceptions. We probably want something gentler for defaults, however
        #(i.e., no reds or yellows; green would probably be appropriate). To
        #accomodate this, we'll need to rename output_call_stack_lists() to
        #output_call_stack_lists_in_style() and define a new
        #output_call_stack_lists() calling
        #output_call_stack_lists_in_style() with style prefix
        #"$(:caller.get).", as is customary. Hardly a priority, but important
        #to implement before going "live."

        # Or perhaps:
        #
        #   ┎┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈• mount_disk() •┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┒
        #   ┇ mount_boot_dir_writable() failed with 1:     ┇
        #   ┇ Expected no arguments.                       ┇
        #   ┇┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┚
        #   ┠┈•
        #   ┖┰┈•
        #    ┖┰┈•
        #     ┖┈┈•
        #
        # I vastly prefer the former, but admit the latter to be slightly
        # easier implemented. Bah! Just go with the former.

#footing
#tracing

#Output a trace of the current call stack to standard output, using user-
#configurable styles prefixed by the dot-suffixed caller's name (i.e.,
#`$(:caller.get).`). See output_call_stack_lists() for further details.

#consisting of all previously called
#functions, sourced files, and `eval` statements in the current call path,
#excluding only the stack frame of the caller's call to this function.

        #FUXME: It's possible index_first__ocsl > count__ocsl at this point, in
        #which case we should report success, outputting nothing.

#        output_call_stack.frame_prefix    red:bold
#        output_call_stack.function_name   blue:bold
#        output_call_stack.function_parens blue
#        output_call_stack.script_name     magenta:bold
#        output_call_stack.script_quotes   magenta
#        output_call_stack.eval_name       cyan:bold
#        output_call_stack.eval_parens     cyan
#        output_call_stack.brace           white:bold
#        output_call_stack.filename        grey:bold
#        output_call_stack.colon           grey
#        output_call_stack.line            red

        #FUXME: Can't we rewrite this as:
        #
        # while is "${${(@P)funcstack_name__ocsl}[${index_first__ocsl}]-}" ==\
        #        ('output_call_stack'|'print_exception')(|'_'*) si and
        #        (( index_first__ocsl++ <= count__ocsl )) {
        #
        # In fact, the current approach appears to be subtly bugged in a way I
        # can't grok. We'd might as well implement the prior optimization, since
        # we're going to have to debug this anyway.
        #FUXME: Wait. That obviously doesn't wait; the "++" is terrible, as we
        #most certainly don't want to implement such integer unless such
        #condition succeeds.

    # Indent the second frame to the right by one space, if such frame exists.
#   indentation__ocsl=' '

            # If this is at or after the third stack frame to be printed, indent
            # such frame to the right. See the prior output examples.
#           if (( index__ocsl > index_first__ocsl + 1 )) {
#               indentation__ocsl+=' '
#           }

    #FUXME: Excise such string definitions above as well.
#        callee_name__ocsl\
#        callee_eval_prefix__ocsl\
#        callee_eval_suffix__ocsl\
#        callee_function_prefix__ocsl\
#        callee_function_suffix__ocsl\
#        callee_filename_prefix__ocsl\
#        callee_filename_suffix__ocsl\
#    callee_eval_prefix__ocsl="${ZY_STYLE_TO_COLOR[output_call_stack.callee_eval_prefix]-}${ZY_STYLE_TO_TEXT[output_call_stack.callee_eval_prefix]-(}${ZY_STYLE_TO_COLOR[output_call_stack.callee_eval]-}"
#    callee_eval_suffix__ocsl="${ZY_STYLE_TO_COLOR[output_call_stack.callee_eval_suffix]-}${ZY_STYLE_TO_TEXT[output_call_stack.callee_eval_suffix]-)}"
#    callee_function_prefix__ocsl="${ZY_STYLE_TO_COLOR[output_call_stack.callee_function_prefix]-}${ZY_STYLE_TO_TEXT[output_call_stack.callee_function_prefix]-}${ZY_STYLE_TO_COLOR[output_call_stack.callee_function]-}"
#    callee_function_suffix__ocsl="${ZY_STYLE_TO_COLOR[output_call_stack.callee_function_suffix]-}${ZY_STYLE_TO_TEXT[output_call_stack.callee_function_suffix]-()}"
#    callee_filename_prefix__ocsl="${ZY_STYLE_TO_COLOR[output_call_stack.callee_filename_prefix]-}${ZY_STYLE_TO_TEXT[output_call_stack.callee_filename_prefix]-\"}${ZY_STYLE_TO_COLOR[output_call_stack.callee_filename]-}"
#    callee_filename_suffix__ocsl="${ZY_STYLE_TO_COLOR[output_call_stack.callee_filename_suffix]-}${ZY_STYLE_TO_TEXT[output_call_stack.callee_filename_suffix]-\"}"
#       callee_name__ocsl="${${(@P)funcstack_name__ocsl}[${index__ocsl}]}"
        # If the callee for this frame was a sourced script, print such callee
        # accordingly. See :call_stack.is_index_script() for further details.
#        if is "${${(@P)funcsourcetrace_name__ocsl}[${index__ocsl}]}" == *':0' si {
#            :str.output_sans_newline\
#                "${callee_filename_prefix__ocsl}${callee_name__ocsl}${callee_filename_suffix__ocsl}"
#        # Else if such callee was an eval() statement, print such callee
#        # accordingly.
#        } elif is "${callee_name__ocsl}" == '(eval)' si {
#            :str.output_sans_newline\
#                "${callee_eval_prefix__ocsl}eval${callee_eval_suffix__ocsl}"
#        # Else, such callee was a called function. Print such callee
#        # accordingly.
#        } else {
#            :str.output_sans_newline\
#                "${callee_eval_function__ocsl}${callee_name__ocsl}${callee_eval_suffix__ocsl}"
#        }

#   first_frame_border_left__ocsl="$(repeat_string "${first_frame_border_left__ocsl}" "$(( count__ocsl - 1 ))")"
#   midst_frame_border_left__ocsl="$(repeat_string "${midst_frame_border_left__ocsl}" "$(( first_frame_border_left__ocsl - 1 ))")"

#       is_call_stack_item_script\
#       "${${(@P)funcsourcetrace_name__ocsliwsp}[${index__ocsliwsp}]}" } {
#    if is "${${(@P)funcsourcetrace_name__ocsliwsp}[${index__ocsliwsp}]}" ==\
#       *':0' si {

    #FUXME: Interestingly, we can simply such boolean initializations with
    #two new type aliases as follows:
    #
    #    alias boolean_true='{
    #       boolean "$(:stdin)"="'${ZY_BOOLEAN_TRUE}'"
    #    } <<<'
    #    alias boolean_false='{
    #       boolean "$(:stdin)"="'${ZY_BOOLEAN_FALSE}'"
    #    } <<<'
    #
    #Then leverage such aliases as follows here and elsewhere:
    #
    #    boolean_true ZY_IS_OUTPUTTING_CALL_STACK_RUNNABLE_BASENAME
    #
    #Sweet, no? Yes!

    # If such runnable is a script, instruct the function below to output only
    # the basename of such script.
#   boolean ZY_IS_OUTPUTTING_CALL_STACK_RUNNABLE_BASENAME="${ZY_BOOLEAN_TRUE}"

    # If any such list is undefined or not a list, fail.
#    { (( ${+funcstack_name__ocsl} +\
#         ${+funcfiletrace_name__ocsl} +\
#         ${+funcsourcetrace_name__ocsl} == 3 )) and
#      is "${(tP)funcstack_name__ocsl}" == 'array-'* si and
#      is "${(tP)funcfiletrace_name__ocsl}" == 'array-'* si and
#      is "${(tP)funcsourcetrace_name__ocsl}" == 'array-'* si } or :die\
#        "Lists \${${funcstack_name__ocsl}\}, \${${funcfiletrace_name__ocsl}\}, and/or \${${funcsourcetrace_name__ocsl}\} undefined."

#   { (( ${+funcstack_name__ocsliwsp} +\
#        ${+funcsourcetrace_name__ocsliwsp} == 2 )) and

        #FUXME: Actually, this should just call 
        #output_call_stack_index_runnable_lists_and_style_prefix() now.
        #FUXME: Wait. It would be *NICE* to just defer to that function; sadly,
        #this function requires the full path of such runnable if a script, while
        #that function truncates such path to its basename. We could, I suppose,
        #either explicitly pass an optional boolean *OR* implicitly set a
        #boolean local (probably a better idea). Hmm; contemplate the latter. Of
        #course, perhaps not, right? I mean, calling such function every
        #iteration would probably impose quite an efficiency burden. Perhaps
        #it's simpler to just implement such functionality ourselves here, yes?
        #In such case, reduce the documentation below to simply: "See
        #output_call_stack_index_runnable_lists_and_style_prefix() for
        #further details."

    #FUXME: Reduce to a manual check. No calling of external functions allowed!
    #Hmmmm; actually, repeating an arbitrary string is quite non-trivial. We'll
    #need to check for the existence of such function and shift it's definition
    #under @{00-core/20-function}.
    #FUXME: Actually, no! I recall it's quite feasible generally using only
    #slightly slower {..} globbing.

        # Get such script's basename. To reduce dependency on external
        # functions, inline such implementation. See get_path_basename() for
        # further details.

#== Configurable Variables ==
#
#This function also accepts a number of hidden settings  inspects the current 
#
#ZY_IS_OUTPUTTING_CALL_STACK_RUNNABLE_BASENAME

#function output_call_stack_lists_index_in_style() {
#    output_call_stack_lists_index_in_style "${@}"
#}

    #FUXME: Nonsense. We need something substantially more robust. See above!
    # If the call stack contains at least three stack frames *AND*
    # ::exception.print_uncaught() called this function (which is the customary
    # case), set the first stack frame to be printed to the caller of
    # ::exception.print_uncaught() rather than this function call. As
    # zeshy-specific implementation details, such calls convey no context to
    # zeshy users and hence must be ignored. While hardly essential, this does
    # improve the utility of output.
#    if (( count__ocsl >= 3 )) and
#        is "${${(@P)funcstack_name__ocsl}[2]}" == '::exception.print_uncaught' si {
#        index_first__ocsl=3
#    # Else, set the first stack frame to be printed to this function call.
#    } else {
#        index_first__ocsl=1
#    }

    # Before performing further validation, resolve a subtlety resulting from
    # this being a function rather than alias and hence modifying the current
    # call stack. Specifically, if the desired call stack is the current call
    # stack, ignore the current function and all directly preceding functions
    # matching glob "output_call_stack_*_runnable*" calling such function.

    #FUXME: Reduce to a manual check. No calling of external functions allowed!
    # Get the number of stack frames on such call stack.
#   frame_count__ocsl="$(get_list_size "${funcstack_name__ocsl}")"

    # If such root is a script, get such script's basename. To reduce dependency
    # on external functions, inline such implementation. See get_path_basename()
    # for further details.
#    if { :call_stack.is_index_script "${call_stack_root}" }
#        :str.return "${call_stack_root:t}"
#    # Else, such root is a function or eval(). Return such root as is.
#    } else {
#        :str.return "${call_stack_root}"
#    }

#        for ((; index_first__ocsirwlasp <= count__ocsirwlasp &&\
#                index_first__ocsirwlasp++ )) {
#            is "${${(@P)funcstack_name__ocsirwlasp}[${index_first__ocsirwlasp}]}" ==\
#               'output_call_stack_'*'_runnable'* si or break
#        }

#:func.doc <<'/---'
#string output_call_stack_index_runnable_in_style(
#    integer frame_index, string style_prefix)
#
#Output the name of the runnable at the passed 1-based positive or negative index
#of the current call stack, using user-configurable styles prefixed by the passed
#string. See output_call_stack_index_runnable_lists_and_style_prefix() for
#further details.
#/---
#function output_call_stack_index_runnable_in_style() {
#    die_unless_args_2 'Expected one index and one style prefix.'
#    output_call_stack_index_runnable_lists_and_style_prefix\
#        "${1}" funcstack funcsourcetrace "${2}"
#}

#:func.doc <<'/---'
#string output_call_stack_index_runnable(integer index)
#
#Output the name of the runnable at the passed 1-based positive or negative index
#of the current call stack, using user-configurable styles prefixed by the
#caller's name suffixed by `.runnable.` (i.e., `$(:caller.get).runnable.`). See
#output_call_stack_index_runnable_in_style() for further details.
#/---
#function output_call_stack_index_runnable() {
#    die_unless_arg 'Expected one index.'
#    output_call_stack_index_runnable_in_style\
#        "${1}" "$(:caller.get).runnable."
#}

    #FUXME: Reduce to a manual check. No calling of external functions allowed!
#    :List.die_unless\
#        "${funcstack_name__pcswfaf}"\
#        "${funcfiletrace_name__pcswfaf}"\
#        "${funcsourcetrace_name__pcswfaf}"

#FUXME: Rename to output_call_stack_root(). There! I said it. Senseless
#nomenclature before, I'm afraid. Naturally, we'll want a corresponding
#output_call_stack_root_in_style().
#print 'in @{call_stack/output}'

#FUXME: Excise. It's a single point of failure, and I don't particularly want to
#bothering with checking for its existence. Merge directly into
#print_exception().
#:func.doc <<'/---'
#string output_exception_call_stack()
#
#Output a trace of the call stack for the currently thrown exception to standard
#output. See output_call_stack_lists() for further details.
#/---
#function output_exception_call_stack() {
#    die_unless_exception
#    output_call_stack_with_funcstack_and_funcfiletrace\
#        ZY__EXCEPTION_FUNCSTACK\
#        ZY__EXCEPTION_FUNCFILETRACE\
#        ZY__EXCEPTION_FUNCSOURCETRACE
#}

#Handle *call stack outputters* (i.e., the stack of all called `zsh`
#functions, sourced `zsh` scripts, and evaluated eval() statements on the current
#call path) functionality.

        #FUXME: Actually, ${filesourcetrace} might provide us a way of
        #distinguishing between whether the current runnable is a called
        #function or sourced file. Such list defines the line and filename at
        #which such runnable is defined -- which should only apply to functions:
        #
        #"funcsourcetrace
        #      ...for files that have been executed by the source or `.'
        #      builtins, the trace information is shown as filename:0, since the
        #      entire file is the definition."
        #
        #So that's how we distinguish between the two, assuming functions called
        #on the first line of a file have trace information "filename:1". (Which
        #seems reasonable but must be tested, of course.)
        #FUXME: O.K.; I've confirmed the above assumption to be the case. We'll
        #need to be passed ${filesourcetrace} as well then, I'm afraid.

        # If this frame signifies a called function, append "()" to such name. Sadly,
        # if a script with the same name exists (which is technically feasible,
        # given zsh support for arbitrary function names), there appears to be
        # no simple way of discerning between the two. *shrug*
#        if { typeset -f -- "${callee_name__pcswfaf}" &>/dev/null } {
#            :str.output_sans_newline\
#                "${ZY_STYLE_TO_COLOR[output_call_stack.function_name]-}${callee_name__pcswfaf}${ZY_STYLE_TO_COLOR[output_call_stack.function_parens]-}()"
#        # If this frame signifies an "eval" statement, color accordingly.
#        } elif is "${callee_name__pcswfaf}" == '(eval)' si {
#            :str.output_sans_newline\
#                "${ZY_STYLE_TO_COLOR[output_call_stack.eval_parens]-}(${ZY_STYLE_TO_COLOR[output_call_stack.eval_name]-}eval${ZY_STYLE_TO_COLOR[output_call_stack.eval_parens]-})"
#        # Else, this frame signifies a shell script. Color accordingly.
#        } else {
#            :str.output_sans_newline\
#                "${ZY_STYLE_TO_COLOR[output_call_stack.script_quotes]-}\"${ZY_STYLE_TO_COLOR[output_call_stack.script_name]-}${callee_name__pcswfaf}${ZY_STYLE_TO_COLOR[output_call_stack.script_quotes]-}\""
#        }

        #FUXME: Increment the padding by one instead.
        # Indent the next stack frame to the right.
#       frame_prefix__pcswfaf=" ${frame_prefix__pcswfaf}"
#             is_frame_first__pcswfaf="${ZY_BOOLEAN_FALSE}"
#           :str.output_sans_newline "${frame_prefix_first__pcswfaf}"
#           :str.output_sans_newline "${frame_prefix_midst__pcswfaf}"

    # True if the current stack frame is the first such frame to be printed.
#    boolean is_frame_first__pcswfaf
#    is_frame_first__pcswfaf="${ZY_BOOLEAN_TRUE}"

#       if (( is_frame_first__pcswfaf )) {
#             is_frame_first__pcswfaf="${ZY_BOOLEAN_FALSE}"
#       frame_prefix_first__pcswfaf\
#       frame_prefix_midst__pcswfaf\
#   frame_prefix_first__pcswfaf="${first_frame_corner_left__pcswfaf}${first_frame_border_left__pcswfaf}${first_frame_joiner_left__pcswfaf}"
#   frame_prefix_midst__pcswfaf="${midst_frame_corner_left__pcswfaf}${midst_frame_border_left__pcswfaf}${midst_frame_joiner_left__pcswfaf}"
    #FUXME: If we ever need to calculate string lengths, do *NOT* embed colors
    #in such substrings until *AFTER* calculating their string lengths, below.
    #FUXME: Shift this to a ${ZY_STYLE_TO_TEXT}-based approach.
    #FUXME: Prefer UTF-8-specific multibyte aesthetics on capable terminals.

#FUXME: Fix the example. Don't just *SAY* what happens. Actually *SHOW* it.
#Print a trace of the current call stack consisting of all previously called
#functions, sourced files, and `eval` statements in the current call path,
#excluding only the stack frame of the caller's call to this function.
#
#Consider redirecting such output to standard error, especially when accompanying
#such stack with error or warning messages. Doing so ensures that calling this
#function from process substitutions (e.g., `$(get_zsh_version)`) prints to the
#terminal device attached to the current shell rather than into a string captured
#by such shell -- without requiring such shell explicitly print such stack: e.g.,
#
#.output_call_stack()
#==========================================
#[source]
#------------------------------------------
## Assuming neither "/spider" or "/murphy" exist, the following command
## substitution throws an exception printing a call stack trace to
## standard error without effort on our behalf.
#>>> string first_file; first_file="$(get_first_file /spider /murphy)"
#------------------------------------------
#==========================================

#FUXME: Oh, yeah? Like what? Any such functions should be shifted under
#@{00-core}, if they can't be outright implemented inline.

# Such functions call functions unavailable at @{00-core} time and hence not
# shiftable to the prior parcel of the same name.

# for the _not_ handled by the prior parcel of the same name
#``Away with ye, matey!'' and hence benefit from exclusion.
    # First stack frame to be printed. , defaulting to the call to this function.
    # If ::exception.print_uncaught() called this function, avoid printing both this
    # call and the call to ::exception.print_uncaught(). As zeshy-specific internal
    # implementation details, such calls convey no useful context to external
    # zeshy users. (While hardly essential, this does improve output.)
    # Line, function name, and filename from which the caller of the previous
    # stack frame called the current stack frame.
#   integer caller_line__pcswfaf
#   string  callee_name__pcswfaf filename__pcswfaf

    # If either such list does not exist, throw an exception. See :List.is() for
    # further details.
#    is -n "${(P)funcstack_name__pcswfaf+x}" and
#       -n "${(P)funcfiletrace_name__pcswfaf+x}" and
#        "${(tP)variable_name__il}" == (array|list)* and
#        "${(tP)variable_name__il}" == (array|list)* si or :die\
#        ''

#    Referencing such
    # styles where  is strongly encouraged, unlike that of color pseudo-styles (e.g.,
    # "${ZY_STYLE_TO_COLOR[color.red:bold]}").
#   ╓•
#   ╙╥•
#    ╙╥•
#     ╙─•
#
#   ╘╤
#    ╘╤
#     ╘╤
#      ╘╤
#
#   ▙▖
#    ▙▖
#     ▙▖

# ....................{ PRINTERS                           }....................
#:func.doc <<'/---'
#string output_call_stack()
#
#Print a trace of the current call stack. See output_call_stack() for further
#details.
#/---
#FUXME: Actually, implementing such function is non-trivial, since the mere act
#of calling output_call_stack() modifies the call stack. Two approaches:
#
#* In this function, attempt to shift the current call off the call stack. This
#  is the simplest and hence ideal fix, if zsh permits it. (Pleeease?)
#* Else, we'll need to convert output_call_stack() to an alias. It's
#  certainly... Oh, no. That doesn't work, as we'd then have to redefine the
#  :die() function defined by @{main}. *sigh*
#function output_call_stack() {
#}

    # Delimit such output from prior output, if necessary.
#   :print_stdout_separated_start
    # Reset terminal attributes in preparation for subsequent output.
#   :print_stdout_separated_stop

        # Note that, when called due to an exception thrown from an interactive
        # alias, such alias will be disabled here and hence not be recognized as
        # a function. Since such alias signifies an alias and not a function,
        # this is (arguably) not a bug. (Nothin' to see here, folks.)

    # Update globals tracking state for :print_stdout_separated_start() calls.
#FUXME: Shift to "00-declare". This is all *REALLY* "early" functionality
#required for core zeshy functionality (e.g., printing exceptions). How about
#"00-startup/10-runnable/call_stack"? Sounds good to me. And we even already
#have the slot open!

#(i.e., the initial
#function or script transitively responsible for the call to this function).
#Get the name of the first (i.e., oldest) function or script on the call stack,
#serving as the root of the current call tree. For scripts, such name is the
#absolute or relative path at which such script was originally called.

#implying. Thus, return true only if the passed runnable either is the
#current runnable or transitively called the current runnable.
#   is_list_contains funcstack "${1}"
    #FUXME: I'm not convinced that printing the name of both this function and
    #caller error handlers is helpful. I mean, do we *REALLY* need the first
    #two lines of:
    #
    #\_ output_call_stack() { /home/leycec/zsh/zeshy/src/main: 499 }
    # \_ ::exception.print_uncaught() { /home/leycec/zsh/zeshy/src/main: 3271992097900940624 }
    #  \_ TRAPZERR() { /bin/zsh: 1 }
    #
    #I'm thinking no. No sane language prints such internals, so... neither
    #shall we, we-we? Keep the "TRAPZERR" line, obviously, but cut everything
    #above that. Also keep any "die" line, but again cut everything above such
    #line. Readability is of key importance in stack traces.
    #FUXME: Then again, the truth is probably more important. O.K.; keep it.
    #FUXME: Die if called directly from the command-line. Ah! Actually, there's
    #no good reason that shouldn't work. What we should do, possibly, is detect
    #whether the call stack has at least three callers *AND* our caller is
    #::exception.print_uncaught(), in which case omit the first two callers, yes? This
    #is a bit more "magicky" than we like, but... is there any reasonable
    #alternative? I submit, "No."
    # Get such name. Since this function is transitively called by :die(), avoid
    # zeshy functions liable to throw exceptions if implemented poorly (e.g.,
    # is_list_nonempty()).
#   if (( ${#funcstack} )) {
#       :str.return "${funcstack[-1]}"
#   } else {
#       :str.return ''
#   }
#on the current call path (i.e.,
#the path of functions and scripts calling the current function or script).
        # If ::exception.print_uncaught() called this function, avoid printing such
        # call, whose internal implementation conveys no meaningful data to most
        # Zeshy users.
#       callee_name="${funcstack[${i}]}"
#       is "${callee_name}" == '::exception.print_uncaught' si and continue

    # Colors to be expanded below.
#   string\
#       color_prefix="${ZY_COLOR[white_bold]-}"\
#       color_function_name="${ZY_COLOR[blue_bold]-}"\
#       color_function_parens="${ZY_COLOR[blue]-}"\
#       color_script_name="${ZY_COLOR[magenta_bold]-}"\
#       color_script_quotes="${ZY_COLOR[magenta]-}"\
#       color_eval_name="${ZY_COLOR[cyan_bold]-}"\
#       color_eval_parens="${ZY_COLOR[cyan]-}"\
#       color_brace="${ZY_COLOR[red_bold]-}"\
#       color_filename="${ZY_COLOR[grey_bold]-}"\
#       color_colon="${ZY_COLOR[grey]-}"\
#       color_line="${ZY_COLOR[red]-}"

        #FUXME: We could take this a step further by associating different
        #colors with different types of runnables (e.g., blue for functions,
        #magenta for scripts, and cyan for eval statements). What print_message ye? Ya!

#, as doing so sets such
    # caller name to ":caller.is_equals". Implement such functions manually
#       'no such caller (this function or its caller called directly from the command line)'
# Consider calling
#get_callee_name_from_subshell if capturing output by process substitution: e.g.,
# >>> function choir() { :str.output_sans_newline "caller: "; :caller.get }
#declare_function '
#boolean get_callee_name_from_subshell()
#
#Get the name of the function or script calling the function or script calling
#this function *WHEN CALLED FROM A SUBSHELL*. Consider calling :caller.get()
#unless capturing output by process substitution: e.g.,
#
#    >>> function timbered() { choir }
#    >>> function choir() { print "caller: $(get_callee_name_from_subshell)" }
#    >>> timbered
#    caller: timbered
#'
#function get_callee_name_from_subshell() {
#    # Validate sanity. See :caller.is() for implementation details.
#    die_if_args
#    curse_string "funcstack: ${funcstack[*]}"
#    (( ${#funcstack} >= 4 )) or :die\
#        'no such caller; this function either not called from a subshell or its caller called directly from the command line'
#
#    # Get such name.
#    :str.output "${funcstack[4]}"
#}

#(This function returns the basename of the string
#returned by get_call_stack_root_name(), in other words.)
#If such name is that of a script originally called with
#Script names contain path components
#If the call stack is empty (i.e., this function was called directly from the
#command line), return "zeshy".
#This function returns an absolute path if the first object on the call stack
#is a script called by an absolute path. Where this is undesirable, consider
#calling output_call_stack_root_in_style().
        # If this name is an absolute path, return that path's basename.
#       if :path.is_absolute "${funcstack[-1]}"
#       then :str.output "${funcstack[-1]:t}"
        # Otherwise, return this name as is.
#       else :str.output "${funcstack[-1]}"
#       fi

#       if is "${funcstack[-1]}" == /* is
# Get the script name for the current script. This is a string succinctly
# describing the script under execution, typically of one to two words.
#
# Scripts may safely redefine this function to return another name; in this
# case, scripts called by the script redefining this function will still call
# this original definition (since functions are not inherited via script
# calls).
    # If the current process is an interactive shell, then return the name of
    # the function that called this function excluding all intermediary I/O-
    # and error handling-specific function calls. Typically, that function is
    # the function that called the function that called this function (i.e.,
    # the function two calls earlier in the function callstack). Insert magical
    # handwaving here.

    #FUXME: Zeshify.
#   (( # == 0 )) || :die 'expected no arguments'
    #FUXME: ${ZY_SCRIPT_FILENAME} is horrible. After extensive grepping about,
    #it's clear we no longer use this hideous hack. Excise!
    # If the caller set a non-empty ${ZY_SCRIPT_FILENAME}, return that name.
#   if [[ -n  "${ZY_SCRIPT_FILENAME-}" ]]; then
#       print -- "${ZY_SCRIPT_FILENAME}"

#FUXME: Rename to get_current_command_name(). Hmm; perhaps not. How about
#get_call_stack_name_first()? Yes. That seems much more representative and
#suggests a new "shell/call_stack" component.
