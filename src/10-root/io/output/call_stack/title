#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *call stack index outputters* (i.e., functions printing runnables
corresponding to current call stack indices, typically employed for printing
message titles).
/---

# For fault tolerance in exception handlers, avoid calling other functions in
# such functions unless explicitly preceding such calls with tests of whether
# such functions are still defined or not.

# ....................{ SETTERS                            }....................
#FIXME: Document styles.
:func.doc <<'/---'
void set_string_to_call_stack_lists_index_in_style(
    string string_name,
    string funcstack_list_name,
    string funcsourcetrace_list_name,
    integer frame_index,
    string style_prefix)

Set the passed string to the name of the runnable at the passed 1-based
(positive or negative) index of the call stack encapsulated by the passed
instances of canonical list globals ${funcstack} and ${funcsourcetrace}, using
user-configurable styles prefixed by the passed prefix. Specifically, if such
runnable was:

* A `zeshy` function, this is such function's name.
* A `zeshy` script, this is:
** If boolean ${ZESHY_IS_OUTPUTTING_CALL_STACK_RUNNABLE_BASENAME} is defined
   to true, the basename of the absolute or relative path such script was
   originally run as.
** Else, the absolute or relative path such script was originally run as. (This
   is the default.)
* A `zsh` evaluation, this is `eval`.
/---
function set_string_to_call_stack_lists_index_in_style() {
    # Validate sanity.
    die_unless_args_5\
        'Expected one string name, one ${funcstack} list name, one ${funcsourcetrace} list name, one index, and one style prefix.'
    string\
        string_name__sstcsliwsp="${1}"\
        funcstack_name__sstcsliwsp="${2}"\
        funcsourcetrace_name__sstcsliwsp="${3}"\
        index__sstcsliwsp="${4}"\
        style_prefix__sstcsliwsp="${5}"\
        callee_name__sstcsliwsp\
        caller_trace__sstcsliwsp
    integer count__sstcsliwsp

    # If any such variable is undefined or not of the expected type, throw an
    # exception. See is_string() and :List.is() for further details.
    is "${(tP)string_name__sstcsliwsp-}" == 'scalar'* si or :die\
        "\${${string_name__sstcsliwsp}\} undefined or not a string variable."
    is "${(tP)funcstack_name__sstcsliwsp-}~~~${(tP)funcsourcetrace_name__sstcsliwsp-}" ==\
       'array'*'~~~array'* si or :die\
        "\${${funcstack_name__sstcsliwsp}\} and/or \${${funcsourcetrace_name__sstcsliwsp}\} undefined or not lists."
#       print "funcstack type: ${(tP)funcstack_name__sstcsliwsp-}; funcsourcetrace type: ${(tP)funcsourcetrace_name__sstcsliwsp-}" 1>&2

    # If such index is not an integer, throw an exception. See :is_int() for
    # further details.
    is "${index__sstcsliwsp}" == ('-'|)<-> si or :die\
        "\"${index__sstcsliwsp}\" not an integer."

    # Size of the first such list. See get_list_size() for further details.
    count__sstcsliwsp="${#${(@P)funcstack_name__sstcsliwsp}}"

    # If such lists are of unequal size, throw an exception.
    (( count__sstcsliwsp == ${#${(@P)funcsourcetrace_name__sstcsliwsp}} )) or :die\
        "List \${${funcstack_name__sstcsliwsp}\} size ${count__sstcsliwsp} unequal to list \${${funcsourcetrace_name__sstcsliwsp}\} size ${#${(@P)funcsourcetrace_name__sstcsliwsp}}."

    # If such index is not a valid index of such call stack, throw an exception.
    # See :call_stack.is_index() for further details.
    (( (1 <= index__sstcsliwsp && index__sstcsliwsp <= count__sstcsliwsp) ||
       (-count__sstcsliwsp <= index__sstcsliwsp && index__sstcsliwsp <= -1) )) or
        :die "\"${index__sstcsliwsp}\" not an index of list \${${funcstack_name__sstcsliwsp}\} (i.e., not in [-${count__sstcsliwsp}, ${count__sstcsliwsp}])."

    # Callee name.
    callee_name__sstcsliwsp="${${(@P)funcstack_name__sstcsliwsp}[${index__sstcsliwsp}]}"

    # Caller filename and line number delimited by ":".
    caller_trace__sstcsliwsp="${${(@P)funcsourcetrace_name__sstcsliwsp}[${index__sstcsliwsp}]}"

    # If such runnable was a sourced script, output such runnable as such. See
    # is_call_stack_item_script() for further details.
    if { is "${caller_trace__sstcsliwsp}" == *":0" and
         -e "${caller_trace__sstcsliwsp[1,-3]}" si } {
#       print "funcstack name: ${funcstack_name__sstcsliwsp}\nfuncstack size: ${#${(@P)funcstack_name__sstcsliwsp}}\nfuncstack head: ${${(@P)funcstack_name__sstcsliwsp}[1]}"
#       print_list "${funcstack_name__sstcsliwsp}"
#       print_list "${funcsourcetrace_name__sstcsliwsp}"

        # If boolean ${ZESHY_IS_OUTPUTTING_CALL_STACK_RUNNABLE_BASENAME} is
        # defined to true, output only the basename of such script. See
        # get_path_basename() for further details.
        if (( ${ZESHY_IS_OUTPUTTING_CALL_STACK_RUNNABLE_BASENAME-0} )) {
            callee_name__sstcsliwsp="${callee_name__sstcsliwsp:t}"
        }

        # Set such string. See :Str.set() for further details.
        noop ${(P)string_name__sstcsliwsp::=${ZESHY_STYLE_TO_COLOR[${style_prefix__sstcsliwsp}filename_prefix]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstcsliwsp}filename_prefix]-\"}${ZESHY_STYLE_TO_COLOR[${style_prefix__sstcsliwsp}filename]-}${callee_name__sstcsliwsp}${ZESHY_STYLE_TO_COLOR[${style_prefix__sstcsliwsp}filename_suffix]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstcsliwsp}filename_suffix]-\"}}
    # Else if such runnable was an evaluation, output such runnable as such.
    } elif is "${callee_name__sstcsliwsp}" == '(eval)' si {
        noop ${(P)string_name__sstcsliwsp::=${ZESHY_STYLE_TO_COLOR[${style_prefix__sstcsliwsp}eval_prefix]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstcsliwsp}eval_prefix]-(}${ZESHY_STYLE_TO_COLOR[${style_prefix__sstcsliwsp}eval]-}eval${ZESHY_STYLE_TO_COLOR[${style_prefix__sstcsliwsp}eval_suffix]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstcsliwsp}eval_suffix]-)}}
    # Else, such runnable was a called function. Output such runnable as such.
    } else {
        noop ${(P)string_name__sstcsliwsp::=${ZESHY_STYLE_TO_COLOR[${style_prefix__sstcsliwsp}function_prefix]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstcsliwsp}function_prefix]-}${ZESHY_STYLE_TO_COLOR[${style_prefix__sstcsliwsp}function]-}${callee_name__sstcsliwsp}${ZESHY_STYLE_TO_COLOR[${style_prefix__sstcsliwsp}function_suffix]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstcsliwsp}function_suffix]-()}}
    }
}

# ....................{ OUTPUTTERS                         }....................
:func.doc <<'/---'
string output_call_stack_title_in_style_caller()

Output a title appropriate for passing to print_string_titled_in_style_caller() derived from the
current call stack, using user-configurable styles prefixed by
the dot-suffixed caller's name followed by `heading.` (i.e.,
`$(:caller.get).heading.`). See output_call_stack_lists_title_in_style()
for further details.
/---
function output_call_stack_title_in_style_caller() {
    # Validate sanity.
    die_if_args
    :str caller

    # Caller name.
    :set_string_to_caller caller

    # Output such title.
    output_call_stack_lists_title_in_style\
        funcstack funcsourcetrace "${caller}.heading."
}

:func.doc <<'/---'
string output_call_stack_lists_title_in_style_caller(
    string funcstack_list_name,
    string funcsourcetrace_list_name)

Output a title appropriate for passing to print_string_titled_in_style_caller() derived from the
call stack encapsulated by the passed instances of canonical list globals
${funcstack} and ${funcsourcetrace}, using user-configurable styles prefixed by
the dot-suffixed caller's name followed by `heading.` (i.e.,
`$(:caller.get).heading.`). See output_call_stack_lists_title_in_style()
for further details.
/---
function output_call_stack_lists_title_in_style_caller() {
    # Validate sanity.
    die_unless_args_2\
        'Expected one ${funcstack} list name and one ${funcsourcetrace} list name.'
    :str caller

    # Caller name.
    :set_string_to_caller caller

    # Output such title.
    output_call_stack_lists_title_in_style\
        "${@}" "${caller}.heading."
}

:func.doc <<'/---'
string output_call_stack_lists_title_in_style(
    string funcstack_list_name,
    string funcsourcetrace_list_name,
    string style_prefix)

Output a title appropriate for passing to print_string_titled_in_style_caller() derived from the
call stack encapsulated by the passed instances of canonical list globals
${funcstack} and ${funcsourcetrace}, using user-configurable styles prefixed by
the passed prefix. For readability, such title principally consists of a
synopsis of such stack's *root runnable* (i.e., the last runnable on and hence
originating such stack, typically called directly from the command line by the
current user). Specifically, if such runnable was:

* A `zeshy` function, this is such function's name.
* A `zeshy` script, this is the basename of the absolute or relative path such
  script was originally run as.
* A `zsh` evaluation, this is `(eval)`.
/---
function output_call_stack_lists_title_in_style() {
    # Validate sanity.
    die_unless_args_3\
        'Expected one ${funcstack} list name, one ${funcsourcetrace} list name, and one style prefix.'
    string style_prefix__ocsltwsp="${3}"

    # Output such runnable sans suffixing newline, ensuring only such runnable's
    # basename is output if such runnable is a script.
    :boolean ZESHY_IS_OUTPUTTING_CALL_STACK_RUNNABLE_BASENAME=${ZESHY_BOOLEAN_TRUE}
    output_call_stack_lists_index_in_style\
        "${1}" "${2}" -1 "${style_prefix__ocsltwsp}runnable."

    # Render text following such output in the default color for such title.
    :str.output_sans_newline\
        "${ZESHY_STYLE_TO_COLOR[${style_prefix__ocsltwsp}text]-}"
}

:func.doc <<'/---'
string output_call_stack_lists_index_in_style(
    string funcstack_list_name,
    string funcsourcetrace_list_name,
    integer frame_index,
    string style_prefix)

Output the name of the runnable at the passed 1-based (positive or negative)
index of the call stack encapsulated by the passed instances of canonical list
globals ${funcstack} and ${funcsourcetrace}, using user-configurable styles
prefixed by the passed prefix. See
set_string_to_call_stack_lists_index_in_style() for further details.
/---
function output_call_stack_lists_index_in_style() {
    # Validate sanity.
    die_unless_args_4\
        'Expected one ${funcstack} list name, one ${funcsourcetrace} list name, one index, and one style prefix.'
    string output

    # Get such name.
    set_string_to_call_stack_lists_index_in_style output "${@}"

    # Output such name sans suffixing newline, as expected by
    # output_call_stack_lists_title_in_style() and other callers.
    :str.output_sans_newline "${output}"
}

# --------------------( WASTELANDS                         )--------------------
#   typeset -f output_call_stack_lists_index_in_style &>/dev/null or
#       :die   'output_call_stack_lists_index_in_style() undefined.'
#   typeset -f output_call_stack_lists_title_in_style &>/dev/null or
#       :die   'output_call_stack_lists_title_in_style() undefined.'
    # Output such title.
#   { typeset -f output_call_stack_lists_title_in_style } silent or
#       :die     'output_call_stack_lists_title_in_style() undefined.'

#Output the name of the runnable at the passed 1-based (positive or negative)
#index of the call stack encapsulated by the passed instances of canonical list
#globals ${funcstack} and ${funcsourcetrace}, using user-configurable styles
#prefixed by the passed prefix. To improve integration with callers inserting
#such name into another string, such output is _not_ suffixed by a newline.
#
#Specifically, if such runnable was:
#
#* A `zeshy` function, this is such function's name.
#* A `zeshy` script, this is:
#** If boolean ${ZESHY_IS_OUTPUTTING_CALL_STACK_RUNNABLE_BASENAME} is defined
#   to true, the basename of the absolute or relative path such script was
#   originally run as.
#** Else, the absolute or relative path such script was originally run as. (This
#   is the default.)
#* A `zsh` evaluation, this is `(eval)`.
#
#    string\
#        funcstack_name__ocsliwsp="${1}"\
#        funcsourcetrace_name__ocsliwsp="${2}"\
#        index__ocsliwsp="${3}"\
#        style_prefix__ocsliwsp="${4}"\
#        runnable__ocsliwsp\
#        runnable_source__ocsliwsp
#    integer count__ocsliwsp
##   typeset -f output_call_stack_lists_index_in_style &>/dev/null or
##       :die   'output_call_stack_lists_index_in_style() undefined.'
#
#    # If any such list is undefined or not a list, fail. See :List.is() for
#    # further details.
#    is "${(tP)funcstack_name__ocsliwsp-}~~~${(tP)funcsourcetrace_name__ocsliwsp-}" ==\
#       'array'*'~~~array'* si or :die\
#        "Lists \${${funcstack_name__ocsliwsp}\} and/or \${${funcsourcetrace_name__ocsliwsp}\} undefined or not lists."
##       print "funcstack type: ${(tP)funcstack_name__ocsliwsp-}; funcsourcetrace type: ${(tP)funcsourcetrace_name__ocsliwsp-}" 1>&2
#
#    # If such index is not an integer, throw an exception. See :is_int() for
#    # further details.
#    is "${index__ocsliwsp}" == ('-'|)<-> si or :die\
#        "\"${index__ocsliwsp}\" not an integer."
#
#    # Size of the first such list. See get_list_size() for further details.
#    count__ocsliwsp="${#${(@P)funcstack_name__ocsliwsp}}"
#
#    # If such lists are of unequal size, throw an exception.
#    (( count__ocsliwsp == ${#${(@P)funcsourcetrace_name__ocsliwsp}} )) or :die\
#        "List \${${funcstack_name__ocsliwsp}\} size ${count__ocsliwsp} unequal to list \${${funcsourcetrace_name__ocsliwsp}\} size ${#${(@P)funcsourcetrace_name__ocsliwsp}}."
#
#    # If such index is not a valid index of such call stack, throw an exception.
#    # See :call_stack.is_index() for further details.
#    (( (1 <= index__ocsliwsp && index__ocsliwsp <= count__ocsliwsp) ||
#       (-count__ocsliwsp <= index__ocsliwsp && index__ocsliwsp <= -1) )) or
#        :die "\"${index__ocsliwsp}\" not an index of list \${${funcstack_name__ocsliwsp}\} (i.e., not in [-${count__ocsliwsp}, ${count__ocsliwsp}])."
#
#    # Name of such runnable.
#    runnable__ocsliwsp="${${(@P)funcstack_name__ocsliwsp}[${index__ocsliwsp}]}"
#
#    # Source of such runnable (i.e., corresponding element of the passed
#    # ${funcsourcetrace} list).
#    runnable_source__ocsliwsp="${${(@P)funcsourcetrace_name__ocsliwsp}[${index__ocsliwsp}]}"
#
#    # If such runnable was a sourced script, output such runnable as such. See
#    # is_call_stack_item_script() for further details.
#    if { is "${runnable_source__ocsliwsp}" == *":0" and
#         -e "${runnable_source__ocsliwsp[1,-3]}" si } {
##       print "funcstack name: ${funcstack_name__ocsliwsp}\nfuncstack size: ${#${(@P)funcstack_name__ocsliwsp}}\nfuncstack head: ${${(@P)funcstack_name__ocsliwsp}[1]}"
##       print_list "${funcstack_name__ocsliwsp}"
##       print_list "${funcsourcetrace_name__ocsliwsp}"
#
#        # If boolean ${ZESHY_IS_OUTPUTTING_CALL_STACK_RUNNABLE_BASENAME} is
#        # defined to true, output only the basename of such script. See
#        # get_path_basename() for further details.
#        if (( ${ZESHY_IS_OUTPUTTING_CALL_STACK_RUNNABLE_BASENAME-0} )) {
#            runnable__ocsliwsp="${runnable__ocsliwsp:t}"
#        }
#
#        # Output such path.
#        :str.output_sans_newline\
#            "${ZESHY_STYLE_TO_COLOR[${style_prefix__ocsliwsp}filename_prefix]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__ocsliwsp}filename_prefix]-\"}${ZESHY_STYLE_TO_COLOR[${style_prefix__ocsliwsp}filename]-}${runnable__ocsliwsp}${ZESHY_STYLE_TO_COLOR[${style_prefix__ocsliwsp}filename_suffix]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__ocsliwsp}filename_suffix]-\"}"
#    # Else if such runnable was an evaluation, output such runnable as such.
#    } elif is "${runnable__ocsliwsp}" == '(eval)' si {
#        :str.output_sans_newline\
#            "${ZESHY_STYLE_TO_COLOR[${style_prefix__ocsliwsp}eval_prefix]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__ocsliwsp}eval_prefix]-(}${ZESHY_STYLE_TO_COLOR[${style_prefix__ocsliwsp}eval]-}eval${ZESHY_STYLE_TO_COLOR[${style_prefix__ocsliwsp}eval_suffix]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__ocsliwsp}eval_suffix]-)}"
#    # Else, such runnable was a called function. Output such runnable as such.
#    } else {
#        :str.output_sans_newline\
#            "${ZESHY_STYLE_TO_COLOR[${style_prefix__ocsliwsp}function_prefix]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__ocsliwsp}function_prefix]-}${ZESHY_STYLE_TO_COLOR[${style_prefix__ocsliwsp}function]-}${runnable__ocsliwsp}${ZESHY_STYLE_TO_COLOR[${style_prefix__ocsliwsp}function_suffix]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__ocsliwsp}function_suffix]-()}"
#    }

    #FUXME: Craziness, honestly. Extreme code duplication between this and
    #output_call_stack_lists_index_in_style(), and it's not entirely
    #clear that *EITHER* block of code is demonstrably important. Hmm; well, it
    #*IS* quite decent code. We should probably just shift it to
    #print_call_stack(), yes?

    # If the desired call stack is the current call stack, ignore the current
    # function and all directly preceding exception handler functions *BEFORE*
    # performing further validation. Since no other functions should be ignored,
    # zsh array indexing flags (e.g., "(I)") do *NOT* suffice. Rather:
    #
    # * Manually find the call stack index of the first stack frame *NOT*
    #   matching such glob.
    # * Copy the sublist of the current call stack following such index into
    #   temporary local lists.
    # * Set the desired call stack list names to such list names.
    #
    # Such logic allows all subsequent code to remain the same, regardless of
    # whether the desired call stack is the current call stack. This is simpler
    # (though slightly less efficient) than implementing optimized logic for
    # when the desired call stack is the current call stack. *shrug*
#    if is "${funcstack_name__ocsliwsp}" == 'funcstack' si {
#        # For obvious reasons, skip the first such index. Since this guarantees
#        # such index to exceed 1, a list copy is *ALWAYS* required.
#        integer  index_first__ocsliwsp=2
#        while (( index_first__ocsliwsp <= count__ocsliwsp )) and
#            is "${${(@P)funcstack_name__ocsliwsp}[${index_first__ocsliwsp}]}" ==\
#                'output_call_stack'(|'_'*) si {
#            index_first__ocsliwsp+=1
#        }
#
#        # Do *NOT* quote list slices, as that merely concatenates elements.
#        list funcstack__ocsliwsp funcsourcetrace__ocsliwsp
#        funcstack__ocsliwsp=(       ${funcstack[${index_first__ocsliwsp},-1]} )
#        funcsourcetrace__ocsliwsp=( ${funcsourcetrace[${index_first__ocsliwsp},-1]} )
#        funcstack_name__ocsliwsp='funcstack__ocsliwsp'
#        funcsourcetrace_name__ocsliwsp='funcsourcetrace__ocsliwsp'
#
#        # Recompute such list size *AFTER* truncating such list above.
#        count__ocsliwsp="${#${(@P)funcstack_name__ocsliwsp}}"
#    }

#the basename of the runnable at the *root* (i.e., last runnable on such
#stack and hence originating such stack, often called directly from the command
#line by the current user) of the call stack encapsulated by the passed instances
#of canonical list globals ${funcstack} and ${funcsourcetrace}, using
#user-configurable styles prefixed by the dot-suffixed caller's name followed by
#`heading.title.` (i.e., `$(:caller.get).heading.title.`).
#
#    corresponding (i.e.,
#the last runnable on such stack and hence originating such stack -- typically
#called directly from the command line by the current user), using user-
#configurable styles prefixed by the caller's name suffixed by `.runnable.`
#(i.e., `$(:caller.get).runnable.`). Specifically, if such runnable was:
#
#* A `zeshy` function, this is such function's name.
#* A `zeshy` script, this is the basename of the absolute or relative path such
#  script was originally run as.
#* A `zsh` evaluation, this is `(eval)`.
#
#See output_call_stack_index_in_style() for further details.

#FUXME: Drop the "_with_suffix" part here and below. Just have the callers of
#such functions add the suffix manually. *Everything else in such functions
#should stay the same.*

#FUXME: Rename to output_call_stack_root_basename_in_style() and
#refactor accordingly. We basically never want a plain
#output_call_stack_root_basename() function.
#:func.doc <<'/---'
#string output_call_stack_root_basename_in_style(string style_prefix)
#
#Output the basename of the runnable at the root of the current call stack, using
#user-configurable styles prefixed by the passed prefix. See
#output_call_stack_lists_root_in_style() for further details.
#/---
#function output_call_stack_root_basename() {
#    die_unless_arg 'Expected one style prefix.'
#    output_call_stack_lists_root_in_style\
#        funcstack funcsourcetrace "${1}"
#}
