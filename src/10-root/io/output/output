#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "COPYING" for additional details.

:parcel <<'/---'
Handle *printer functions* (i.e., high-level functions printing strings).
Namely, maintain globals tracking the current state of standard output and
error, including modification times of the device files associated with such
file descriptors after the most recent call to a printer function writing such
file descriptors (e.g., :string.output()).

== Nomenclature ==

In conventional languages, standard output and error serve only as streams to
which only human-readable strings intended for end users are printed. However,
in shell languages and hence `zeshy`, standard output and error serve as that
_and_ as sinks to which machine-readable strings intended for command
substitution are printed.

To manage such complexities, `zeshy` supports three broad classes of functions
for writing to standard output and error -- each with a corresponding
nomenclature for easier identification. In increasing order of abstraction and
functionality, these are:

* *Getters*, low-level functions returning strings to callers by writing to a
  subshell's standard output from command substitution (e.g.,
  `float time; time="$(get_time)"`). Most such functions are prefixed by `get_`;
  some, however, are prefixed by a verb specific to their function (e.g.,
  :canonicalize_path()).
* *Outputters*, mid-level functions printing strings by writing to the current
  shell's standard output and/or error. Such functions _may_ embellish such
  strings with terminal-specific colors (e.g., 8-color ANSI) and locale-specific
  encodings (e.g., UTF-8) configured by the current user, but otherwise behave
  straightforwardly. All such functions are prefixed by `output_`, and most by
  `:output_string_`.
* *Printers*, high-level functions printing strings by writing to the current
  shell's standard output and/or error. Like outputters, printers embellish such
  strings with settings configured by the current user. Unlike outputters,
  printers additionally behave in a context-aware manner, including:
  * If such output is preceded by prior output, printing vertical whitespace
    delimiting all prior and subsequent output.
  * If such output is attached to a terminal device _and_ exceeds the height of
    such terminal, paging such output with the current user's preferred pager
    (e.g., `less`, `more`).
  +
  All such functions are prefixed by `print_`.

Hence, while printer functions handle repetitive and often error-prone
contextual tasks on behalf of the caller, getter and outputter functions do
_not_. Likewise, while printer and outputter functions are rarely called from
command substitutions, getter functions are _always_.
/---

#FIXME: It'd be great to provide support for display server-specific display of
#dialog boxes for zeshy-based GUI scripts. See the line beginning
#"# First, try zenity." in shell script "start-tor-browser" bundled with the
#TorBrowser Bundle. Such script attempts to leverage the following external
#commands, in order: zenity (probably X-specific?), kdialog (KDE- and probably
#X-specific), xmessage (X-specific), and gxmessage (GNOME X-specific).

#FIXME: O.K.; extensive testing conclusively demonstrates the case. Just run the
#following command repeatedly:
#
#    >>> sync; get_path_mtime /dev/pts/9
#
#The output clearly shows standard output's mtime to be updated exactly 8
#seconds to the nanosecond, which is clearly the reason for the nanoseconds
#never changing for standard output's mtime. So, no bug: just an unfortunate
#implementation detail.
#
#I'm afraid this means that standard output's mtime is useless for real-world
#use, suggesting we'll need to revert to the prior implementation. (Sucks; I
#know.)
#
#We'll still want to test whether or not standard output's path has changed, as
#that's reliably infortative. ${ZESHY_STDOUT_PRIOR_MTIME}, however, should be
#ripped out in favor of the name of the most recent printer function to have
#been called. Searching up the callstack for such name was quite involved, as I
#recall. (Ye unbidden Gods, but why did I strip this out without properly
#checking whether or not it would work? Bad assumptions, I'm afraid.)
#FIXME: O.K.; apparently, TTY mtime *USED* to be updated in effectively real-
#time. This changed as of May 2013, at which time the working code below
#depending on real-time mtime updates silently broke. Specifically, Linux kernel
#file "drivers/tty/tty_io.c" now states:
#"/* We limit tty time update visibility to every 8 seconds or so. */". This is
#referred to as the "8 second rule." While a sound change in general, this is
#mildly unfortunate from our (admittedly) provincial userland perspective. While
#this could be hacked around this as follows, I'm unconvinced it's worth it:
#
#* If the mtime of the corresponding PTY device is less than 8 seconds ago,
#  tacitly assume such device has been written to. (This is the only sane
#  response, I'm afraid.)
#* Else, the mtime of such device is reliable. In such case, if such mtime has
#  *NOT* changed, then we definitively know such device has *NOT* been written
#  to and may react accordingly.
#FIXME: As further confirmation, consider this intriguing mailing list thread:
#
#"On http://vladz.devzero.fr/013_ptmx-timing.php, we can see how to find
# out length of a password using timestamps of /dev/ptmx. It is
# documented in "Timing Analysis of Keystrokes and Timing Attacks on
# SSH". To avoid that problem, do not update time when reading
# from/writing to a TTY.
#
# I am afraid of regressions as this is a behavior we have since 0.97
# and apps may expect the time to be current, e.g. for monitoring
# whether there was a change on the TTY. Now, there is no change. So
# this would better have a lot of testing before it goes upstream."
#
#For further thread tidbits, see:
#http://www.serverphorums.com/read.php?12,697887

# ....................{ GLOBALS                            }....................
:string_global ZESHY_STATE_STDOUT_PATH <<'/---'
Canonicalized absolute path of the device file associated with standard output
for the current shell at the time of the most recent call to
:update_stdout_state() or the empty string if such function has yet to be called.
/---

:string_global ZESHY_STATE_STDERR_PATH <<'/---'
Canonicalized absolute path of the device file associated with standard error
for the current shell at the time of the most recent call to
:update_stderr_state() or the empty string if such function has yet to be called.
/---

# ....................{ UPDATERS                           }....................
declare_function_with_stdin <<'/---'
void :update_stdout_state()

Update globals recording the state of standard output after the most recent call
to a printer function (e.g., :string.output()), where ``state'' implies the
modification time of the device file associated with standard output at the time
of such call. Such state assists subsequent calls to :print_stdout_separated_start() in
deciding whether prior and subsequent output should be delimited by a newline.
/---
# Since standard output and error are typically both muxed to the same terminal,
# testing the modification time of the device file associated with standard
# output implicitly tests the same for standard error. Hence, testing only the
# latter suffices to ensure that prior and subsequent output are properly
# delimited -- even if such output was to standard error rather than output.
function :update_stdout_state() {
    die_if_args
    :set_string_to_stdout_file ZESHY_STATE_STDOUT_PATH
}

declare_function_with_stdin <<'/---'
void :update_stderr_state()

Update globals recording the state of standard error after the most recent call
to a printer function (e.g., :string.output()). See :update_stdout_state() for
further details.
/---
function :update_stderr_state() {
    die_if_args
    :set_string_to_stderr_file ZESHY_STATE_STDERR_PATH
}

# ....................{ RESETTERS                          }....................
declare_function_with_stdin <<'/---'
void :reset_stdout_state()

Reset tracking for standard output to its default state. Specifically, reset
color attributes for the current terminal to such terminal's defaults _and_
nullify tracking globals for standard output. See :print_stdout_separated_stop() for further
details.
/---
function :reset_stdout_state() {
    # Validate sanity.
    die_if_args

    # Reset terminal attributes.
    reset_terminal_color

    # Reset tracking globals.
    ZESHY_STATE_STDOUT_PATH=''
}

# ....................{ OUTPUTTERS ~ start                 }....................
declare_function_with_stdin <<'/---'
str :output_stdout_start()

Prepare for outputting to standard output. Specifically (in order):

* Reset color attributes for the terminal attached to standard output to such
  terminal's defaults. See reset_terminal_color() for further details.
/---
function :output_stdout_start() {
    die_if_args
    reset_terminal_color
}

declare_function_with_stdin <<'/---'
str :output_stderr_start()

Prepare for outputting to standard error. See :output_stdout_start() for further
details.
/---
function :output_stderr_start() {
    #FIXME: This suggests the need for separate :reset_stdout_color() and
    #:reset_stderr_color(). I say we excise reset_terminal_color(), yes?
    die_if_args
    { reset_terminal_color } :to_stderr
}

# ....................{ OUTPUTTERS ~ stop                  }....................
declare_function_with_stdin <<'/---'
str :output_stdout_stop()

Conclude prior outputting to standard output. Specifically, perform similar
operations as :output_stdout_start() in the reverse order.
/---
function :output_stdout_stop() {
    die_if_args
    reset_terminal_color
}

declare_function_with_stdin <<'/---'
str :output_stderr_stop()

Conclude prior outputting to standard output. See :output_stderr_stop() for
further details.
/---
function :output_stderr_stop() {
    die_if_args
    { reset_terminal_color } :to_stderr
}

# ....................{ PRINTERS ~ start                   }....................
declare_function_with_stdin <<'/---'
str :print_stdout_start()

Prepare for printing to standard output. Specifically (in order):

* Update globals tracking standard output state. See :update_stdout_state() for
  further details.
* Reset color attributes for the terminal attached to standard output to such
  terminal's defaults. See reset_terminal_color() for further details.
/---
function :print_stdout_start() {
    # Validate sanity.
    die_if_args

    # Update output state tested by subsequent zeshy printers *BEFORE* resetting
    # terminal attributes, as the latter touches device files examined by the
    # former.
    :update_stdout_state
    :output_stdout_start
}

declare_function_with_stdin <<'/---'
str :print_stderr_start()

Prepare for printing to standard error. See :print_stdout_start() for further
details.
/---
function :print_stderr_start() {
    die_if_args
    :update_stderr_state
    :output_stderr_start
}

# ....................{ PRINTERS ~ stop                    }....................
declare_function_with_stdin <<'/---'
str :print_stdout_stop()

Conclude prior printing to standard output. Specifically, perform similar
operations as :print_stdout_start() in the reverse order.
/---
function :print_stdout_stop() {
    # Validate sanity.
    die_if_args

    # Reset terminal attributes *BEFORE* updating output state tested by
    # subsequent zeshy printers, as the former touches device files examined by
    # the latter.
    :output_stdout_stop
    :update_stdout_state
}

declare_function_with_stdin <<'/---'
str :print_stderr_stop()

Conclude prior printing to standard output. See :print_stderr_stop() for further
details.
/---
function :print_stderr_stop() {
    die_if_args
    :output_stderr_stop
    :update_stderr_state
}

# ....................{ PRINTERS ~ separated               }....................
#FIXME: Update documentation.

declare_function_with_stdin <<'/---'
str :print_stdout_separated_start()

Prepare for subsequent printing to standard output. Specifically, reset color
attributes for the current terminal to such terminal's defaults _and_ print
whitespace separating subsequent from prior shell output to standard output if
all of the following conditions hold:

** The current shell previously called at least one `zeshy`-specific printer
   function (e.g., :string.output(), print_message_heading()), a prerequisite of the
   condition below.
** The current function was _not_ called directly from the command line (i.e.,
   was called by another function), a prerequisite of the condition below.
** The function calling the current function differs from the most recently
   called printer function. If such functions are the same, their output should
   usually be conjoined rather than separated by whitespace; if such functions
   differ, however, separating their output with whitespace usually improves
   readability and aesthetics.
* _Or_:
** The current modification time of standard output (in seconds since the Unix
   epoch) differs from the previous such time recorded by the most recently
   called printer function, implying that another runnable run at least one
   second before the current call but after the most recently called printer
   function has printed to standard output without calling
   update_stdout_tracking() to update such time. In theory, all runnables
   should update such time after printing to standard output; in practice, the
   ``regulatory burden'' imposed by such a rule guarantees its unlikelihood.
   While this condition fails to detect runnables run in the same second as the
   current call which printed to standard output without updating such time, it
   does reliably detect older such runnables. This condition is a convenience
   fallback and should _not_ be counted upon.
/---
function :print_stdout_separated_start() {
    # Validate sanity.
    die_if_args
    :string stdout_path_old="${ZESHY_STATE_STDOUT_PATH-}"

    # Prepare for printing to standard output.
    :print_stdout_start

    # If the global that tracks standard output is sane (i.e., is set, nonzero,
    # and more recent than the time at which the current shell was started), get
    # and test the time at which such shell last printed to standard output
    # against such global. If the two differ *AND* the canonicalized absolute
    # path of standard output has not changed, print a delimiting newline.
    if is "${stdout_path_old}" == "${ZESHY_STATE_STDOUT_PATH}" si {
#       :output_string_to_stderr "stdout_path_old: ${stdout_path_old}; ZESHY_STATE_STDOUT_PATH: ${ZESHY_STATE_STDOUT_PATH}"
        :output_newline
    }
}

# ....................{ STOPPERS                           }....................
declare_function_with_stdin <<'/---'
void :print_stdout_separated_stop()

Cleanup after prior printing to standard output. Specifically, Reset global
tracking state for `zeshy` printer functions _and_ color attributes for the
current terminal to such terminal's defaults. See reset_terminal_color() and
:update_stdout_state() for further details.
/---
function :print_stdout_separated_stop() {
    die_if_args
    :print_stdout_stop
}

#FIXME: In lieu of unit tests...
# function olii() {
#     print_message_heading 'yummy'
#     :string.output 'here we are'
#     print_message_heading 'tummy'
#     :string.output 'there we go'
# 
#     print_message_item 'yum'
#     print_message_item 'ows'
# }

# --------------------( WASTELANDS                         )--------------------
# tested by subsequent zeshy printers
    # set_float_to_stderr_mtime ZESHY_STDERR_PRIOR_MTIME
    # set_float_to_stdout_mtime ZESHY_STDOUT_PRIOR_MTIME
    # ZESHY_STDOUT_PRIOR_MTIME=0

#FUXME: Rename to ${ZESHY_STATE_STDOUT_PATH} and likewise below.
# :float_global ZESHY_STDOUT_PRIOR_MTIME <<'/---'
# Modification time of the device file associated with standard output for the
# current shell at the time of the most recent call to :update_stdout_state() or 0
# if such function has yet to be called.
# /---
# 
# :float_global ZESHY_STDERR_PRIOR_MTIME <<'/---'
# Modification time of the device file associated with standard error for the
# current shell at the time of the most recent call to :update_stdout_state() or 0
# if such function has yet to be called.
# /---

#FUXME: Wild. O.K.; I think I've tracked down a bit of why :print_stdout_separated_start() no
#longer works as intended: "stat" caching, probably induced by a recent kernel
#upgrade changing internal behavior. We need to find a way of circumventing
#this.
#FUXME: O.K.; I've discovered that zstat() appears to be performing caching
#independent of kernel behavior, which we can't seem to get around. That said,
#the following command (admittedly GNU-specific, but beggers can't particularly
#be choosers) appears to circumvent both this issue *AND* the nanoseconds issue:
#
#    >>> command stat --format='%y' /dev/fd/1
#    2013-09-21 04:12:10.531266625 -0400
#    >>> command stat --format='%y' /dev/fd/1
#    2013-09-21 04:12:10.875260409 -0400
#    >>> command stat --format='%Y~~~%y' /dev/fd/1
#    1379751717~~~2013-09-21 04:21:57.688637663 -0400
#
#A few things to note:
#
#* You *MUST* reference "/dev/fd/1" directly rather than its symbolic link
#  "/dev/stdout", for the simple reason that "stat" doesn't follow such links by
#  default. Of course, you can obviate this by passing "-L" to "stat" -- but,
#  then, why not just avoid the symbolic link altogether? Do so, I should think.
#* This is GNU-specific. Even under non-GNU systems, however, I'm discouraged by
#  the over-caching that zstat() performs. We should probably *ALWAYS* defer to
#  the system "stat" command to avoid such entanglements.
#* Naturally, we'll need to parse such output apart. Happily, we already do so.
#* I'm *STRONGLY* concerned that get_path_mtime() will not behave sanely when
#  run from a piped subshell (which could also be a contributing factor in none
#  of this quite working right). This is easily circumventable by defining a new
#  set_float_to_path_mtime() function and redefining both get_path_mtime() and
#  set_float_to_stdout_mtime() to call such function -- which actually
#  simplifies matters, quite a bit. (Unsure why I didn't just define such
#  function from the beginning, really!)
#
#Reimplement get_path_mtime() and cohorts, then.
#FUXME: Hah! get_path_mtime() is *ALREADY* implemented in this manner, it would
#appear. Clearly, though, we need to *STRONGLY* document why zstat() isn't an
#option, even ignoring the nanoseconds issue. And we still need to define
#set_float_to_path_mtime(), so there's plenty to keep us busy with. :)

#FUXME: On attempting to track down our spurious :print_stdout_separated_start() issue, I noted
#the following output:
#
#    [rhosfa leycec}~/zsh/zeshy/src/gr 'or true'
#    stdout_path:             /dev/pts/6; stdout_mtime:             1379124448.1266725063
#    ZESHY_STATE_STDOUT_PATH: /dev/pts/6; ZESHY_STDOUT_PRIOR_MTIME: 1379124440.1266725063
#    ...
#    [rhosfa leycec}~/zsh/zeshy/src/gr 'or true'
#    stdout_path:             /dev/pts/6; stdout_mtime:             1379125120.1266725063
#    ZESHY_STATE_STDOUT_PATH: /dev/pts/6; ZESHY_STDOUT_PRIOR_MTIME: 1379124448.1266725063
#
#Note the two mtimes differ by 8 seconds but have the same exact nanoseconds.
#Clearly, get_path_mtime() has a subtle bug (or three). 
#
#Interesting! While get_path_mtime() *DEFINITELY* has a bug relating to
#nanoseconds (...in that they never change, which isn't very useful), the main
#issue obviously lies elsewhere. zeshy should be resetting
#${ZESHY_STDOUT_PRIOR_MTIME} to the current... Ah, right. So, as we may recall,
#"gr" is an alias expanding to a function redirecting its output to... Ah,
#nevermind. Since run_code_paged() should be running grep_path_recursive() in
#the current shell, I really don't see why this is failing. Clearly,
#${ZESHY_STDOUT_PRIOR_MTIME} is *NOT* being reset. To debug this, we should
#probably start appending to a log file on every call to :print_stdout_separated_stop().

#FUXME: This *STILL* doesn't behave terribly reliably on copious output. The
#best example is probably:
#
#    >>> eqe virtual/ssh
#
#This prints numerous headings, some of which are (seemingly randomly) preceded
#by separating whitespace and others of which are not. The culprit is almost
#certainly line buffering in either character-special devices (namely, terminal
#drivers) or underlying commands (e.g., "equery"). I'm not entirely convinced a
#sane solution exists, I'm afraid. I'd hate to jettison this, but it *SIMPLY
#DOESN'T WORK.* That said, it could be worth at least examining the solutions
#documented at the following URL for disabling line buffering, of which the most
#promising is the "stdbuf" command provided by recent versions of "coreutils":
#
#    http://mywiki.wooledge.org/BashFAQ/009
#
#Interestingly, the exact same problem persists even after eliminating all
#instances of "| page_stdin" from the function that eqe() calls. So it's not the
#fault of merely redirecting stdout to a pipe. It *MUST* be buffering! Right?
#
#If buffering is at fault and "stdbuf" does rectify the issue, we'll need to
#contemplate how to actually globally apply "stdbuf" to all commands printing
#output. While we'll have to do so manually (namely, be replacing all instances
#of "command ${command_name}" with "command stdbuf ${command_name}" or better
#yet expansion of some new alias such run_command_unbuffered:() conditionally
#expanding to "command stdbuf -oL" only if "stdbuf" is pathable and "command"
#otherwise), grepping for '\bcommand \b' should yield a helpful starting place.
#*shrug*
#FUXME: Interesting. Buffering probably isn't at fault. Globally replacing
#"command equery" with "command stdbuf -oL equery" had utterly no effect on the
#prior issue, suggesting we're dealing with a zeshy-specific bug here, as
#suggested way above. The issue is probably that it's infeasible to reliably
#obtain the nanosecond-portion of file mtime, even with the tricks that
#get_path_mtime() employs -- in which case this has all really been for naught.

    # When debugging, note it's impossible to safely print
    # ${ZESHY_STDOUT_PRIOR_MTIME}. Why? Because merely printing such float
    # changes the return value of get_stdout_mtime(), guaranteeing the next call
    # to :print_stdout_separated_start() to erroneously print whitespace. (Ugh.)

#FUXME: Rename to finalize_stdout_state().
#FUXME: Actually, rename :print_stdout_separated_stop().
#FUXME: Rename to start_stdout_state(). Hmm; perhaps not. How about
#initiate_stdout_state()? Excellent! Fits with nomenclature below.
#FUXME: Actually, rename to... hmm:
#
#* :print_stdout_separated_start().
#* :output_stdout_separated_start().
#* :prepare_stdout_separated_start().
#* :delimit_stdout_start().
#* :prepare_stdout_start().
#* :massage_stdout_start().
#
#Right. I like :print_stdout_separated_start(), yes?

#       :output_string_to_stderr "stdout_path: ${stdout_path}; stdout_mtime: ${stdout_mtime}${ZESHY_ASCII_NEWLINE}ZESHY_STATE_STDOUT_PATH: ${ZESHY_STATE_STDOUT_PATH}; ZESHY_STDOUT_PRIOR_MTIME: ${ZESHY_STDOUT_PRIOR_MTIME}"
    # :float stdout_mtime
#   output_call_stack

    #FUXME: No point, I'm afraid, given Linux kernel changes. See far above.
    # Time at which the current shell last printed to standard output. Get such
    # time *BEFORE* resetting terminal attributes, as the former examines device
    # files touched by the latter.
    # set_float_to_stdout_mtime stdout_mtime

    # Canonicalized absolute path of the standard output device file.
    # :set_string_to_stdout_file stdout_path
    # :output_string_to_stderr "stdout_path: ${stdout_path}; stdout_mtime: ${stdout_mtime}${ZESHY_ASCII_NEWLINE}ZESHY_STATE_STDOUT_PATH: ${ZESHY_STATE_STDOUT_PATH}; ZESHY_STDOUT_PRIOR_MTIME: ${ZESHY_STDOUT_PRIOR_MTIME}"

    # if is "${stdout_path}" == "${ZESHY_STATE_STDOUT_PATH-}" si and
        # (( ${ZESHY_STDOUT_PRIOR_MTIME-0} >= ${ZESHY_TIME_START-1} &&\
        #    stdout_mtime > ${ZESHY_STDOUT_PRIOR_MTIME-0} )) {


    # Reset terminal attributes *BEFORE* updating output state, as the former
    # touches device files tested by the latter.
    # reset_terminal_color

    # # Record the modification times of standard output and error.
    # :update_stdout_state

    # Canonicalized absolute path of the standard output device file. While we
    # could get such path at any time, do so here for simplicity.
    # :set_string_to_stdout_file stdout_path

    # string stdout_path
    # float  stdout_mtime
    # integer i
    # for ((  i=1; i <= 6; i++ )) {
    #     # set_float_to_stdout_mtime stdout_mtime
    #     # :set_string_to_stdout_file stdout_path
    #     # print "[cur] stdout mtime: ${stdout_mtime}\nstdout path: ${stdout_path}"

    #     :set_string_to_stdout_file stdout_path
    #     :string.output "stdout filename: ${stdout_path}"
    #     command stat\
    #         --dereference\
    #         --printf "%y~~~%Y"\
    #         -- "${stdout_path}"
    #     :output_newline
    # }

    # set_float_to_stdout_mtime stdout_mtime
    # :set_string_to_stdout_file stdout_path
    # print "[cur] stdout mtime: ${stdout_mtime}\nstdout path: ${stdout_path}"

    # grep_path_recursive "${HOME}/zsh/zeshy/src" 'or true'
    # grep_path_recursive "${HOME}/zsh/zeshy/src" 'or true'
#:parcel <<'/---'
#Handle *output tracking* of globals recording the state of standard output and
#error after the most recent call to a printer function (e.g., :string.output()),
#where ``state'' typically means the modification time of the device files
#associated with standard output and error at the time of such call.
#/---

# ....................{ OUTPUTTERS                         }....................
#FUXME: I remain unconvinced of the general utility of this function. Honestly,
#we'd be better off excising it entirely. It's uselessly general. (Do we still
#call this anywhere? We certainly shouldn't.)
#declare_function_with_stdin <<'/---'
#string output_line_horizontal()
#
#Print a *hard rule* (i.e., horizontal line) to standard output.
#/---
#function output_line_horizontal() {
#    # Validate sanity.
#    die_if_args
#    string rule
#
#    # Print such rule.
#    rule="$(repeat_string\
#         "${ZESHY_STYLE_TO_TEXT[output_line_horizontal.border]-}"\
#        $(get_terminal_width))"
#    :string.output\
#        "${ZESHY_STYLE_TO_COLOR[output_line_horizontal.border]-}${rule}${ZESHY_STYLE_TO_COLOR[color.reset]-}"
#}

# ....................{ PRINTERS                           }....................
#FUXME: Actually, this is nonsense. By the above definition, *ALL* printers
#should page output. But that would render this function nonsensical. Honestly,
#let's just rename this back to :output_string_colored(). Err -- is this still
#genuinely being called anywhere? Arguably, we should simply excise this
#function away. If we *DO* keep it, alter the implementation to directly call
#reset_terminal_color() twice.
#FUXME: O.K.; I've tracked down the last reference to :string.output():
#@{message/error}. After excising such reference, globally replace
#':string.output\b' with ':string.output' everywhere.

#declare_function_with_stdin <<'/---'
#string :string.output(string text1 = "", string text2, ...)
#
#Print the passed strings (defaulting to the empty string) to standard output
#suffixed by a newline, while sanitizing the current terminal for such output.
#Specifically:
#
#. Reset color attributes for the current terminal to such terminal's defaults.
#. Print such strings in **raw mode** (i.e., printing embedded escape sequences
#  such as `\n` as is rather than converting such sequences to the corresponding
#  characters). See :string.output() for further details.
#. Reset color attributes for the current terminal again.
#
#== Comparison with Low-level Runnables ==
#
#Unlike low-level general-purpose output aliases (e.g., :string.output()) and
#builtins (e.g., echo(), print()) intended to be called by any script or
#function, this function is intended to be called only by high-level printer
#functions (e.g., print_message()). While such aliases are generally helpful,
#avoid calling such builtins, which often behave unsafely (e.g., when passed
#hyphen-prefixed strings): e.g.,
#
#.:string.output() versus print()
#==========================================
#[source]
#------------------------------------------
#>>> string lammoth="-z" morgoth="rm -rf *"
#
## Bad! Never do this, unless guaranteed no hyphens prefix such string.
## If hyphens do prefix such string, zsh treats the first word of such
## string as options to print(). This can be extremely unsafe, as this
## example demonstrates.
#>>> print "${lammoth}" "${morgoth}"
#>>> rm -rf *   # Don't accidentally hit <Enter> here. WHAT, YOU JUST DID!?!
#
## Good. Always do this, instead.
#>>> :string.output "${lammoth}" "${morgoth}"
#-z rm -rf *    # That's more like it.
#------------------------------------------
#==========================================
#/---
#function :string.output() {
#    :print_stdout_separated_start
#    :string.output "${*}"
#    :print_stdout_separated_stop
#}

#FUXME: This should either page output or be removed. Hence, let's probably just
#remove this.
#declare_function_with_stdin <<'/---'
#string print_string_with_newline_prefix_if_needed(
#    string text1 = "", string text2, ...)
#
#Print the passed strings (defaulting to the empty string) to standard output
#suffixed by a newline, while handling and tracking state for standard output
#_and_ sanitizing the current terminal for such output. Specifically:
#
#. Handle output tracking state by print a newline delimiting such strings from
#  prior terminal output, if such output exists. See
#  :print_stdout_separated_start() for further details.
#. Print such strings in raw mode, resetting color attributes for the current
#  terminal both before and after. See :string.output() for further details.
#. Update output tracking state. See :print_stdout_separated_stop() for further details.
#/---
#function print_string_with_newline_prefix_if_needed() {
#    :print_stdout_separated_start
#    :string.output "${*}"
#    :print_stdout_separated_stop
#}

#FUXME: Document the very tangible differences between (in increasing order of
#abstraction and functionality) getters, outputters, and printers.

#Handle low-level *printer functions* (i.e., functions printing strings in a
#manner independent of globals tracking output state). See @{track} for further
#details.

#FUXME: Actually, this is fairly terrible. If we care enough to want to print a
#string in a "colored" manner, then we care enough to simply call :string.output()
#instead. Replace all calls to this function with calls to :string.output()
#instead; then excise this function.
#declare_function_with_stdin <<'/---'
#string :output_string_colored(string text1 = "", string text2, ...)
#
#Print the passed strings (defaulting to the empty string) to standard output
#suffixed by a newline _without_ handling or tracking state for standard output.
#Specifically:
#
#. Reset color attributes for the current terminal to such terminal's defaults.
#. Print such strings in **raw mode** (i.e., printing embedded escape sequences
#  such as `\n` as is rather than converting such sequences to the corresponding
#  characters). See :string.output() for further details.
#. Reset color attributes for the current terminal again.
#
#See :string.output() for further details.
#/---
#function :output_string_colored() {
#    reset_terminal_color
#    :string.output "${*}"
#    reset_terminal_color
#}

#FUXME: Right. Rename the existing parcel "io/output/output" to
#"io/output/print" and shift the following output_*() functions to a new parcel
#"io/output/output".
#FUXME: Rename to output_line_horizontal(). The caller requires fine control over
#prefixing and suffixing whitespace; in this case, such whitespace cannot be
#reliably automated away.
#FUXME: Not necessarily the best parcel for such function, as it's a tad lower-
#level.
#FUXME: Shouldn't we suffix rather than prefix such output with delimiting
#whitespace, unlike most printer functions? If so, we'll need to call a new
#print_string_*() variant.

#:parcel <<'______________<heredoc?>______________'
#Handle high-level *printer functions* (i.e., functions printing strings in a
#manner dependent on globals tracking output state). See @{track} for further
#details.
#______________<heredoc?>______________

# Such state includes:
#
#* The modification time of standard output at the time of the most recent call
#  to a `zeshy` printer function (e.g., :string.output()).
#* The filename and line number at which such function was defined.

    # If the current locale encodes to UTF-8, output UTF-8; else, ASCII.
#   if { is_locale_encoding_utf8 } {
#       hard_rule_character='═'
#   } else {
#       hard_rule_character='='
#   }

#FUXME: Rename to ZESHY_OUTPUT_PRIOR_MTIME_STDOUT.
#FUXME: This is actually redundant, for the simple reason that any function call
#updating the prior globals ${ZESHY_OUTPUT_PRIOR_MTIME_STDOUT} and
#${ZESHY_OUTPUT_PRIOR_MTIME_STDERR} (e.g., print_message()) is signalling that
#the output for the next such call should *NOT* be prefixed by a newline. Why?
#Because, by updating such globals, the mtimes for "/dev/stdout" and
#"/dev/stderr" is guaranteed to equal such globals, in which case no newline
#prefix will be printed. But even if this were not the case, a larger issue
#remains: this global is fundamentally unreliable. It blithely assumes that the
#${funcfiletrace[2]} accurately identifies the name of the high-level caller
#printer function ultimately responsible for calling
#:print_stdout_separated_start(). Naturally, this is only
#ocassionally true. Fixing this would require searching the call stack for...
#what, exactly? The Hindu Godesses only know.
#
#tl;dr
#=====
#Excise this to eliminate redundancy.
#:string_global ZESHY_STDOUT_PRIOR_SCRIPT_LINE <<'/---'
#Unique identifier of the previous runnable (e.g., print_message()) to have most
#recently called update_stdout_tracking() or the empty string if such
#function has yet to be called. Such identifier is the topmost element of stack
#${funcfiletrace} at the time of such call.
#
#`zsh` tracks call stack state with two list globals: ${funcname} and
#${funcfiletrace}. Since ${funcname} elements are runnable names, such list
#distinguishes between calls to different runnables but _not_ between different
#calls to the same runnable. Since ${funcfiletrace} elements are filename and
#line pairs signifying a runnable called on such line, such list distinguishes
#between all calls and hence subsumes ${funcname} for purposes of uniquely
#identifying runnables on the call stack.
#/---

    # Prefer an "if"- to "and"-style conditional to avoid returning false.
    #
    # Prefer explicit string equality testing to calling is_string_equals(), as
    # the latter behaves poorly when either such string expands to the empty
    # string (as curiously appears to be the case when called from an exception
    # handler).
    #
    # Avoid comparing nonextant variables rather than defaulting such variables
    # to seemingly sane default values (e.g., null). The latter behaves
    # unpredictably. For example, if ${funcfiletrace[2]} is set but
    # ${ZESHY_STDOUT_PRIOR_SCRIPT_LINE} is not, defaulting the latter to a
    # seemingly sane default value erroneously guarantees delimiting whitespace
    # will be printed.
    #
    # Subtleties abound, ribald bald acolytes.
#   if is -n "${ZESHY_STDOUT_PRIOR_SCRIPT_LINE-}" and
#       "${funcfiletrace[2]-$'\0'}" !=\
#            "${ZESHY_STDOUT_PRIOR_SCRIPT_LINE}" si or {
        # Sadly, this is the only reliable means of obtaining such time.
#       float stdout_mtime; set_float_to_stdout_mtime stdout_mtime
#       (( ${ZESHY_STDOUT_PRIOR_MTIME-0} &&
#            ZESHY_STDOUT_PRIOR_MTIME != stdout_mtime ))
#   } {
#       float stdout_mtime; set_float_to_stdout_mtime stdout_mtime; :output_string_to_stderr "funcfiletrace[2]: ${funcfiletrace[2]-}; ZESHY_STDOUT_PRIOR_SCRIPT_LINE: ${ZESHY_STDOUT_PRIOR_SCRIPT_LINE-}; ZESHY_STDOUT_PRIOR_MTIME: ${ZESHY_STDOUT_PRIOR_MTIME}; stdout_mtime: ${stdout_mtime}"

#FUXME: Rename to ZESHY_OUTPUT_PRIOR_SCRIPT_LINE.

#   :string.output "funcfiletrace[-2]: ${funcfiletrace[-2]-}\nZESHY_STDOUT_PRIOR_SCRIPT_LINE: ${ZESHY_STDOUT_PRIOR_SCRIPT_LINE-}"

#       "${funcfiletrace[-2]-$'\0'}" !=\
#FUXME: Rename to print_string_sans_newline_suffix().
#FUXME: Likewise, rename :output_string_sans_newline() to
#:output_string_sans_newline().
#declare_function_with_stdin <<'/---'
#string print_string_sans_newline_suffix(string text1 = "", string text2, ...)
#
#Print the passed strings (defaulting to the empty string) to standard output
#suffixed by no newline while handling and tracking state for standard output.
#See :string.output() for further details.
#/---
#function print_string_sans_newline_suffix() {
#    :print_stdout_separated_start
#    :output_string_sans_newline "${*}"
#    :print_stdout_separated_stop
#}

#FUXME: Wait. We never call this anywhere, and I'm fairly certain we'll never
#need to, either. Excise!

# ....................{ PRINTERS ~ stdin                   }....................
#FUXME: This function actually called anywhere? Not terribly sure of the point
#of this function, honestly. Replace with :stdin.get() or output_stdin(), ideally.
#declare_function_with_stdin <<'/---'
#string print_stdin[stdin: string input]
#
#Get standard input piped to the current shell. Since subshells do not inherit
#piped input, avoid calling this function from subshells (e.g., as
#`$(get_stdin_piped)`). Consider calling :stdin.is_nonempty() before this function
#to ensure such input exists: e.g.,
#
#.print_stdin()
#==========================================
#[source]
#------------------------------------------
#>>> 
#>>> function pachamama() {
#...     if { :stdin.is_nonempty } {
#...         print_stdin
#...     } else {
#...         :string.output "${@}"
#...     }
#... }
#>>> :string.output tawantinsuyu | pachamama
#tawantinsuyu
#>>> pachamama tawantinsuyu
#tawantinsuyu
#------------------------------------------
#==========================================
#/---
#function print_stdin() {
#    # Validate sanity.
#    die_if_args
#    die_unless_stdin_readable_sans_blocking
#
#    # Print such input.
#    :stdin.get
#
#    # Close such input, ensuring :stdin.is_nonempty() subsequently returns false.
#    close_stdin
#
#    # Store printer function globals, if needed.
#    update_stdout_tracking
#}

#FUXME: Actually call this elsewhere (e.g., print_message()).
#FUXME: Fix documentation.
    # Mobilize printing on the current terminal.
    # Print such string sans newline suffix.
    # Finalize printing on the current terminal.

#FUXME: No longer convinced we require update_stdout_tracking(). We still need
#:print_stdout_separated_stop() for resetting terminal colors and settings --
#but as for update_stdout_tracking(), what's the point? Since we are inevitably
#going to perform message wrapping in print_message(), etc., there's no longer a
#need to prevent delimiting output with a newline when such output is output by
#the same printer function as the most recent output.
#FUXME: Excising update_stdout_tracking() allows us to dramatically simplify the
#implementation of :print_stdout_separated_start() as well, which is certainly nice.
#The only condition such function should now test is stdout mtime.
#FUXME: Contemplate excising this. Do we still expand this anywhere?

    # Handle previously updated standard output tracking.
#   :print_stdout_separated_start
    # Update standard output tracking in preparation for subsequent handling.
#   :print_stdout_separated_stop
# ....................{ PRINTERS                           }....................
#FUXME: Unconvinced this to be a helpful function. Certainly, the name is not
#helpful at all. Grep the codebase for where this is actually called from.
#declare_function_with_stdin <<'/---'
#string curse_string(string text1, string text2, ...)
#
#Print the passed strings to standard error with default trailing newline. See
#:string.output() for further details.
#/---
#function curse_string() {
#    die_unless_args 'expected at least one string'
#    :string.output "${*}" 1>&2
#    update_stdout_tracking
#}

# No :string.output*() functions call prepend_args_with_stdin_if_piped(),
# as doing so often invites obscene issues. When called by a caller receiving
# piped input, :string.output*() functions silently capturing and closing such
# input before the caller can do so break such caller in subtle and *VERY*
# difficult to debug ways. Moreover, there are no to few reasonable scenarios in
# which :string.output*() functions would be piped rather than merely passed input
# strings. For straightforward safety, avoid inviting such wayward breakage.

#declare_function_with_stdin <<'/---'
#string :string.output(string text1, string text2, ...)
#
#Print the passed strings to standard output with default trailing newline.
#Unlike low-level builtins echo() and print(), this and most other printer
#functions print embedded escape sequences as is rather than converting such
#sequences to the corresponding characters. Such conversions often mangle
#arbitrary output and hence are generally unhelpful. See
#print_string_with_escapes() for further details.
#
#Avoid calling such low-level builtins, which behave unexpectedly dangerously
#when passed hyphen-prefixed strings: e.g.,
#
#.:string.output() versus print()
#==========================================
#[source]
#------------------------------------------
#>>> string lammoth="-z" morgoth="rm -rf *"
#
## Bad! Never do this, unless guaranteed no hyphens prefix such string.
## If hyphens do prefix such string, zsh treats the first word of such
## string as options to print(). This can be extremely unsafe, as this
## example demonstrates.
#>>> print "${lammoth}" "${morgoth}"
#>>> rm -rf *   # Don't accidentally hit <Enter> here. WHAT, YOU JUST DID!?!
#
## Good. Always do this, instead.
#>>> :string.output "${lammoth}" "${morgoth}"
#-z rm -rf *    # That's more like it.
#------------------------------------------
#==========================================
#/---
#function :string.output() {
#    die_unless_args 'expected at least one string'
#    :string.output "${*}"
#    update_stdout_tracking
#}

#FUXME: Given the current implementation, this function name's a bit of a
#misnomer. Rename to... what? I mean, ideally, shouldn't *THIS* function become
#the new :string.output() and the existing :string.output() and curse_string()
#functions simply excised? I reckon that's probably the way forward -- but to
#get there, we'll need to make darn sure that most existing calls to
#:string.output() be renamed to return_string() instead.

#FUXME: *SWEET*. The existing tracking nomenclature is exceedingly awkward. I
#consequently propose renaming:
#
#* :print_stdout_separated_start()      to handle_stdout_tracking().
#* :print_stdout_separated_stop() to update_stdout_tracking().
#* reset_output()  to reset_stdout_tracking().
#
#Remove update_stdout_tracking() and reset_stdout_tracking(). They're just
#overkill; it's not clear such a distinction will ever be useful.
#FUXME: Consider instead renaming:  instead to:
#
#* :print_stdout_separated_start()      to vivify_stdout_tracking().
#* :print_stdout_separated_start()      to initiate_output().
#* :print_stdout_separated_stop() to finalize_output().
#
#Hmm. What about simply :print_stdout_separated_start() and :print_stdout_separated_stop()?
#FUXME: Right... Simply :print_stdout_separated_start() and :print_stdout_separated_stop(), I
#should think.

# ....................{ PRINTERS ~ newline                 }....................
#FUXME: What the heck is this? I fail to see any demonstrable benefit here. In
#fact, this function *SHOULD* be calling :print_stdout_separated_start() to serve
#as a genuine printer function, in which case the implementation makes utterly
#no sense. Replace all instances of this function will :output_newline().
#declare_function_with_stdin <<'/---'
#string print_newline()
#
#Print a blank line to standard output.
#/---
#function print_newline() {
#    die_if_args
#    :output_newline
#    update_stdout_tracking
#}

    # Validate passed arguments.
#   die_unless_args 'expected at least one string'

#declare_function_with_stdin <<'/---'
#string :string.output(string text1, string text2, ...)
#
#Print the passed strings to standard output with default trailing newline.
#Unlike low-level builtins echo() and print(), this and most other printer
#functions print embedded escape sequences as is rather than converting such
#sequences to the corresponding characters. Such conversions often mangle
#arbitrary output and hence are generally unhelpful. See
#print_string_with_escapes() for further details.
#
#Avoid calling such low-level builtins, which behave unexpectedly dangerously
#when passed hyphen-prefixed strings: e.g.,
#
#.:string.output() versus print()
#==========================================
#[source]
#------------------------------------------
#>>> string lammoth="-z" morgoth="rm -rf *"
#
## Bad! Never do this, unless guaranteed no hyphens prefix such string.
## If hyphens do prefix such string, zsh treats the first word of such
## string as options to print(). This can be extremely unsafe, as this
## example demonstrates.
#>>> print "${lammoth}" "${morgoth}"
#>>> rm -rf *   # Don't accidentally hit <Enter> here. WHAT, YOU JUST DID!?!
#
## Good. Always do this, instead.
#>>> :string.output "${lammoth}" "${morgoth}"
#-z rm -rf *    # That's more like it.
#------------------------------------------
#==========================================
#/---
#function :string.output() {
#    die_unless_args 'expected at least one string'
#    :string.output "${*}"
#    update_stdout_tracking
#}


#Unlike low-level builtins echo() and print(), this and most other printer
#functions print embedded escape sequences as is rather than converting such
#sequences to the corresponding characters. Such conversions often mangle
#arbitrary output and hence are generally unhelpful. See
#print_string_with_escapes() for further details.
#
#Avoid calling such low-level builtins, which behave unexpectedly dangerously
#when passed hyphen-prefixed strings: e.g.,

#Unlike such low-level
#aliases and builtins, this function:
# subject to the conditions of :print_stdout_separated_start().
#suffixed by a newline in a color-aware manner. Prefix and suffix such output
#with ANSI color codes resetting color attributes to terminal-specific defaults.

    #FUXME: It'd be far more symmetric to simply call
    #reset_output() here, which incidentally would probably
    #also simplify caller logic. Grep where this function is used and see
    #whether or not all calls to this function are preceded by
    #:print_stdout_separated_start() (as I suspect they are). Since that function
    #already calls reset_terminal_color() internally, we can *GREATLY* simplify
    #such logic by simply shifting all such calls to
    #:print_stdout_separated_start() into this function right here, replacing
    #reset_terminal_color() here with a call to such function.

#FUXME: Is this function still called anywhere? The implementation is rather
#ungainly and, arguably, erroneous by design.
#declare_function_with_stdin <<'/---'
#string print_string_sans_newline_suffix(string text1 = "", string text2, ...)
#
#Print the passed strings (defaulting to the empty string) to standard output
#without trailing newline. See :string.output() for further details.
#/---
#function print_string_sans_newline_suffix() {
    # Validate passed arguments.
#   die_unless_args 'expected at least one string'
#   string text="${*}"

    # Print such string unnewlined.
#   :output_string_sans_newline "${text}"

    #FUXME: This is patently nonsense, now that we test the mtime of
    #"/dev/stdout" with nanosecond resolution. Indeed, it would be safer to
    #*ALWAYS* call update_stdout_tracking(), which updates the last
    #recorded mtime of "/dev/stdout". But, honestly, this function just doesn't
    #work, because ${ZESHY_OUTPUT_STATE_RUNNABLE_ID} will be this function if
    #we call update_stdout_tracking(), guaranteeing the next call to
    #:print_stdout_separated_start() will simply *ALWAYS* print such whitespace,
    #which is the opposite effect of what we want.
    #FUXME: We could introduce a new global set by this function and tested by
    #:print_stdout_separated_start() to avoid such complexities; but, really, this
    #is all *EXTREME* overkill. Excise this function, I should think.

    # Unlike output printed by most printer functions, output printed by this
    # function can conceivably be the empty string. In such case, to avoid
    # printing an unwanted newline on the next call to a printer function, the
    # call stack root must not be reset. Since strings consisting of only ANSI
    # color codes are effectively the empty string, test for emptiness after
    # excluding such codes.
#   if (( $(get_string_length_printable "${text}") )) {
#       print -r "string \"${text}\" length: $(get_string_length_printable "${text}")"
#       update_stdout_tracking
#   }
#}

#FUXME: O.K.; we need to manually sift through the codebase and change all
#current calls to :string.output() for purposes of returning values to
#return_string() instead. The former now performs additional logic conflicting
#with mere value returning; the latter does not. Unavoidable, I'm afraid. As a
#positive bonus, however, the codebase will be moderately more readable.

#FUXME: Should probably be initialized to 0 and the global below to "" when
#serialized into zeshy's user digest file. Unsure how to reliably accomplish
#that. Perhaps perform such initialization in a *VERY* late precompilation hook
#function? Alternately, we should probably just have a list global declared at
#the "src/compile" level of the names of all globals to be initialized to "="
#(i.e., the empty string) immediately before compilation into the digest. This
#is necessary for all globals tracking transient state and hence likely to be
#useful elsewhere in the future.

# (( ${+ZESHY_STDOUT_PRIOR_MTIME} == 0 )) or {
#${+ZESHY_STDOUT_PRIOR_MTIME} == 0 ||
#       ${ZESHY_STDOUT_PRIOR_MTIME-0} &&

    #FUXME: Hyphens are also acceptable delimiters, yes?
    #FUXME: We should probably preserve newlines, yes?

#       print_newline
#      (( ${ZESHY_STDOUT_PRIOR_MTIME-0} &&\
#           ZESHY_STDOUT_PRIOR_MTIME != $(get_stdout_mtime) )) {
    #FUXME: O.K.; I've hunted down why this doesn't work as advertised. It's
    #exceptionally subtle but certainly solvable. Basically, it boils down to
    #get_stdout_mtime(): it's an inherently stupid function, because getters are
    #only ever called as process substitutions, which in this case always
    #returns the stdout of the subshell (a pipe!) rather than the stdout of the
    #current shell (typically, a pseudo-terminal). We need to *EXCISE*
    #get_stdout_mtime() and make a new alias set_float_to_stdout_mtime():
    #
    #alias set_float_to_stdout_mtime='{
    #   # Do the typical thing here, getting all of stdin into a single local
    #   # variable named:
    #   string float_name__sftso
    #   :var.die_unless_type_float "${float_name__sftso}"
    #
    #   # Resolve "/dev/fd/1" to a non-symbolic absolute path. Assuming the
    #   # current shell to be a pseudo-terminal, "/dev/fd/1" is typically a
    #   # symbolic link to the device for such terminal (e.g., "/dev/pts/7").
    #   # Referring to standard output by such resolved rather than symbolic
    #   # path is essential; we run the command getting standard output's mtime
    #   # from a process substitution in which symbolic path "/dev/fd/1" refers
    #   # to a shell pipe rather than the desired pseudo-terminal.
    #   #
    #   # Sadly, the only safe means of resolving such path is as below.
    #   # Replacing the first pipeline subcommand with a call to
    #   # :canonicalize_path() uselessly returns "/dev/fd/1" without resolving
    #   # such path. Likewise, replacing the second pipeline subcommand with a
    #   # process substitution has the same effect. (My inveterate Gods, but
    #   # this is subtle.)
    #   string stdout_filename__sftso
    #   :string.output "${ZESHY_STDOUT_FILE_DESCRIPTOR_PATH}"(:A) |
    #       set_string_to_stdin_pipe stdout_filename__sftso
    #
    #   # Set such float to such path's mtime. See set_float_to_float() for
    #   # further details.
    #   get_path_mtime "${stdout_filename__sftso}" |
    #       set_float_to_stdin_pipe "${float_name__sftso}"
    #} <<<'
    #
    #Craziness, but it works. Shift to "05-alias/io/standard". *shakes head*
    #FUXME: We need to add a new set_float_to_stdin_pipe() to "always/io/standard",
    #which then requires a new set_float_to_float() in
    #"always/variable/float/float". It's all trivial -- just needs to be done!
    #FUXME: Alternatively, we could just make a new
    #:set_var_to_stdin_pipe() function. It's not to have the strict typing of
    #set_string_to_stdin_pipe() elsewhere, but it's really just an inefficiency here.
    #Then, we could just call set_scalar_to_stdin() above twice. Hmmm...
    #actually, that gains us effectively nothing. There are *ONLY* three scalar
    #types, so we'd might as well support them all type-safely. Honestly, any
    #inefficiency here is minor compared to the weight of zeshy as a whole.
    #O.K.; go with the original plan above!
    # When debugging, note that it's not genuinely possible to print
    # ${ZESHY_STDOUT_PRIOR_MTIME}. Why? Because merely printing

#   :string.output "resetting ZESHY_STDOUT_PRIOR_SCRIPT_LINE: ${ZESHY_STDOUT_PRIOR_SCRIPT_LINE}" 1>&2
#   :string.output "resetting ZESHY_STDOUT_PRIOR_MTIME: ${ZESHY_STDOUT_PRIOR_MTIME}; ZESHY_STDOUT_PRIOR_SCRIPT_LINE: ${ZESHY_STDOUT_PRIOR_SCRIPT_LINE}" 1>&2
    #FUXME: Sadly, we need to drop the ${ZESHY_STDOUT_PRIOR_MTIME} testing.
    #Why? Because, with a coarse granularity of only seconds, this function
    #effectively reduces to a random number generator: sometimes it prints
    #delimiting whitespace as expected, sometimes it doesn't. This is terrible.
    #However, document the current solution for posterity.
    #FUXME: *WAIT*. Any kernel worth running zsh on should support nanosecond-
    #resolution mtimes; see:
    #  http://stackoverflow.com/questions/7206014/get-a-nanosecond-precise-atime-mtime-ctime-fields-for-file-stat
    #
    #zsh appears to have integrated a patch; see:
    #  http://www.zsh.org/mla/workers/2007/msg00972.html
    #FUXME: Ah-ha! While zsh currently supplies no means of retrieving
    #nanosecond-resolution times via zstat(), the system-specific stat() command
    #does *IF* passed option "-c '%y====%Y'": e.g.,
    #
    #  >>> stat --dereference --printf '%y\0%Y' /dev/fd/1
    #  2013-05-22 19:39:01.436503138 -04001369265941
    #
    #Awesome, no? We'll need to parse the actual nanosecond mtime back together
    #from such string. For the above, for example, such mtime is:
    #
    #  1369265941.436503138
    #
    #By saving such value to a float, "viola!" Nanosecond-resolution times.
    #FUXME: Since the output of "-c '%y'" is system- and user-specific, we
    #should simply round such time to the nearest integer if it fails to match
    #the above specification: e.g.,
    #
    #  1369265941.0

    #FUXME: We should be using the test operator "-om" in place of...
    # Ensure each tested variable exists before testing such
    # variable's
    # To avoid returning success when both string variables are
    # undefined, default undefined string variables to a value that zsh
    # operation guarantees such variables to *NEVER* be set to (i.e., null).
    #
    # Subtleties abound, ribald bald acolytes.
#   if is "${funcfiletrace[2]-$'\0'}" !=\
#         "${ZESHY_STDOUT_PRIOR_SCRIPT_LINE-$'\0'}" si or

#-n "${ZESHY_STDOUT_PRIOR_SCRIPT_LINE-}" and
#       "${#funcfiletrace}" -ge 2 and
#
#${+ZESHY_STDOUT_PRIOR_MTIME} &&\
#FUXME: Excise everywhere, shifting documentation above where applicable. I
#recall only referencing this global in this component. Check on that...
#declare_global_with_stdin <<'/---'
#string ZESHY_PRINT_CALL_STACK_ROOT
#
#Most recent call stack root to have called a high-level print function (e.g.,
#print_message(), print_warning()) or the empty string if no such function has
#been called, where "call stack root" is the first zsh function, script, or
#command line to have initiated the current call stack.
#
#Specifically, this string is the first element of list global ${funcfiletrace}
#at the time of the most recent call to a high-level print function as recorded
#by :print_stdout_separated_start(). zsh tracks call stack state with
#two list globals: ${funcname} and ${funcfiletrace}. The former distinguishes
#between calls to different functions and scripts but *NOT* between different
#calls to the same function or script or between different command lines. The
#latter distinguishes between all such calls, hence subsuming the former. Given
#only a filename and line, inspecting such line usually furnishes the function
#name called on such line. Therefore, each element of ${funcfiletrace} uniquely
#identifies the corresponding call in the call stack. Since the first element of
#such list corresponds to the caller responsible for initiating the entire call
#stack, such element effectively differentiates such stack from subsequent call
#stacks initiated by other callers.
#
#See :print_stdout_separated_start() for further details.
#/---
#
#stored call stack root specific to `zeshy` printer functions to the current call
#stack root. This function is typically called by low-level `zeshy` printer functions
#(e.g., :string.output()) to notify subsequently called high-level print functions
#(e.g., print_message()) that at least one such print function has already been
#called under the current call stack root and that
#:print_stdout_separated_start() should thus print a delimiting newline.
#If standard output for the current shell is attached to a terminal, set the
#stored call stack root specific to `zeshy` printer functions to the current call
#stack root. This function is typically called by low-level `zeshy` printer functions
#(e.g., :string.output()) to notify subsequently called high-level print functions
#(e.g., print_message()) that at least one such print function has already been
#called under the current call stack root and that
#:print_stdout_separated_start() should thus print a delimiting newline.
#      (( ZESHY_STDOUT_PRIOR_MTIME )) and
    #FUXME: Convert to an "if" statement and attempt to remove the trailing
    #report_success().

    # If the previously recorded call stack root (defaulting to the empty string
    # if not previously recorded) is the current call stack root, at least one
    # message has already been output under such call stack, so this function
    # must prefix the current message to be output with whitespace.
    #
    # Else the previously recorded call stack root and current call stack root
    # differ, suggesting no message has been output under such call stack, so no
    # prefixing whitespace is required.
    #
    # Prefer explicit string equality testing to calling is_string_equals(), as
    # the latter behaves poorly when either such string expands to the empty
    # string (as curiously appears to be the case when called from an exception
    # handler). Subtleties abound, dear acolytes.
#   print "printing newline if equals: ZESHY_PRINT_CALL_STACK_ROOT: ${ZESHY_PRINT_CALL_STACK_ROOT-}; funcfiletrace[-1]: ${funcfiletrace[-1]}" 1>&2; output_call_stack 1>&2
#   is "${ZESHY_PRINT_CALL_STACK_ROOT-}" == "${funcfiletrace[-1]}" si and
#       print_newline
#       print "printing newline; call stack ends: ${funcfiletrace[-1]} / ${funcfiletrace[-1]}"

    # Succeed regardless of whether such newline was printed.
#   report_success
# the following conditions all hold 
    #FUXME: This isn't quite right, and one can readily see why when
    #uncommenting the print() statement below: a granularity of seconds is
    #simply too low to reliably detect changes. Ideally, "mtime" would be
    #recorded in milli- or nanoseconds. Since it isn't, another approach is
    #required. 

#FUXME: Adjust the conditions under which a newline is printed to the following:
#
#* If ${ZESHY_STDOUT_PRIOR_SCRIPT_LINE} is unequal to the currently called printer
#  function name (e.g., "print_message"),
#* If ${ZESHY_STDOUT_PRIOR_MTIME} is non-empty (or non-zero, if we
#  decide to use an integer as we probably should) *AND* unequal to the
#  current mtime for "/dev/fd/1" *AND*
#* Then and only then print a newline.
#See 
#Print a blank line to standard output if at least one Zeshy print function has
#already been called under the current call stack root (i.e., called either by
#such root or by a function or script transitively called by such root). This
#function is typically called by high-level Zeshy print functions (e.g.,
#print_message()) to print a newline delimiting subsequent from previous output.
#See ${ZESHY_PRINT_CALL_STACK_ROOT} for further details.
    # * Standard output for the current shell is attached to either a terminal
    #   or pipe (e.g., page_stdin()) (thus avoiding printing a newline when
    #   ,
    #if { is_stdout_terminal_or_pipe } and
#FUXME: Rename to update_printer_globals(). Hmm, perhaps
#update_stdout_tracking() or set_last_print_globals()?
#FUXME: Rename to ZESHY_FUNCTION_PRINTER_STDOUT_MTIME.
#FUXME: Rename to ZESHY_FUNCTION_PRINTER_NAME.
#FUXME: Do we actually call this anywhere? And if so, why? All such calls
#should probably simply be expanding :output_string_sans_newline(). Grep the
#codebase.
    # Succeed regardless of whether such root was reset.
#   report_success
# (e.g., newlines, nulls, strings, lists).
# ....................{ PRINTERS ~ separated               }....................
#FUXME: Such functions should internally depend on new functions of new
#component "variable/string/separate", which actually perform the calling of
#builtin print(). Consider function names:
#
#* concatenate_strings() or unseparate_strings(). Probably the former; the
#  latter is simply odd. Right. Every language needs a concatenate function,
#  so... this is ours!
#* separate_strings_with_newline() or delimit_strings_by_newline(). The former.
#* separate_strings_with_null().
#FUXME: Rename this function to print_strings_concatenated().
#declare_function_with_stdin <<'/---'
#string print_strings_unseparated(string text1, string text2, ...)
#
#Print the passed strings to standard output with default trailing newline and
#_not_ internally delimited by ${IFS}, the internal field separator: e.g.,
#
#.print_strings_unseparated()
#==========================================
#[source]
#------------------------------------------
#>>> print_strings_unseparated "Where Alph," "the sacred river," "ran"
#Where Alph,the sacred river,ran
#------------------------------------------
#==========================================
#/---
#function print_strings_unseparated() {
#    # Temporarily set global string ${IFS} to the empty string. Since zsh
#    # implicitly delimits lists interpolated with the "*" operator when double-
#    # quoted with such global, the following commands print the passed arguments
#    # undelimited. This incantation was astonishingly difficult to discover.
#    die_unless_args 'expected at least one string'
#    string IFS=
#    print -r -- "${*}"  # if not double-quoted, zsh oddly ignores ${IFS}
#    update_stdout_tracking
#}

#declare_function_with_stdin <<'/---'
#string print_strings_newlined(string text1, string text2, ...)
#
#Print the passed strings to standard output delimited by newlines: e.g.,
#
#.print_strings_newlined()
#==========================================
#[source]
#------------------------------------------
#>>> print_strings_newlined sludge elf transmuter
#sludge
#elf
#transmuter
#------------------------------------------
#==========================================
#/---
#function print_strings_newlined() {
#    die_unless_args 'expected at least one string'
#    print -lr -- "${@}"
#    update_stdout_tracking
#}
#
#declare_function_with_stdin <<'/---'
#string print_strings_nulled(string text1, string text2, ...)
#
#Print the passed strings to standard output delimited and terminated by nulls.
#Suffix each such string with character "\0", in other words: e.g.,
#
#.print_strings_nulled()
#==========================================
#[source]
#------------------------------------------
#>>> print_strings_nulled "Through caverns" "measureless to" "man"
#Through caverns\0measureless to\0man
#------------------------------------------
#==========================================
#/---
#function print_strings_nulled() {
#    die_unless_args 'expected at least one string'
#    print -Nr -- "${@}"
#    update_stdout_tracking
#}

#       ZESHY_PRINT_CALL_STACK_ROOT="${funcfiletrace[-1]}"
#       print "resetting ZESHY_PRINT_CALL_STACK_ROOT: ${ZESHY_PRINT_CALL_STACK_ROOT}" 1>&2; output_call_stack 1>&2
    # Succeed regardless of whether such root was set.
#   report_success
    # If standard output for the current shell is attached to either a terminal
    # or pipe (e.g., page_stdin()), store such globals.
    #
    # Prefer an "if"- to "and"-style conditional to avoid returning false.
#   if { is_stdout_terminal_or_pipe } {

#FUXME: Rename to print_strings_unseparated() or print_strings_undelimited()?
#Yes, I rather like the latter. Though, the former is a bit more readable...
#FUXME: Rename to print_string_unnewlined() or perhaps simply
#:output_string_sans_newline(). Yeah; the latter is pretty sweet.
#Print the passed strings to standard output without delimitation:
#FUXME: Hmm; this should really be called print_string_with_escapes(). Function
#name print_string_with_escapes() implies something completely different (i.e., that
#all shell-reserved characters will be printed escaped).

# common escapes escaped (i.e., converted to the corresponding characters):
# Unlike say(), print no theme-specific nonsense (e.g., ANSI color codes).
# Unlike cry(), print no theme-specific nonsense (e.g., ANSI color codes).
# (i.e., such that a newline separates each such string from the next)
    # If the previously recorded call stack root (defaulting to the empty string
    # if not previously recorded) is the current call stack root, at least one
    # message has already been output under such call stack, so this function
    # must prefix the current message to be output with whitespace.
#   if is_string_equals\
#       "${ZESHY_PRINT_CALL_STACK_ROOT-}" "${funcfiletrace[-1]}"
#   then print_newline
#       print "printing newline; call stack ends: ${funcfiletrace[-1]} / ${funcfiletrace[-1]}"

    #FUXME: This is now redundant, as the subsequent :string.output()
    #function sets this.

    # Else the previously recorded call stack root and current call stack root
    # differ, suggesting no message has been output under such call stack, so no
    # prefixing whitespace is required. Instead, replace the previously recorded
    # call stack root with the current.
#   else ZESHY_PRINT_CALL_STACK_ROOT="${funcfiletrace[-1]}"
#   fi

#Prefix the next string to be output with whitespace delimiting such string from
#previously output strings if at least one such string has already been output
#under the current call stack root. This function manages string global
#${ZESHY_PRINT_CALL_STACK_ROOT} on behalf of the caller, usually a high-level
#print function (e.g., print_message(), print_header()).
#
#FUXME: A bit unintuitive. Not sure either is terribly better, but how about
#renaming to print_string_no_newline() or print_string_newlineless() or
#:output_string_sans_newline(). The latter coincides with print_strings_unseparated()
#and thus strikes me as the best bet.
# demarcating subsequent from prior lines
#FUXME: This function strikes me as a poor idea. Functions should not, ideally,
#handle such aesthetic-dependent behavior. Cut everywhere.
#FUXME: Actually, it's a fine idea: it's just the nomen
    #FUXME: Bit more natural to call as a pipe: e.g.,
    #    print_message "${*}" | :output_string_sans_newline
    #We'll need to add pipe support to such functions. Since this is something
    #we want to do anyway, it's hard to see complaints.
#   :output_string_sans_newline "$(print_message "${*}")"
#   :output_string_sans_newline "$(print_warning "${*}" 2>&1)" 1>&2
#FUXME: How often do the curse_*() functions come up? Grep the codebase. I
#suspect the answer is "never", or near enough, in which case we should excise
#everything except curse_string(). The whole thing's nonsensical code
#duplication, anyway, as any curse_*() function is implemented simply by calling
#the corresponding print_*() function appended by "1>&2". What could be simpler?

#declare_function '
#void curse_string_escaped(string text1, string text2, ...)
#
#Print the passed strings to standard error with default trailing newline and
#all escapes escaped, as with print_string_with_escapes().
#'
#function curse_string_escaped() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    print -- "${*}" 1>&2
#}

#declare_function '
#void curse_string_undelimited(string text1, string text2, ...)
#
#Print the passed strings to standard error without delimitation: e.g.,
#
#    >>> curse_string_undelimited "Through caverns" "measureless to" "man"
#    Through cavernsmeasureless toman
#'
#function curse_string_undelimited() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    string IFS=
#    print -r -- "${*}" 1>&2  # if not double-quoted, zsh oddly ignores ${IFS}
#}

#declare_function '
#void curse_string_nulled(string text1, string text2, ...)
#
#Print the passed strings to standard output delimited and terminated by nulls.
#See curse_string_nulled for details.
#'
#function curse_string_nulled() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    print -Nr -- "${@}" 1>&2
#}

#declare_function '
#void curse_newline()
#
#Print a blank line to standard error.
#'
#function curse_newline() {
#    die_if_args
#    print 1>&2
#}
#FUXME: Rename to :output_string_sans_newline(). Every other alternative is absurdly
#and frankly stupidly verbose (e.g., "unsuffixed_by_newline",
#"without_newline"). Since "newline" is increasingly used as a verb (e.g., "That
#text shouldn't be newlined."), I don't see why we can't coin a derivative
#neologism from that: non-newline! Google shows a large number of hits for
#"non-newline" as a noun, so... There we go.
#declare_function '
#void curse_string_sans_newline_suffix(string text1, string text2, ...)
#
#Print the passed strings to standard error with no default trailing newline.
#'
#function curse_string_sans_newline_suffix() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    print -nr -- "${*}" 1>&2
#}

#declare_function '
#string print_string_sans_newline_suffix(string text1, string text2, ...)
#
#Print the passed strings to standard output in a color-aware manner with *NO*
#trailing newline. See :string.output() for further details.
#'
#function print_string_sans_newline_suffix() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    print -nr -- "${ZESHY_COLOR_RESET-}${*}${ZESHY_COLOR_RESET-}"
#}

#   print "stdin: $(< /dev/stdin)"
#FUXME: Rename to print_nondelimited(); similarly, below. While Google shows an
#effectively equal number of hits for both undelimited and non-delimited, the
#latter is much more consistent with nomenclature elsewhere.
#FUXME: Rename to print_with_delimiter_newline(); similarly, below.
# * Rename "cry" to "cry" and "outcry" to simply "outcry". Likewise,
#   rename "say" to "put" and "output" to simply "output". Truly, for this is
#   Awesome Incarnate.
# * Alternatively, rename "outcry" to "decry", "say" to "vow", and "output"
#   to "devow". Personally, I prefer the "out"-prefixed forms, as that cleanly
#   suggests an input_*() family of functions to accept input.
# * O.K.; how about this. The "cry" forms are quite perfect, but the "say"
#   forms... I quite like "output" to "output", but "say" to "put"? It reads
#   awkwardly, to put it mildly. Let's go non-orthogonal here, for readability.
#   How about "say" to "say", which coincides nicely with "cry"? Then we have:
#
#   print_warning -> print_warning      curse_string -> outcry
#   print_message -> print_message      :string.output -> output
# * I'm strongly in favor of:
#   output() or stsay() or msay()
#   outcry() or ???????()
#   Yeah, output() and outcry() read quite well.
