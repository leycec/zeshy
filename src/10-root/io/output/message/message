#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *message printers* (i.e., functions printing informative messages).
/---

#FIXME: Consider prefixing each wrapped message line under non-interactive
#cronjobs with an appropriate timestamp (e.g., "["$(date +'%F %T')"]") rather
#than embedding such lines in an ANSI-flavored box.

# ....................{ PRINTERS                           }....................
#FIXME: Correct example output.
:func.doc <<'/---'
string print_message(string message1 = "", ...)

Print the passed strings (defaulting to the empty string) as a message entitled
under the name of the runnable originating the current call stack. For
aesthetics, such title will be centered to the width of the current terminal and
such message wrapped to such width. Assuming default user-configurable `zeshy`
styles, both will be formatted with box drawing characters appropriate to the
current character locale encoding (e.g., UTF-8). See print_string_titled_in_style_caller() for
further details: e.g.,

.print_message()
==========================================
[source]
------------------------------------------
>>> string on_falsehood=\
...    "An error does not become truth by reason of multiplied propagation, nor
...     does truth become error because nobody sees it. Truth stands, even if
...     there be no public support. It is self sustained."
>>> print_message "${on_falsehood}"
┎──────────────────────────────────╼ zeshy ╾───────────────────────────────────┒
┃ An error does not become truth by reason of multiplied propagation, nor does ┃
┃ truth become error because nobody sees it. Truth stands, even if there be no ┃
┃ public support. It is self sustained.                                        ┃
┖──────────────────────────────────────────────────────────────────────────────┚
------------------------------------------
==========================================
/---
function print_message() {
    print_string_titled_in_style_caller "${*}"\
        "$(output_call_stack_title_in_style_caller) Message"
}

:func.doc <<'/---'
string print_message_interactively(string message1 = "", ...)

Print the passed strings (defaulting to the empty string) as a message if the
current shell is interactive or return silently otherwise. See print_message()
for further details.
/---
function print_message_interactively() {
    # Implement such conditional with an "if"- rather than "and"-based
    # statement, as the latter returns non-zero exit status when noninteractive.
    if { :shell.is_interactive } {
        print_message "${*}"
    }
}

:func.doc <<'/---'
string print_message_unboxed(string message1 = "", ...)

Print the passed strings (defaulting to the empty string) as a message,
replacing all *boxing* (i.e., substrings consisting of a newline followed by
zero or more horizontal whitespace characters) in such strings with single
spaces before wrapping the result to the width of the current terminal. See
print_message() and replace_string_boxing_with_spaces() for further details:
e.g.,

.print_message_unboxed()
==========================================
[source]
------------------------------------------
>>> string on_representation=\
...    "The oppressed are allowed once every few years to decide which
...     particular representatives of the oppressing class shall represent and
...     repress them in parliament."
>>> print_message_unboxed "${on_representation}"
┎──────────────────────────────────╼ zeshy ╾───────────────────────────────────┒
┃ The oppressed are allowed once every few years to decide which particular    ┃
┃ representatives of the oppressing class shall represent and repress them in  ┃
┃ parliament.                                                                  ┃
┖──────────────────────────────────────────────────────────────────────────────┚
>>> print_message "${on_representation}"
┎──────────────────────────────────╼ zeshy ╾───────────────────────────────────┒
┃ The oppressed are allowed once every few years to decide which               ┃
┃ particular representatives of the oppressing class shall represent and       ┃
┃ repress them in parliament.                                                  ┃
┖──────────────────────────────────────────────────────────────────────────────┚
------------------------------------------
==========================================
/---
function print_message_unboxed() {
    print_message "$(replace_string_boxing_with_spaces "${*}")"
}

# ....................{ PRINTERS ~ heading                 }....................
:func.doc <<'/---'
string print_message_heading(string heading1, ...)

Print the passed string(s) as a heading centered to the width of the current
terminal, styled under the user-configurable styles prefixed by
`print_message_heading.`. See center_string_in_style() for further details,
replacing `${style_prefix}` with such prefix (e.g.,
`print_message_heading.border_right`, styling the right border).
/---
function print_message_heading() {
    # Validate sanity.
    die_unless_args 'Expected one or more strings.'

    #FIXME: Interesting. Terrible, but interesting. If you uncomment the print
    #statements below and call this function like so:
    #
    #    >>> COLUMNS=20 print_message_heading yum  
    #    ... terminal width: 20 (20)
    #    ... terminal width: 102 (102)
    #    ... ┃┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈• yum •┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┃
    #
    #Clearly, the call to :print_stdout_separated_start() resets the setting of ${COLUMNS}. Why?
    #But it gets stranger. If you indirectly call this function like so (noting
    #that die_if_runnable() calls die_evaluated() internally setting ${COLUMNS}
    #as above):
    #
    #    >>> die_if_runnable info
    #    ... terminal width: 98 (98)
    #    ... terminal width: 98 (98)
    #
    #That works as expected. But the first case doesn't. What in the three Hells
    #of Man and Machine is going on here? *sigh*
#   print "terminal width: $(get_terminal_width) (${COLUMNS})"

    # Print such heading.
    :print_stdout_separated_start
#   print "terminal width: $(get_terminal_width) (${COLUMNS})"
    center_string_in_style_caller "${*}"
    :print_stdout_separated_stop
}

# ....................{ PRINTERS ~ item                    }....................
:func.doc <<'/---'
str print_message_item(str item1, ...)

Print the passed string(s) as an itemized message, wrapped to the width of the
current terminal but neither prefixed by a heading or suffixed by a footer.
Assuming default user-configurable `zeshy` styles, such message will be
formatted with line drawing characters appropriate to the current character
locale encoding (e.g., UTF-8): e.g.,

.print_message_item()
==========================================
[source]
------------------------------------------
>>> string on_liberty=\
...    "I'm a lover of my own liberty, and so I would do nothing to restrict
...     yours. I simply want to please my own conscience, which is God."
>>> string on_forgiveness=\
...    "The weak can never forgive. Forgiveness is the attribute of the strong."
>>> print_message_item "${on_liberty}"; print_message_item "${on_forgiveness}"
┇ I'm a lover of my own liberty, and so I would do nothing to restrict yours. ┇
╏ I simply want to please my own conscience, which is God. •┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╏
┇ The weak can never forgive. Forgiveness is the attribute of the strong. •┈┈┈┇
------------------------------------------
==========================================
/---
function print_message_item() {
    # To avoid prefixing such items with spurious newlines, avoid delimiting
    # such output with calls to :print_stdout_separated_start() and :print_stdout_separated_stop(). The Linux
    # kernel imposes a delay on TTY mtime updates, ensuring :print_stdout_separated_start()
    # cannot reliably determine whether or not prior output exists and hence
    # almost always simply outputs a prefixing newline.
    die_unless_args 'Expected one or more strings.'
    :print_stdout_start
    wrap_string_in_style_caller "${*}"
    :print_stdout_stop
}

:func.doc <<'/---'
string print_message_item_interactively(string message1 = "", ...)

Print the passed strings (defaulting to the empty string) as an itemized
message if the current shell is interactive or return silently otherwise. See
print_message_item() and :context.is_cli() for further details: e.g.,

.print_message_item_interactively()
==========================================
[source]
------------------------------------------
>>> string on_dogs=\
...    "To his dog, every man is Napoleon; hence the constant popularity of dogs."
>>> string on_death=\
...    "Death is the only thing we haven't succeeded in completely vulgarizing."
>>> string on_propaganda=\
...    "The propagandist's purpose is to make one set of people forget that
...     certain other sets of people are human."
>>> {
...     print_message_item_interactively "${on_dogs}"
...     print_message_item_interactively "${on_death}"
...     print_message_item_interactively "${on_propaganda}"
... }
┇ To his dog, every man is Napoleon; hence the constant popularity of dogs. •┈┇
┇ Death is the only thing we haven't succeeded in completely vulgarizing. •┈┈┈┇
┇ The propagandist's purpose is to make one set of people forget that •┈┈┈┈┈┈┈┇
╏ certain other sets of people are human. •┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╏
------------------------------------------
==========================================
/---
function print_message_item_interactively() {
    if { :shell.is_interactive } {
        print_message_item "${@}"
    }
}

#FIXME: In lieu of unit tests...
function pumo() {
    print_message_heading 'Zetsubou Billy'
    print 'okok'
    print_message_heading 'Louisiana Bob'

    print_message_item\
        'To his dog, every man is Napoleon; hence the constant popularity of dogs.'
    print_message_item\
        'Death is the only thing we haven''t succeeded in completely vulgarizing.'
    print_message_item\
        'The propagandist''s purpose is to make one set of people forget that certain other sets of people are human.'

    print_message_item\
        'To his dog, every man is Napoleon; hence the constant popularity of dogs.'
    print 'humhum'
    print_message_item\
        'Death is the only thing we haven''t succeeded in completely vulgarizing.'
    print "humhum${ZY_ASCII_NEWLINE}"
    print_message_item\
        'The propagandist''s purpose is to make one set of people forget that certain other sets of people are human.'
}

# ....................{ EXCEPTIONS                         }....................
#FIXME: Interestingly, we don't actually want all exceptions to be handled. We
#always want *UNEXPECTED* exceptions to be handled. Expected exceptions,
#however, should only be handled if the current user's Zeshy configuration
#requests such handling, which should be disabled by default. The canonical
#example of an expected exception is an external command wrapped by a Zeshy
#function returning non-zero exit status on failing to find a match (e.g.,
#"command grep" wrapped by grep_path()). Note that even in this case, of course,
#not all errors emitted by "command grep" are expected: only on failing to find
#a match, which must be explicitly tested for. This suggests a new helper
#function die_unhandled(), which (as expected) does everything :die() does but
#excludes only the call to handle_exception(). Since this reduplicates a great
#deal of intricate code, perhaps :die() and die_unhandled() can simply delegate
#to an internal utility function with prototype:
#
# string die_handled_if(
#   string error_message = '', boolean is_handling_exception)
#
#Obviously, such functions should be shifted to a new component in the proper
#Zeshy codebase: say, "shell/exception".
#FIXME: While such functionality is essential for oddball corner-cases (e.g.,
#"grep"), what we generally want is a simple way of squelching exceptions when
#the current shell is interactive *AND* the current call stack ends with a
#particular function that was called by some other particular function earlier
#in such stack. This could possibly be implemented as a global map from the
#former to latter, which function :die() and associates would need to respect.
#Consider the following definition:
#
#map_global_export\
#    ZY__EXCEPTION_HIDE_IF_INTERACTIVELY_THROWN_BY_FUNCTION_NAMES
#
#Ah; wait. The "_INTERACTIVELY" is redundant, since such code paths can only
#come about as interactive alias expansions. Also, it's not specifically
#function names -- it's runnable names. Reduce to:
#
#map_global_export\
#    ZY__EXCEPTION_HIDE_IF_THROWN_BY_RUNNABLE_NAMES
#
#Define such global as follows:
#
#ZY__EXCEPTION_HIDE_IF_THROWN_BY_RUNNABLE_NAMES=(
#    'ls' 'l'
#    'ls' 'ls'
#    'grep' 'g'
#    'grep' 'grep'
#    'grep' 'gr'
#    ...
#)
#
#Now, that's in a great format for consumption by die_*() functions. But it's
#not really the greatest for definition; given the tenuous nature of interactive
#aliases, we really want to automate definition of such global. This should,
#naturally, be done by the alias_cli_abbreviation() and
#alias_cli_substitution() functions. (O.K.; I suppose alias_cli()
#applies as well.) Under alias_cli_substitution(), it's easy to set two such
#entries: for both, the key is the command name being substituted; for the
#first, the value is the same name; for the second, the value is such
#substitution's abbreviation (if any!). Under alias_cli_abbreviation(),
#thing's are a bit less automated: we'll need to improve
#alias_cli_abbreviation() to accept an optional second argument specifying the
#name of the core underlying external command that such abbreviation eventually
#runs. Hence, this:
#
#    alias_cli_abbreviation {cal}endar{q}uarter='print_calendar_quarter'
#
#...would need to be expanded to this:
#
#    alias_cli_abbreviation {cal}endar{q}uarter='print_calendar_quarter' cal
#
#This then adds a single entry to the above global resembling this:
#
#    ZY__EXCEPTION_HIDE_IF_THROWN_BY_RUNNABLE_NAMES+='cal' 'calq'
#
#There's really no other sensible way to handle abbreviations. This works, it's
#only a minor nuisance; let's go-goggogogogo-go!
#
#The first steps, clearly, will be automating alias_cli_substitution() to
#perform such definition and :die() to respect such definition (possibly subject
#to a user-configurable boolean enabling or disabling such functionality). After
#getting that to work, then contemplate the extension of such logic to
#alias_cli_abbreviation(). Such global could (possibly) be called:
#
#    boolean_global_export ZY_IS_HANDLING_ERROR_IF_THROWN_BY_NONHANDLING_RUNNABLES
#
#Hmm; what about:
#
#    boolean_global_export ZY_IS_ERROR_HANDLED_IF_HIDDEN
#    ZY_IS_ERROR_HANDLED_IF_HIDDEN=${ZY_BOOLEAN_FALSE}
#
#Much better. >)

# string die_unhandled(string error_message = '')
#function die_unhandled() {
#    #FUXME: Implement such function. Unsure this is the best name, to be honest.
#    die_handled_if "${@}" ${ZY_BOOLEAN_FALSE}
#}

# --------------------( WASTELANDS                         )--------------------
# function print_message_item() {
#     # Validate sanity.
#     die_unless_args 'Expected one or more strings.'
# 
#     # Print such item.
#     # :print_stdout_separated_start
#     wrap_string_in_style_caller "${*}"
#     # :print_stdout_separated_stop
# }

    # Validate sanity.
#   die_unless_args 'Expected one or more strings.'

    # Print such item.
    # :print_stdout_separated_start
#   wrap_string_in_style_caller "${*}"
    # :print_stdout_separated_stop

    #FUXME: Only suffix such basename with "()" if such runnable is a function.
    #Indeed, haven't we already contemplated similar logic elsewhere?

# ....................{ GETTERS                            }....................
#FUXME: Excise.
#:func.doc <<'/---'
#string get_print_message_prefix()
#
#Get the contextual label with which to prefix each line of message output.
#/---
#function get_print_message_prefix() {
#    die_if_args
#    :str.output "${ZY_STYLE_TO_COLOR[color.reset]-}${ZY_STYLE_TO_COLOR[print_message.caller]-}$(output_call_stack_root_in_style)${ZY_STYLE_TO_COLOR[print_message.colon]-}: ${ZY_STYLE_TO_COLOR[print_message.message]-}${ZY_STYLE_TO_COLOR[color.reset]-}"
#}

#   print_message.heading.corner_left  '┎'
#   print_message.heading.corner_right '┒'
#   print_message.heading.border_left  '─'
#   print_message.heading.border_right '─'
#   print_message.heading.joiner_left  '• '
#   print_message.heading.joiner_right ' •'
#   print_message.body.border_left     '┃ '
#   print_message.body.border_right    ' ┃'
#   print_message.footing.corner_left  '┖'
#   print_message.footing.corner_right '┚'
#   print_message.footing.border_left  '─'
#   print_message.footing.border_right '─'

#   print_message.heading.text         grey:bold
#   print_message.heading.corner_left  blue:bold
#   print_message.heading.corner_right grey:bold
#   print_message.heading.border_left  blue
#   print_message.heading.border_right blue
#   print_message.heading.joiner_left  grey
#   print_message.heading.joiner_right grey
#   print_message.body.text            white:bold
#   print_message.body.border_left     blue
#   print_message.body.border_right    blue
#   print_message.footing.corner_left  grey:bold
#   print_message.footing.corner_right blue:bold
#   print_message.footing.border_left  blue
#   print_message.footing.border_right blue

#FUXME: Rename to print_message_heading(), for forward compatibility with
#new functions print_warning_heading() and print_error_heading().

    # Validate sanity.
    # See :str.output() for further details.

#FUXME: print_message() output consumes three lines per single-line message,
#making single-line messages a poor fit for such function. Given this, callers
#printing sufficiently "short" messages should generally elect to call a
#different function instead -- say, print_message_item(). Such function should
#output the passed string in a manner permitting aesthetically pleasing lists of
#successive items: e.g.,
#
#    # This...
#    >>> print_message_item "'Twas brillig and the slithy toves"
#    >>> print_message_item "Did gyre and gimble in the wabe;"
#
#    # ...should be rendered something like this.
#:func.doc <<'/---'
#string ignore_me()
#
#* 'Twas brillig and the slithy toves
#* Did gyre and gimble in the wabe;
#
#>>> 'Twas brillig and the slithy toves >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#>>> Did gyre and gimble in the wabe; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#
#--< 'Twas brillig and the slithy toves >---------------------------------------
#--< Did gyre and gimble in the wabe; >-----------------------------------------
#
#--{ 'Twas brillig and the slithy toves }---------------------------------------
#--{ Did gyre and gimble in the wabe; }-----------------------------------------
#
#[ 'Twas brillig and the slithy toves ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#[ Did gyre and gimble in the wabe; ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#┆ 'Twas brillig and the slithy toves ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
#┆ Did gyre and gimble in the wabe; ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
#
#┋ 'Twas brillig and the slithy toves ┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄
#┋ Did gyre and gimble in the wabe; ┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄
#
#┇ 'Twas brillig and the slithy toves ┠─────────────────────────────────────────
#┇ Did gyre and gimble in the wabe; ┠───────────────────────────────────────────
#
#┇ 'Twas brillig and the slithy toves ╾─────────────────────────────────────────
#┇ Did gyre and gimble in the wabe; ╾───────────────────────────────────────────
#
#┇ 'Twas brillig and the slithy toves ╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍
#┇ Did gyre and gimble in the wabe; ╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍
#
#┇ 'Twas brillig and the slithy toves ┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉
#┇ Did gyre and gimble in the wabe; ┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉
#
#┇ 'Twas brillig and the slithy toves ╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌
#┇ Did gyre and gimble in the wabe; ╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌
#
#Examples of a single item message wrapped onto three lines followed by another
#single item message fitting on a single line:
#
#┇ Is all our Life, then but a dream Seen faintly in the goldern gleam Athwart ┈
#┋ Time's dark resistless stream? Bowed to the earth with bitter woe Or laughing
#┋ at some raree-show We flutter idly to and fro. ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
#┇ Did gyre and gimble in the wabe; ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
#
#┇ Is all our Life, then but a dream Seen faintly in the goldern gleam Athwart ┈
#╏ Time's dark resistless stream? Bowed to the earth with bitter woe Or laughing
#╏ at some raree-show We flutter idly to and fro. ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
#┇ Did gyre and gimble in the wabe; ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
#
#A simple question: for messages wrapped onto multiple lines, should all lines
#be padded to the right or only the last such lines? Compare:
#
#┇ Is all our Life, then but a dream Seen faintly in the goldern gleam
#╏ Time's dark resistless stream? Bowed to the earth with bitter woe Or
#╏ at some raree-show We flutter idly to and fro. ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
#┇ Did gyre and gimble in the wabe; ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
#
#┇ Is all our Life, then but a dream Seen faintly in the goldern gleam ╍╍╍╍╍╍╍╍╍
#╏ Time's dark resistless stream? Bowed to the earth with bitter woe Or ╍╍╍╍╍╍╍╍
#╏ at some raree-show We flutter idly to and fro. ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
#┇ Did gyre and gimble in the wabe; ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
#
#┇ Is all our Life, then but a dream Seen faintly in the goldern gleam ─────────
#┃ Time's dark resistless stream? Bowed to the earth with bitter woe Or ────────
#┃ at some raree-show We flutter idly to and fro. ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
#┇ Did gyre and gimble in the wabe; ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
#
#┇ Is all our Life, then but a dream Seen faintly in the goldern gleam ┈┈┈┈┈┈┈┈┈
#╏ Time's dark resistless stream? Bowed to the earth with bitter woe Or ────────
#╏ at some raree-show We flutter idly to and fro. ──────────────────────────────
#┇ Did gyre and gimble in the wabe; ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
#
#┇ Is all our Life, then but a dream Seen faintly in the goldern gleam         ┇
#╏ Time's dark resistless stream? Bowed to the earth with bitter woe Or        ╏
#╏ at some raree-show We flutter idly to and fro.                              ╏
#┇ Did gyre and gimble in the wabe;                                            ┇
#
#┇ Is all our Life, then but a dream Seen faintly in the goldern gleam ┈┈┈┈┈┈┈┈┇
#╏ Time's dark resistless stream? Bowed to the earth with bitter woe Or ┈┈┈┈┈┈┈╏
#╏ at some raree-show We flutter idly to and fro. ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╏
#┇ Did gyre and gimble in the wabe; ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┇
#
#| Is all our Life, then but a dream Seen faintly in the goldern gleam --------|
#| Time's dark resistless stream? Bowed to the earth with bitter woe Or -------|
#| at some raree-show We flutter idly to and fro. -----------------------------|
#| Did gyre and gimble in the wabe; -------------------------------------------|
#
#* Is all our Life, then but a dream Seen faintly in the goldern gleam --------*
#* Time's dark resistless stream? Bowed to the earth with bitter woe Or -------*
#* at some raree-show We flutter idly to and fro. -----------------------------*
#* Did gyre and gimble in the wabe; -------------------------------------------*
#
#[ Is all our Life, then but a dream Seen faintly in the goldern gleam --------]
#[ Time's dark resistless stream? Bowed to the earth with bitter woe Or -------]
#[ at some raree-show We flutter idly to and fro. -----------------------------]
#[ Did gyre and gimble in the wabe; -------------------------------------------]
#
#{ Is all our Life, then but a dream Seen faintly in the goldern gleam --------}
#< Time's dark resistless stream? Bowed to the earth with bitter woe Or ------->
#< at some raree-show We flutter idly to and fro. ----------------------------->
#{ Did gyre and gimble in the wabe; -------------------------------------------}
#
#[ Is all our Life, then but a dream Seen faintly in the goldern gleam --------]
#( Time's dark resistless stream? Bowed to the earth with bitter woe Or -------)
#( at some raree-show We flutter idly to and fro. -----------------------------)
#[ Did gyre and gimble in the wabe; -------------------------------------------]
#
#Right. The last several rather rock. We have our fickle winners somewhere in
#there, lay friends! (Actually, the last does indeed principally rock.)
#
#Mildly compelling stuff. I'm tipsy with typographically monospaced relish.
#/---

    # Prefix with which to label such message.
#   string message_label; message_label="$(output_call_stack_root_in_style)"
#   :str.output "$(output_call_stack_root_in_style)"
#   :str.output "${ZY_STYLE_TO_COLOR[color.reset]-}${ZY_STYLE_TO_COLOR[print_message.caller]-}$(output_call_stack_root_in_style)${ZY_STYLE_TO_COLOR[print_message.colon]-}: ${ZY_STYLE_TO_COLOR[print_message.message]-}${ZY_STYLE_TO_COLOR[color.reset]-}"
#   :str.output "${message_label}: "
#   :str.output "${ZY_STYLE_TO_COLOR[color.reset]-}${ZY_STYLE_TO_COLOR[print_message.caller]-}${message_label}${ZY_STYLE_TO_COLOR[print_message.colon]-}: ${ZY_STYLE_TO_COLOR[print_message.message]-}${ZY_STYLE_TO_COLOR[color.reset]-}"

#FUXME: This fundamentally makes no sense anymore and hence should be excised.
#Such function should only ever be called for requesting user input, anyway.
#Honestly, wouldn't print_message_item() provide a better prompt for such input?
#Consider:
#
#┇ Enter any character to continue. ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┇
#┗ n̲
#
#┇ Enter any character to continue. ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┇
#┖ n̲
#
#Both look half decent, really. Unicode supports an underscore diacritic. So
#should most modern terminals with an ANSI escape code, I believe. Hence, input
#should be formatted to be underscore (and possibly italic), mimicking an input
#field for GUI forms.

#:func.doc <<'/---'
#string print_message_sans_newline(
#    string message1 = "", string message2, ...)
#
#Print the passed strings (defaulting to the empty string) as an inerrant
#message suffixed by no newline. See print_message() for further details.
#/---
#function print_message_sans_newline() {
#    print_string_sans_newline_suffix "$(get_print_message_prefix)${*}"
#}

#FUXME: Rename to print_message_if_context_cli() and edit to call
#:context.is_cli() instead.
#   print_message.caller  cyan_bold
#   print_message.colon   grey_bold
#   print_message.message white_bold

#FUXME: The distinction between print_message() and print_message_unboxed() is
#blatantly nonsensical. *EVERY* message should be implicitly wrapped. The
#caller shouldn't have to decide which of the two functions to call based on
#some arbitrary and inconsistent measure of whether the message being passed is
#sufficiently long to possibly require wrapping. I mean, really.
#FUXME: Such wrapping refactoring should also be extended to errors and warnings.
#FUXME: The current get_print_message_prefix()-based implementation is somewhat
#oversimplistic. Ideally, we'd probably prefer Unicode-based output resembling:
#
#------\
#info()| This is a single-line message.
#------/
#------\
#      | This is a three-line message.
#info()| Rather swell, isn't it?
#      | I should dare say so!
#------/
#
#This obviates the need for prefixing whitespace, which is rather nice.
#Interestingly, obviating such need effectively obviates our current need for
#tracking standard output state *ENTIRELY*, suggesting we could profitably...
#oh, perhaps not, actually. We often have code printing multiple single-line
#messages: e.g.,
#
#   print_message 'doing something...'
#   do --something
#
#   print_message 'doing something else...'
#   do --something else
#
#Ideally, such output should be rendered as:
#
#/----------------------------------[ info() ]---------------------------------\
#| doing something...                                                          |
#| doing something else...                                                     |
#\-----------------------------------------------------------------------------/
#
#Rather than as:
#
#/----------------------------------[ info() ]---------------------------------\
#| doing something...                                                          |
#\-----------------------------------------------------------------------------/
#/----------------------------------[ info() ]---------------------------------\
#| doing something else...                                                     |
#\-----------------------------------------------------------------------------/
#
#Sadly, I'm not entirely sure how to effect that. Oh, wait; yes, I *AM* sure. If
#the current terminal accepts VT100 escape codes (as under pretty much every zsh
#installation), we can do the following in, say, start_stdout_box():
#
#* If VT100 support is available *AND* the prior and current printers are the
#  same *AND* standard output has not changed since the last call to such
#  printer, then and only then *ERASE* the previous output line (which will
#  necessarily be the bottom edge of a box).
#
#FUXME: It'd probably be simpler to encapsulate such check in a new print_box()
#function rather than separate start_stdout_box() and
#start_stdout_box() functions. Make it so!
#FUXME: Note the need for a new start_stdout_box() function, to be
#called by print_message(), print_error(), and print_warning(). All other print
#functions should continue to call the existing :print_stdout_separated_start()
#function, whose implementation should be simplified a bit. Since no other print
#functions care about whether or not the prior and current functions were the
#same, :print_stdout_separated_start() should always prefix such output with delimiting
#whitespace if standard output has changed since the last call to such a print
#function. (In other words, just drop the current checking for function name
#equality.)
#:str.output "$(get_print_message_prefix)${*}"
#See :str.output() for further details.

#Print the passed strings (defaulting to the empty string) suffixed by a newline
#and decorated by user-configured colors to standard output as a non-erroneous
#message if the current shell is interactive or the empty string otherwise. See
#print_message() for further details.

#Print the passed strings (defaulting to the empty string) wrapped to the current
#terminal width, prefixing each resulting line with an inerrant label (e.g.,
#`zeshy: `). See print_string_wrapped_with_line_prefix() for further details:
#e.g.,

#   print_string_wrapped_with_line_prefix "${*}" "$(get_print_message_prefix)"
#FUXME: Rename to print_message_unboxed() and reimplement to simply call:
#
#    print_message "$(replace_string_boxing_with_spaces "${*}")"
#
#replace_string_newline_and_prefix_spaces_with_space() does exactly what its
#nomenclature purports.

#replace_string_newline_and_spaces_with_space

#FUXME: Create warning and error analogues of this function. Yum!
#FUXME: The more I consider it, the more I wonder if this function shouldn't
#simply be renamed print_message() and the existing print_message() excised.
#After all, isn't line wrapping *ALWAYS* desirable? Given such wrapping,
#however, I wonder if a new vertically oriented prefix might be in order: e.g.,
#
#  zeshy| The oppressed are allowed once every few years to decide which
#  zeshy| particular representatives of the oppressing class shall represent and
#  zeshy| repress them in parliament.
#
#Honestly, pipe is probably *NOT* the best delimiter. Contemplate UTF-8.
#FUXME: There currently exists a subtle, but important, bug in our wrapping PCRE:
#if the current word is a single word containing no hyphen, such word will
#probably be ignored by the wrapping implementation and not output at all! Ug.
#FUXME: Rename to print_message_sans_newline(). (Yes, this is called elsewhere.)
#FUXME: Documentation not quite right, assuming we've implemented conditional
#logic to avoid prefixing adjacent output of the same type with delimiting
#whitespace (e.g., multiple print_message() calls in a row).
#Print the passed strings (defaulting to the empty string) suffixed by a newline
#and decorated by user-configured colors to standard output as a non-erroneous
#message. If at least one `zeshy` print function has already been called under
#the current call stack root, prefix such message with delimiting whitespace.

#   print_string_sans_newline_suffix "$(print_message "${@}")"
# and decorated by user-configured colors to standard output 
#   print_message_sans_newline_prefix "${@}"
#:func.doc <<'/---'
#string print_message_sans_newline_prefix(
#    string message1 = "", string message2, ...)
#
#Print the passed strings (defaulting to the empty string) suffixed by a newline
#and decorated by user-configured colors to standard output as a non-erroneous
#message. Do _not_ prefix such message with delimiting whitespace, regardless of
#whether at least one `zeshy` print function has already been called under the
#current stack root.
#/---
#function print_message_sans_newline_prefix() {
#    :str.output "$(get_print_message_prefix)${*}"
#}

    #FUXME: Just for testing. Eliminate this after we get worky.
#   typeset -f output_call_stack_root_in_style &>/dev/null or
#       :die "output_call_stack_root_in_style() undefined"

#...    "Readers may more closely recognize our own culture in [Erich] Fromm's"\
#...    "description of the Dobus, Kwaikutl, Aztecs, and others he put into the"\
#...    "category of \"destructive.\" These cultures, he said, are"\
#...    "\"characterized by much interpersonal violence, destructiveness,"\
#...    "aggression, and cruelty, both within the tribe and against others, a"\
#...    "pleasure in war, maliciousness, and treachery. The whole atmosphere of"\
#...    "life is one of hostility, tension, and fear. Usually there is a great"\
#...    "deal of competition, great emphasis on private property (if not in"\
#...    "material things then in symbols), strict hierarchies, and a
#...    "considerable amount of war-making.\""
#...    "It all comes down to how a culture handles wealth. If a culture manages
#...     it through what [Ruth] Benedict called a \"siphon system,\" whereby
#...     wealth is constantly siphoned from rich to poor, the society as a whole
#...     and its members as individuals will be, for obvious reasons, secure.
#...     They will not need to hoard wealth. Since this generosity is manifested
#...     not only monetarily but in all aspects of life, they will also not need
#...     to act out their now-nonexistent insecurities in other ways."
#zeshy: The history of all hitherto existing society is the history of class
#zeshy: struggles.

#Print the passed strings (defaulting to the empty string) suffixed by a newline
#and decorated by user-configured colors to standard output as a non-erroneous
#block of messages. While print_message() prefixes only the first message line
#with an inerrant label (e.g., `zeshy: `), this function:
#
#. Splits such block into substrings of length equal to the current terminal
#  width subtracted by the length of such label (for all substrings except the
#  last, which only has at most such length).
#. Prints each such substring prefixed by such label and suffixed by a newline.
#
#See print_message() for further details: e.g.,

#FUXME: Fix documentation. I'm also unconvinced "block" is the correct term,
#here *OR* above. How about print_string_wrapped_with_line_prefix()?
#   for (( line_index_start = 0, line_index_end = line_length;
#          line_index_start <= text_length;
#          line_index_start += line_length,
#          line_index_end   += line_length )) {
#       :str.output\
#           "${prefix}${text[${line_index_start},${line_index_end}]}"
#   }

    #FUXME: Hmm. Split such block into chunks of length
    #(( terminal_width - message_prefix_length )). If such length is negative,
    #split instead into chunks of length ${terminal_width}.
    #FUXME: Just iterate manually rather than splitting into a list. The last
    #line will probably require special handling.

#the output of the next call to a function.
# Handle high-level print functions (e.g., messages, warnings, and errors).
#If at least one such string has already been printed under the current call
#stack root, prefix such message with delimiting whitespace.
# If at least one such string has already been printed under the current call
#stack root, prefix such message by a newline.
#FUXME: ZY_PRINT_CALL_STACK_ROOT handling currently falls down if output is
#printed prior to calling the first high-level print function. There's really no
#good way around this; in fact, extensive googling suggests the only reasonable
#method would be to write a new "zeshy" wrapper script teeing all zeshy output
#to some user-specific temporary file and then testing whether or not such file
#is of size 0 or not. Of course, we'd have to truncate such file to 0 on
#detecting a new call stack; and, of course, such files might either constitute
#a security risk or consume the entirety of the disk. In other words, it's an
#absurdly stupid solution. Which is to say, there *IS* no good solution, and we
#should document this fact somewhere. (Probably above, under a new "CAVEATS"
#section.) What we *CAN* do, however, is modify :str.output() to *ALWAYS* set
#ZY_PRINT_CALL_STACK_ROOT to the current call stack root. This is a simple
#and hence efficient assignment requiring only a single list lookup. Don't
#bother testing such global prior to assignment; the combined test + assignment
#is far more expensive than the mere assignment. In other words, just do *AFTER*
#successfully printing:
#
#    ZY_PRINT_CALL_STACK_ROOT="${funcfiletrace[-1]}"
#
#FUXME: O.K.; that's great, except we'll need do so in *EVERY* function of
#component "output", ideally wrapped in a function call. (No need for an alias,
#obviously.) I'm perfectly fine with that. It just needs doing.

#Hence, this string is the first element of array global ${funcfiletrace} at the
#time of the most recent call to high-level print function.
#
#is always
#if one carefully considers it, given a
#filename and file line 
#
#To guarantee uniqueness
#typically, command line. To
#guarantee 
#
#For both
#uniqueness While there
#
#Name of the most recent function or script to have called a Zeshy print function
#internally tracking such state (e.g., print_message_heading(), print_message()) or the
#empty string if no such function has been called. Such functions set this name
#to that of the caller when the current call stack does *NOT* contain this name''s
#current value, resetting such state. Alternatively, callers may explicitly set
#this name to a caller of their choosing by calling set_print_function_caller().
#
#In either case, this name notifies each call to a concerned Zeshy print function
#of whether or not this constitutes the first call to such a function by such
#caller. If this is the first call, such function does *NOT* prefix output with
#delimiting whitespace; otherwise, such function does prefix output with
#delimiting whitespace.
#
#For example, suppose the current user calls make_grub2_boot_image() from the
#command line and that such function calls print_message_heading(). Since the call stack
#cannot contain this name''s current value (whatever that was),  thus setting this
#name to "make_grub2_boot_image".  thus setting this name to
#"make_grub2_boot_image", before calling make_initramfs() that then calls
#print_message_heading(). As the current call stack contains this name''s current value,
#print_message_heading() 
#
#this name is currently "make_grub2_boot_image" and function
#make_initramfs() calls print_message_heading(), then since make_grub2_boot_image() transitively calls make_initramfs(), such heading
#is in the current output group and will be printed accordingly.
#
#A heading is in the current output group if the current caller is either such
#group or transitively called by such group. For example, if the current caller
#is make_initramfs() and the current output group is make_grub2_boot_image() (as
#signified by "is ${ZY_PRINT_CALLER} == ''make_grub2_boot_image''"), then
#since make_grub2_boot_image() transitively calls make_initramfs(), such heading
#is in the current output group and will be printed accordingly.

#FUXME: I'm unconvinced this works, actually. Consider calling
#make_grub2_boot_image() twice from the command line. The second go around,
#this name will be "make_grub2_boot_image", thus inducing print_message_heading() to
#prefix the first heading output by the second call to make_grub2_boot_image()
#with a newline. *sigh*
#...well, that's a tremendously obvious flaw in the rough. This clearly won't
#work reliably as advertised -- any of it. Ah; wait. I know how to amend this.
#*phew* Bit annoying, but if we just... Hmmmm. Yikes. Technically, we can do
#this, but won't we have to hash the contents of *BOTH* ${funcstack} and the
#${funcfiletrace}? Hmmmm. Technically, we could efficiently compact both lists
#into a single string with:
#
#   # We'll need to do this manually, both for efficiency and to avoid
#   # permuting the call stack. Exclude the current call, for subsequent
#   # comparability.
#   "${(j:$'\0':)funcstack[1,-2]}\0\0${(j:$'\0':)funcfiletrace[1,-2]}"
#
#Should be *REASONABLY* efficient, assuming the call stack isn't recursively
#stupidly deep. (If it is, this probably dies a flaming death... but then, no
#one reasonable should be doing recursion in zsh, yes?)
#
#O.K.; so what that "hashed" string does is allow us to reliably answer the
#question: is the current call to a print function the first in its "group"?
#Specifically, if:
#
#* ${ZY_PRINT_CALL_STACK_ROOT} is on the current call stack (which is
#  fairly efficiently determined given typical call stack depths) and...
#  * "${(j:$'\0':)funcstack[1,${caller_index}]}\0\0${(j:$'\0':)funcfiletrace[1,${caller_index}]}"
#    is the same as the previously cached value above, where "${caller_index}"
#    is the integer found on such stack, then this is *NOT* the first call to a
#    print function by the current caller.
#* Else, this is.
#
#I wish I could say that it's simple, but it's not. It should, however, reliably
#work, thanks in part to zsh's incrementing the "line" number on each function
#called from the command line (guaranteeing different calls hash to different
#strings above). For sanity, we'll probably want to embed the above string hashing
#in an alias -- which can then be conveniently called from both
#set_print_function_caller() and print_message_heading() and friends. What's particularly
#brilliant about the whole thing is that it implicitly tracks *ANY* Zeshy print
#function. Hence, if one function calls print_message_heading() that then calls another
#function that calls print_message(), the latter call will be smart enough to note
#it to *NOT* be the first call to such a print function. Wow, great! Utterly no
#idea how I'll ever document this monstrosity, but it should certainly work. Now
#for a tea break.
#FUXME: Use a herestring-style alias. Shouldn't be terribly much overhead, given
#the short string lengths involved... and way more reliable.
#FUXME: Ah-ha! This is *ALL* extreme overkill, though the method above does point
#to the correct way. Note that we only want to track output for each call hierarchy
#rooted at the same root caller: that is, each discrete call stack rooted at some
#caller tracks whether output has been printed for that call stack or not. But this
#is painfully simple to track: rather than all of this "caller_name" and "heading_group"
#nonsense, just record the following string in a global variable:
#
#    "${funcstack[1]}\0${funcfiletrace[-1]}"
#
#That's it. Then, on each call to a print function, simply test such variable for
#equality with the same string re-evaluated at the current context. If they're the
#same, then this is another call to the same call hierarchy, so *PRINT A NEWLINE*;
#else, this is the first call to a new call hierarchy, so set such global variable
#to such string's evaluation. Painfully simple, no?
#FUXME: I believe we can dispense with at least
#${ZY_PRINT_CALLER_IS_PRINTED} and possibly also
#set_print_function_caller().
#FUXME: Right. Since we'll be leveraging such functionality in multiple places,
#abstract out into a function entitled, say... print_message_prefix().
#FUXME: Merge the contents of this file with "message", for obvious reasons.

# Print the passed heading (defaulting to the empty string). See
# ${ZY_PRINT_CALL_STACK_ROOT} for further discussion.
# or print no such such whitespace otherwise.
#   is_string_nonempty ZY_PRINT_CALL_STACK_ROOT and is_string_equals\
#       "${ZY_PRINT_CALL_STACK_ROOT}" "${funcfiletrace[-1]}"

    # If *NOT* called directly from the command line, this function was called
    # by another function or script. Determine whether the heading just passed
    # by such caller is in the current output group.
#   :caller.is and {
#       print "ZY_PRINT_CALL_STACK_ROOT=${ZY_PRINT_CALL_STACK_ROOT}"
#       print "ZY_PRINT_CALLER_IS_PRINTED=${ZY_PRINT_CALLER_IS_PRINTED}"
        # If such heading is in the current output group (i.e., if the current
        # caller or some transitive parent of such caller on the call stack
        # is such group), determine whether or not a heading has been printed
        # in such group. See ${ZY_PRINT_CALL_STACK_ROOT} for further discussion.
#       if is_string_nonempty "${ZY_PRINT_CALL_STACK_ROOT}" and
#           call_stack.contains "${ZY_PRINT_CALL_STACK_ROOT}"; then
            # If some heading has already been printed for such group, delimit
            # the heading to be printed below from prior output with whitespace.
#           is_boolean_false "${ZY_PRINT_CALLER_IS_PRINTED}" or {
#               print 'non-first heading!'
#               print_newline
#           }
        # Else, such heading is *NOT* in the current output group. Start a new
        # group with same name as the caller.
#       else
#           print "setting new output group to \"$(:caller.get)\""
#           ZY_PRINT_CALL_STACK_ROOT="$(:caller.get)"
#       fi

        # Notify subsequent calls to this function that a heading has been
        # printed for such group. While we could set such boolean for the
        # specific cases necessitating its setting rather than for all cases
        # indiscriminantly, this approach invites fewer subtleties. Trust us.
#       ZY_PRINT_CALLER_IS_PRINTED=${ZY_BOOLEAN_TRUE}
#   }

# ....................{ STARTERS                           }....................
#FUXME: Improve documentation, please.
#declare_function '
#void set_print_function_caller(string caller_name="$(:caller.get)")
#
#Set the current output caller (defaulting to the calling function or script).
#See ${ZY_PRINT_CALL_STACK_ROOT} for further discussion.
#'
#function set_print_function_caller() {
#    die_unless_args_0_to_1 'expected optional group name'
#    ZY_PRINT_CALL_STACK_ROOT="${1:-$(:caller.get)}"
#    ZY_PRINT_CALLER_IS_PRINTED=${ZY_BOOLEAN_FALSE}
#}

#declare_global '
#boolean ZY_PRINT_CALLER_IS_PRINTED
#
#If true, at least one heading has been printed for the current output group.
#See ${ZY_PRINT_CALL_STACK_ROOT} for further discussion.
#'

#FUXME: Rename set_print_function_caller() to something a bit more fitting, and
#note that such function should really *NEVER* be called by any functions except
#print_*() functions.
#See such function for further details.
#printing a heading in the current output group, print_message_heading() precedes such
#heading by delimiting whitespace *UNLESS* this is the first heading to be
#printed for such group (i.e., no such heading has been printed yet). When
#printing a heading *NOT* in the current output group, print_message_heading() closes the
#previous group and opens a new group with same name as the caller.

#The output group of two or more headings is simply the topmost function
#or script either directly printing such headings by calling print_message_heading() or
#indirectly printing such headings by calling other functions and scripts calling
#print_message_heading().
#
#In the former case, no output group need be explicitly set, as print_message_heading()
#implicitly sets the current output group to that of the caller. (See below.)
#In the latter case, a output group must be explicitly set by calling
#set_print_function_caller(). (See such function for further details.)

# ....................{ PRINTERS ~ sections                }....................
#FUXME: Eliminate the distinction between say_first_section() and
#say_next_section() by replacing such functions with a single
#print_message_heading() function. This function internally retains the name of the last
#function that called this function (e.g., with a global string
#${ZY_SAY_HEADING_CALLER_FUNCTION_NAME}). If such name is empty or different
#than the current function that called this function, print a first section
#heading; otherwise, print a next section heading. In either case, cache the
#current caller function name for use in the next call to this function. Pretty
#simple, actually.
#Ah, wait; that's not *quite* right. We actually need to search up the callstack
#for ${ZY_SAY_HEADING_CALLER_FUNCTION_NAME}; it's not enough to just assume
#that if the function directly calling this function differs, then we're in a
#new logical block of headings. Anyway, not terribly difficult. Be fun to write
#some callstack search routines, eh?
#Ah! Wait. Yes, we could implement such implicit searching, but it seems
#increasingly error-prone. Instead, the function prototype should resemble:
#
# string print_message_heading(
#   string heading, string heading_group = "$(get_caller_function_name)")
#
#Implement :caller.get() as a function (not alias!) looking two up on the
#caller stack. This should work without error if the caller is in fact a global
#script; just return the script name, for example.
#
#The output group is an arbitrary name distinguishing this "group" of headings
#from other such groups, defaulting to the caller name. Callers performing
#complex logic should pass a different output group... Hmm. This is all well
#and good, but perhaps we should provide additional functions, as well:
#
# string set_print_function_caller(string heading_group = "$(get_caller_function_name)")
# string unset_print_function_caller()
#
#These set a global string ${ZY_PRINT_CALLER}. Then, slightly change
#print_message_heading() to:
#
# string print_message_heading(
#   string heading,
#   string heading_group = "${ZY_PRINT_CALLER:-$(get_caller_function_name)}")
#
#print_message_heading() then internally compares the passed heading_group (with the above
#default) to its cached ${ZY_SAY_HEADING_CALLER_FUNCTION_NAME} (which should
#probably be ${ZY_PRINT_CALLER_PRIOR}). If different... well, you know the game.
#
#Sweet. That seems just right. Simple functions can just call print_message_heading() with
#one argument without needing to call set_print_function_caller() or
#unset_print_function_caller(). More complex functions can just call print_message_heading() with
#two arguments. And truly complex groups of functions can call set_print_function_caller()
#prior to calling print_message_heading() with one argument prior to calling
#unset_print_function_caller().
#
#Hmmm; set_print_function_caller() and unset_print_function_caller() might cause too many head-
#aches, hmm? Just calling print_message_heading() with two arguments should suffice for
#an initial implementation, no? Ah; wait. We really just need the following:
#
# string print_message_heading(string heading)
# string set_print_function_caller(string heading_group = "$(get_caller_function_name)")
# string unset_print_function_caller()
#
#Tada! Flash. Crash. Bamb.
#FUXME: Hmmm. Heading groups seem a tad overkill, actually. *AS WELL AS NON-
#TRIVIAL* to interact with properly, as it's the caller's responsibility to then
#ensure calling unset_print_function_caller() in an "} always {...}" block surrounding
#such code. Right. You know, the prior search-up-the-call-stack method is
#actually pretty rockin'. We'll just need to define an additional separate
#function setting ${ZY_HEADING_CALL_STACK_ROOT} to the caller name and then search
#for such caller in the call stack on subsequent calls to print_message_heading(). No need
#for set_print_function_caller() and set_print_function_caller() or for passing an optional
#output group parameter to print_message_heading(). *SWEEEET*.

#declare_function '
#string say_first_section(string header1, string header2, ...)
#
#Print the passed strings as the header of a section (i.e., a contiguous block
#of related output). Sections demarcate :str.output into logical blocks, each
#preceded by a terse header synopsizing such block. To ensure aesthetic output,
#call this function *ONLY* on the first such section and say_next_section()
#on all remaining sections.
#'
#function say_first_section() {
#    print_message "[${@}]"
#}

#declare_function '
#string say_first_section(string header1, string header2, ...)
#
#Print the passed strings as the header of any section other than the first.
#'
#function say_next_section() {
#    print_newline
#    say_first_section "${@}"
#}

        # Border colors.
#       string\
#           color_border="${ZY_COLOR[blue]}"\
#           color_joiner="${ZY_COLOR[blue_bold]}"\
#           color_heading="${ZY_COLOR[grey_bold]}"

            # If no heading has been printed for such group, this is the first.
            # Inform future calls to this function that a heading has now been
            # printed for such group.
#           if is_boolean_false "${ZY_PRINT_CALLER_IS_PRINTED}"
#           then
#               print 'first heading!'
#               ZY_PRINT_CALLER_IS_PRINTED=${ZY_BOOLEAN_TRUE}
            # Else, some heading has been printed for such group. Since this is
            # not the first, delimit such heading from prior with whitespace.
#           else
#               print 'non-first heading!'
#               print_newline
#           fi

#           else is_heading_first=${ZY_BOOLEAN_FALSE}

    # If true, such heading is the first to be printed for the current heading
    # group. To simplify logic below, defaults to true.
#   boolean is_heading_first=${ZY_BOOLEAN_TRUE}

    # If such heading is *NOT* the first to be printed for the current heading
    # group, delimit such heading from prior headings with whitespace.
#   is_boolean_false "${is_heading_first}" and print_newline

    # Else, this function was called directly from the command line. While edge
    # case, such unlikelihood must be accounted for.
#   else is_heading_first=${ZY_BOOLEAN_TRUE}
#   fi

    # Validate passed arguments.
#   die_unless_args 'expected at least one string'
# false, thus preceding headings by such whitespace.
    # If this function has been called at least once, string global
    # ${ZY_PRINT_CALLER} should have been set by such call. In
    # such case, search the current call stack for a function or script with
    # such name. See ${ZY_PRINT_CALLER} for further details.
#in the call stack under which all  transitively calling responsible for 
#
#Name of the most recent output group to track state for calls to print_message_heading()
#or the empty string if no such group .
#Name of the function or script to most recently called print_message_heading().
#On subsequent calls, print_message_heading() searches the current call stack for a
#function or script with such name. If found, the passed heading cannot be the
#first heading to be printed for such caller; else the passed heading *IS* the
#first heading to be printed for such caller. print_message_heading() prints such heading
#accordingly (e.g., prefixing non-first headings with blank newlines).
#string ZY_PRINT_CALLER
#           character_border='━'
#           character_joiner_left='❴'
#           character_joiner_right='❵'
#           character_border='━⁆⦃❴᚜{'
#           character_border='━━ hello ᚜'
#           character_joiner_left='{'
#           character_joiner_left='⦃'
#           character_joiner_right='⦄'
#           color_heading="${ZY_COLOR[green]}"
#           color_joiner="${ZY_COLOR_BOLD[green]}"\
#in deciding whether a passed heading is the first to have been printed for the
#caches such name to assist subsequent calls to print_message_heading() in deciding whether
#a passed heading is the first to have been printed for the
#function or script currently calling print_message_heading(),
#
#, which
#uses such name to determine whether or not a passed heading is the first to
#have been printed for such function or script.
#
#heading to be . in subsequent calls to print_message_heading().

#Name of the most recent function or script to have called print_message_heading().

#FUXME: Admit it: this is pretty sucky output. Let's prettify this, please! Try
#calling output() rather than say() with output resembling:
#
#=====================[ output                             ]====================
#
#Clearly, the output should scale with terminal width. If terminal width is too
#small (say, <= 20), forego the desired heuristic and just output the passed
#section. Hmm... or not? Let's not edge case, for now. Just assume everything
#works. 8) O.K.; here we go:
#
#* Divide terminal width by 4, apportioning the left and right banners each 1/4
#  the width and the middle section 2/4 (1/2) the width.
#* Don't worry about centering output. We'd rather columns line up vertically.
#* And...that's it, really. Shouldn't be too cumbersome, nay? The slightly hard
#  part is ensuring that, if the terminal width is not cleanly divisible by 4:
#  * Round all divisions *DOWN*, for safety.
#  * Add the difference of the terminal width and the summation of the three
#    widths (i.e., left banner, right banner, section header) back to the
#    section header. That should do us right, no?
#* Naturally, it'd be nice to colorify this, too. All things come.
#FUXME: Print the actual headings with output_line_horizontal_titled(), as discussed in
#the "output" component.

#           color_outline="${ZY_COLOR[blue]}"\
#           color_outline="${ZY_COLOR[grey]}"\
#           color_divider="${ZY_COLOR_BOLD[grey]}"\
#           :str.output "incremented right border to ${east_outline_count} characters"

#FUXME: I must admit, I'm no longer enamoured with such nomenclature. Consider
#renaming say() to print_message (), cry() to print_warning(), output_line_horizontal() back
#to output_line_horizontal(), and so on elsewhere. The distinction between "print" and
#"say" has been largely unhelpful and rather confusing, given that functions
#such as output_call_stack() now print colored output. I mean, what, would we
#rename functions from "print_" to "say_" on the implementation changing to
#color output? No, of course not! So, the distinction really doesn't mean
#anything anymore. Strike it, sir.

# with thematic embellishment (e.g., colors).
# The say() and cry() functions defined here appear after and hence override
# the previously defined functions of the same name defined by "main".

#FUXME: Cumbersome. Not only is accessing such colors in a safe manner
#excrutiatingly awkward, verbose, and slightly slow (e.g.,
#"${ZY_COLOR[${ZY_COLOR_NAME_CALLER_NAME-z}]-}"), it's also unnecessary:
#simply declare a new map global ${ZY_STYLE_TO_COLOR} initialized on Zeshy
#*STARTUP AFTER* declaring ${ZY_COLOR} as follows:
#
#ZY_STYLE_TO_COLOR=(
#   ignorable   "${ZY_COLOR[grey]}"
#   incidental  "${ZY_COLOR[grey_bold]}"
#   caller_name "${ZY_COLOR[blue]}"
#)
#
#Obviously, only *GLOBALLY* applicable styles should go in here. Should be quite
#fast to initialize, using only zsh parameter expansions. *SIGNIFICANTLY* easier
#to access; for example, say()'s implementation now resembles:
#
#    :str.output "${ZY_STYLE_TO_COLOR[caller_name]-}$(output_call_stack_root_in_style)${ZY_STYLE_TO_COLOR[ignorable]-}: ${ZY_COLOR[white_bold]-}${*}"
#
#FUXME: O.K., so, the obvious is patently awesome. But I wonder if we can do any
#better? In particular, I'd like ZY_STYLE_TO_COLOR to be user configurable. I
#mean, why should users have to setup their own discrete theme just to be able to
#tweak a single color? That said, the obvious issue arises that ${ZY_COLOR}
#will not have been initialized at configuration sourcing time; hence, we'd have
#to list only color *names*, perhaps in a separate map resembling:
#
#ZY_STYLE_TO_COLOR_NAMES=(
#   ignorable   grey
#   incidental  grey_bold
#   caller_name blue
#)
#
#We'd have to then parse that to initialize ${ZY_STYLE_TO_COLOR}, which arguably
#becomes a bit less efficient. It's probably fine to do so at Zeshy startup for
#now, but in the future tense we might consider defining individual global maps
#ZY_STYLE_TO_COLOR_2, ZY_STYLE_TO_COLOR_8, and so on copied all-at-once into
#ZY_STYLE_TO_COLOR, much as for ZY_COLOR and siblings. Mhhhm; yes. Should
#work perfectly, ya-ya!
#
#Throw the above map into a new configuration file
#"if_config/if_shell_interactive/00-color", and away we go! :-0

#   :str.output "${ZY_COLOR[${ZY_COLOR_NAME_CALLER_NAME-z}]-}$(output_call_stack_root_in_style)${ZY_COLOR[${ZY_COLOR_NAME_IGNORABLE-z}]-}: ${ZY_COLOR[yellow_bold]-}${*}" 1>&2
#   :str.output "${ZY_COLOR[${ZY_COLOR_NAME_CALLER_NAME-z}]-}$(output_call_stack_root_in_style)${ZY_COLOR[${ZY_COLOR_NAME_IGNORABLE-z}]-}: ${ZY_COLOR[white_bold]-}${*}"
#declare_global '
#string ZY_COLOR_NAME_CALLER_NAME
#
#Name of the color used for caller names (e.g., printed by say() and cry()). Such
#name is any key of map global ${ZY_COLOR}.
#'
#ZY_COLOR_NAME_CALLER_NAME='blue'
#
#declare_global '
#string ZY_COLOR_NAME_IGNORABLE
#
#Name of the color used for ignorable strings (e.g., spurious punctuation). Such
#name is any key of map global ${ZY_COLOR}.
#'
#ZY_COLOR_NAME_IGNORABLE='grey'

#FUXME: Odd. Under root, but *NOT* customary users, this version is *NOT*
#overriding the original version defined under "main". What the...? Right.
#Pretty obvious: since "main" defines say(), the difference of functions defined
#after and before sourcing the Zeshy codebase fails to include say() (i.e.,
#say() was defined both after and before such sourcing). My only question is:
#how was this *EVER* working? It really shouldn't have been, right? Assuming
#that to be the issue, what would a *REASONABLE* solution be? I'd rather not
#hard-code function names in the "compile" differencing code, but unsure whether
#a sane alternative exists.
#FUXME: Define a new output_line_horizontal_titled() function accepting a banner, printing
#such title centered in such banner.
    # Dismantled, this is:
    #
    # * "(l:..::..:)", expanding to the second argument padded (i.e., repeated)
    #   to the length specified with the first argument.
    # Define a placeholder variable to avoid "parameter not set" warnings below.
#   string placeholder
#       "${ZY_COLOR[grey]}${(l:$(get_terminal_width)::${character_banner}:)placeholder}"
    # Character constituting such banner.
#FUXME: Incidentally, we *REALLY* want a print_message_interactively() function. It's long
#past time, so make it so!
#   print_warning "${*}" |& :str.output_sans_newline 1>&2
