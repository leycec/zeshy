#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *usage printers* (i.e., functions documenting command-line interfaces,
usually in response to command-line options `-h` and `--help`).
/---

# ....................{ PRINTERS                           }....................
:func.document <<'/---'
string :print_zeshy_usage()

Print a human-readable synopsis of `zeshy`\'s *command-line interface* (i.e.,
command-line arguments and options accepted by the `zeshy` and `zeshy-login`
wrapper scripts`).
/---
function xil :print_zeshy_usage() {
    # Validate sanity.
    die_if_args
    :map usage_overview
    :list usage_options_main usage_options_parameterized usage_options_startup

    # Data structures to be passed to such printer below.
    usage_overview=(
        command  'zeshy'
        args     '[OPTION]... [FILE [ARGUMENT]...]'
        synopsis
            'Open a new zeshy interpreter. If passed an optional FILE, source such path as a zeshy shell script passed the passed ARGUMENTs.'
    )

    usage_options_main=(
        'Main options'
        'i' 'interactive' 'open an interactive non-login shell'
        'l' 'login'       'open an interactive login shell'
        'h' 'help'        'print this help string and exit'
        ''  'version'     'print a version string and exit'
        'v' 'verbose'     'print debug statements (as under --debug)'
        ''  '--'          'cease parsing options'
    )

    usage_options_parameterized=(
        'Parameterized options'
        'c COMMAND' 'command=COMMAND' 'run the passed zeshy shell command (e.g., "is_dir /")'
        'o OPTION'  'option=OPTION'   'enable the passed zsh shell option ("man zshoptions")'
    )

    usage_options_startup=(
        'Startup options'
        '' 'zeshy-dot-dir=PATH' 'change zeshy''s dot directory (defaults to "~/.zeshy")'
        '' 'digest-release'     'switch to zeshy''s optimized digest (default)'
        '' 'digest-debug'       'switch to zeshy''s developer digest'
        '' 'compile-digest'     'recompile zeshy''s digest (even if already up-to-date)'
        '' 'compile-digest-if-zeshy-changed'
                                'recompile zeshy''s digest if zeshy''s codebase changed'
    )

    # Print such usage.
    :print_usage\
        usage_overview\
        usage_options_main usage_options_parameterized usage_options_startup
}

#FIXME: Document. Oh, boy... For simplicity, let's largely document this by
#example, eh?

:func.document <<'/---'
string :print_usage(
    string overview_map_name,
    string options_list_name1?, ...)

Print *command usage* (i.e., a terse specification of such command's command-
line interface) from the passed overview map and zero or more options lists.
For readability, such usage will be dynamically paged if exceeding the height
of the current terminal: e.g.,

.:print_usage()
==========================================
[source]
------------------------------------------
>>> :print_usage ...
------------------------------------------
==========================================

== Overview Map ==

== Options Lists ==
/---
function :print_usage() {
    # Validate sanity.
    die_unless_args\
        'Expected one overview map name and optional options list names.'
    :string map_name_overview="${1}"
    shift_arg

    # Page all output exceeding the height of the current terminal.
    {
        # Handle previously updated output state.
        :print_stdout_separated_start

        # Print the mandatory overview.
        ::output_usage_overview "${map_name_overview}"

        # If passed at least one options list name, print such options.
        if { is_args } {
            ::output_usage_options "${@}"
        }

        # Update output state in preparation for subsequent output.
        :print_stdout_separated_stop
    } | page_stdin
}

# ....................{ OUTPUTTERS                         }....................
:func.document <<'/---'
string ::output_usage_overview(string overview_map_name)

Output the *command usage overview* (i.e., a terse synopsis of such command's
command-line interface) described by the passed map. This low-level utility
function is typically _only_ called by the high-level :print_usage(). See such
function for further details.
/---
function ::output_usage_overview() {
    # Validate sanity.
    die_unless_arg 'Expected one overview map name.'
    :string\
        overview_map_name__ouo="${1}"\
        command_name__ouo\
        command_args__ouo\
        command_synopsis__ouo
    :Map.die_unless "${overview_map_name__ouo}"
    shift_arg

    # Mandatory command to print usage for. If such map lacks such key, this
    # implicitly throws an exception.
    :set_string_to_map_key_value\
        command_name__ouo "${overview_map_name__ouo}" 'command'

    # Print such command name.
    :output_string_sans_newline\
        "${ZESHY_STYLE_TO_COLOR[print_usage.usage]-}Usage${ZESHY_STYLE_TO_COLOR[print_usage.usage_colon]-}: ${ZESHY_STYLE_TO_COLOR[print_usage.command_name]-}${command_name__ouo}"

    # If such map contains optional command arguments, print such arguments.
    if { :set_string_to_map_key_value_if_found\
        command_args__ouo "${overview_map_name__ouo}" 'args' } {
        #FIXME: It'd be nice to extend replace_string_matches_glob_with_string()
        #to accept *MULTIPLE* glob string pairs. This is certainly feasible and
        #should remain reasonably efficient, given a single eval() statement.
        #(No looping required, I should imagine.)
        #FIXME: It'd be nice to perform a modest amount of pretty printing in
        #the event that such arguments exceed the width of the current line.
        #Shouldn't be terribly difficult; just requires a bit of consideration.

        # Print such arguments, prefixing all braces, ellipses, and words with
        # their corresponding color styles.
        :output_string_sans_newline\
            " ${${${command_args__ouo//(#m)[\[\]]/${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]-}${MATCH}}//.../${ZESHY_STYLE_TO_COLOR[print_usage.arg_ellipsis]-}...}//(#m)[[:alpha:]]##/${ZESHY_STYLE_TO_COLOR[print_usage.arg_name]-}${MATCH}}"
    }

    # Complete the usage line.
    :output_newline

    # If such map contains an optional command synopsis, print such synopsis.
    if { :set_string_to_map_key_value_if_found\
        command_synopsis__ouo "${overview_map_name__ouo}" 'synopsis' } {
        #FIXME: Just call :wrap_string() instead.
        # Line wrap such synopsis.
        :set_string_to_string_wrapped\
            command_synopsis__ouo "${command_synopsis__ouo}"

        #FIXME: Abstract out such string replacements to a new function as above.

        # Print such synopsis, prefixing the command name and all uppercase words
        # of at least two characters with their corresponding color styles.
        :output_newline
        :string.output\
            "${ZESHY_STYLE_TO_COLOR[print_usage.synopsis]-}${${command_synopsis__ouo//${command_name__ouo}/${ZESHY_STYLE_TO_COLOR[print_usage.synopsis_command_name]-}${command_name__ouo}${ZESHY_STYLE_TO_COLOR[print_usage.synopsis]-}}//(#m)[[:upper:]](#c2,)/${ZESHY_STYLE_TO_COLOR[print_usage.synopsis_arg_name]-}${MATCH}${ZESHY_STYLE_TO_COLOR[print_usage.synopsis]-}}"
    }
}

:func.document <<'/---'
string ::output_usage_options(string options_list_name1, ...)

Print the *command usage options* (i.e., a terse synopsis of such command's
command-line options) described by the passed lists. This low-level utility
function is typically _only_ called by the high-level :print_usage(). See such
function for further details.
/---
function ::output_usage_options() {
    # Validate sanity.
    die_unless_args 'Expected one or more options list names.'
    :string\
        pcre_wrapping__ouo\
        option_indentation__ouo='  '\
        option_short__ouo\
        option_short_colored__ouo\
        option_long__ouo\
        option_long_colored_pcu\
        option_text__ouo\
        option_text_line__ouo\
        option_text_pcre_wrapper__ouo\
        ZPCRE_OP
    :int\
        terminal_width__ouo\
        option_names_width__ouo\
        option_names_length__ouo\
        option_text_width__ouo\
        options_list_size__ouo

    # List of text for the current option wrapped into newline-delimited lines.
    :list option_text_lines__ouo

    # Width in characters of the current terminal.
    :set_int_to_terminal_width_if_found_or_default terminal_width__ouo

    # Width in characters of the option names area (i.e., the portion of each
    # line allotted to short and long options names and arguments),
    # corresponding to one third of the current terminal width. Avoid decimal
    # approximations of one third (e.g., "0.33"), which usually fail to ensure
    # that "$(( 1 * (1/3.) == 1 ))". To ensure floating point rather than
    # integer division, suffix either "1" or "3" by ".".
    option_names_width__ouo=$(( terminal_width__ouo * (1/3.) ))

    # Width in characters of the option text area (i.e., the portion of each
    # line allotted to options descriptions), corresponding to two thirds of the
    # current terminal width.
    option_text_width__ouo=$((\
        terminal_width__ouo - option_names_width__ouo ))

    # If either such width is less than 1, throw an exception.
    :int.die_unless_positive "${option_names_width__ouo}"\
        "Option name width ${option_names_width__ouo} non-positive."
    :int.die_unless_positive "${option_text_width__ouo}"\
        "Option text width ${option_text_width__ouo} non-positive."

    # Get a PCRE permitting line wrapping of option text.
    set_string_to_pcre_wrapping_to_width\
        pcre_wrapping__ouo ${option_text_width__ouo}

    # Compile such PCRE *AFTER* wrapping the synopsis above, which also
    # internally compiles a PCRE conflicting with this PCRE's compilation below.
    # See for_string_text_matching_pcre:() for further details.
    pcre_compile -- "${pcre_wrapping__ouo}"
    pcre_study

    #FIXME: This function exhibits an uncommonly high degree of unfortunate
    #premature optimizations. For example, the first statement in the iteration
    #below should simply be a call to :List.is(). Undo such optimizations please.
    #(Far more importantly, note we should now be calling
    #:set_string_to_string_ansiless_repeated_to_length() to perform string
    #padding. Good Gods, but I can hardly fathom how I actually concocted this
    #function. zsh may be slow, but it's not *THAT* slow. *sigh*)

    # For each options list, print all options in such list.
    :string options_list_name__ouo
    for     options_list_name__ouo ("${@}") {
        # Size of such list.
        set_int_to_list_size options_list_size__ouo "${options_list_name__ouo}"
        :output_strings_newlined\
            "${options_list_name__ouo}: ${(@P)options_list_name__ouo}"

        # If such size is *NOT* at least 4 and (excluding the leading heading) a
        # multiple of three, throw an exception.
        ((   options_list_size__ouo >= 4 &&
            (options_list_size__ouo - 1) / 3. == 1 )) or {
#           print_list "${options_list_name__ouo}"
            :die "List \"${options_list_name__ouo}\" contains ${options_list_size__ouo} elements rather than a heading and one or more triples."
        }

        # Print such options' heading.
        :output_newline
        :string.output "${ZESHY_STYLE_TO_COLOR[print_usage.heading_name]-}${${(@P)options_list_name__ouo}[1]}${ZESHY_STYLE_TO_COLOR[print_usage.heading_colon]-}:"

        # For each trifecta of short and long options and option text, print
        # the holy triumvurate of shame!
        for option_short__ouo option_long__ouo option_text__ouo (
            "${${(@P)options_list_name__ouo}[2,-1]}") {
            # If a short option was defined, format such option.
            if { is_string_nonempty "${option_short__ouo}" } {
                # If such option is longer than a character, throw an exception.
                :die_unless_char "${option_short__ouo}"

                # If such option is prefixed by an optional dash, remove such
                # dash before prefixing such option by a mandatory dash below.
                option_short__ouo="${option_short__ouo#-}"

                # Prefix the first optional space and argument in such option
                # with corresponding color styles.
                option_short_colored__ouo="${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]-}-${ZESHY_STYLE_TO_COLOR[print_usage.option_name]-}${option_short__ouo/(#m) */${ZESHY_STYLE_TO_COLOR[print_usage.option_arg]-}${MATCH}}"

                # Prefix such option by a dash, to simplify logic below.
                option_short__ouo="-${option_short__ouo}"
            # Else, no such option was defined. Empty the corresponding string.
            } else {
                option_short_colored__ouo=''
            }

            # If a long option was defined, format such option (as above).
            if { is_string_nonempty "${option_long__ouo}" } {
                option_long__ouo="${option_long__ouo#--}"
                option_long_colored__ouo="${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]-}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]-}${option_long__ouo}/(#b)=(*)/${ZESHY_STYLE_TO_COLOR[print_usage.option_equals]-}=${ZESHY_STYLE_TO_COLOR[print_usage.option_arg]-}${match[1]}}"
                option_long__ouo="--${option_long__ouo}"
            # Else, no such option was defined. Empty the corresponding string.
            } else {
                option_long_colored__ouo=''
            }

            # If option text was defined, wrap such text into a list of lines.
            option_text_lines__ouo=()
            if { is_string_nonempty "${option_text__ouo}" } {
                # Wrap such text with the previously compiled PCRE. See
                # for_string_text_matching_pcre:() and
                # wrap_string_to_width() for further details.
                ZPCRE_OP='0 0'
                while { pcre_match -b -n ${ZPCRE_OP[(w)2]} --\
                    "${option_text__ouo}" } {
                    option_text_lines__ouo+="${ZESHY_STYLE_TO_COLOR[print_usage.option_synopsis]-}${match[1]}"
                }
            }

            # If a short option was defined, print such option.
            if { is_string_nonempty "${option_short__ouo}" } {
                # Print such option.
                :output_string_sans_newline\
                    "${option_indentation__ouo}${option_short_colored__ouo}"

                # If a long option was also defined, print a delimiting comma
                # followed by such option.
                if is -n "${option_long__ouo}" si {
                    # Print a delimiting comma.
                    :output_string_sans_newline\
                        "${ZESHY_STYLE_TO_COLOR[print_usage.option_comma]-}, "

                    # Length of concatenated short and long options.
                    :set_int_to_string_byte_count option_names_length__ouo\
                        "${${option_indentation__ouo}${option_short__ouo}, ${option_long__ouo}}"

                    # If such options fit on a single line, do so.
                    if (( option_names_length__ouo <= option_names_width__ouo )) {
                        # Print the long option, padded on the right by
                        # sufficient whitespace to ensure well-formatted
                        # columns. Such strings contain ANSI color codes and
                        # hence cannot be reliably padded by expansion under
                        # either parameter expansion flags "(l...)" or "(r...)".
                        # Instead, simply repeat the desired number of spaces by
                        # either such flag. See repeat_string() for further
                        # details.
                        #
                        # Print also the first line of options text (defaulting
                        # to the empty string), delimited by a newline.
                        :string.output\
                            "${option_long_colored__ouo}${(l:$(( option_names_width__ouo - option_names_length__ouo )):):-}${option_text_lines__ouo[1]-}"

                        # For each additional line of options text that exists,
                        # print full padding followed by such line, delimited
                        # by a newline. Do *NOT* quote this list slice.
                        for option_text_line__ouo\
                            (${option_text_lines__ouo[2,-1]}) {
                            :string.output\
                                "${(l:${option_names_width__ouo}:):-}${option_text_line__ouo}"
                        }
                    # Else, such options only fit on separate lines. Shift the
                    # long option to the next line, indented to the right.
                    } else {
                        # Print sufficient padding followed by the first line
                        # of options text (defaulting to the empty string),
                        # delimited by a newline. Note that while the length of
                        # the short option is constant and hence could be
                        # reduced to a magic number, recomputing such length
                        # does little tangible harm.
                        :string.output\
                            "${(l:$(( option_names_width__ouo - ${#${${option_indentation__ouo}${option_short__ouo},}} )):):-}${option_text_lines__ouo[1]-}"

                        # Print the indented long option followed by sufficient
                        # padding and the second line of options text
                        # (defaulting to the empty string), delimited by a
                        # newline.
                        :output_string_sans_newline\
                            "${option_indentation__ouo}${option_long_colored__ouo}"

                        # If no more lines of options text exist, print a
                        # newline.
                        if (( ${#option_text_line__ouo} < 2 )) {
                            :output_newline
                        # Else, print such lines.
                        } else {
                            # Length of the long option.
                            :set_int_to_string_byte_count\
                                option_names_length__ouo\
                                "${${option_indentation__ouo}${option_long__ouo}}"

                            # If such option fits on a single line, print the
                            # next line following such option.
                            if (( option_names_length__ouo <= option_names_width__ouo )) {
                                :string.output\
                                    "${(l:$(( option_names_width__ouo - ${#${${option_indentation__ouo}${option_long__ouo}}} )):):-}${option_text_lines__ouo[2]-}"

                            #FIXME: This is hardly ideal. Options text lines
                            #should be contiguous, if not necessarily left-
                            #aligned to the same margin. To do so here, print
                            #spaces rather than a newline here followed by a
                            #*PORTION* of the next line. Naturally, this
                            #requires rewrapping the third line and all
                            #subsequent lines of options text, if such lines
                            #exist. Annoying, though certainly feasible. See to it!

                            # Else, print a newline followed by the next line.
                            } else {
                                :output_newline
                                :string.output\
                                    "${(l:${option_names_width__ouo}:):-}${option_text_lines__ouo[2]-}"
                            }

                            # For each additional line of options text that exists,
                            # print full padding followed by such line (as above).
                            for option_text_line__ouo\
                                (${option_text_lines__ouo[3,-1]}) {
                                :string.output "${(l:${option_names_width__ouo}:):-}${option_text_line__ouo}"
                            }
                        }
                    }
                # Else, only a short option was defined.
                } else {
                    # Print sufficient padding followed by all lines of options
                    # text (as above).
                    :string.output\
                        "${(l:$(( option_names_width__ouo - ${#${${option_indentation__ouo}${option_short__ouo}}} )):):-}${option_text_lines__ouo[1]-}"
                    for option_text_line__ouo (${option_text_lines__ouo[2,-1]}) {
                        :string.output\
                            "${(l:${option_names_width__ouo}:):-}${option_text_line__ouo}"
                    }
                }
            # Else, no short option was defined. If only a long option was
            # defined, print such option (as above).
            } elif { is_string_nonempty "${option_long__ouo}" } {
                :output_string_sans_newline\
                    "${option_indentation__ouo}${option_long_colored__ouo}"
                :set_int_to_string_byte_count option_text_line__ouo\
                    "${option_indentation__ouo}${option_long__ouo}"

                if (( ${#option_text_line__ouo} == 0 )) {
                    :output_newline
                } else {
                    if (( option_names_length__ouo <= option_names_width__ouo )) {
                        :string.output\
                            "${(l:$(( option_names_width__ouo - ${#${${option_indentation__ouo}${option_long__ouo}}} )):):-}${option_text_lines__ouo[1]-}"
                    } else {
                        :output_newline
                        :string.output\
                            "${(l:${option_names_width__ouo}:):-}${option_text_lines__ouo[1]-}"
                    }

                    for option_text_line__ouo\
                        (${option_text_lines__ouo[2,-1]}) {
                        :string.output\
                            "${(l:${option_names_width__ouo}:):-}${option_text_line__ouo}"
                    }
                }
            # Else, no short or long options were defined. Since this
            # constitutes a fatal error, throw an exception.
            } else {
                :die "No short or long options defined for current option."
            }
        }
    }
}

# --------------------( WASTELANDS                         )--------------------
# This function is typically called
# only by ::output_usage(). See such function for further details.

                # See :die_unless_char() for further details.
                # (( ${#option_short__ocuo} == 1 )) or\
                #     :die "Short option \"${option_short__ocuo}\" not a character."

        #  See get_list_size() for further details.
        # :List.die_unless "${options_list_name__ocuo}"
        # :output_strings_newlined "${options_list_name__ocuo}: ${(@P)options_list_name__ocuo}"
        # options_list_size__ocuo="${#${(@P)options_list_name__ocuo}}"

        # If such list does not exist, throw an exception. See :List.die_unless()
        # for further details.
        # is "${(tP)options_list_name__ocuo-}" ==\
        #     ${~ZESHY__VAR_TYPE_GLOB_LIST} si or
        #     :die "List \"${options_list_name__ocuo}\" undefined."

        # Sanitize the current terminal in preparation for subsequent output.
#       :print_stdout_separated_stop
        # Update state in preparation for the next printer function.
                #FUXME: If such option exceeds the total width of the options
                #"area", what we do depends. If:
                #
                #* A short option was also defined, then this long option should
                #  reside indented by three characters right on the next line.
                #* Else, the following option description should be shifted to the
                #  next line.
                #
                #Rather different operations, but the resulting effect is...
                #rather pleasing.

#       options_heading__pcuo="$(get_list_head "${options_list_name__pcuo}")"
#       :output_newline
#       :string.output "${ZESHY_STYLE_TO_COLOR[print_usage.heading_title]}${options_heading__pcuo}${ZESHY_STYLE_TO_COLOR[print_usage.heading_colon]}:"

#   option_text_pcre_wrapper__pcuo="$(get_pcre_wrapping_at_line_length\
#       ${option_text_width__pcuo})"

    # Compile such PCRE. See for_string_text_matching_pcre:() for further details.
#   pcre_compile -- "${option_text_pcre_wrapper__pcuo}"

    # Indentation prefixing the option name at the head of each line.
#   string option_indentation__pcuo='  '

                # If such option is prefixed by two optional dashs, remove such
                # dashes before prefixing such option by two mandatory dashes.
#               option_long__pcuo="${option_long__pcuo#--}"

                # Prefix the first optional equals sign and argument in such
                # option with corresponding color styles.
#               option_long_colored__pcuo="${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}${option_long__pcuo}/(#b)=(*)/${ZESHY_STYLE_TO_COLOR[print_usage.option_equals]}:catch${ZESHY_STYLE_TO_COLOR[print_usage.option_value]}${match[1]}}"

                # Prefix such option by two dashes, to simplify logic below.
#               option_long__pcuo="--${option_long__pcuo}"
            #FUXME: After paging to page_stdin(), we no longer need to print the
            #current usage string. (Nice!)
            # Else, no short or long options were defined. Since this
            # constitutes a fatal error, throw an exception.
#           } else {
#               :die "no short or long options defined for current option; usage string is:${ZESHY_ASCII_NEWLINE}${usage__pcuo}"

    #FUXME: Rather than appending to ${usage__pcu} here, shouldn't we simply
    #output text as we construct it and page the entire "for" loop via
    #page_stdin()? That would seem to reduce the discernable downtime for the
    #current user, as well as slightly simplify things. Hmm; I suppose we don't
    #really want ${usage_pcu} at all, then! Just wrap the whole function in a
    #"{...} | page_stdin" block (after performing initial exception handling).
    #FUXME: Be sure to use :output_string_sans_newline() where appropriate, below!
    # Print such usage paged.
#   page_string "${usage__pcuo}"

#FUXME: Consider splitting into two functions: print_usage_overview()
#and print_usage_options().

    #FUXME: Excise!
    # Print such usage.
#    :string.output "${ZESHY_STYLE_TO_COLOR[print_usage.usage]}Usage${ZESHY_STYLE_TO_COLOR[print_usage.usage_colon]}: ${ZESHY_STYLE_TO_COLOR[print_usage.command_name]}zeshy ${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}[${ZESHY_STYLE_TO_COLOR[print_usage.arg_name]}OPTION${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}]${ZESHY_STYLE_TO_COLOR[print_usage.arg_ellipsis]}... ${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}[${ZESHY_STYLE_TO_COLOR[print_usage.arg_name]}FILE ${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}[${ZESHY_STYLE_TO_COLOR[print_usage.arg_name]}ARGUMENT${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}]${ZESHY_STYLE_TO_COLOR[print_usage.arg_ellipsis]}...${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}]
#
#${ZESHY_STYLE_TO_COLOR[print_usage.usage_text]}Open a new zsh shell running zeshy. If passed an optional FILE, source such path
#as a zeshy zsh shell script passed the passed ARGUMENTs.
#
#${ZESHY_STYLE_TO_COLOR[print_usage.heading_title]}Main options${ZESHY_STYLE_TO_COLOR[print_usage.heading_colon]}:
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}-${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}i${ZESHY_STYLE_TO_COLOR[print_usage.option_comma]}, ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}interactive      ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}open an interactive non-login zsh shell
#}
#
#    # Print such usage.
#    :string.output "${ZESHY_STYLE_TO_COLOR[print_usage.usage]}Usage${ZESHY_STYLE_TO_COLOR[print_usage.usage_colon]}: ${ZESHY_STYLE_TO_COLOR[print_usage.command_name]}zeshy ${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}[${ZESHY_STYLE_TO_COLOR[print_usage.arg_name]}OPTION${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}]${ZESHY_STYLE_TO_COLOR[print_usage.arg_ellipsis]}... ${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}[${ZESHY_STYLE_TO_COLOR[print_usage.arg_name]}FILE ${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}[${ZESHY_STYLE_TO_COLOR[print_usage.arg_name]}ARGUMENT${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}]${ZESHY_STYLE_TO_COLOR[print_usage.arg_ellipsis]}...${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}]
#
#${ZESHY_STYLE_TO_COLOR[print_usage.usage_text]}Open a new zsh shell running zeshy. If passed an optional FILE, source such path
#as a zeshy zsh shell script passed the passed ARGUMENTs.
#
#${ZESHY_STYLE_TO_COLOR[print_usage.heading_title]}Main options${ZESHY_STYLE_TO_COLOR[print_usage.heading_colon]}:
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}-${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}i${ZESHY_STYLE_TO_COLOR[print_usage.option_comma]}, ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}interactive      ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}open an interactive non-login zsh shell
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}-${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}l${ZESHY_STYLE_TO_COLOR[print_usage.option_comma]}, ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}login            ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}open an interactive login zsh shell
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}-${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}h${ZESHY_STYLE_TO_COLOR[print_usage.option_comma]}, ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}help             ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}print this help string and exit
#      ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}version          ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}print a version string and exit
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}-${ZESHY_STYLE_TO_COLOR[print_usage.option_comma]},  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--                 ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}stop parsing options
#
#${ZESHY_STYLE_TO_COLOR[print_usage.heading_title]}Parameterized options${ZESHY_STYLE_TO_COLOR[print_usage.heading_colon]}:
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}-${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}c ${ZESHY_STYLE_TO_COLOR[print_usage.option_value]}COMMAND${ZESHY_STYLE_TO_COLOR[print_usage.option_comma]},            ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}run the passed zeshy shell command (e.g., \"is_dir /\")
#     ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}command${ZESHY_STYLE_TO_COLOR[print_usage.option_equals]}:catch${ZESHY_STYLE_TO_COLOR[print_usage.option_value]}COMMAND
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}-${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}o ${ZESHY_STYLE_TO_COLOR[print_usage.option_value]}OPTION${ZESHY_STYLE_TO_COLOR[print_usage.option_comma]},             ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}enable the passed zsh shell option (\"man zshoptions\")
#     ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}option${ZESHY_STYLE_TO_COLOR[print_usage.option_equals]}:catch${ZESHY_STYLE_TO_COLOR[print_usage.option_value]}OPTION
#
#${ZESHY_STYLE_TO_COLOR[print_usage.heading_title]}Startup options${ZESHY_STYLE_TO_COLOR[print_usage.heading_colon]}:
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}-${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}v${ZESHY_STYLE_TO_COLOR[print_usage.option_comma]}, ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}verbose          ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}print debug statements during zeshy startup
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}zeshy-dot-dir${ZESHY_STYLE_TO_COLOR[print_usage.option_equals]}:catch${ZESHY_STYLE_TO_COLOR[print_usage.option_value]}PATH   ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}change zeshy's dot directory (defaults to \"~/.zeshy\")
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}no-zeshy-dot-dir     ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}ignore zeshy's dot directory and files therein; hence,
#                            run zeshy with default settings and no digest file
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}compile-digest       ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}recompile zeshy's digest, even if up-to-date
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}compile-digest-if-zeshy-home-changed
#                         ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}recompile zeshy's digest if zeshy's codebase changed"

            #FUXME: Excise.
            # Else, no option text was defined. To simplify logic below,
            # initialize such list to only a single newline.
#           } else {
#               option_text_lines__pcu=( "${ZESHY_ASCII_NEWLINE}" )
#           }

                #FUXME: This should dynamically append as much whitespace is
                #required to ensure well-formatted columns. We'll need to get
                #the string length of ${option_short__pcu} sans ANSI colors,
                #then subtract the total width of the options "area" by such
                #length. Shouldn't be terribly hard.
#               usage__pcu+="${option_names__pcu}"

                        # Length of short option only. While such length 
#                       option_names_length__pcu="${#${  ${option_short__pcu},}}"

#See align_string_to_length_right() for
                        # further details.
                    #FUXME: There's a far more efficient way. Just retain the
                    #original unformatted option names! We'll need two new
                    #string locals above. *shrug*
                    # Length of short and long options if (hypothetically)
                    # fitting on a single line. See
                    # get_string_length_printable() for further
                    # details.
#                   option_names_length__pcu="${#${${option_names__pcu}${option_long__pcu}//${ZESHY_ANSI_CSI}${~ZESHY_ANSI_SGR_GLOB}}}"

#               ="$(wrap_string_to_width\
#                   "${option_text__pcu}" ${option_text_width})"
        #FUXME: Actually, we really need a 
        #FUXME: Implement such exception handler.

        #FUXME: Implement such iterator. We'll want to 
#       for_list_items_in_range\
#           "${options_list_name__pcu}" 2 -1\
#           option_short__pcu option_long__pcu option_text__pcu\
#           ''
#       :List.die_unless "${options_list_name__pcu}"

        #FUXME: Not right, obviously. Parse such string apart. Actually, just
        #use a series of global string replacements. Should be fairly simple.
#       overview__pcu+=" ${command_args__pcu}"

    # If such map lacks mandatory key-value pairs, throw an exception.
#       'v' 'verbose'           'print optional debug statements'
#       '' 'release'            'switch to zeshy''s optimized digest (default)'
#       '' 'debug'              'switch to zeshy''s developer digest'
