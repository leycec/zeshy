#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'-/-'
Handle *langinfo getters* (i.e., functions obtaining string constants returned
by the canonical POSIX C function `nl_langinfo`). While map ${langinfo} also
provides access to such constants, such map's keys are _not_ terribly human-
readable or -rememberable (e.g., `CRNCYSTR`, the currency symbol for the current
locale).
-/-

# ....................{ GETTERS                            }....................
:func.doc <<'/---'
string get_locale_format_currency()

Get the format string for currency signs in the current locale (e.g., `-$`). The
first character of such string signifies how to print such sign, while all
characters following such character signify the sign. Specifically, if the
first character of such string character is:

* `-`, such sign should be printed _before_ currency values.
* `+`, such sign should be printed _after_ currency values.
* `.`, such sign should be printed _in place of_ the radix point returned by
  get_locale_delimiter_radix() rather than before or after currency values.
/---
function get_locale_format_currency() {
    die_if_args
    return_string "${langinfo[CRNCYSTR]}"
}

# ....................{ GETTERS ~ delimiter                }....................
:func.doc <<'/---'
string get_locale_delimiter_radix()

Get the radix point for the current locale (e.g., `.`), also referred to as the
decimal mark when applying the conventional base 10 notation. Such string
separates the integer from fractional portion of floating point numbers under
such locale.
/---
function get_locale_delimiter_radix() {
    die_if_args
    :str.output "${langinfo[RADIX]}"
}

:func.doc <<'/---'
string get_locale_delimiter_thousands()

Get the thousands separator for the current locale (e.g., `,`). For readability,
such character optionally separates each group of three consecutive digits of
integers and the integer portion of floating point numbers under such locale.
/---
function get_locale_delimiter_thousands() {
    die_if_args
    :str.output "${langinfo[THOUSEP]}"
}

# ....................{ GETTERS ~ pcre                     }....................
# Sadly, the arguably more informative string constants "YESSTR" and "NOSTR"
# have been withdrawn from recent versions of the locale specification.

:func.doc <<'/---'
string get_locale_pcre_yes()

Get a regular expression matching positive single-character responses to yes/no
questions for the current locale (e.g., `^[yYoO].*`).
/---
function get_locale_pcre_yes() {
    die_if_args
    :str.output "${langinfo[YESEXPR]}"
}

:func.doc <<'/---'
string get_locale_pcre_no()

Get a regular expression matching negative single-character responses to yes/no
questions for the current locale (e.g., `^[nN].*`).
/---
function get_locale_pcre_no() {
    die_if_args
    :str.output "${langinfo[NOEXPR]}"
}

# ....................{ SETTERS                            }....................
:func.doc <<'/---'
void set_list_to_locale_characters_yes(string list_name)

Set the passed list (ideally, a list set) to the set of all characters
signifying positive responses to yes/no questions under the current locale, in
the same order as returned by get_locale_pcre_yes(): e.g.,

.set_list_to_locale_characters_yes()
==========================================
[source]
------------------------------------------
>>> set_locale en_CA.utf8
>>> get_locale_pcre_yes
^[yYoO].*
>>> listset canadian_yes
>>> set_list_to_locale_characters_yes canadian_yes
>>> :str.output "${canadian_yes[@]}"
y Y o O
------------------------------------------
==========================================
/---
function set_list_to_locale_characters_yes() {
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize changes with set_list_to_locale_characters_no().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Validate passed arguments.
    die_unless_arg 'Expected one list name.'
    string list_name__sltlcy="${1}" pcre__sltlcy
    :List.die_unless "${list_name__sltlcy}"

    # If the PCRE returned by get_locale_pcre_yes() is prefixed by a character
    # class, get the contents of such class. Since all such PCREs should be of
    # the form "^[${class}].*" and hence prefixed by a character class, this is
    # (largely) a formality.
    #
    # According to the set of all such PCREs harvested by Perl 5 package
    # http://cpansearch.perl.org/src/TOBYINK/Lingua-Boolean-Tiny-0.006/lib/Lingua/Boolean/Tiny/More.pm,
    # a small subset of such PCREs are *NOT* of the above form: e.g.,
    #
    # * Central Khmer, having YESEXPR "^[yY]([eE][sS])?".
    # * Konkani, having YESEXPR "^(\x{939}\x{92f}|[yY])".
    # * Ukranian, having YESEXPR
    #   "^([Yy+]|[\x{422}\x{442}][\x{410}\x{430}][\x{41a}\x{43a}]?)\$".
    #
    # Even in such nonconformant cases, however, such PCRE always contains a
    # character class. Since nonconformant PCREs arguably constitute bugs in the
    # corresponding locale definitions, ignoring such issues by only matching a
    # character class seems the simplest general-purpose approach.

    pcre__sltlcy="$(get_locale_pcre_yes)"
    if { :is_string_matches_glob_grouped\
        "${pcre__sltlcy}" *'\['([^'\]']#)'\]'* } {
#       print "yes characters: ${match[1]}"
#       print_list match
        # Decode encoded characters in such class (e.g., from "\x{43a}" to "ะบ").
        # Split such class on individual characters into the passed list.
        set_list_to_string_characters\
            "${list_name__sltlcy}" "$(unescape_pcre "${match[1]}")"
    # Else, throw an exception.
    } else {
        :die "nl_langinfo() YESEXPR \"${pcre__sltlcy}\" contains no \"[\"- and \"]\"-delimited character class."
    }
}

:func.doc <<'/---'
void set_list_to_locale_characters_no(string list_name)

Set the passed list (ideally, a list set) to the set of all characters
signifying negative responses to yes/no questions under the current locale, in
the same order as returned by get_locale_pcre_no(). See
set_list_to_locale_characters_yes() for further details.
------------------------------------------
==========================================
/---
function set_list_to_locale_characters_no() {
    # See set_list_to_locale_characters_yes() for further details.
    die_unless_arg 'Expected one list name.'
    string list_name__sltlcy="${1}" pcre__sltlcy
    :List.die_unless "${list_name__sltlcy}"
    pcre__sltlcy="$(get_locale_pcre_no)"
    if { :is_string_matches_glob_grouped\
        "${pcre__sltlcy}" *'\['([^'\]']#)'\]'* } {
        set_list_to_string_characters\
            "${list_name__sltlcy}" "$(unescape_pcre "${match[1]}")"
    } else {
        :die "nl_langinfo() NOEXPR \"${pcre__sltlcy}\" contains no \"[\"- and \"]\"-delimited character class."
    }
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Remove the following line after fixing this.
    #FUXME: Interesting. zsh fails to pass the glob verbatim. We may need
    #to add another "no*" prefix to our glob aliases. Hmmmmm.
#   match=()

        # Decode encoded characters in such character class (e.g., from
        # "\x{43a}" to "ะบ").
#       character_class__sltlcy="$(unescape_pcre "${match[1]}")"

        # Convert "\x{...}" expressions in such character class into the UTF-8-
        # encoded characters such expressions match.
    #FUXME: We *REALLY* need to define :is_string_matches_glob() *EARLY*, to
    #ensure that noglob is available on such function to the zeshy codebase.

#FUXME: POSIX function nl_langinfo() provides a large number of rather cool
#functions for dynamically incorporating the current user's locale in a
#language-independent fashion. I particularly liked "YESEXPR", which, to
#quote: "Returns a regular expression that can be used with the regex
#function to recognize a positive response to a yes/no question." Nice! But
#how the heck do we access this from the command line, if such library is
#available? *OOOH*. Ridiculous. Just call "locale yesexpr". God, that's neat-
#o. For a description of all available options, see "man nl_langinfo".
