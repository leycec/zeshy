#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2018 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'-/-'
Handle public locales. Public locales are locales generated by either
installing "glibc" or an equivalent C library (e.g., "uclibc") or running an
external command (e.g., "locale-gen"). All other locales are private, and
hence inaccessible to customary applications.
-/-

# ....................{ EXCEPTIONS                         }....................
:func.doc <<'/---'
void die_unless_locale_public(
    string locale,
    string error_message = "\"${locale}\" not a public locale")

Throw an exception with the passed message unless the the passed locale has been
generated on the current system.
/---
function die_unless_locale_public() {
    die_unless_args_1_to_2 'expected one locale and optional error message'
    string locale="${1}"
    is_locale_public "${locale}" or
        :die "${2:-\"${locale}\" not a public locale}"
}

# ....................{ TESTERS                            }....................
:func.doc <<'/---'
[status: boolean] is_locale_public(string locale)

Return success if the passed locale has been generated on the current system.
/---
function is_locale_public() {
    die_unless_arg 'expected one locale'
    is_string_line "$(command locale -a)" "${1}"
}

# ....................{ PRINTERS                           }....................
:func.doc <<'/---'
string print_locales_public()

Get a newline-delimited list of public locales generated on the current system.
/---
function print_locales_public() {
    #FIXME: Does "uclibc" install a comparable command?
    # "glibc" installs "locale", which when run with option "-a" lists all
    # available locales in newline-delimited format. Since alternative C
    # libraries (e.g., "uclibc") are unlikely to install such command, throw an
    # exception unless "locale" is currently installed.
    die_if_args
    die_unless_pathable locale
    command locale -a
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Contemplate alternate nomenclature resembling:
#locale.public.list:
#locale.public.die_unless:
#locale.public.is:
#Hmm. It's quaint, really; but not terribly readable. I vastly prefer the
#current (mostly) human-readable style. That said, I'm concerned about the long-
#term implications of a lack of namespacing.

# Such locales
# are usually installed on either installing "glibc" or running corresponding
# utilities (e.g., "localegen" under Gentoo).
    #FUXME: Antiquated. Just call locale.
#   get_first_nonempty_variable_value_if_found LC_ALL LC_CTYPE LANG or
#       :stdout.echo "C"
# ${LC_ALL} supersedes ${LC_CTYPE} superseding ${LANG} for purposes of
# ascertaining the character locale, according to:
#
#     http://rosettacode.org/wiki/Terminal_control/Unicode_output
#   if :str.is_nonempty LC_ALL
#   then :stdout.echo ${LC_ALL}
#   elif :str.is_nonempty LC_CTYPE
#   then :stdout.echo ${LC_CTYPE}
#   elif :str.is_nonempty LANG
#   then :stdout.echo ${LANG}
#   else :die 'environment variables "LC_ALL", "LC_CTYPE", and "LANG" either not defined or empty'
#   fi

    #FUXME: We *REALLY* want to verify the passed string is a valid locale
    #under the current system, since we're not actually calling a command. How?
# While the Linux community appears to prefer the
# former, enough systems use the latter to necessitate matching both.#
