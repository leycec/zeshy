#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle core standard input functionality.

== Caveats ==

Standard file descriptors are shell-specific. Hence, avoid calling functions or
expanding functions operating on such descriptors from subshells. Attempting to
do so fails to both operate on and close such descriptors in the current shell.
/---

# ....................{ EXCEPTIONS                         }....................
:func.document <<'/---'
:void die_unless_stdin_pipe()

Throw an exception with the passed message unless standard input to the current
context is a pipe. See :is_stdin_pipe() for further details.
/---
function die_unless_stdin_pipe() {
    die_if_args
    :is_stdin_pipe or :die 'Standard input unpiped.'
}

:func.document <<'/---'
:void die_unless_stdin_terminal()

Throw an exception with the passed message unless standard input to the current
context is a terminal. See :is_stdin_terminal() for further details.
/---
function die_unless_stdin_terminal() {
    die_if_args
    :is_stdin_terminal or :die 'Standard input not a terminal.'
}

# ....................{ TESTERS                            }....................
:func.document <<'/---'
[status = :bool] :is_stdin()

Report success if standard input to the current context is *open* (i.e.,
attached to either an existing pipe _or_ file other than that of the bit
bucket). Typically, such input is closed only if the current process is
*headless* (i.e., _not_ running under a terminal process) and hence attached to
the bit bucket (e.g., `/dev/null`).
/---
function :is_stdin() {
    # Validate sanity.
    die_if_args

    # If standard input is attached to either a terminal or pipe, such input is
    # by definition open. This is *NOT* merely an optimization. See the body of
    # :is_stdin_file_simple() for further details.
    :is_stdin_terminal or :is_stdin_pipe or {
        # Else, such input is open only if the target file to which such
        # input's symbolic link points both exists and is *NOT* the bit bucket.
        :string stdin_target
        :set_string_to_symlink_target_last stdin_target\
            "${ZESHY_STDIN_PATH-/dev/stdin}"

        # Report success only if such target exists and...
        is_file "${stdin_target}" and {
            # ...is *NOT* the bit bucket.
            :string bit_bucket
            :set_string_to_bit_bucket bit_bucket

            # Is such target the bit bucket?
            :is ${stdin_target} != ${bit_bucket} :si
        }
    }
}

:func.document <<'/---'
[status = :bool] :is_stdin_here_doc_or_string()

Report success if standard input to the current context is either a
*here-document or -string* (i.e., if such input is received non-interactively
from either a `<<`-enabled here-document or `<<<`-enabled here-string mediated
through a `zsh`-specific temporary file).

== Caveats ==

*Success only strongly implies (rather than strictly guaranteeing) such input
to be either a here-document or -string.* If such input is in fact a here-
document or -string, `zsh` mediates such input through a temporary file deleted
immediately after use prefixed by the standard `zsh`-specific prefix for such
files (e.g., `/tmp/zsh`). Technically, the current user and/or system _could_
symbolically link such input to such a file outside of a here-document or
-string, in which case this function erroneously reports success.

The unlikelihood of such a meaninglessly malicious scenario strongly implies
the exit status reported by this function to signify its specified condition.
/---
function :is_stdin_here_doc_or_string() {
    # Validate sanity.
    die_if_args
    :string stdin_target

    # Target file to which the symbolic link for standard input points.
    :set_string_to_symlink_target_last\
        stdin_target "${ZESHY_STDIN_PATH-/dev/stdin}"

    # Report success if such file does not exist *AND* is prefixed by the
    # zsh-specific temporary path prefix.
    not is_file "${stdin_target}" and {
        # Prefix prefixing all zsh-specific temporary paths.
        :string zsh_temp_prefix
        :set_string_to_zsh_temp_prefix zsh_temp_prefix

        # Test such target.
        :is_string_prefix "${stdin_target}" "${zsh_temp_prefix}"
    }
}

:func.document <<'/---'
[status = :bool] :is_stdin_file_simple()

Report success if standard input to the current context is a *simple file*
(i.e., if such input is received non-interactively from a typical file rather
than interactively from a device file).

== Implications ==

This function reports failure if such input is either:

* A *pipe*, either named (e.g., `/tmp/fifo`) or unnamed (i.e., a typical pipe).
* A *pseudo-terminal device file* (e.g., `/dev/pts/0`). This is usually the case
  if the current process is running unredirected under a graphical terminal
  emulator (e.g., `xterm`).
* The *bit bucket device file* (e.g., `/dev/null`). This is usually the case if
  the current process is a cronjob.
/---
function :is_stdin_file_simple() {
    # Validate sanity.
    die_if_args

    # If standard input is attached to either a terminal or pipe, such input
    # cannot be a simple file. In either case, report failure.
    #
    # Technically, in either case (under Linux, at least), the canonical
    # symbolic link for standard input is guaranteed to transitively point to a
    # non-simple file. Assuming such guarantee holds across all other supported
    # platforms, the logic below would implicitly report failure in either
    # case, implying this conditional to be unnecessary (but improve efficiency
    # in the common case).
    #
    # We now instructively show why this must be the case (again -- under
    # Linux, at least). If standard input is attached to a:
    #
    # * Terminal, such link points to such terminal's device file. Since device
    #   files are *NOT* simple files, the logic below would implicitly report
    #   failure in such case.
    # * Pipe, such link points to a non-existent file in the same directory
    #   with basename resembling "pipe:[35692595]". Since non-existent files
    #   are also *NOT* simple files, the logic below would implicitly report
    #   failure in such case. If such file were creatable, such guarantee could
    #   be circumvented by merely creating an empty simple file in such
    #   directory with such basename. However, since such directory resides in
    #   the "/proc" pseudo-filesystem under Linux and hence is read-only, such
    #   file cannot be created -- even when attempting to do so as root.
    #
    # While this test is merely an optimization under Linux, there exists no
    # guarantee of it not being required under other platforms. In short, it's
    # best not to leave such delicate matters to chance.
    not { :is_stdin_terminal or :is_stdin_pipe } and {
        # Target file to which such link points.
        :string stdin_target
        :set_string_to_symlink_target_last\
            stdin_target "${ZESHY_STDIN_PATH-/dev/stdin}"

        # Report success only if such file exists *AND* is simple.
        is_file "${stdin_target}" and :is_file_simple "${stdin_target}"
    }
}

:func.document <<'/---'
[status = :bool] :is_stdin_pipe()

Report success if standard input to the current context is a *pipe* (i.e., if
such context is any subcommand of a pipeline -- excluding the first such
subcommand, which receives no piped input).
/---
function :is_stdin_pipe() {
    die_if_args
    :is -p ${ZESHY_STDIN_PATH-/dev/stdin} :si
}

:func.document <<'/---'
[status = :bool] :is_stdin_terminal()

Report success if standard input to the current context is an *interactive
terminal*.

== Blocking Behaviour ==

If standard input to the current context is an interactive terminal, attempting
to read such input will block the current process until the current user
interactively types either one character _or_ zero or more characters followed
by a newline (depending on the type of read performed).

Else, standard input is probably either a pipe or file, in which case reading
such input will block the current process only when such pipe or file has unread
bytes _and_ is still open for reading.

In either case, this function does _not_ provide a reliable means of testing
whether or not attempting to read standard input will block the current process.
To test such condition reliably, consider either iteratively calling
:stdin.is_nonempty() or non-iteractively calling
:is_stdin_pipe_or_file_simple() instead.
/---
function :is_stdin_terminal() {
    die_if_args
    :is -t ${ZESHY_STDIN_FILE_DESCRIPTOR-0} :si
}

:func.document <<'/---'
[status = :bool] :is_stdin_noninteractive()

Report success if standard input to the current context is *non-interactively
open* (i.e., attached to neither an interactive terminal or the bit bucket).
Success suggests (but, due to improbable but possible edge cases, does _not_
necessarily imply) that the caller may read such input without silently
blocking on interactive input. See :is_stdin_terminal() and :is_stdin_open()
for further details.
/---
function :is_stdin_noninteractive() {
    die_if_args
    not :is_stdin_terminal and :is_stdin
}

#FIXME: Actually, the documentation isn't *QUITE* right. This function *IS*
#reliably callable in a non-iterable manner when testing whether standard input
#derived from a here-document or -string. In such case, zsh appears to
#synchronously and hence deterministically (i.e., *ALWAYS*) establish such
#standard input *BEFORE* calling the function receiving such input; in such
#case, this function *ALWAYS* reports success if called by such function.

#FIXME: In lieu of unit tests...
#function empo() {
#    print ok | { :is_stdin_pipe     and print 'ok' or print 'ko' }
#    print ok | { :stdin.is_nonempty and print 'ok' or print 'ko' }
#    {   print "stdin: $(:stdin.get)"
#        :stdin.is_nonempty and print 'ok' or print 'ko' } <<< yumo
#   string yimo; :string.set_to_stdin yimo <<< hamo; print "yimo: ${yimo}"
#}

# ....................{ GETTERS                            }....................
:func.document <<'/---'
:string get_stdin_until_eot[stdin = (:string input)]

Get all standard input to the current context until receiving a line of such
input containing only the end-of-transmission (EOT) character. If no such line
is received, all input will be returned.

This function is intended to be called as a coprocess in low-level functions
capturing output (e.g., run_silent_and_set_string_to_stderr()). Since
coprocesses typically loop on standard input until receiving end-of-file _and_
since there exists no builtin means of piping end-of-file to standard input,
this function leverages the EOT character for such purposes.
/---
function get_stdin_until_eot() {
    # Technically, there exist two means of caching standard input:
    #
    # 1. Appending each line of such input delimited by newline to a string and
    #    returning such string as is.
    # 2. Appending each line of such input undelimited to a list and returning
    #    such list joined on newline.
    #
    # Having implemented both, the former informally appears to behave much more
    # efficiently in time (and presumably in space) than the latter. Hence, we
    # adopt such approach.
    #
    # Incidentally, do *NOT* attempt to trap signals (either locally or
    # globally) within this function. Doing so irrevocably terminates the entire
    # process group of shells owning this shell -- a probable zsh bug. See
    # run_code_and_set_string_to_coprocess_output_from_redirection().

    # Validate sanity.
    die_if_args
    :string stdin stdin_line

    # Temporarily buffer each line of standard input to string local ${stdin},
    # which will be output "all at once" after input subsequently terminates.
    #
    # Do *NOT* incrementally output such lines (e.g., with :string.output()) in
    # the loop body. Doing so behaves as expected on sufficiently small input
    # but deadlocks on sufficiently large input when invoked from a pipeline or
    # coprocess subshell whose parent shell only reads such input back from such
    # subshell "all at once." In this case, "small" and "large" are defined by
    # the size of the kernel-specific socket buffer. If the current system
    # supports configuring such size, run "limit sockbufsize" to get such size;
    # else, the current kernel internally hardcodes such size.
    #
    # Since the socket buffer has finite size, attempting to write a string of
    # output larger than such size to such buffer blocks the process attempting
    # such write -- in the example above, the pipeline or coprocess subshell
    # executing this function.  If the process on the read end of such buffer --
    # in the example above, the parent shell of such subshell -- is *NOT*
    # concurrently reading such buffer but waiting for another command to
    # terminate, the inevitable result is deadlock. How bad is it? Bad:
    # indefinite, pseudo-random, and always silent.
    #
    # See page_stdin() for related logic.
    :string IFS=
    while {
        read -r stdin_line and
            :is ${stdin_line} != ${ZESHY_ASCII_EOT} :si
    } {
        stdin+="${stdin_line}${ZESHY_ASCII_NEWLINE}"
    }

    # Return such input to the caller via a *SINGLE* output statement. Avoid
    # suffixing such input with a newline; the prior loop already did.
    #
    # If such input is sufficiently large, attempting to output the entirety
    # of such input from a pipeline or coprocess subshell will block such
    # subshell unless the parent shell concurrently reads such output.
    # Fortunately, this is the common case under the 
#   :output_string_to_stderr 'Coprocess terminating.'
    :output_string_sans_newline "${stdin[1,-2]}"
}

# --------------------( WASTELANDS                         )--------------------
# function :stdin.is_nonempty() {
#     # Validate sanity.
#     die_if_args
#     :int exit_status
#     :list zselect_status
# 
#     # Given the criticality and commonality of this test, one would assume there
#     # to exist builtins or commands for accomplishing it. One would be wrong.
#     # Testing whether such file descriptor and hence input is readable without
#     # blocking requires calling the commonly available kernel function select().
#     # Ideally, such test would elegantly reduce to the following:
#     #
#     #     read -t 0 -k 0
#     #
#     # Dismantled, this is:
#     #
#     # * "-t 0", testing whether standard input is readable without blocking and
#     #   returning immediately if not.
#     # * "-k 0", reading 0 bytes from standard input if such input is readable.
#     #
#     # Unfortunately, "read -t 0 -k 0" always returns failure. This differs from
#     # bash, in which "read -t 0 -N 0" conditionally returns success when one
#     # expects it to. Hence, this test defers to select() instead.
#     #
#     # Since zselect() (the zsh select() wrapper) returns failure with exit
#     # status 2 when the underlying OS fails to provide a select() function,
#     # capture and test such status rather than implicitly returning such status
#     # as this function's exit status.
#     #
#     # Dismantled, this is:
#     #
#     # * "-t 0", reporting whether input bytes exist to be read without waiting.
#     # * "-a ...", setting such list to contain a string resembling either
#     #   "-r 0" if standard input is nonempty or "" if standard input is empty.
#     #   Since zselect() defaults such list to ${reply} if unpassed *AND* since
#     #   such list is commonly used by callers and should *NOT* be overwritten by
#     #   such a low-level function as this, explicitly specify such list. Since
#     #   this function never references such list, our specifying it here is
#     #   simply to avoid overwriting ${reply}. (Frankly, this "unique" choice of
#     #   API design is one of the more eclectic that we've ever seen. And we were
#     #   proficient in ML... once.)
#     # * "-r ...", testing such file descriptor for nonempty reading.
#     #
#     # Note that the "{" and "}" delimiters surrounding such integer assignment
#     # are essential; neglecting delimiters assigns such integer standard input
#     # to *THIS* function rather than such exit status. (O^o)
#     #
#     # Thus does another feeble mind break.
#     if { zselect -t 0 -a zselect_status -r ${ZESHY_STDIN_FILE_DESCRIPTOR-0} } {
#         set_integer_to_status exit_status
#     }
# 
#     # If such status indicates such function to be absent, throw an exception.
#     if (( exit_status == 2 )) {
#         :die 'Kernel function select() undefined.'
#     }
# 
#     # Else, return such status as is. Technically, zselect() returns:
#     #
#     # * 0 if any passed file descriptor is both nonempty and readable.
#     # * 1 otherwise.
#     #
#     # Since this function tests only one file descriptor for nonempty reading,
#     # such status exactly coincides with what the caller expects. (Scoooooore!)
#     return ${exit_status}
# }

#FUXME: Actually, even this generalization fails to suffice. Thanks to here-
#documents and -strings, we need to generalize this a bit further, also
#necessitating a nomenclature change -- ideally, to something a bit more
#generic (e.g., :is_stdin_readable_non_int()). In turn, such tester
#should first call :stdin.is_nonempty() before attempting more
#complex testing heuristics. How about this:
#
#    :stdin.is_nonempty or
#        { not :is_stdin_terminal and :is_stdin_open }
#
#While we could probably replace the latter condition with the following, the
#above seems both simpler and more generally applicable:
#
#        :is_stdin_pipe or
#        :is_stdin_file_simple or
#        :is_stdin_here_doc_or_string
#
#Actually, such function should *NEVER* report success if standard input is a
#terminal. Hence, such condition should resemble:
#
#    not :is_stdin_terminal and {
#        :stdin.is_nonempty or
#        :is_stdin_open
#    }
#
#Wait. Since :is_stdin_open() is almost always true, the above reduces to:
#
#    not :is_stdin_terminal and :is_stdin_open
#
#Nice. Such function should then be named :is_stdin_readable_noninteractive(),
#readily capturing such function's intent.
#FUXME: Define :is_stdin_open() to call :is_file_descriptor_open() with the
#file descriptor for standard input, as required above.

#FUXME: Unrelatedly, define a new tester :is_stdin_here_doc_or_string(),
#reporting success if standard input derived from a here-document or -string.
#Given functionality we've implemented elsewhere, the implementation should be
#fairly trivial:
#
#* Get the transitive target of the symbolic link for standard input.
#* If such target no longer exists *AND* is prefixed by the zsh temporary
#  prefix, report success; else, failure.

# , such conditions
# do *NOT* suffice to 
    #   In
    # practice, such file should *NOT* exist.
    # Since device files are *NOT*
    # simple files, the logic below would implicitly report failure in such
    # case, in which case this does reduce to a mere optimization.
    #
    # Hence, in the general case, this is *NOT* merely an optimization.
    #
    # canonical file for  While the logic would implicitly report failure in the former case (since
    # d, this

    # While this is merely an optimization;
    #
    # Since
    # the logic below would implicitly report failure in either case, this
    # conditional is unnecessary but improves efficiency in the common case.

#FUXME: Excise.
# :func.document <<'/---'
# [status: bool] :is_stdin_pipe_or_file_simple()
# 
# Report success if standard input to the current context is either a pipe or
# simple file. Since both pipes and simple files tend to operate in a non-
# interactive and hence non-blocking manner, success suggests (but does _not_
# necessarily imply) that the caller may read from standard input without concern
# for whether such read will silently block. See :is_stdin_file_simple() and
# :is_stdin_file_simple() for further details.
# /---
# function :is_stdin_pipe_or_file_simple() {
#     die_if_args
#     :is_stdin_pipe or :is_stdin_file_simple
# }

#FUXME: Actually, doesn't the above cond imply standard input to be readable without blocking?
# if standard input is open and *NOT* attached to a terminal,

# ....................{ TESTERS ~ blocking                 }....................
#FUXME: Arguably, this function should be considered harmful. There's no sane or
#sensible way to implement it safely. The current implementation is awful, as is
#any other forseeable implementation. The intrinsic difficulty is that it takes
#the shell a non-negligible amount of time to establish a pipe when under heavy
#system load. That said, there still might be a limited use case for this
#function -- but certainly *NOT* as documented below. Note the above strong
#caveat and substantially rewrite such documentation.
#FUXME: To repair such function, reduce the "-t 5" below to "-t 0" and on we go!
#This reduces the edge-case utility of such function but renders it demonstrably
#more sane. That said, it might be helpful to define another function
#:is_stdin_pipe_or_readable_sans_blocking(), which is probably the closest we can
#get to a working implementation that accords with user expectations. *shrug*
#FUXME: Actually, :is_stdin_pipe_or_readable_sans_blocking() may not be all that
#more helpful, given the underlying indeterminism. Thankfully, we believe we've
#unlocked this horrid puzzle box. What we *REALLY* wanted to know all along is
#whether or not stdin is attached to an interactive terminal or not. That's
#right: that's basically what we were asking. But we can already test that
#simply by calling :is_stdin_terminal()! Indeed, this suggests the following new
#tester:
#
#    function :is_stdin_pipe_or_file() {
#        die_if_args
#        not :is_stdin_terminal
#    }
#
#Dead simple. If stdin is *NOT* an interactive terminal, it's either a (usually)
#non-interactive pipe or file (handle). Is this actually true? Pretty much! It's
#easy to test: since "/dev/stdin" is always a symlink to "/proc/self/fd/0" under
#Linux, just call "ls -l /proc/self/fd/0" in a variety of different situations:
#e.g.,
#
#    >>> command ls -l /proc/self/fd/0
#    lrwx------ 1 leycec leycec 64 Jan 29 20:56 /proc/self/fd/0 -> /dev/pts/11
#    >>> { command ls -l /proc/self/fd/0 } <<<here
#    lr-x------ 1 leycec leycec 64 Jan 29 20:56 /proc/self/fd/0 -> /tmp/zshq4ZlVz (deleted)
#    >>> print ok | { command ls -l /proc/self/fd/0 }
#    lr-x------ 1 leycec leycec 64 Jan 29 20:57 /proc/self/fd/0 -> pipe:[79562890]
#
#Interestingly, calling "command ls -l /proc/self/fd/0" either directly at the
#interactive CLI or from a seemingly non-interactive zsh script reports
#"/dev/stdin" to be the same interactive pseudo-terminal. (Intriguing.)
#
#In any case, this more or less validates the above claim and hence function
#implementation. Go, go, go!
#FUXME: Interesting! When run from a cronjob, we get:
#    >>> command ls -l /proc/self/fd/0
#    lrwx------ 1 leycec leycec 64 Jan 29 20:56 /proc/self/fd/0 -> /dev/null
#So, although standard input is technically always open, it can be effectively
#closed by redirecting it to the bit bucket. Naturally, :is_stdin_pipe_or_file()
#should test for this explicitly. For safety, we should probably implement such
#tester manually.
#FUXME: Great! Now document such function and shift above.

    # Given the criticality and commonality of this test, one would assume there
    # to exist builtins or commands for accomplishing it. One would be wrong.
    # Testing whether such file descriptor and hence input is readable without
    # blocking requires calling the commonly available kernel function select().
    # Ideally, such test would elegantly reduce to the following:
    #
    #     read -t 0 -k 0
    #
    # Dismantled, this is:
    #
    # * "-t 0", testing whether standard input is readable without blocking and
    #   returning immediately if not.
    # * "-k 0", reading 0 bytes from standard input if such input is readable.
    #
    # Unfortunately, "read -t 0 -k 0" always returns failure. This differs from
    # bash, in which "read -t 0 -N 0" conditionally returns success when one
    # expects it to. Hence, such test defers to select() instead.
    #
    # Since zselect() (the zsh select() wrapper) returns failure with exit
    # status 2 when the underlying OS fails to provide a select() function,
    # capture and test such status rather than implicitly returning such status
    # as this function's exit status.
    #
    # Since standard input is context-specific, such exit status *CANNOT* be
    # trivially captured with command substitution (e.g.,
    # "$(zselect ... | get_status)"). Instead, implement the equivalent of
    # alias set_integer_to_status(). Unfortunately, such alias transitively
    # calls this function; breaking such recursion requires this function to
    # internally reimplement set_integer_to_stdin(). *sigh*
    #
    # Dismantled, this is:
    #
    # * "-t 5", returning after waiting at most 0.05s for standard input to
    #   receive input. While this technically constitutes blocking behavior,
    #   such minimally negligible wait time is essential to avoid erroneously
    #   reporting failure. As example, establishing "/dev/stdin" as a named pipe
    #   between a simple print() writer and zselect() reader consumes on the
    #   order of between 0.001s to 0.02s on an (admittedly) obsolete machine, in
    #   which case the following test commonly fails:
    #
    #       >>> print '' | { zselect -t 0 -r 0 and print Fail or print Success }
    #       Fail
    #
    #   Contrariwise, the following test commonly succeeds:
    #
    #       >>> print '' | { zselect -t 1 -r 0 and print Fail or print Success }
    #       Success
    #
    #   Such ad-hoc observation constitutes more common sense than rocket
    #   science. However, since decreasing such timeout to 0 breaks the common
    #   case *AND* since increasing such timeout above 5 correspondingly slows
    #   the entire zeshy codebase, we defer to common sense.
    # * "-a ...", setting such list to contain a string resembling either
    #   "-r 0" if standard input is nonempty or "" if standard input is empty.
    #   Since zselect() defaults such list to ${reply} if unpassed and since
    #   such list is commonly used by callers and should *NOT* be overwritten by
    #   such a low-level function as this, explicitly specify such list. Since
    #   this function never references such list, our specifying it here is
    #   simply to avoid overwriting ${reply}. Frankly, this "unique" choice of
    #   API design is one of the more eclectic that we've ever seen. And we were
    #   proficient in ML... Once.
    # * "-r ...", testing such file descriptor for nonempty reading.
    #
    # Note that the "{" and "}" delimiters surrounding such integer assignment
    # are essential; neglecting delimiters assigns such integer standard input
    # to *THIS* function rather than such exit status. (O^o)
    #
    # Thus does another feeble mind break.
    # { zselect -t 5 -a zselect_status -r ${ZESHY_STDIN_FILE_DESCRIPTOR-0} } and
    #     set_integer_to_status exit_status

# Since reading from
# standard input via conventional techniques (e.g., `< /dev/stdin`, zsh builtin
# read(), zeshy alias :stdin.get()) typically blocks or behaves erratically if no
# such input has been written, consider always calling this function or
# die_unless_stdin_readable_sans_blocking() before reading from standard input.

# Creating and sending
# output to the input end of shell pipes, process substitution, here-strings and
# -documents, and similar means of providing standard input requires a non-
# deterministic and hence non-computable amount of wall clock time.
# 
# requires forking at least one asynchronous subshell, a
# computationally expensive task. 

#FUXME: Excise entirely, we should think. The underlying function is
#sufficiently unreliable that we should *NEVER* be throwing an exception on its
#result.
# :func.document <<'/---'
# void die_unless_stdin_readable_sans_blocking(
#     string error_message = "Standard input unreadable without blocking.")
# 
# Throw an exception with the passed message unless standard input for this
# function is nonempty. See :stdin.is_nonempty() for further details.
# /---
# function die_unless_stdin_readable_sans_blocking() {
#     die_unless_args_0_to_1 'Expected optional error message.'
#     :stdin.is_nonempty or
#         :die "${1-Standard input unreadable without blocking.}"
# }

# This excludes device files,
    # including both the bit bucket and pseudo-terminals.
    # If standard input is piped, report success. Else...
    #     # Target file to which the symbolic link for standard input points
    #     # (e.g., "/dev/stdin" links to "/dev/null" when run as a cronjob).
    #     :string filename_stdin
    #     :set_string_to_path_canonical filename_stdin\
    #         "${ZESHY_STDIN_PATH-/dev/stdin}"

    #     # If such file is regular, report success. This excludes device files,
    #     # including both the bit bucket and pseudo-terminals.
    #     :is_file_simple "${filename_stdin}"
    # }

#   :string.output "call stack: ${funcstack[*]}"
# Most functions defined by this parcel are called by printer functions (e.g.,
# print_error()) possibly called by the exception handler and hence must be
# defined before such functions.

#FUXME: As currently defined, :stdin.is_nonempty() and by extension
#die_unless_stdin_readable_sans_blocking() simply aren't the safest function. If
#a pipe takes longer than 0.05s to initialize and write input to, such functions
#currently fail. This might be acceptable in the general case, but it's
#certainly unacceptable here. Consider a system under heavy load, for example;
#since this function is *ALWAYS* piped input, such pipe could take considerably
#longer than 0.05s to initialize and write input to even though it will
#certainly eventually succeed. To ameliorate this, rename this function to
#:set_var_to_stdin_pipe_blocking() and the above functions similarly; then,
#internally 
#   die_unless_stdin_readable_sans_blocking

    # If standard input is piped into the current context, return success
    # immediately. Such input is *ALWAYS* readable without blocking, even when
    # what is piped is merely the empty string.
#   if { :is_stdin_pipe } {
#       report_success
#   }

    # Else, standard input is *NOT* piped but written into the current context
    # with the file descriptor for such input. In this case, testing whether

#FUXME: Rename to :stdin.is_nonempty() and correct the
#documentation accordingly. The current nomenclature no longer applies, since
#this function returns success whenever standard input is piped -- even if such
#input is empty!

# For safety, this function closes
#such input after doing so.
#Specifically, return
#success if:
#
#* Standard input is piped to such context. Assuming the runnable writing
#  standard output to such pipe and hence such input 
#
#  Piped input is _always_ readable
#  without blocking, even if such input is merely the empty string.
#
#for this function is *nonempty* (i.e., if such
#input contains at least one byte to be read). Consider calling either this
#function or die_unless_stdin_readable_sans_blocking() before reading from standard input; if such
#input is empty, `zsh` quietly blocks on reading, which is bad.

    # If standard input is piped into the current context, return success
    # immediately. Such input is *ALWAYS* readable without blocking, even when
    # what is piped is merely the empty string.

    # immediately without waiting for standard input to
    #   receive input. This is essential for non-blocking behavior.
    # If standard input is piped into the current context, return success
    # immediately. Such input is *ALWAYS* readable without blocking, even when
    # what is piped is merely the empty string.
#   if { :is_stdin_pipe } {
#       report_success
#   }

    # Else, standard input is *NOT* piped but written into the current context
    # with the file descriptor for such input. In this case, testing whether
    # such file descriptor and hence input is readable without blocking requires
    # calling the commonly available kernel function select(). Ideally, such
    # test would elegantly reduce to the following:

    # If standard input is nonempty (i.e., at least one byte of input has either
    # been piped or written to this function), read such input into such string.
#   if { :stdin.is_nonempty } {
#       print 'reading stdin...' 2>&1
        # Set such string. Avoid expanding alias :stdin.get() here. Naturally, the
        # reason is fairly subtle. This function is transitively called by printer
        # functions themselves transitively called by exception handlers. Since
        # zeshy defines aliases in a startup_zeshy() hook *AND* since exceptions
        # may be thrown prior to such hook, this function *CANNOT* safely expand any
        # aliases -- including :stdin.get().
        #
        # The double quotes surrounding such command substitution are *ESSENTIAL*.
        # Their omission results in newlines in such input being silently converted
        # to spaces, which (of course) is awful and awfully difficult to debug.
#       noop ${(P)variable_name__svts::="$(< "${ZESHY_STDIN_PATH-/dev/stdin}")"}
#       print 'reading stdin... ok' 2>&1

        # Close such input, ensuring :stdin.is_nonempty() subsequently returns false.
        # Since expanding alias close_stdin() directly in the body of this function
        # ensures its expansion at function definition rather than call time,
        # expanding such alias here is inherently safe -- unlike above.
#       close_stdin
    # Else, standard input is empty, in which case attempting to read such input
    # would silently block the current shell until reading such input. As this
    # would be terrible, *NEVER* read from an empty stream of standard input.
#   } else {
#       noop ${(P)variable_name__svts::=}
#   }

#Report success if standard input for this function is *nonempty* (i.e., if such
#input contains at least one byte to be read). Consider calling either this
#function or die_unless_stdin_readable_sans_blocking() before reading from standard input; if such
#input is empty, `zsh` quietly blocks on reading, which is bad.

    #FUXME: Fix such documentation. Namely, remove the "or :is_stdin_pipe" and
    #all discussion thereof.

    # Ideally, such test would elegantly reduce to the following:
    #
    #     >>> read -t ${ZESHY_STDIN_FILE_DESCRIPTOR-0} -k 0 or :is_stdin_pipe
    #
    # Dismantled, this is:
    #
    # * "-t 0", testing whether standard input is available...
    # * "-k 0", without reading standard input (i.e., reading 0 characters).
    #   This is essential, since zsh would otherwise read an input line.
    #
    # If file descriptor "/dev/stdin" was previously written to, such test would
    # return success without blocking on or reading input; else, such test would
    # returns failure. In the latter case, standard input may still exist in the
    # guise of piped input, which must thus also be tested.
    #
    # Unfortunately, "read -t 0 -k 0" always returns failure. This differs from
    # bash, in which "read -t 0 -N 0" conditionally returns success when you
    # expect it to.
    #
    # Happily, an efficient alternative presents itself: simply test whether the
    # device file for standard input has nonzero size. If it does, standard
    # input is nonempty; otherwise, as above, standard input still exists in the
    # guise of piped input, which must thus also be tested.

    #FUXME: Ugh. Just because stdin is a pipe does *NOT* imply such input to be
    #nonempty. I mean, obviously; consider:
    #    print -n | { :is_stdin_pipe and print $(:stdin.get) }
    #The above blocks forever. (I think?) Stdin is an empty pipe! Woops. We've
    #fixed this below, but I'm unsure if there will be knockon effects elsewhere
    #in the codebase.
    #FUXME: Woops. Commenting out "or :is_stdin_pipe" basically caused the entire
    #system to collapse in a demented and feeble manner. What we really need is
    #a new function :is_stdin_pipe_nonempty() and to revise below to:
    #
    #   is -s "${ZESHY_STDIN_PATH-/dev/stdin}" si or {
    #       :is_stdin_pipe and :is_stdin_pipe_nonempty }
    #
    #Problem is, I'm none too sure how to implement :is_stdin_pipe_nonempty().
    #How do we "peek" at a pipe without modifying the stdin it provides? Right.
    #You can't. Instead, you read a single byte. If it's EOF, you return false;
    #else, you return true and have to push the byte of stdin on to where it's
    #supposed to go. This works when you *KNOW* what you want to do with stdin
    #but utterly fails in the general case (i.e., here). Here's what the
    #implementation resembles, though I can't imagine using it:
    #
    #first_byte=$(dd bs=1 count=1 2>/dev/null | od -t o1 -A n)
    #if [ -z "$first_byte" ]; then
    #  # stuff to do if the input is empty
    #else
    #  {
    #    printf "\\${first_byte# }"
    #    cat
    #  } | {
    #    # stuff to do if the input is not empty
    #  }
    #fi
    #FUXME: Apparently, there's a command "ifne" that does something like this.
    #Ugh. No way we're adding a dependency on some obscure "moreutils" utility.
    #FUXME: O.K.; forget it. This *CANNOT* be reliably tested. It's infeasible,
    #because stdin can't be pushed back onto. *EXCISE THIS FUNCTION*. I'm
    #serious. It's dangerous. Carefully note why this cannot be reliably
    #achieved. Fortunately, we only call this function in two or three other
    #functions -- which is great. What we *CAN* do is replace this function with
    #the following viable alternative:
    #
    #function get_stdin_if_found() {
    #    #FUXME: I think this should work. Test me up.
    #    string stdin
    #    if { read -t ${ZESHY_STDIN_FILE_DESCRIPTOR-0} stdin }
    #        return_string "${stdin}"
    #    } else {
    #        report_failure
    #    }
    #}
    #
    #A similar setter is also definable, of course. Do so! Naturally, such
    #functions are non-blocking. We could also implement blocking versions; but,
    #honestly, I hardly see the point.

#   is -s "${ZESHY_STDIN_PATH-/dev/stdin}" si or :is_stdin_pipe

#There exists no :stdin.is_nonempty()

#       if { :is_stdin_pipe } { print 'piped stdin!' 1>&2
#       } else               { print 'written stdin!' 1>&2 }

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with setters below.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#   noop ${(P)string_name::=$(< "${ZESHY_STDIN_PATH-/dev/stdin}")}

#, running only such command does *NOT*
    # suffice to prove no such input
#Set the passed float variable to the entirety of standard input. For safety,
#close standard input after doing so: e.g.,

    # Set such float. Avoid expanding alias :stdin.get() here. See
    # set_string_to_stdin_pipe() for further details.
#   set_float_to_float "${1}" "$(< /dev/stdin)"

# While such functions are technically
# reimplementable as aliases, doing so  and hence be a poor idea.
# While set_string_to_stdin_pipe() is currently implemented as a function rather than
# alias, this runnable is called by printer functions (e.g., print_error())
# called by the exception handler and hence must be defined before such
# functions. While this runnable is technically implementable as an alias, the
# implementation below discusses why doing so would be a poor idea. Hence, this
# runnable is implemented as a function in the same parcel as similar aliases.

#FUXME: Shift set_float_to_stdin_pipe() here as well.
#FUXME: Shift such functions to a new parcel -- say,
#"00-declare/05-runnable/io/standard/function". Perhaps shift the aliases to
#"00-declare/05-runnable/io/standard/alias"?

    # Avoid expanding alias close_stdin() here, as discussed above.
#   exec ${ZESHY_STDIN_FILE_DESCRIPTOR-0}<&-

#FUXME: Replace magic numbers 0, 1, etc. with zeshy global expansions.

#, a common source of subtle bugs.
#, ensuring subsequent commands run by the current shell erroneously
#perceive such descriptor to be open after having been closed under the subshell

# ....................{ GETTERS                            }....................
#FUXME: This is *TERRIBLE*. See "io/output/output" for details.
#:func.document <<'/---'
#float get_stdout_mtime()
#
#Get the *mtime* (i.e., modification time) in high-resolution fractional seconds
#since the Unix epoch of the most recent write to standard output by the current
#shell. See get_time() for further details.
#/---
#function get_stdout_mtime() {
#    # Validate sanity.
#    die_if_args
#   die_unless_arg
#   string float_name__gsm="${1}"
#   :var.die_unless_type_float "${float_name__gsm}"

    # Get such time. Use
    # ${ZESHY_STDOUT_FILE_DESCRIPTOR_PATH} rather than
    # ${ZESHY_STDOUT_PATH} for such purposes, as Linux updates such time for
    # the former but not latter on output. Technically, we can also use the
    # canonicalization of ${ZESHY_STDOUT_PATH} for such purposes; since this
    # is both less efficient and without benefit, we prefer the former path.
#    get_path_mtime "${ZESHY_STDOUT_FILE_DESCRIPTOR_PATH}"
#}


#Since subshells do _not_ inherit parent shell file descriptors, there exists no
#convenience alias or function :stdin.get().
    #FUXME: *OH*. "zstat" accepts option "-f" accepting a file descriptor.
    #Hence, we should add a new get_file_descriptor_mtime() to parcel
    #"path/file/descriptor" and call such function instead here.

    #FUXME: This strikes me as stupidly system-specific. Why not just bite the
    #bullet and canonicalize ${ZESHY_STDOUT_PATH} every call to this function?
    #If efficiency becomes a concern, just inline such call. Right?
#is piped input as part of a pipeline command).
#FUXME: Rename to die_unless_stdin_pipe(). A noun complies much better with
#nomenclature elsewhere (e.g., :is_stdin_terminal_or_pipe()).
#Since subshells do _not_ inherit file descriptors from their parent shell, there
#exists no corresponding get_
#   string string_name__ssts="${1}"
#   :var.die_unless_type_string "${string_name__ssts}"
# Avoid calling functions
# operating on such descriptors from subshells.
#
# Calling functions defined by this component from a subshell fails to close the
# corresponding file descriptor in the current shell; subsequent commands in the
# current shell thus erroneously see such descriptor as an open file when in
# fact such file is empty and should have been closed. To amend this, always
# call close_stdin() when calling such functions from a subshell.
# rather, only call such functions
# from the current shell#
#FUXME: Poorly named function, since it should never be called as a conventional
#getter. Rename to print_stdin(). Not sure we require the "_piped"
#distinction, yes? In which case, excise the call to
#die_unless_stdin_pipe() below.

# Handle traditional and named pipes.
#
# --------------------( CAVEATS                            )--------------------
# * Prefer calling piped input functions from the current shell rather than a
#   subshell unless absolutely necessary. Calling such functions from a subshell
#   fails to close standard input in the current shell; subsequent commands in
#   the current shell thus erroneously see standard input to be an open pipe,
#   when in fact such pipe is empty and should have been closed. To fix this,
#   always call close_stdin() after calling piped input functions in a
#   subshell.

#FUXME: This component doesn't really belong here. A common component named
#"standard_input" elsewhere is a much better fit.

#such shell is running any command after the first in a pipe.
# ....................{ SETTERS                            }....................
#FUXME: Silly. Clearly, a vestige from when we thought we needed such
#functionality as an alias. Cut everywhere.
# void set_string_to_stdin_piped(string variable_name)
#
# Set the variable with the passed name to all standard input piped to the
# current shell. Consider calling :is_stdin_pipe() before calling this function
# to test whether or not such input exists: e.g.,
#
#     >>> ska_maria() {
#     ...     string hojas
#     ...     if :is_stdin_pipe
#     ...     then set_string_to_stdin_piped hojas
#     ...     else hojas="${@}"
#     ...     fi
#     ...     :string.output ${hojas}
#     ... }
#     >>> :string.output pastora | ska_maria
#     pastora
#     >>> ska_maria pastora
#     pastora
#function set_string_to_stdin_piped() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one variable name'
#    die_unless_stdin_pipe
#    string string_name="${1}"
#    :var.die_unless_type_string "${string_name}"
#
#    # Capture piped input into the passed variable.
#    :string.set ${string_name} "$(< /dev/stdin)"
#
#    # Close standard input, ensuring :is_stdin_pipe() now returns false.
#    close_stdin
#}

#   string piped_input
#   set_string_to_stdin_piped piped_input
#   :string.output "${piped_input}"
# ....................{ RUNNERS                            }....................
# string call_with_piped_input(
#   string function_name, string function_arg1, string function_arg1, ...)
#
# Call the passed function by piping the standard input piped to the current
# function or script to such function.
#
# In theory, run_code_with_stdin_piped() subsumes this function's functionality;
# in practice, run_code_with_stdin_piped() requires function arguments be quote
# protected and hence is more cumbersome to call than this function. Prefer this function calling run_code_with_stdin_piped() when calling functions with quoted arguments,
#call_with_piped_input() {
    # Validate and run passed arguments.
#    die_unless_args 'expected one command'
#    run cat '/dev/stdin' \| "${@}"

    # Close standard input, ensuring :is_stdin_pipe() now returns false.
#    close_stdin
#}

# string run_code_with_stdin_piped(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command by piping the standard input piped to the current
# function or script to such command. Typically, this alias is used in concert
# with the :is_stdin_pipe() alias to seemlessly propagate input: e.g.,
#
#     >>> salvia() {
#     ...     :is_stdin_pipe and run_code_with_stdin_piped cat or :string.output "${@}" cat
#     ... }
#     >>> print  divinorum | salvia
#     divinorum
#     >>> salvia divinorum
#     divinorum
#run_code_with_stdin_piped() {
    # Validate and run passed arguments.
#    die_unless_args 'expected one command'
#    run cat '/dev/stdin' \| "${@}"

    # Close standard input, ensuring :is_stdin_pipe() now returns false.
#    close_stdin
#}

    #FUXME: We really want a new function set_string(), implemented resembling:
#set_string() {
#   noop ${(P)1::="${2}"}
#}
#This avoids an eval() and hence should be fairly efficient. (Of course, it
#imposes an additional function call... *shrug*)
#   noop ${(P)string_name::=$(< /dev/stdin)}
#   noop ${(P)string_name::="$(< /dev/stdin)"}
#   eval ${string_name}:catch"$(< /dev/stdin)"

#FUXME: Rename set_with_piped_input(), coinciding with run_code_with_stdin_piped().
#FUXME: No reason this can't also be made a run-style function. It should call
#close_stdin(), as expected.
#   exec 0<&-
#FUXME: Arguably, these functions may not belong here. Bizarre! They don't even
#work. Shifting to aliases... *sigh*
# --------------------( CLOSERS                            )--------------------
# void close_stdin()
#
# Close the standard input file descriptor (0) and named pipe ("/dev/stdin").
#close_stdin() {
#    die_if_args
#    exec 0<&-
#}

# void close_stdout()
#
# Close the standard :string.output file descriptor (1) and named pipe ("/dev/stdout").
#close_stdout() {
#    die_if_args
#    exec 1>&-
#}

# void close_stderr()
#
# Close the standard error file descriptor (2) and named pipe ("/dev/stderr").
#close_stderr() {
#    die_if_args
#    exec 2>&-
#}

#   string output; output="$(< /dev/stdin)";

# :func.document <<'/---'
# [status: bool] :is_stdin_pipe_or_readable_sans_blocking()
# 
# Report success if standard input to the current context is either a pipe _or_
# readable without blocking (i.e., readable without waiting -- possibly
# indefinitely and always silently -- for such input to be written). In the former
# case, the caller is guaranteed to be ...
# either
# case, success indicates that the caller may read from  Since
# standard input is effectively always open, there exists 
# /---

        # :string.output ${status} | { exit_status="$(:stdin.get)" } or
        # :string.output ${status} | { exit_status="$(:stdin.get)" }

    # Locally trap SIGUSR1 to gracefully terminate this function. This is the
    # typical means of terminating this function when called by the coprocess.
    # See below for details on the returned string.
#   run_hook_on_signal_interrupt_local '
#       print "coprocess ${sysparams[pid]} received SIGINT" 1>&2
#       report_failure'
#   print "coprocess received SIGUSR1" 1>&2

#function get_stdin_until_eot_WAT() {
#    die_if_args
##   boolean is_uninterrupted=${ZESHY_BOOLEAN_TRUE}
#    string stdin stdin_line
##   trap 'exec 0>&-' INT
##   trap 'return 1' INT
##   trap 'is_uninterrupted=0' INT
##   run_hook_on_signal_interrupt_local 'is_uninterrupted=0'
##   run_hook_on_signal_interrupt_local 'return 0'
##       print "coprocess ${sysparams[pid]} received SIGINT" 1>&2
##       is_uninterrupted=0
##       is_uninterrupted=${ZESHY_BOOLEAN_FALSE}'
##       report_failure'
##       :die "UghUgh."
##   print "coprocess received SIGUSR1" 1>&2
##   while (( is_uninterrupted )) and {
#    while {
#        IFS= read -r stdin_line and
#        is "${stdin_line}" != "${ZESHY_ASCII_EOT}" si } {
#        stdin+="${stdin_line}${ZESHY_ASCII_NEWLINE}"
#    }
#    :output_string_sans_newline "${stdin[1,-2]}"
#}
#
##FUXME: Excise. This is now rightfully obsolete and should *NEVER* be called.
#:func.document <<'/---'
#string get_stdin_until_signal_user1[stdin: string text]
#
#Get all standard input to the current context until receiving the first user-
#defined signal, SIGUSR1. If no such signal is received, all input will be
#returned. See run_hook_on_signal_user1() for further details.
#
#This function was intended to be called by the coprocess in low-level functions
#capturing command output (e.g., run_silent_and_set_string_to_stderr()). Since
#coprocesses typically loop on standard input until receiving end-of-file _and_
#since there exists no builtin means of piping end-of-file to standard input,
#this function leverages SIGUSR1 for such purposes instead.
#/---
#function get_stdin_until_signal_user1() {
#    # Validate sanity.
#    die_if_args
#    string stdin stdin_line
##   print "coprocess ${sysparams[pid]} starting" 1>&2
#
#    # Locally trap SIGUSR1 to gracefully terminate this function. This is the
#    # typical means of terminating this function when called by the coprocess.
#    # See below for details on the returned string.
##    run_hook_on_signal_user1_local '
##        print "coprocess ${sysparams[pid]} received SIGUSR1" 1>&2
##        :output_string_sans_newline "${stdin[1,-2]}"
##        report_success'
##       print "coprocess received SIGUSR1" 1>&2
#
#    # Temporarily buffer each line of standard input to string local ${stdin},
#    # which will be output "all at once" after input subsequently terminates.
#    #
#    # Do *NOT* incrementally output such lines (e.g., with :string.output()) in
#    # the loop body. Doing so behaves as expected on sufficiently small input
#    # but deadlocks on sufficiently large input when invoked from a pipeline or
#    # coprocess subshell whose parent shell only reads such input back from such
#    # subshell "all at once." In this case, "small" and "large" are defined by
#    # the size of the kernel-specific socket buffer. If the current system
#    # supports configuring such size, run "limit sockbufsize" to get such size;
#    # else, the current kernel internally hardcodes such size.
#    #
#    # Since the socket buffer has finite size, attempting to write a string of
#    # output larger than such size to such buffer blocks the process attempting
#    # such write -- in the example above, the pipeline or coprocess subshell
#    # executing this function.  If the process on the read end of such buffer --
#    # in the example above, the parent shell of such subshell -- is *NOT*
#    # concurrently reading such buffer but waiting for another command to
#    # terminate, the inevitable result is deadlock. How bad is it? Bad:
#    # indefinite, pseudo-random, and always silent.
#    #
#    # See page_stdin() for related logic.
#    while { IFS= read -r stdin_line } {
#        stdin+="${stdin_line}${ZESHY_ASCII_NEWLINE}"
#        print -n '.' 1>&2
##       print "coprocess ${sysparams[pid]} received line: ${stdin_line}" 1>&2
#    }
#
#    # Return such input to the caller via a *SINGLE* output statement. Avoid
#    # suffixing such input with a newline; the prior loop already did.
#    #
#    # If such input is sufficiently large, attempting to output the entirety
#    # of such input from a pipeline or coprocess subshell will block such
#    # subshell unless the parent shell concurrently reads such output.
#    # Fortunately, this is the common case under the 
##   print "coprocess ${sysparams[pid]} returning normally" 1>&2
#    :output_string_sans_newline "${stdin[1,-2]}"
#}

#       run_hook_on_signal_interrupt_local '
#           print "coprocess ${sysparams[pid]} received SIGINT" 1>&2
#           report_failure'

#Get all standard input to the current context, up to but _not_ including the
#first input line containing only the end-of-transmission (EOT) character. If no
#such line exists, all input will be returned.
#
#== Motivation ==
#
#This function is principally intended to be called as a coprocess in low-level
#`zeshy` runners (e.g., run_silent_and_set_string_to_stderr()). Since coprocesses
#typically loop on standard input until receiving end-of-file _and_ since there
#exists no builtin means of piping end-of-file to standard input, this function
#leverages the end-of-transmission character for such purposes instead.

#   string stdin_line
#   list stdin
#       join_list_on_newline stdin
#       report_success'
#       print "!!!!!!!!!!!!!!!!!!!!!!!!\ncoprocess received SIGUSR1" 1>&2
#       print "!!!!!!!!!!!!!!!!!!!!!!!!\ncoprocess still here" 1>&2'
#       :output_string_sans_newline "${stdin[1,-2]}"
#   :output_string_sans_newline "${stdin[@]}"
#   join_list_on_newline stdin
#FUXME: Rename function. We no longer expect the interrupt signal. Document why!
#(Namely, an obvious conflict with valid uses of interrupt signals -- namely, as
#signaled by the current user interactively.)
# Clearly, there's
    # some devious interplay of shell-enforced standard input and/or output
    # buffering at work here. It's unfortunate this particular piece of critical
    # machinery is so (seemingly) fragile, but there you are.

#function get_stdin_until_eot() {
#    # Validate sanity.
#    die_if_args
#    string line
#
#    # Output all lines of standard input back to the caller until either
#    # reaching the end of such input or a line containing only an EOT character.
#    # Dismantled, this is:
#    #
#    # * "IFS=", preventing read() from splitting input on field separators.
#    # * "-r", preserving input characters (e.g., backslashes do not escape).
#    while { IFS= read -r line and is "${line}" != "${ZESHY_ASCII_EOT}" si } {
#        :string.output "${line}"
#    }
#}

#   while { IFS= read -r line and is "${line}" != "${ZESHY_ASCII_EOT}" si } {
#       :string.output "${line}" >>/tmp/tmp.zeshy
#   while { IFS= read -r line and is "${line}" != *($'\C-D'|'-----')* si } {

#== Motivation ==
#, for reasons discussed there.  outside of a file context
    # Load zsh module "zselect", if not already. While @{zsh/module} already
    # autoloads modules on zeshy startup, this function is often called
    # before completing such startup and hence autoloading.
#   zmodload zsh/zselect
