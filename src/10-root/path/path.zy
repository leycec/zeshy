#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2017 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Core path functionality.
/---

#FIXME: It'd be nice to incorporate "zmv", for those who want and/or expect it.
#"zmv" is a built-in shell function applying extended glob patterns to
#the usual "mv" command, thus allowing batch renaming of file- and path-names.
#(Use option "-n" before permanently applying any such pattern, so as to
#prete[n]d- apply the pattern as initial "trial run;" or, use option "-i" to
#force "zmv" to [i]nteractively ask your permission to perform each rename.)
#For example: zmv -n '(*).txt' '$1.xtx'  # renames files ending in 'txt' to
#end in 'xtx'. Naturally, "zmv" is an autoloadable function: e.g.,
#autoload -U zmv

# ....................{ GETTERS                            }....................
#FIXME: Refactor into setters, with mute and minor apologies.

:func.doc <<'/---'
string get_path_basename(string pathname)

Get the basename of the passed path. See :set_string_to_path_basename() for
further details.
/---
function get_path_basename() {
    # For simplicity, inline such implementation rather than deferring to
    # :set_string_to_path_basename().
    die_unless_arg 'Expected one pathname.'
    :stdout.echo "${1:t}"
}

:func.doc <<'/---'
string get_path_dirname(string pathname)

Get the dirname of the passed path (i.e., sans basename).
/---
function get_path_dirname() {
    die_unless_arg 'Expected one pathname.'
    :stdout.echo "${1:h}"
}

# ....................{ GETTERS ~ size                     }....................
:func.doc <<'/---'
integer get_path_size(string pathname)

Get the size in bytes of the passed path. If such path is:

* A directory, this is the recursive disk usage reported by the `du` command.
* A symbolic link, this is the non-dereferenced file size of such link. To get
  the dereferenced file or directory size of the non-symbolic target of such
  link, explicitly call :path.canonicalize() prior to this function.
* Anything else (e.g., device node, plain file), this is the typical file size
  reported by the "stat" command.

Regardless of type, such size is always the physical space allocated to such
path by the filesystem containing such path and _not_ the logical space such
path pretends to consume (e.g., due to contiguous runs of logical zeroes in the
case of sparse files or redirection in the case of symbolic links).
/---
function get_path_size() {
    # Validate sanity.
    die_unless_arg 'Expected one pathname.'
    :str pathname="${1}"
    die_unless_path "${pathname}"

    # If the passed path is a directory, get its recursive disk usage.
    if { is_dir "${pathname}" } {
        #FIXME: Extract to a new :set_int_to_dir_size() function and call here.
        get_string_word "$(run_code_with_options 'command du'\
            'ZY_OPTIONS_DU ZY_OPTIONS_DU_IF_GETTING_DIR_SIZE' --\
            "${(q)pathname}")" 1
    # Else, the passed path is a non-directory file (e.g., symbolic link,
    # device node, plain file). Dismantled, this is:
    #
    # * "-L", preserving rather than dereferencing symbolic links. (In contrast
    #   to some commands, zstat() dereferences by default.)
    # * "+size", expanding to such file's size in bytes.
    } else {
        #FIXME: Extract to a new :set_int_to_file_size() function and call here.
        zstat -L +size "${pathname}"
    }
}

#FIXME: Shift to "path" and complete implementation.
#function remove_list_nonpaths() {
    # Filter non-extant paths from the passed paths. Dismantled, this is:
    #
    # * "${^@}", iteratively expanding to each passed path.
    # * "(e:...:), excluding paths failing the test:
    #   * '[[ -e "${REPLY}" ]]', succeeding only for extant paths.
#    :args.set "${^@}"(e:'[[ -e "${REPLY}" ]]':)
#}

# ....................{ SETTERS                            }....................
:func.doc <<'/---'
void :set_string_to_path_basename(string string_name, string pathname)

Set the passed string variable to the passed path's *basename* (i.e., substring
following the last `/` in such path if containing at least one `/` or such path
otherwise).
/---
function :set_string_to_path_basename() {
    die_unless_args_2 'Expected one string name and one pathname.'
    :Str.set "${1}" "${2:t}"
}

:func.doc <<'/---'
void :set_string_to_path_dirname(string string_name, string pathname)

Set the passed string variable to the passed path's *dirname* (i.e., substring
preceding the last `/` in such path if containing at least one `/` or such path
otherwise).
/---
function :set_string_to_path_dirname() {
    die_unless_args_2 'Expected one string name and one pathname.'
    :Str.set "${1}" "${2:h}"
}

# ....................{ REMOVERS                           }....................
:func.doc <<'/---'
void :remove_path_basename(string string_name)

Remove the basename from the passed string variable in-place, reducing such
string to its dirname.
/---
function :remove_path_basename() {
    die_unless_arg 'Expected one string name.'
    :str string_name__rpb="${1}"
    :Str.die_unless "${string_name__rpb}"
    :Str.set "${string_name__rpb}" "${(P)string_name__rpb:h}"
}

:func.doc <<'/---'
void :remove_path_dirname(string string_name)

Remove the dirname from the passed string variable in-place, reducing such
string to its basename.
/---
function :remove_path_dirname() {
    die_unless_arg 'Expected one string name.'
    :str string_name__rpd="${1}"
    :Str.die_unless "${string_name__rpd}"
    :Str.set "${string_name__rpd}" "${(P)string_name__rpd:t}"
}
