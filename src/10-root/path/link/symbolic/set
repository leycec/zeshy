#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "COPYING" for additional details.

:parcel <<'/---'
Handle *symbolic link setters* (i.e., functions setting passed variables to
symbolic link-related metadata).
/---

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void :set_string_to_symlink_target_first(
    string string_name, string symlink_filename)

Set the passed string variable to the passed symbolic link's *immediate target*
(i.e., absolute or relative path to which such link directly links). This
function does _not_ resolve intermediate symbolic links or guarantee such
target to exist, be an absolute path, or _not_ be a symbolic link. For such
functionality, consider calling :set_string_to_path_canonical() instead.
/---
function :set_string_to_symlink_target_first() {
    # Validate sanity.
    die_unless_args_2 'Expected one string name and filename.'
    :string\
        string_name__sststf="${1}"\
        filename_src__sststf="${2}"\
        filename_trg__sststf
    :list filename_stats__sststf
    die_unless_symlink "${filename_src__sststf}"

    # List of canonical statistics for such link. Such logic is somewhat
    # circuitous but remains both the most efficient and reliable. A common
    # alternative is to run external command "readlink" if installed as follows:
    #
    #     :string.set "${string_name__sststf}"\
    #         "$(command readlink -- "${filename__sststf}")"
    :set_list_to_path_stats filename_stats__sststf "${filename_src__sststf}"
    # Immediate target of such link.
    filename_trg__sststf="${filename_stats__sststf[${ZESHY_STAT_INDEX_SYMLINK_TARGET}]}"

    # If such target no longer exists (e.g., as is the common case when
    # resolving the canonical path for standard input received from a here-
    # document or -string), such target is suffixed by the human-readable label
    # " (deleted)". Convert such target to the corresponding path by removing
    # such label.
    remove_string_suffix filename_trg__sststf ' (deleted)'

    # Set such string to such symbolic link.
    :string.set "${string_name__sststf}" "${filename_trg__sststf}"
}

declare_function_with_stdin <<'/---'
void :set_string_to_symlink_target_last(
    string string_name, string symlink_filename)

Set the passed string variable to the passed symbolic link's *transitive
target* (i.e., absolute or relative path of a non-symbolic link to which such
link transitively links after iteratively resolving all intermediate symbolic
links to which such link links). If such link's immediate target is _not_ a
symbolic link, such link's transitive and immediate targets are necessarily
identical; else, such targets differ. This function does _not_ guarantee such
transitive target to exist, be an absolute path, or _not_ be a symbolic link.
For such functionality, consider calling :set_string_to_path_canonical()
instead.
/---
function :set_string_to_symlink_target_last() {
    # Validate sanity.
    die_unless_args_2 'Expected one string name and filename.'
    :string\
        string_name__sststl="${1}"\
        filename_src__sststl="${2}"\
        filename_trg__sststl
    die_unless_symlink "${filename_src__sststl}"

    # Technically, this function is trivially implementable when the GNU
    # coreutils-specific version of "readlink" is pathable:
    #
    #    :string.set\
    #        "${string_name__sststl}"\
    #        "$(readlink -f -- "${filename__sststl}")"
    #
    # Since such implementation is lamentably inefficient (due to unavoidable
    # use of subshell capturing) *AND* conditionally dependent on the
    # pathability of such command (implying the following manual algorithm
    # would still need to be implemented as a fallback), we unconditionally
    # implement this function via a pure-zsh algorithm iteratively resolving
    # all intermediate symbolic links in the chain of such links originating
    # from such source symbolic link until either obtaining a non-symbolic link
    # (in which case the passed link is unbroken) *OR* a previously resolved
    # symbolic link (in which case the passed link is broken).

    # Map from all symbolic links resolved during such iteration to the empty
    # string. Such map enables such iteration to detect and halt on cycles in
    # the implied link graph (i.e., symbolic links transitively linking to
    # themselves), preventing an otherwise noxious infinite loop.
    :map filenames_resolved__sststl

    # Continue resolving links until acquiring the desired transitive target.
    while { true } {
        # Resolve the current source link to its target.
        :set_string_to_symlink_target_first\
            filename_trg__sststl "${filename_src__sststl}"

        # If such target either is *NOT* a link or is but has already been
        # resolved, cease iteration. In either case, such target is the
        # requested transitive target.
        if {
            not is_symlink "${filename_trg__sststl}" or
            (( ${+filenames_resolved__sststl[${filename_trg__sststl}]} ))
        } {
            break
        }

        # Else, such target is an unresolved symbolic link. In preparation for
        # the next iteration:
        #
        # * Record such source link as having been resolved.
        # * Set the current source link to such target.
        filenames_resolved__sststl[${filename_src__sststl}]=
        filename_src__sststl="${filename_trg__sststl}"
    }

    # Set such string to such transitive target.
    :string.set "${string_name__sststl}" "${filename_trg__sststl}"
}

#FIXME: In lieu of unit tests...
# function taro() {
#     :string pathname='/dev/stdin' pathname_first pathname_last
#     {
#         :set_string_to_symlink_target_first pathname_first "${pathname}"
#         :set_string_to_symlink_target_last  pathname_last  "${pathname}"
#         :string.output "target (first): ${pathname_first}${ZESHY_ASCII_NEWLINE}target (last): ${pathname_last}"
#     } <<<yum
# }

# --------------------( WASTELANDS                         )--------------------
    # Continue resolving links until the current target either is *NOT* a link
    # or is but has already been resolved. In either case, such target is the
    # requested transitive target. Note that neither condition is the case on
    # the first iteration, guaranteeing at least one iteration.
    # while {
    #     not is_symlink "${filename_src__sststl}" or
    #     not (( ${+filenames_resolved__sststl[${filename_src__sststl}]} ))
    # } {

#FUXME: Define a new :set_string_to_symlink_target_last() function as well. The
#implementation is sadly non-trivial and probably even platform-specific. Where
#"readlink" is pathable, such function is trivially implementable by running
#'readlink -f -- "${pathname}"'; else, a fallback implementation that would
#definitely work cross-platform-portably (but somewhat inefficiently) would be
#to iteratively call :set_string_to_symlink_target_first() until the resulting target
#either does not exist *OR* is not a symbolic link. Mildly clever, no?
#FUXME: Actually, the latter implementation will be somewhat more convolute, as
#we'll need to expressly guard against infinite cycles in the possibly cyclic
#graph implied by such link indirection (e.g., A -> B -> A). Naturally,
#maintain a local map during such algorithm iteration recording all previously
#visited symbolic links.

# :define_function_if :set_string_to_symlink_target_last
#    'die_unless_args_2 "Expected one string name and filename."
#     :string string_name__sststl="${1}" filename__sststl="${2}"
#     die_unless_symlink "${filename__sststl}"'
