#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "COPYING" for additional details.

#FIXME: There appears to be at least one (and probably more related) *CRITICAL*
#issue with the "zsh-mime-setup" script called below. Unfortunately, such
#script currently defines suffix aliases for script filetypes (e.g., "sh").
#Since *ALL* scripts are already prefixed by an appropriate shebang line, such
#aliases are substantially more harmful than helpful: e.g.,
#
#    # No! No!
#    >>> print ${saliases[sh]}
#    zsh-mime-handler
#
#To compound matters, the zsh function such aliases expand (i.e.,
#zsh-mime-handler()) currently fails with error. While this is probably a zsh
#emulation failure on zeshy's part, it's nonetheless fairly dispiriting,
#implying that trying to run shell scripts in the conventional way (e.g.,
#"./tmp.sh") will always fail with an obscure exception message.
#
#*THIS IS HORRIBLE*. We see no recourse other than to disable such
#functionality, until uncovering a better solution. We really need to just
#investigate why such function is failing. (Again, probably an obscure
#emulation issue.)
#
#Honestly, we should probably just define equivalent pure-zeshy functionality.

:parcel <<'/---'
Handle file *media types* (i.e., lowercase `/`-delimited strings uniquely
identifying file formats), also referred to as *MIME types* in pre-2005
parlance.

== Configuration ==

This parcel assumes external mappings from filetype to mimetype and from
mimetype to command handling such mimetype. Installing mappings is simple, if
somewhat tedious:

.Media Type Configuration
==========================================
[source]
------------------------------------------
# Edit "/etc/mime.type", adding one line for the mimetype for each such
# filetype (e.g., a line "application/pdf pdf" for associating PDF files
# with the "application/pdf" mimetype and hence Okular, above).
>>> edit_file /etc/mime.type

# Edit "/etc/mailcap", adding one line for the application opening each such
# filetype (e.g., a line "application/pdf;/usr/bin/okular %s" for opening
# PDF files in Okular).
>>> edit_file /etc/mailcap

# Reload mimetype aliases.
>>> setup_mimetype_aliases
------------------------------------------
==========================================

== See Also ==

* http://www.bash2zsh.com/essays/essay1_file_manager.html[Readable introduction]
  to `zsh` suffix aliases in relation to media types and file magic.
/---

# ....................{ GLOBALS                            }....................
# There are various thoughts on media type validation. The W3C approach,
# naturally, recommends the following overly overkill PCRE:
#
#     /^[a-zA-Z0-9!#$%^&\*_-\+{}\|'.`~]+/[a-zA-Z0-9!#$%^&\*_-\+{}\|'.`~]+$/
#     http://lists.w3.org/Archives/Public/xml-dist-app/2003Jul/0064.html
#
# The Zend framework takes a different tack, opting instead for:
#
#     /^[a-z-]+\/[a-z0-9.+-]+$/i'
#     https://github.com/zendframework/zf2/blob/master/library/Zend/Mail/Header/ContentType.php
#
# The former arguably encompasses pathological edge cases that sane frameworks
# report as erroneous. We opt for the latter, generalized for
# case-insensitivity. Since non-ASCII Unicode characters do *NOT* constitute
# valid media type characters, avoid otherwise helpful character classes (e.g.,
# "[[:alpha:]]").

:string_global\
    ZESHY_MEDIA_TYPE_GLOB='[a-zA-Z_-]##/[a-zA-Z0-9.+_-]##' <<'/---'
Glob matching valid media types (e.g., `text/plain`). See :is_media_type() for
further details.
/---

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_media_type(str media_type)

Report success if the passed string is a syntactically valid *media type* (i.e.,
(i.e., MIME type in pre-2005 parlance): e.g.,

.:is_media_type()
==========================================
[source]
------------------------------------------
>>> string on_work=\
...    "No one should ever work. Work is the source of nearly all the misery in
...     the world. Almost any evil you'd care to name comes from working or from
...     living in a world designed for work. In order to stop suffering, we have
...     to stop working. That doesn't mean we have to stop doing things. It does
...     mean creating a new way of life based on play; in other words, a ludic
...     conviviality, commensality, and maybe even art. There is more to play
...     than child's play, as worthy as that is. I call for a collective
...     adventure in generalized joy and freely interdependent exuberance. Play
...     isn't passive. Doubtless we all need a lot more time for sheer sloth and
...     slack than we ever enjoy now, regardless of income or occupation, but
...     once recovered from employment-induced exhaustion nearly all of us want
...     to act. Oblomovism and Stakhanovism are two sides of the same debased
...     coin."
>>> :is_media_type "All living things on earth are kindred." or
...     get_string_line "${on_work}" 1
No one should ever work. Work is the source of nearly all the misery in
------------------------------------------
==========================================
/---
function :is_media_type() {
    die_unless_arg 'Expected one media type.'
    is "${1}" == ${~ZESHY_MEDIA_TYPE_GLOB} si
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
str :get_file_media_type(str filename)

Get the *media type* (i.e., MIME type in pre-2005 parlance) of the passed file:
e.g.,

.:get_file_media_type()
==========================================
[source]
------------------------------------------
>>> :get_file_media_type "/etc/issue"
text/plain
------------------------------------------
==========================================
/---
function :get_file_media_type() {
    die_unless_arg 'Expected one filename.'
    :string media_type
    :set_string_to_file_media_type media_type "${1}"
    :string.output "${media_type}"
}

#FIXME: In lieu of unit tests...
# function lita() {
#     is_binary_executable /bin/busybox
# }

# ....................{ SETTERS                            }....................
#FIXME: Actually, there exists a preferable means of getting MIME types. If
#"xdg-mime" is installed, such Bourne shell script is preferred to calling the
#lower-level "file" command. Indeed, such script should be reimplemented here as
#a pure-zeshy function. (Documentation for such script warns against running
#such script as root. While prudent, we would only be calling such script to
#perform a side-effect free MIME type query, suggesting such script to be safe
#in this specific context.) Usage is quite simple:
#
#    >>> xdg-mime query filetype photo.jpg
#    photo.jpg
#        image/jpeg
#
#Hence, just return the second line stripped of prefixing whitespace.
#FIXME: *ACTUALLY*, the ideal approach is probably to call "mimetype" if
#pathable. This is a Perl script (and hence *WAY* preferable to a hacky Bourne
#shell script) leveraging the Shared MIME-info database. Output is sane: e.g.,
#
#    >>> mimetype --brief /usr/bin/mimetype
#    application/x-perl
#
#Nice. No munging required. Perl. No insanity required. The particularly nice
#thing about "mimetype" is that it requires no external dependencies apart from
#the Perl modules it *ALWAYS* comes installed with (e.g., "File::MimeInfo").
#This differs sharply from "xdg-open", which basically has no intelligence of
#its own and simply defers all real work to the current desktop environemnt --
#which seems extremely heavyweight for such a simple process.
#FIXME: Add example.

declare_function_with_stdin <<'/---'
void :set_string_to_file_media_type(string string_name, string filename)

Set the passed string variable to the *media type* (i.e., MIME type in pre-2005
parlance) of the passed file.
/---
function :set_string_to_file_media_type() {
    # Validate sanity.
    die_unless_args_2 'Expected one string name and one filename.'
    :string\
        string_name__sstfmt="${1}"\
        filename__sstfmt="${2}"\
        media_type__sstfmt

    # If such path is not a file, fail. "file" successfully outputs media type
    # "inode/directory" for directories rather than failing with nonzero exit
    # status, requiring our intervention.
    die_unless_file "${filename__sstfmt}"

    #FIXME: GNU-specific. Unfortunately, there exists no short option for
    #"--mime-type". How do the BSDs handle this? Ah, I see; "--mime-type" parses
    #the desired substring from "-i" (i.e., "--mime"), which should certainly
    #exist on BSDs. We'll have to do some heavier lifting to generalize this,
    #but it certainly seems doable: parse "-i" output ourselves on BSD.
    #FIXME: O.K.; the output for file "/etc/issue" resembles:
    #    /etc/issue: text/plain; charset=us-ascii
    #To account for filenames containing ":", we'll clearly need to dynamically
    #create a glob first matching the desired filename (with glob characters
    #escaped, of course), followed by a colon, and so on. Certainly doable, but
    #somewhat annoying.

    # Defer to "file". (Oh, how we obsequiously bow before thy magnanimity.)
    media_type__sstfmt="$(command file\
        --brief --mime-type -- "${filename__sstfmt}")"
    # :output_string_to_stderr "media type for \"${filename}\": ${media_type}"

    # Alas, "file" is perhaps not as rigorously tested as expected. "file" 5.12,
    # for example, behaves as follows:
    #
    #    # The following output isn't simply mistaken. It's fatally wrong. Why?
    #    # Such output fails to conform to valid media type syntax, thus
    #    # breaking functionality elsewhere expecting valid syntax.
    #    >>> command file --brief --mime-type -- /bin/busybox
    #    application/x-executableapplication/octet-stream
    #
    # Since such issues are likely to be subsequently fixed, we refuse to invest
    # any effort in doing so. Since such issues nonetheless exist *AND* since
    # this function is transitively depended on by core functionality elsewhere
    # (e.g., is_binary_executable()), we should at least attempt to detect such
    # issues and notify the user accordingly.
    :is_media_type "${media_type__sstfmt}" or :die\
        "File \"${filename__sstfmt}\" media type \"${media_type__sstfmt}\" invalid. Command \"file\" appears to be broken; consider downgrading to a prior version."

    # Get such type.
    :string.set "${string_name__sstfmt}" "${media_type__sstfmt}"
}

# ....................{ PRINTERS                           }....................
declare_function_with_stdin <<'/---'
str :print_aliases_suffix_from_mailcap()

Print a human-readable synopsis of all *media type-specific suffix aliases*
(i.e., suffix aliases previously defined by setup_mimetype_aliases()).
/---
function :print_aliases_suffix_from_mailcap() {
    # See define_aliases_suffix_from_mailcap:() for further details.
    die_if_args
    run_code_paged run_code_under_zsh_defaults zsh-mime-setup -l
}

# ....................{ PRECOMPILERS                       }....................
#FIXME: Temporarily disabled. See the head of this file for commentary.
# :run_hook_on_zeshy_precompile :precompile_zeshy_aliases_suffix_from_mailcap

declare_function_with_stdin <<'/---'
void :precompile_zeshy_aliases_suffix_from_mailcap()

Define one suffix alias for each media type mapped by system-wide and user-
specific `mailcap` files. See define_aliases_suffix_from_mailcap:() for further details.
/---
function :precompile_zeshy_aliases_suffix_from_mailcap() {
    # Validate sanity.
    die_if_args
    :list mailcap_filenames

    # System-wide and user-specific mailcap files mapping MIME types to the
    # application handling files of such type.
    mailcap_filenames=( '/etc/mailcap' "${HOME}/.mailcap" )

    # If any such files exist, define mimetype aliases from such file(s).
    # Prevent runnables such function temporarily defines from polluting the
    # current namespace and hence being compiled into the digest file.
    if { :is_file_1_or_more "${mailcap_filenames[@]}" } {
        :define_aliases_suffix_from_mailcap
    }

    # Add such files to the list of paths the digest file depends on.
    add_zeshy_digest_dependency_path "${mailcap_filenames[@]}"
}

declare_function_with_stdin <<'/---'
void :define_aliases_suffix_from_mailcap()

Define one suffix alias for each mimetype mapping listed in the system-wide and
user-specific "mailcap" files. Such aliases associate filename suffixes with the
command handling such files, enabling BSD-style file handling: e.g.,

.:define_aliases_suffix_from_mailcap()
==========================================
[source]
------------------------------------------
# Run files to open files. What could be simpler? Assuming installation of
# PDF readers and mimetype mapping associating the PDF mimetype with some
# PDF reader, running PDF files now opens such files in such reader.
>>> define_aliases_suffix_from_mailcap:
>>> ./Devour_All_the_Living_Things.pdf
------------------------------------------
==========================================
/---
function :define_aliases_suffix_from_mailcap() {
    # Validate sanity.
    die_if_args

    # Define such aliases by autoloading non-zeshy zsh functions
    # zsh-mime-setup() and zsh-mime-handler() and then calling the former,
    # which internally calls the latter. For safety, do so in a manner:
    #
    # * Preventing non-suffix aliases and functions such functions temporarily
    #   define from polluting the current namespace and hence being compiled
    #   into the current digest file.
    # * Under zsh emulation and hence default zsh options and traps.
    run_code_and_undefine_runnables_defined_except_alias_suffixes\
    run_code_under_zsh_defaults\
       ':autoload_function_zsh zsh-mime-setup zsh-mime-handler
        zsh-mime-setup -f'
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Interesting. The fact that the second but not first line below works
    #implies we need to convert :autoload_function_zsh() into an alias --
    #ideally, one accepting multiple arguments. But we don't support that at the
    #moment, so just hack :autoload_function_zsh() into an alias accepting only
    #one argument via the traditional here-string mechanism. Then expand such
    #alias like so:
    #
    #    :autoload_function_zsh zsh-mime-setup
    #    :autoload_function_zsh zsh-mime-handler
    #
    #Done!
    #FUXME: Wait. Actually, the emulation :autoload_function_zsh() currently
    #performs is *POINTLESS*. Revert its implementation to simply:
    #
    #    autoload -Uz -- ${@}
    #
    #And note why: namely, emulate() prohibits passing both options -L and -c,
    #implying we can't properly emulate zsh functions *AND* enable sticky
    #functionality. Hence, even autoloaded zsh functions must be explicitly
    #wrapped with run_code_under_zsh_defaults().

    # Autoload such function and functions such function transitively calls.
    # While zeshy autoloads such functions on startup, zeshy calls this function
    # during precompilation before startup.
    # :autoload_function_zsh zsh-mime-setup zsh-mime-handler
    # emulate -R zsh -c "autoload -Uz -- zsh-mime-setup zsh-mime-handler"

    # #FUXME: :autoload_function_zsh() *SHOULD* now perform sufficient zsh
    # #emulation that we no longer need to wrap zsh autoloads with
    # #run_code_under_zsh_defaults(). Test this, of course. If working, excise the
    # #call to run_code_under_zsh_defaults() below.
    # #FUXME: run_code_and_undefine_runnables_defined_except_alias_suffixes()
    # #is a pretty terrible function name, it must be admitted. How about...
    # #run_code_and_undefine_new_runnables_sans_alias_suffixes()? Slightly better,
    # #anyway.

    # # Define such aliases. (While such function does initially call emulate(),
    # # such call fails to revert traps and hence remains unsafe.)
    # #
    # # Prevent runnables such function temporarily defines from polluting the
    # # current namespace and hence being compiled into the current digest file.
    # run_code_and_undefine_runnables_defined_except_alias_suffixes\
    # run_code_under_zsh_defaults\
    #     zsh-mime-setup -f

    # #FUXME: Actually, it'd be both safer and simpler to redefine this entire
    # #function as follows:
    # #
    # #    function :define_aliases_suffix_from_mailcap() {
    # #        # Validate sanity.
    # #        die_if_args
    # #        run_code_and_undefine_runnables_defined_except_alias_suffixes\
    # #        run_code_under_zsh_defaults\
    # #           ':autoload_function_zsh zsh-mime-setup zsh-mime-handler
    # #            zsh-mime-setup -f'
    # #    }
    # #
    # #Nice!

    # # For the same reason, undefine functions autoloaded above.
    # :undefine_func zsh-mime-setup zsh-mime-handler

    # calling non-zeshy autoloadable zsh function
    # zsh-mime-setup(), which internally assumes the similar zsh function.
    # zsh-mime-handler() to also have been .
    #
    # (While such function does initially call emulate(),
    # such call fails to revert traps and hence remains unsafe.)
    #
    # Prevent runnables such function temporarily defines from polluting the
    # current namespace and hence being compiled into the current digest file.

    # # Validate sanity. Since "file" successfully outputs media type
    # # "inode/directory" for directories (rather than failing with nonzero exit
    # # status), throw an exception if such path is not a file.
    # die_unless_arg 'Expected one filename.'
    # :string filename="${1}" media_type
    # die_unless_file "${filename}"

    # #FUXME: GNU-specific. Unfortunately, there exists no short option for
    # #"--mime-type". How do the BSDs handle this? Ah, I see; "--mime-type" parses
    # #the desired substring from "-i" (i.e., "--mime"), which should certainly
    # #exist on BSDs. We'll have to do some heavier lifting to generalize this,
    # #but it certainly seems doable: parse "-i" output ourselves!
    # #FUXME: O.K.; the output for file "/etc/issue" resembles:
    # #    /etc/issue: text/plain; charset=us-ascii
    # #To account for filenames containing ":", we'll clearly need to dynamically
    # #create a glob first matching the desired filename (with glob characters
    # #escaped, of course), followed by a colon, and so on. Certainly doable, but
    # #somewhat annoying.

    # # Defer to "file". (Oh, how we obsequiously bow before thy magnanimity.)
    # media_type="$(command file --brief --mime-type -- "${filename}")"
    # # :output_string_to_stderr "media type for \"${filename}\": ${media_type}"

    # # Alas, "file" is perhaps not as rigorously tested as expected. "file" 5.12,
    # # for example, behaves as follows:
    # #
    # #    # The following output isn't simply mistaken. It's fatally wrong. Why?
    # #    # Such output fails to conform to valid media type syntax, thus
    # #    # breaking functionality elsewhere expecting valid syntax.
    # #    >>> command file --brief --mime-type -- /bin/busybox
    # #    application/x-executableapplication/octet-stream
    # #
    # # Since such issues are likely to be subsequently fixed, we refuse to invest
    # # any effort in doing so. Since such issues nonetheless exist *AND* since
    # # this function is transitively depended on by core functionality elsewhere
    # # (e.g., is_binary_executable()), we should at least attempt to detect such
    # # issues and notify the user accordingly.
    # :is_media_type "${media_type}" or :die\
    #     "Media type \"${media_type}\" invalid for file \"${filename}\". Your installation of command \"file\" appears to be broken; consider downgrading to a prior version."

    # # Get such type.
    # :string.output "${media_type}"

# passed files). Such pathable media action. Such action must be a command in the current user's ${PATH}
# selected from the following list:

#FUXME: MIME types are now officially referred to as "media types," which
#certainly seems more human-readable. Contemplate renaming this component and
#corresponding functions below.

    # On digest compilation, Zeshy
    # parses such files to define suffix aliases for such MIME types. See
    # precompile_zeshy_mimetype_aliases() for further details.

# Such function assumes default shell options and
    # hence *CANNOT* be run under Zeshy shell options.
#FUXME: Defining such aliases at precompilation rather than startup time
#surprisingly *SIGNIFICANTLY* decreases performance -- by as much as several
#seconds on both digest compilation and subsequent startup! That's a bit crazy.
#Investigate when time affords. For the meanwhile, we revert to startup-based
#alias definition.
#FUXME: Ah; I think I've nailed it. Note, however, that the prior implementation
#under "WASTELANDS" failed to properly undefine functions *INTERNALLY* defined
#by such scripts. So, how do we do that? I reckon we want a new run_code_*()
#function -- say, run_code_and_:undefine_funcs_defined(). Naturally, such
#function should run the passed command and then undefine all new functions
#defined by such command. Not terribly difficult, using an approach similar to
#that of "src/compile".

    #FUXME: Not the most granular of exception messages, obviously. To improve
    #output, I suspect we'll probably have to reimplement "zsh-mime-setup" in
    #pure Zeshy, at some lamentable future point.
    # If such definition failed, throw an exception.
#   run_code_silent_stdout :print_aliases_suffix_from_mailcap or
#       :die 'mimetype aliases not defined'

    #FUXME: Honestly, this is a bit odd. It works, but both the nomenclature and
    #underlying implementation just don't fit here. "zsh-mime-setup" is a zsh
    #script, yes; but at this point of Zeshy startup, zsh-mime-setup() has
    #already been autoloaded. Hence, it's much more straightforward simply to
    #call zsh-mime-setup(). The issue with that, of course, is that such
    #function assumes stock zsh options. Hence, what we *REALLY* want is a new
    #Zeshy function for calling non-Zeshy zsh functions under emulation: say,
    #run_code_with_default_zsh_options(). Ah, but that's not quite right.
    #Emulation doesn't *JUST* revert to default options; it also temporarily
    #unsets TRAPZERR(). How about run_code_under_zsh_emulation()? That
    #nicely coincides with the existing run_code_under_shell(). Ah; right.
    #Then let's go with run_code_under_shell_zsh().
#   :source_script_defining_function zsh-mime-setup -f

    #FUXME: How does run_code_paged() find "zsh-mime-setup", and couldn't we
    #implement a similar solution below?
#:run_hook_on_zeshy_precompile precompile_zeshy_mimetype_aliases

#declare_function '
#void precompile_zeshy_mimetype_aliases()
#
#Define one suffix alias for each mimetype mapping listed in the system-wide and
#user-specific "mailcap" files. See define_aliases_suffix_from_mailcap:() for further details.
#'
#function precompile_zeshy_mimetype_aliases() {
#    # Validate sanity.
#    die_if_args
#
#    # If either the system-wide or user-specific "mailcap" file exists and is
#    # non-empty, try to define mimetype aliases using such file(s).
#    { is_file_nonempty '/etc/mailcap' or
#      is_file_nonempty "${HOME}/.mailcap" } and {
#        # Autoload the underlying functions such function calls. While Zeshy
#        # autoloads such functions on startup, Zeshy performs precompilation
#        # before startup.
#        autoload_function zsh-mime-setup zsh-mime-handler
#
#        # Define such aliases.
#        define_aliases_suffix_from_mailcap:
#
#        # Avoid compiling autoloaded functions into Zeshy's user digest.
#        :undefine_func zsh-mime-setup zsh-mime-handler
#    }
#}

    # Else, print a non-fatal warning.
#   else print_warning 'no mimetype aliases defined: "~/.mailcap" and "/etc/mailcap" 0-byte or not found'
#   fi

#   :source_script_defining_function zsh-mime-setup -f
    #FUXME: Revert back to the prior method of:
    #
    #   run_code_silent_stdout :print_aliases_suffix_from_mailcap or {
    #
    #But replace run_code_silent() with an equivalent function
    #squelching *ONLY* stdout. We need to print stderr, for obvious reasons.

    # If either the system-wide or user-specific "mailcap" file exists and is
    # non-empty, define mimetype aliases from such file(s).
#   if is_file_nonempty "${HOME}/.mailcap" or is_file_nonempty '/etc/mailcap'
#   then define_aliases_suffix_from_mailcap:
    # Else, print a non-fatal warning.
#   else print_warning 'no mimetype aliases defined: "~/.mailcap" and "/etc/mailcap" empty or not found'
#   fi

#FUXME: *YE GODS*! This should absolutely be done at precompile time instead.
#Note this implies we should add tests for both "~/.mailcap" and "/etc/mailcap"
#to :digest_zeshy.is_outdated(), which shouldn't be too cumbersome.
# run_hook_on_zeshy_startup_if_interactive startup_zeshy_mimetype_aliases
#   if :is_file "${HOME}/.mailcap" and is_file_nonempty "${HOME}/.mailcap" or
#      :is_file '/etc/mailcap'     and is_file_nonempty '/etc/mailcap'
    # If no such aliases were defined, print an error.
#   run_code_silent :print_aliases_suffix_from_mailcap or {
#       string message_prefix='no mimetype aliases defined: "~/.mailcap" and "/etc/mailcap"'

#       if :is_file "${HOME}/.mailcap" or :is_file '/etc/mailcap'
#       then print_warning "${message_prefix} empty"
#       else print_warning "${message_prefix} not found"
#       fi

#       # Technically, :print_aliases_suffix_from_mailcap() failing does not necessary imply
#       # no mimetype aliases to be defined. run_code_paged() may, for
#       # example, be subject to an internal bug. To ascertain which, run
#       # :print_aliases_suffix_from_mailcap() again, loudly.
#       print_warning ":print_aliases_suffix_from_mailcap() output:"
#       :print_aliases_suffix_from_mailcap
#   }

# This is helpful only from non-
# interactive scripts, since from interactive shells one opens a filename by
# simply typing the filename.
#alias_cli_abbreviation {e}ditfile='edit_file'
#alias_cli_abbreviation {v}iewfile='view_file'

    #FUXME: Unhelpful, I suspect.
    # Set default mailcap and mimetype paths prior to installing suffix aliases
    # dependent on these paths.
#   zstyle :mime: mailcap    ~/.mailcap    /etc/mailcap
#   zstyle :mime: mime-types ~/.mime.types /etc/mime.types

    # Emit a message corresponding to whether or not we've already installed
    # aliases with a prior call to this function.
#   if is "$(mimetype_aliases_list)"
#   then print_message 'reinstalling mimetype aliases...'
#   else print_message   'installing mimetype aliases...'
#   fi

# ....................{ MAIN                               }....................
# Automatically install mimetype aliases, as this is *ALWAYS* generally helpful.
#mimetype_aliases_init
