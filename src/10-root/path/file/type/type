#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *filetypes* (i.e., `.`-prefixed filename suffixes).
/---

# ....................{ EXCEPTIONS                         }....................
:func.doc <<'/---'
void :die_unless_file_type_equals(
    string pathname,
    string filetype,
    string error_message = "File \"${pathname}\" not of type \"${filetype}\".")

Throw an exception with the passed message unless the passed filename has the
passed filetype. See :is_file_type_equals() for further details.
/---
function :die_unless_file_type_equals() {
    die_unless_args_2_to_3\
        'Expected one pathname, one filetype, and optional error message.'
    string pathname="${1}" filetype="${2}"
    :is_file_type_equals "${pathname}" "${filetype}" or :die\
        "${3-File \"${pathname}\" not of type \"${filetype}\".}"
}

# ....................{ TESTERS                            }....................
:func.doc <<'/---'
[status: bool] :is_file_type_equals(string filename, string filetype)

Report success if the passed filename has the passed filetype: e.g.,

.:is_file_type_equals()
==========================================
[source]
------------------------------------------
>>> string on_status_quos=\
...    "At issue is not whether the global economy will pass away. It is
...     passing away. Rising populations and debt combined with depletion of
...     freshwater sources and fossil fuel make the status quo untenable. The
...     only question is whether civil society will survive the transition. Can
...     we use the darknet to preserve representative democracy, or will we seek
...     protection from brutal strong-men as the old order begins to fail?"
>>> :is_file_type_equals "saverin.in" "out" or get_string_line "${on_status_quos}" -1
protection from brutal strong-men as the old order begins to fail?
------------------------------------------
==========================================
/---
function :is_file_type_equals() {
    # Validate sanity.
    die_unless_args_2 'Expected one filename and one filetype.'
    string filename="${1}" filetype_test="${2}" filetype_true

    #FIXME: For efficiency, switch to calling
    #:set_string_to_file_type_if_found() instead.

    # Test such filetype.
    filetype_true="$(get_file_type_if_found "${filename}")" and
        is "${filetype_test}" == "${filetype_true}" si
}

# ....................{ GETTERS                            }....................
:func.doc <<'/---'
string get_file_type(string filename)

Get the passed filename's filetype. If such filename has no filetype, an
exception is thrown. See :set_string_to_file_type_if_found() for further
details: e.g.,

.get_file_type()
==========================================
[source]
------------------------------------------
>>> get_file_type "hastur.tar.gz"
tar.gz
>>> get_file_type "pasteur.ar.gz"
gz
------------------------------------------
==========================================
/---
function get_file_type() {
    die_unless_arg 'Expected one filename.'
    :str filetype
    :set_string_to_file_type filetype "${1}"
    :str.output "${filetype}"
}

:func.doc <<'/---'
[stdout: string, status: bool] get_file_type_if_found(string filename)

Get the passed filename's filetype if such filename has a filetype or report
failure otherwise. See :set_string_to_file_type_if_found() for further details:
e.g.,

.get_file_type_if_found()
==========================================
[source]
------------------------------------------
>>> get_file_type_if_found "a_thing_of_beauty" or :str.output "is a joy"
is a joy
------------------------------------------
==========================================
/---
function get_file_type_if_found() {
    die_unless_arg 'Expected one filename.'
    :str filetype
    :set_string_to_file_type_if_found filetype "${1}" and
        :str.output "${filetype}"
}

# ....................{ GETTERS ~ path                     }....................
:func.doc <<'/---'
string get_path_sans_file_type:(string pathname)

Get the passed pathname excluding `.`-prefixed filetype if such path is suffixed
by such type or such pathname ``as is'' otherwise: e.g.,

.get_path_sans_file_type:()
==========================================
[source]
------------------------------------------
>>> get_path_sans_file_type: "/endymion/hastur.tar.gz"
/endymion/hastur
>>> get_path_sans_file_type: "/hyperion/azazoth"
/hyperion/azazoth
------------------------------------------
==========================================
/---
function get_path_sans_file_type:() {
    # Validate sanity.
    die_unless_arg 'Expected one pathname.'
    string pathname="${1}" filetype

    # If such pathname contains a filetype, remove such filetype. See
    # remove_string_suffix() for further details.
    if { filetype="$(get_file_type_if_found "${pathname}")" } {
        :str.output "${pathname%.${filetype}}"
    # Else, return such pathname as is.
    } else {
        :str.output "${pathname}"
    }
}

# ....................{ SETTERS                            }....................
#FIXME: Add examples.
:func.doc <<'/---'
void :set_string_to_file_type(string string_name, string filename)

Set the passed string to the passed filename's filetype. If such filename has no
filetype, an exception is thrown. See :set_string_to_file_type_if_found() for
further details.
/---
function :set_string_to_file_type() {
    :set_string_to_file_type_if_found "${@}" or {
        :str filename="${2}"
        :die "File \"${filename}\" has no filetype."
    }
}

:func.doc <<'/---'
[status: bool] :set_string_to_file_type_if_found(
    string string_name, string filename)

Set the passed string to the passed filename's *filetype* (i.e., `.`-prefixed
suffix of such filename excluding such `.`) if such filename has a filetype or
report false otherwise.

== Multipart Filetypes ==

This function supports *multipart filetypes* (i.e., filetypes containing at
least one `.`), of which the most common example are two-part `tar` filetypes
(e.g., `tar.bz2`). For such filenames, such string will be set to `tar` followed
by such filename's rightmost `.`-delimited suffix. For all other filenames, such
string will merely be set to such filename's rightmost `.`-delimited suffix.
/---
function :set_string_to_file_type_if_found() {
    # Validate sanity.
    die_unless_args_2 'Expected one string name and one filename.'
    string string_name__sstftif="${1}" filename__sstftif="${2}"

    # If such path's basename has a filetype, set such string to such filetype.
    is "$(get_path_basename "${filename}")" == *'.'(#b)(('tar.'|)[^.]##) si and
        :Str.set string_name__sstftif "${match[1]}"
}

# --------------------( WASTELANDS                         )--------------------
# function get_file_type() {
#     # Validate sanity.
#     die_unless_arg 'Expected one filename.'
#     string filename="${1}"
# 
#     # Get such file type if found or throw an exception.
#     get_file_type_if_found "${filename}" or
#         :die "File \"${filename}\" has no filetype."
# }

# function get_file_type_if_found() {
#     # Validate sanity.
#     die_unless_arg 'Expected one filename.'
#     string filename="${1}"
# 
#     # Match the passed filename's filetype, discarding leading ".".
#     is "$(get_path_basename "${filename}")" == *'.'(#b)(('tar.')|)[^.]## si and
#         :str.output "${match[1]}"
# }

#. If such filename has no filetype,
#this is the filename itself

#   filetype="$(get_file_type_if_found "${filename}")" or
#       :die "\"${filename}\" has no filetype"
#   :str.return "${filetype}"
#>>> :is_file_type_equals "saverin.in" "out" or :str.output "Othello says, \"Hi.\""
#Othello says, "Hi."

#. Since this
#function tests only such filename, no such file need actually exist
#FUXME: Rename to get_path_sans_file_type:(). It makes little sense to speak of
#anything but files in regards to file types and, anyway, breaks nomenclature.
