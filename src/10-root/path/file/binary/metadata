#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *binary file metadata* (e.g., author, bitrate, codec, tags).
/---

# ....................{ GLOBALS                            }....................
:map_global ZESHY_FILE_TYPE_TO_FUNCTION_NAME_PRINTING_METADATA <<'/---'
Map from filetype to function printing metadata for files of such filetype.
/---

# ....................{ CACHERS                            }....................
declare_function '
void cache_print_file_metadata_globals()

Initialize globals required by print_file_metadata(). For each external command
called by such function and exposing a runtime option for listing all filetypes
supported by such command (e.g., "ffprobe -formats", listing all FFmpeg-
supported filetypes), parse such filetypes into global map
${ZESHY_FILE_TYPE_TO_FUNCTION_NAME_PRINTING_METADATA}.
'
function cache_print_file_metadata_globals() {
    # Validate sanity.
    die_if_args

    # If Libav and hence "avprobe" is installed, parse such utility's formats.
    is_pathable avprobe :and {
        #FIXME: Recall the first two lines of "avprobe -show_format" output are
        #a useless version string. *CUT*. Since this requires we split such
        #output on newlines and set_list_to_string_column() already does so,
        #perhaps a new set_list_to_lines_column() function is in order.
        #set_list_to_string_column() could defer to set_list_to_lines_column()
        #to do its work. (Yes, I can't see any firm objections to such
        #implementation.)
        ZESHY_FILE_TYPE_TO_FUNCTION_NAME_PRINTING_METADATA
    }
}

# ....................{ PRINTERS                           }....................
declare_function '
string print_file_metadata(string filename1, string filename2, ...)

Print all textual metadata (e.g., author, codec, tags) in the passed files.
'
function print_file_metadata() {
    # Validate passed arguments.
    die_unless_args_1_or_more 'expected at least one filename'

    #FIXME: Actually, page_stdin() no longer blocks on completion. This
    #implementation seems quite unwiedly; can't we simplify a tad?

    # Print such metadata paged, deferring to print_file_metadata_unpaged().
    # Since such printing is computationally expensive and hence unlikely to
    # completely print quickly, paging via run_code_paged() is preferable to paging
    # via page_stdin(). The former prints input responsively, in an on-demand
    # manner; the latter prints input unresponsively, blocking on completion.
    run_code_paged print_file_metadata_unpaged "${(q)@}"
}

declare_function '
string print_file_metadata_unpaged(string filename1, string filename2, ...)

Print all textual metadata (e.g., author, codec) in the passed files without
paging such metadata. This function is only intended to be called by
print_file_metadata().
'
function print_file_metadata_unpaged() {
    # Validate passed arguments.
    die_unless_args_1_or_more 'expected at least one filename'

    # If global map ${ZESHY_FILE_TYPE_TO_FUNCTION_NAME_PRINTING_METADATA} has
    # not already been initialized, do so.
    is_map_nonempty ZESHY_FILE_TYPE_TO_FUNCTION_NAME_PRINTING_METADATA or
        cache_print_file_metadata_globals

    # Synopsize such metadata before printing detailed metadata for such files.
    is_installed file and {
        print_message_heading "synopsis"
        print_file_metadata_synopsis "${@}"
    }

    # Print detailed metadata for each such file, if possible.
    string function_name
    for filename ("${@}") {
        # If some function prints metadata for such file, do so. Else, silently
        # ignore such file. (Hopefully the above synopsis described such file!)
        :map.is_key\
           ZESHY_FILE_TYPE_TO_FUNCTION_NAME_PRINTING_METADATA "${filetype}" and {
            print_message_heading "\"${filename}\""
            "${ZESHY_FILE_TYPE_TO_FUNCTION_NAME_PRINTING_METADATA["${filetype}"]}"\
                "${filename}"
        }
    }
}

#FIXME: Rename to print_file_synopsis() and shift out of this component.
declare_function '
string print_file_metadata_synopsis(string filename1, string filename2, ...)

Print a human-readable synopsis of all textual metadata (e.g., author, codec)
in the passed files by running "file", a commonly available external command
tabulating metadata output into multiple columns when passed multiple files.
Such output aptly, if imperfectly, synopsizes a multitude of common formats.
'
function print_file_metadata_synopsis() {
    # Validate passed arguments.
    die_unless_args_1_or_more 'expected at least one filename'
    die_unless_pathable file

    # Print such synopsis.
    run_code_with_options_configured 'run_code_paged command file'\
        'ZESHY_OPTIONS_FILE ZESHY_OPTIONS_FILE_IF_PRINTING_METADATA_SYNOPSIS'\
        -- "${(q)@}"
}

# ....................{ PRINTERS ~ audio                   }....................
declare_function '
string print_file_metadata_mp3(string filename)

Print all textual metadata in the passed MP3 compressed audio file.
'
function print_file_metadata_mp3() {
    # Validate passed arguments.
    die_unless_arg 'expected one filename'
    string filename="${1}"
    :die_unless_file_type_equals "${filename}" 'mp3'

    #FIXME: "ffprobe" supports nearly every conceivable media format, as
    #verified by running "ffprobe -formats", which lists all recognized file
    #types. Great idea: dynamically parse such list and, for each printed file
    #type, associate such filetype with a function using ffprobe to print such
    #metadata. This suggests a rather different structure to this component,
    #reverting back to the prior map style. While seemingly cumbersome, using
    #maps is *MONSTROUSLY* more convenient than this overly verbose one-function-
    #per-file-type structure. So... yeah. Back we go, into the breach!
    #FIXME: Other tools to support:
    #
    #* "avprobe". Basically identical to "ffprobe", for obvious reasons. Note
    #  "avprobe" takes *HIGHER* precedence over "ffprobe", again for obvious
    #  reasons.
    #* "exiftool". (Very popular; very stable. Try out and install to see what
    #  formats it supports and whether its output is preferable to that of
    #  "ffprobe". Despite the name, "exiftool" works on most metadata formats --
    #  not just EXIF. Hmm; you know, it might be helpful to print out *BOTH*
    #  "avprobe" and "exiftool" output; I suspect the two to be complimentary.)
    #* "mediainfo". (Gentoo has it. I wasn't terribly impressed with the
    #  website, but strongly suspect that to be *VERY* out-of-date by now. Heck,
    #  it beats nothing; and if that's all the user has installed, that's what
    #  we use, right?)
    #* "mp3info". (Again, a bit old and no longer updated, but pretty much
    #  *EVERYONE* still uses it for rudimentary ID3 tag printing. Awesome!)
    #* "identify". (ImageMagick. Not for audio files, obviously, but great
    #  nonetheless. Listed here to avoid neglecting it. :))
    #
    #O.K.; that's basically it. The above list gleaned after two hours of
    #furious googling, basically. While there probably do technically exist
    #other audio file describers, they're probably not worth uncovering at this
    #early stage of things.
    #FIXME: The first two lines of "avprobe -show_format" output are a useless
    #version string. *CUT*.

    # Prefer FFmpeg's "ffprobe" utility, if installed.
    if is_pathable ffprobe
    then ffprobe -show_format "${filename}"
    fi
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Generalize to accept multiple filenames, particularly helpful for
#running interactively as "pfm *".
    #FUXME: Extract into a new print_file_metadata_fallback() function calling
    #run_code_with_options_configured() with a new
    #"ZESHY_OPTIONS_FILE_IF_PRINTING_METADATA_SYNOPSIS" list in "if_config/posix".
        # If some function prints metadata for files of such file's filetype, do so.
#       function_name="print_file_metadata_$(get_file_type "${filename}")"
#       :func.is "${function_name}" and {
#           say_next_section "\"${filename}\" metadata"
#           "${function_name}" "${filename}"
#       }

    # for each such file. External command "file" tabulates output into multiple
    # columns when passed multiple files. Such output aptly, if imperfectly,
    # synopsizes metadata for a multitude of common formats.
#       die_unless_file_binary "${filename}"

#       # Set the function name printing metadata for files of such file's filetype.
#       filetype="$(get_file_type "${filename}")"
#       function_name="print_file_metadata_${filetype}"

#       # If some function prints metadata for files of such file's filetype, do so.
#       print_message "printing \"${filename}\" metadata..."
#       if :func.is "${function_name}"
#       then "${function_name}" "${filename}"
#       # Else, attempt to print such metadata by running pathable "file" as a
#       # fallback. While imperfect, "file" often prints surprisingly accurate
#       # metadata.
#       else file --dereference "${filename}"
#       fi

#FUXME: This is more general than media. Frankly, this is going to eventually be
#an *INSANELY* enormous function using a conventional "case" approach. Switch to
#a proper map from filetype to function printing all metadata for such filetype.
#If no such function exists, print a warning and default to running "file".
    # If some function prints metadata for files of such file's filetype, do so.
#   if :map.is_key\
#          ZESHY_FILETYPE_TO_FUNCTION_NAME_PRINT_METADATA "${filetype}"; then
#       "${ZESHY_FILETYPE_TO_FUNCTION_NAME_PRINT_METADATA["${filetype}"]}"\
#           "${filename}"
    # Else, default to pathable "file".

# ....................{ GLOBALS                            }....................
#FUXME: Overly heavyweight, actually. Instead, simply call the expected function
#dynamically. If we ever subsequently desire, such a map approach can easily be
#bolted on dynamic function calling (e.g., if such function does not exist).
#declare_global '
#map ZESHY_FILE_TYPE_TO_FUNCTION_NAME_PRINTING_METADATA
#
#Map from filetype to function printing metadata for files of such filetype.
#'
#ZESHY_FILE_TYPE_TO_FUNCTION_NAME_PRINTING_METADATA=(
#    'mp3' print_file_metadata_mp3
#)

#ZESHY_METADATA_FILETYPE_TO_FUNCTION_NAME_PRINT_METADATA
