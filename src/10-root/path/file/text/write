#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *text writers* (i.e., functions either writing or appending to file
contents).
/---

# ....................{ WRITERS                            }....................
:func.doc <<'/---'
void write_file_with_string(string filename, string text)

Overwrite the contents of the passed text file with the passed string if such
file exists or create a new file containing such string otherwise. Since this
function does _not_ interactively confirm such append, call this function only
where guaranteed to be non-destructive.
/---
function write_file_with_string() {
    # Validate sanity.
    die_unless_args_2 'Expected one string and one filename.'
    :str filename="${1}"

    # If such file's parent directory does *NOT* exist, make such directory.
    :make_dir_parent_if_not_found "${filename}"

    # Write such string to such file. zeshy disables zsh option "clobber", thus
    # requiring operator ">!" to force truncation of such file if nonzero.
    :str.output "${2}" >!"${filename}"
}

:func.doc <<'/---'
void append_file_with_string(string filename, string text)

Append the passed string to the contents of the passed text file if such file
exists or create a new file containing such string otherwise. Since this
function does _not_ interactively confirm such append, call this function only
where guaranteed to be non-destructive.
/---
function append_file_with_string() {
    # Validate sanity.
    die_unless_args_2 'Expected one string and one filename.'
    :str filename="${1}"

    # If such file's parent directory does *NOT* exist, make such directory.
    :make_dir_parent_if_not_found "${filename}"

    # Append such string to such file. zeshy disables zsh option "clobber", thus
    # requiring operator ">>!" to force truncation of such file if nonzero.
    :str.output "${2}" >>!"${filename}"
}

# ....................{ WRITERS ~ var                      }....................
:func.doc <<'/---'
void :write_script_with_var_binding(
    string filename,
    string var_name1, ...)

Overwrite the passed file with *bindings* for the passed variables (i.e.,
exactly one or two `zsh` commands declaring _and_ defining each such variable).
Such file will be prefixed by the `zsh` shebang line specific to the current
system (e.g., `#!/usr/bin/env zsh`) _and_ contain only low-level commands valid
under both `zsh` and `zeshy`; hence, such file will be a sourceable `zsh` _and_
`zeshy` script.

== Binding Deserialization ==

Consider calling :source_script() to *deserialize* such bindings (i.e., reverse
the serialization this function performs, by running such script and importing
the variables such script declares and defines back into the current shell).
/---
function :write_script_with_var_binding() {
    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected one filename and one or more variable names.'
    :str filename="${1}" zsh_shebang_line var_bindings
    shift_arg

    # Shebang line prefixing zsh scripts for the current system.
    :set_string_to_zsh_shebang_line zsh_shebang_line

    # Such variable bindings.
    :Var.Binding "${@}" var_bindings

    # Write such shebang and bindings to such script.
    write_file_with_string\
        "${filename}"\
        "${zsh_shebang_line}${ZESHY_ASCII_NEWLINE}${var_bindings}"
}

:func.doc <<'/---'
void :append_script_with_var_binding(
    string filename,
    string var_name1, ...)

Append the contents of the passed `zsh` script with bindings for the passed
variables. See :write_script_with_var_binding() for further details.
/---
function :append_script_with_var_binding() {
    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected one filename and one or more variable names.'
    :str filename="${1}"
    shift_arg

    # If such script already exists, append such bindings.
    if { :is_file "${filename}" } {
        # Get such bindings.
        :str var_bindings
        :Var.Binding "${@}" var_bindings

        # Append such bindings.
        append_file_with_string "${filename}" "${var_bindings}"
    # Else, such file does not exist. Call :write_script_with_var_binding() to prefix
    # the contents of such file with a shebang line.
    } else {
        :write_script_with_var_binding "${filename}" "${@}"
    }
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Actually, we should just be calling write_file_with_string() here.
#(Likewise, in the appender function below.) To do so reasonably, however,
#we'll have to first refactor get_variable_binding() into a setter.

        # Print such variables' bindings (i.e., declarations and definitions).
        # Avoid operator ">>!" here; such operator creates such file if not
        # already extant, which in this case would create a shell script *NOT*
        # prefixed with a shebang line. Using operator ">>" instead ensures an
        # exception will be thrown in the unlikely event such file is moved or
        # removed in between the prior conditional succeeding and this command
        # running.
        # get_variable_binding "${@}" >> "${filename}"

    # If such file's parent directory does *NOT* exist, make such directory.
    # :make_dir_parent_if_not_found "${filename}"

    # Overwrite such file. Dismantled, this is:
    #
    # * ">!", forcefully overwriting such file if already extant.
    # {
    #     # For safety, prefix such script with the canonical zsh shebang line.
    #     get_zsh_shebang_line

    #     # Print such variables' bindings (i.e., declarations and definitions).
    #     get_variable_binding "${@}"
    # } >! "${filename}"

    # For safety, prefix such script with the canonical zsh shebang line.
# Consider calling :source_script() to deserialize the bindings previously
# such script back into such variables.
