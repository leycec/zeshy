#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *text files* (i.e., non-binary files).
/---

#FIXME: When printing text files to a terminal, perform syntax highlighting of
#source files. Calling :get_file_media_type() should efficiently suffice to decide
#this. There exist any number of source code highlighters; the three most
#popular as of this date are:
#
#* GNU source-highlighter (https://www.gnu.org/software/src-highlite).
#* Highlight (http://www.andre-simon.de/doku/highlight/en/langs.html).
#* Pygments (http://pygments.org/languages).
#
#Ideally, I'd like to default to Pygments if available. In practice, we should
#probably default to the highlighter that provides a command line option for
#either listing supported languages and/or filetypes *OR* for testing whether it
#supports the passed file(s).
#
#Happily, a helpful blog post has already been authored on how to robustly
#replace "cat" and "less" with zsh-specific Pygmentized versions. See:
#    http://www.jonathangross.de/2012/08/13/adding-a-little-color-to-your-command-line-life

# ....................{ EXCEPTIONS                         }....................
:func.doc <<'/---'
void die_unless_file_text(
    string filename,
    string error_message = "\"${filename}\" not a text file.")

Throw an exception with the passed message unless the passed text file exists.
See is_file_text() for further details.
/---
function die_unless_file_text() {
    die_unless_args_1_to_2\
        'Expected one pathname and optional error message.'
    string filename="${1}"
    is_file_text "${filename}" or :die "${2:-\"${filename}\" not a text file.}"
}

:func.doc <<'/---'
void die_unless_files_text(string filename1, string filename2, ...)

Throw an exception with a stock message unless all passed text files exist.
/---
function die_unless_files_text() {
    die_unless_args 'Expected one or more filenames.'
    string filename
    for    filename ("${@}") {
        die_unless_file_text "${filename}"
    }
}

# ....................{ TESTERS                            }....................
:func.doc <<'/---'
[status: boolean] is_file_text(string pathname)

Report success if the passed path is an existing *text file* (i.e., non-binary
file), as decided by dynamically inspecting such file's contents with `file`.

== Symbolic Links ==

Symbolic links are binary files and hence _not_ text files. Although most high-
level commands operating on text files accept text files as text files, low-
level commands (e.g., `zsh` module `mapfile`) do not. For safety, this function
thus complies with the technical definition of symbolic links as non-text files
by returning failure when passed symbolic links. If this is unacceptable,
consider calling die_if_link_symbolic() before calling this function.
/---
function is_file_text() {
    die_unless_arg 'Expected one pathname.'
    string pathname="${1}"
    :is_file "${pathname}" and not is_file_binary "${pathname}"
}

# ....................{ TESTERS ~ text                     }....................
:func.doc <<'/---'
[status: boolean] is_file_text_equals(string filename, string text)

Report success if the passed text file contains only the passed text.
/---
function is_file_text_equals() {
    # Validate sanity.
    die_unless_args_2 'Expected one filename and one string.'
    string filename="${1}" text="${2}"
    die_unless_file_text "${filename}"

    # Test such text.
    is_string_equals "$(get_file_text "${filename}")" "${text}"
}

:func.doc <<'/---'
[status: boolean] is_file_text_contains(string filename, string text)

Report success if the passed text file contains the passed text.
/---
function is_file_text_contains() {
    # Validate sanity.
    die_unless_args_2 'Expected one filename and one string.'
    string filename="${1}" substring="${2}"
    die_unless_file_text "${filename}"

    # Test such text.
    is_string_contains "$(get_file_text "${filename}")" "${substring}"
}

#FIXME: Provide examples.
:func.doc <<'/---'
[status: boolean] is_file_text_matches_pcre_multiline(
    string filename, string pcre)

Report success if the passed text file matches the passed PCRE with multiline
matching enabled.
/---
function is_file_text_matches_pcre_multiline() {
    # Validate sanity.
    die_unless_args_2 'Expected one filename and one PCRE.'
    string filename="${1}" pcre="${2}"
    die_unless_file_text "${filename}"

    # Test such PCRE.
    is_string_matches_pcre_multiline "$(get_file_text "${filename}")" "${pcre}"
}

# ....................{ PRINTERS                           }....................
:func.doc <<'/---'
string print_file_text(string filename1, ...)

Print a human-readable synopsis of the contents of all passed text files.
/---
function print_file_text() {
    #FIXME: This only applies to an eventual :print_file_text_with_options()
    #implementation and hence should be shifted there... when such function
    #exists.

    # If standard input appears to derive from a non-interactive source and
    # hence be readable without blocking, pass such input to "cat" and return.
    if { :is_stdin_noninteractive } {
        die_if_args
        :stdin | command cat | page_stdin
        report_success
    }

    # Validate sanity.
    die_unless_args 'Expected one or more filenames.'

    # Page such file contents. Since "cat" fails to prepend each file's contents
    # with such file's filename, do so by iterating such files (rather than
    # passing all such files to a single "cat" call.) Fix this, scallywag "cat"!
    :str filename
    for     filename ("${@}") {
        print_message_heading '"'${filename}'" Contents'
        command cat -- "${filename}"
    } | page_stdin
}

#FIXME: Rename to print_path_line_count_recursive(), as the implementation
#below demonstrates.
:func.doc <<'/---'
integer get_file_text_line_count_recursive(string path)

Get the total number of lines corresponding to the file(s) in the passed path,
as follows:

* If no path is passed, default to the current directory.
* If this path is a directory, recursively sum the number of lines for files
  in this path ignoring binary files.
* If this path is a file:
** And this file is a PDF, use `pdftotext` to sum the number of text lines in
   the rendered PDF.
** Else, sum the number of lines in this file.
/---
function get_file_text_line_count_recursive() {
    # Validate passed parameters.
    die_unless_args_0_to_1 'Expected optional pathname.'
    string find_path; file_path="${1:-$(get_dir)}"
    integer line_count

    if { is_dir "${find_path}" } {
        print_message_item_interactively\
            "Counting lines for all text files in \"${find_path}\"..."

        #FIXME: This is horrible. Replace dependency on "find" and "wc" with
        #pure homecooked zsh.
        # Recursively find all files *NOT*:
        #
        # * Non-files (e.g., directories, device files).
        # * Dotfiles and dot directories (e.g., ".cvs/", ".git/", ".svn/").
        # * Binary files. We borrow this expression from is_file_text().
        line_count="$(find "${find_path}"\
            -type d -iname '*test*' -prune -o\
            -type f \( ! -regex '.*/\..*' \)\
            $(is_file_text_find_compatible)\
            -exec wc -l {} \; |\
            awk '{ total += \$1 } END { print total }')"
    } elif { :is_file "${find_path}" } {
        print_message_interactively "counting lines for \"${find_path}\"..."

        #FIXME: This is rather shoddy. Generalize to multiple filetypes and
        #functions handling such filetypes as for extract_archive().
        if { :is_file_type_equals "${find_path}" 'pdf' and is_pathable pdftotext } {
            line_count="$(pdftotext "${find_path}" - | wc -l)"
        } else {
            die_unless_file_file "${find_path}"
            line_count="$(wc -l "${find_path}")"
        }
    } else {
        :die "\"${find_path}\" neither a file or directory."
    }

    # Print such count human-readably.
    convert_integer_to_string_localized "${line_count}"
}

# --------------------( WASTELANDS                         )--------------------
        # # When passed one file, "cat" output unambiguously corresponds to such
        # # file. In such a case, "cat" suffices.
        # if { is_arg } {
        #     { command cat -- "${(q)@}"
        # # When passed multiple files, "cat" fails to prepend the output from
        # # each with the corresponding filename. (Fix this, scallywag "cat"!)
        # } else {

#:stdin.is_nonempty
#FUXME: Rename to is_file_text_line_matches_pcre(). No, wait. Rename to
#is_file_text_matches_pcre_multiline() and correct all functions calling this
#function. *sigh*
# If such synopsis exceeds the height, this function pipes such to the current
# pager  or as is (i.e., without paging) otherwise.

#FUXME: If such file is a symbolic link to a text file, make this still work.
#All we have to do is canonicalize its path, as in get_file_text(). Make it so.

#   filename="$(:path.canonicalize "${filename}")"
    # If such path is an existing nonfile and the canonical file to which such path
    # refers is *NOT* binary, return success; else, failure.

#Report success if the passed path is an existing text file _and_ is either a:
#
#* *Text file* (i.e., a non-binary file), as decided by dynamically inspecting
#  the contents of such file with `file`.
#* Symbolic link to a text file. Technically, symbolic links are binary files.
#  Subjectively, however, nearly all commands operating an text files accept
#  symbolic links to text files as text files. Hence, this function does the
#  same. If unacceptable, consider calling die_if_link_symbolic() before calling
#  this function.

    #FUXME: Uhm; we also need to encapsulate "< /dev/stdin" as :stdin().
    #Easy, it's just yet another requirement.
        # Canonicalize such path, thus converting symbolic links in such path
        # into their transitive targets.
#This implements a pure-`zsh` analogue to the GNU-specific `grep --perl-regexp`.
#As the
#function name suggests, this function does _not_ interactively confirm such
#overwriting. Call this function only where guaranteed to be non-destructive.
    #FUXME: Convert to a run_code_with_options()-centric implementation. Or
#   string filename="${1}" text="${2}"
#FUXME: Rename write_file_with_string() to write_file_with_string_text().
#Naturally, reorder arguments as well and apply to appending below. Actually,
#drop the "_text"; obviously, the outcome is a text file. So, just:
#write_file_with_string(). This nicely coincides with other such functions as
#:write_script_with_var_binding() on the one hand and :str.output() on the other.
#Hence, "string" is the dominant object here. Hmm; come to think of it, why not
#print_string_to_file() and :print_var_to_script()? Ah; no. Write and read
#are much better file-oriented verbs here.
#
#tl;dr:
#Rename to write_file_with_string().

#FUXME: Rename to is_file_text_pcre_match_line() or perhaps
#is_file_text_match_line_pcre() or is_file_text_matches_line_pcre(). Ah; we're
#getting closer. We really want the "_line" adjacent to the "_text", however,
#which synchronizes much better with the conception of "line" as a discrete
#component. That then leaves us with is_file_text_matches_pcre_multiline() and a
#corresponding is_file_text_line_match() function. All good, yes? We should
#broadly apply similar fixes elsewhere to "_line" functions: particularly, to
#"variable/string/line".
#
#tl;dr:
#Rename to is_file_text_matches_pcre_multiline().

#FUXME: Rename to is_file_text_equals(), is_file_text_string(), or
#is_file_text_equals(). Hmm; the latter, possibly? This suggests a similar
#is_string_equals(), which makes perfect sense, permitting an implementation
#here resembling:
#       get_file_text "${pathname}" | is_string_equals "${text}"
#       is "$(get_file_text "${pathname}")" == "${text}" si
#Nice!
# or is_file_text_contains(). Yes... yes? Come to think,
#I now prefer (I know, I know...) verbs "equals" and "contains" for such matches
#and nouns "prefix" and "suffix" for such matches. Apply elsewhere, yes?
#run_code_with_stdin_piped
#FUXME: This probably isn't behaving as intended. It *SHOULD* be printing
    #file contents to stderr while concatenating together file contents. In
    #practice, it probably just exhumes an error. Hurk!
#   string output
#   for filename ("${@}") {
#       output+="$(< "${filename}" 1>&1 1>&2)"
#   }
    # Test under the "mapfile" module for efficiency.
#   load_mapfile
#   is ${mapfile[${filename}]} == *"${text}"* si
#   unload_mapfile
#   run_code_with_mapfile: "is \${mapfile[${filename}]} == *""${text}""* si"

#FUXME: It'd be nice to abstract out the load_module/freeze_variable/unload_module
#cruft into a helper function -- say, with_mapfile(): e.g.,
#
#    with_mapfile 'print ${${(f)mapfile[${filename}]}[1]}'

    # Load zsh module "mapfile".
#   load_module zsh/mapfile

    # Forcibly prevent harmful ${mapfile} and hence filesystem changes.
#   freeze_variable mapfile

    # Print the first line of the file with the passed filename.
#   print ${${(f)mapfile[${filename}]}[1]}

    # Unload "mapfile", for safety.
#   unload_module zsh/mapfile
#FUXME: Should be renamed to, say, "get_find_command_file_text_filter()", and
#consequently moved -- ideally, into a new "zeshy/file/find".
# boolean is_file_text_find_compatible()
#
# Return a string which, when passed as argument to a "find" process, filters
# the currently visited filename if the corresponding file is binary. "find"
# itself provides no built-in means of performing such filtering, unfortunately.
#is_file_text_find_compatible() {
#    print "\-exec sh -c 'file --mime-encoding {} | grep --invert-match --quiet \": binary$\"' \\\;"
#}
