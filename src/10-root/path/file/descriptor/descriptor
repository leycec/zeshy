#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *file descriptors* (i.e., nonnegative integers signifying open files
accessible as device files under pseudo-filesystem `/dev/fd`).
/---

# ....................{ EXCEPTIONS                         }....................
:func.document <<'/---'
void die_unless_file_descriptor(
    string file_descriptor_name,
    string error_message = "\"${file_descriptor_name}\" not a file descriptor.")

Throw an exception with the passed message unless the passed file descriptor is
well-formatted. See is_file_descriptor() for further details.
/---
function die_unless_file_descriptor() {
    die_unless_args_1_to_2\
        'Expected one file descriptor name and optional error message.'
    :string file_descriptor_name__dufd="${1}"
    is_file_descriptor "${file_descriptor_name__dufd}" or
        :die "${2-\"${file_descriptor_name__dufd}\" not a file descriptor.}"
}

:func.document <<'/---'
void die_unless_file_descriptor_open(
    string file_descriptor_name,
    string error_message =
        "File descriptor \"${file_descriptor_name}\" not open.")

Throw an exception with the passed message unless the passed file descriptor is
open under the current shell. See is_file_descriptor_open() for further details.
/---
function die_unless_file_descriptor_open() {
    die_unless_args_1_to_2\
        'Expected one file descriptor name and optional error message.'
    :string file_descriptor_name__dufdo="${1}"
    is_file_descriptor_open "${file_descriptor_name__dufdo}" or
        :die "${2-File descriptor \"${file_descriptor_name__dufdo}\" not open.}"
}

:func.document <<'/---'
void die_unless_file_descriptor_open_writable(
    string file_descriptor_name,
    string error_message =
        "File descriptor \"${file_descriptor_name}\" not opened for writing.")

Throw an exception with the passed message unless the passed file descriptor is
open for writing under the current shell. See
is_file_descriptor_open_writable() for further details.
/---
function die_unless_file_descriptor_open_writable() {
    die_unless_args_1_to_2\
        'Expected one file descriptor name and optional error message.'
    :string file_descriptor_name__dufdw="${1}"
    is_file_descriptor_open_writable "${file_descriptor_name__dufdw}" or
        :die "${2-File descriptor \"${file_descriptor_name__dufdw}\" not opened for writing.}"
}

# ....................{ TESTERS                            }....................
:func.document <<'/---'
[status: bool] is_file_descriptor(string file_descriptor_name)

Report success if the passed file descriptor is *well-formatted* (i.e., is a
nonnegative integer), regardless of whether such descriptor is open under the
current shell.
/---
function is_file_descriptor() {
    # File descriptors are internally implemented as non-negative integers.
    die_unless_arg 'Expected one file descriptor name.'
    :string file_descriptor_name__ifd="${1}"
    :is_int_nonnegative "${(P)file_descriptor_name__ifd}"
}

#FIXME: Insufficient. The mere existence of such file descriptor does *NOT*
#imply such descriptor to be open: it merely demonstrates such descriptor to
#exist. Hence, this function should be renamed :is_file_descriptor() and the
#current :is_file_descriptor() renamed to :is_file_descriptor_valid(). Then,
#this function should be reimplemented to actually test whether such descriptor
#is open or not. To do so, we'll probably want to:
#
#* Die if symbolic link "/dev/fd/${(P)file_descriptor_name}" does not exist.
#* Resolve such link to its transitive target by calling
#  :set_string_to_symlink_target_last().
#* If such target matches glob "'pipe:['*']', report success. (No idea how to
#  test whether such pipe actually exists. Oh, right: can't we test
#  ":is -p ${(P)file_descriptor_name} :si" in that case?)
#* Else if such link is broken, report failure.
#
#Not terribly arduous; we just need to get around to it, eh?
#FIXME: Interesting! When run from a cronjob, we get:
#
#    >>> command ls -l /proc/self/fd/0
#    lrwx------ 1 leycec leycec 64 Jan 29 20:56 /proc/self/fd/0 -> /dev/null
#
#So, although standard input is technically always open, it can be effectively
#closed by redirecting it to the bit bucket. What this implies is that, indeed,
#our initial implementation was correct: the mere existence of a file
#descriptor technically implies such descriptor to be open. However, if such
#descriptor symlinks to the canonical bit bucket (e.g., "/dev/null"), such
#descriptor is effectively closed despite technically being open. We need to
#handle such distinction.
#
#See :is_stdin() for painfully similar functionality.
#FIXME: Perform the following nomenclature changes:
#
#* Rename is_file_descriptor_open() to :is_file_descriptor().
#* Rename is_file_descriptor() to :is_file_descriptor_valid().
#* Define a new :is_file_descriptor_open() report success if
#  :is_file_descriptor() with such descriptor succeeds *AND* the transitive
#  target of such descriptor is *NOT* the canonical bit bucket. (Yay!)
#FIXME: Incidentally, *NONE* of these functions comply with zeshy nomenclature.
#Testers and exception handlers should be passed variable values rather than
#names. *Ugh.*

:func.document <<'/---'
[status: bool] is_file_descriptor_open(string file_descriptor_name)

Report success if the passed file descriptor is open under the current shell.
/---
function is_file_descriptor_open() {
    # Validate sanity.
    die_unless_arg 'Expected one file descriptor name.'
    :string file_descriptor_name__ifdo="${1}"
    die_unless_file_descriptor "${file_descriptor_name__ifdo}"

    # Test such descriptor.
    is_path\
        "$(get_file_descriptor_file_device "${file_descriptor_name__ifdo}")"
}

:func.document <<'/---'
[status: bool] is_file_descriptor_open_readable(string file_descriptor_name)

Report success if the passed file descriptor is open for reading under the
current shell.
/---
function is_file_descriptor_open_readable() {
    die_unless_arg 'Expected one file descriptor name.'
    string file_descriptor_name__ifdofr="${1}"
    die_unless_file_descriptor "${file_descriptor_name__ifdofr}"
    is_path_readable\
        "$(get_file_descriptor_file_device "${file_descriptor_name__ifdofr}")"
}

:func.document <<'/---'
[status: bool] is_file_descriptor_open_writable(string file_descriptor_name)

Report success if the passed file descriptor is open for writing under the
current shell.
/---
function is_file_descriptor_open_writable() {
    die_unless_arg 'Expected one file descriptor name.'
    string file_descriptor_name__ifdofw="${1}"
    die_unless_file_descriptor "${file_descriptor_name__ifdofw}"
    is_path_writable\
        "$(get_file_descriptor_file_device "${file_descriptor_name__ifdofw}")"
}

# ....................{ GETTERS                            }....................
:func.document <<'/---'
string get_file_descriptor_file_device(string file_descriptor_name)

Get the absolute path of the device file of the pseudo-filesystem `/dev/fd`
opened for the passed file descriptor under the current shell.
/---
function get_file_descriptor_file_device() {
    # According to section "REDIRECTION" of "man zshmisc", zsh cross-platform-
    # portably treats "/dev/fd/${file_descriptor}" as the underlying platform-
    # specific path. Hence, this should require no platform-specific munging.
    #
    # Technically, we should test whether such descriptor is open under the
    # current shell as well. But doing so would require this function be called
    # under such shell, which getter functions never are. In the interests of
    # caller convenience, assume such descriptor is open. We know; we know.
    die_unless_arg 'Expected one file descriptor name.'
    string file_descriptor_name__gfdd="${1}"
    die_unless_file_descriptor "${file_descriptor_name__gfdd}"

    # Get such path.
    :string.output "/dev/fd/${(P)file_descriptor_name__gfdd}"
}

# ....................{ SETTERS                            }....................
:func.document <<'/---'
void set_string_to_file_descriptor_file(
    string string_name, string file_descriptor_name)

Set the passed string variable to the absolute path of the target file opened
for reading and/or writing by the passed file descriptor under the current
shell. If such descriptor is not open under such shell, an exception is thrown.

== Motivation ==

Since file descriptors are shell-specific _and_ since conventional getter
functions are called from command substitutions and hence subshells, this
function is a setter rather than getter.
/---
function set_string_to_file_descriptor_file() {
    # Validate sanity.
    die_unless_arg_2 'Expected one string name and one file descriptor name.'
    string string_name__sstfdf="${2}"  file_descriptor_name__sstfdf="${2}"
    die_unless_file_descriptor_open "${file_descriptor_name__sstfdf}"

    # Get such path. For safety, prefer :set_string_to_path_canonical() to
    # :path.canonicalize().
    :set_string_to_path_canonical "${string_name__sstfdf}"\
        "$(get_file_descriptor_file_device "${file_descriptor_name__sstfdf}")"
}

# ....................{ OPENERS ~ file                     }....................
:func.document <<'/---'
void open_file_descriptor_to_file_read(
    string file_descriptor_name, string filename)

Open the passed file descriptor under the current shell for reading from the
passed file. If such descriptor is already open under the current shell,
silently close such descriptor first. See
open_file_descriptor_to_file_write() for further details.
/---
function open_file_descriptor_to_file_read() {
    # See open_file_descriptor_to_file_write().
    die_unless_args_2 'Expected one file descriptor name and one filename.'
    string file_descriptor_name__ofdff="${1}" filename__ofdff="${2}"
    die_unless_file_descriptor "${file_descriptor_name__ofdff}"
    close_file_descriptor_if_open_nonstandard "${file_descriptor_name__ofdff}"
    eval "exec {${file_descriptor_name__ofdff}}<'${filename__ofdff}'"
}

:func.document <<'/---'
void open_file_descriptor_to_file_write(
    string file_descriptor_name, string filename)

Open the passed file descriptor under the current shell for overwriting the
contents of the passed file. If such descriptor is already open under such
shell, silently close such descriptor first: e.g.,

.open_file_descriptor_to_file_write()
==========================================
[source]
------------------------------------------
>>> file_descriptor                       white_pony
>>> open_file_descriptor_to_file_write white_pony "/diamond/eyes"
>>> write_file_descriptor_with_string     white_pony "koi no yokan"
>>> close_file_descriptor                 white_pony
>>> print_file_text "/diamond/eyes"
koi no yokan
------------------------------------------
==========================================
/---
function open_file_descriptor_to_file_write() {
    # Validate sanity.
    die_unless_args_2 'Expected one file descriptor name and one filename.'
    string file_descriptor_name__ofdtf="${1}" filename__ofdtf="${2}"
    die_unless_file_descriptor "${file_descriptor_name__ofdtf}"

    # If such descriptor is open and nonstandard, close such descriptor.
    close_file_descriptor_if_open_nonstandard "${file_descriptor_name__ofdtf}"

    # Allocate such descriptor.
    eval "exec {${file_descriptor_name__ofdtf}}>'${filename__ofdtf}'"
}

# ....................{ OPENERS ~ descriptor               }....................
:func.document <<'/---'
void open_file_descriptor_to_stdout(string file_descriptor_name)

Open the passed file descriptor under the current shell for appending to the
standard output stream of such shell: e.g.,

.open_file_descriptor_to_stdout()
==========================================
[source]
------------------------------------------
>>> file_descriptor                         black_rose
>>> open_file_descriptor_to_stdout black_rose
>>> write_file_descriptor_with_string       black_rose "immortal"
immortal
>>> close_file_descriptor                   black_rose
------------------------------------------
==========================================
/---
function open_file_descriptor_to_stdout() {
    die_unless_arg 'Expected one file descriptor name.'
    open_file_descriptor_to_file_descriptor_write "${1}"\
        ZESHY_STDOUT_FILE_DESCRIPTOR
}

:func.document <<'/---'
void open_file_descriptor_to_stderr(string file_descriptor_name)

Open the passed file descriptor under the current shell for appending to the
standard error stream of such shell: e.g.,

.open_file_descriptor_to_stderr()
==========================================
[source]
------------------------------------------
>>> file_descriptor                         birch_white
>>> open_file_descriptor_to_stderr birch_white
>>> write_file_descriptor_with_string       birch_white "birch black"
birch black
>>> close_file_descriptor                   birch_white
------------------------------------------
==========================================
/---
function open_file_descriptor_to_stderr() {
    die_unless_arg 'Expected one file descriptor name.'
    open_file_descriptor_to_file_descriptor_write "${1}"\
        ZESHY_STDERR_FILE_DESCRIPTOR
}

:func.document <<'/---'
void open_file_descriptor_to_file_descriptor_write(
    string target_file_descriptor_name, string source_file_descriptor_name)

Open the first passed file descriptor for overwriting the contents of the file
already opened by the second passed file descriptor under the current shell. If
the former is already open under the current shell, silently close such
descriptor first. This function thus performs file descriptor duplication: e.g.,

.open_file_descriptor_to_file_descriptor_write()
==========================================
[source]
------------------------------------------
>>> file_descriptor black_star
>>> open_file_descriptor_to_file_descriptor_write\
...     black_star ZESHY_STDOUT_FILE_DESCRIPTOR
>>> write_file_descriptor_with_string black_star "respiration"
respiration
>>> close_file_descriptor black_star
------------------------------------------
==========================================
/---
function open_file_descriptor_to_file_descriptor_write() {
    # Validate sanity.
    die_unless_args_2 'Expected one target and one source file descriptor name.'
    string fd_name_target__ofdtfd="${1}" fd_name_source__ofdtfd="${2}"
    die_unless_file_descriptor "${fd_name_target__ofdtfd}"
    die_unless_file_descriptor "${fd_name_source__ofdtfd}"

    # If the target file descriptor is open and nonstandard, close such
    # descriptor.
    close_file_descriptor_if_open_nonstandard "${fd_name_target__ofdtfd}"

    # Open such descriptor. Unfortunately, the following seemingly valid
    # assignment fails with nonzero exit status:
    #
    #     eval "exec {${fd_name_target__ofdtfd}}>&${(P)fd_name_source__ofdtfd}"
    #
    # Unless expanding the source descriptor before its expansion in such
    # "eval" statement, such statement inexplicably fails. While this should
    # probably be reported, expand such descriptor beforehand in the meanwhile.
    integer fd_source__ofdtfd="${(P)fd_name_source__ofdtfd}"
    eval "exec {${fd_name_target__ofdtfd}}>&${fd_source__ofdtfd}"
}

# ....................{ WRITERS                            }....................
:func.document <<'/---'
void write_file_descriptor_with_string(
    string file_descriptor_name, string text1, ...)

Overwrite the existing contents of the file opened for writing by the passed
file descriptor with the passed strings. See
open_file_descriptor_to_file_write() for further details.
/---
function write_file_descriptor_with_string() {
    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected one file descriptor name and one or more strings.'
    string file_descriptor_name__wfdws="${1}" filename__wfdws
    die_unless_file_descriptor_open_writable "${file_descriptor_name__wfdws}"
    shift_arg

    # Absolute path of the file to be written.
    set_string_to_file_descriptor_file\
        filename__wfdws "${file_descriptor_name__wfdws}"

    # Write such strings. Bizarrely, zsh provides no corresponding ">>&"
    # operation. Instead, ">&" appends and *NO* operation writes. While
    # nonsensical, there's not terribly much we can do about it. So, we
    # stupidly fake it by silently removing the underlying file. Yes, this is
    # non-atomic and hence terrible. *shrug*
    remove_file "${filename__wfdws}"
    append_file_descriptor_with_string "${file_descriptor_name__wfdws}" "${@}"
}

:func.document <<'/---'
void append_file_descriptor_with_string(
    string file_descriptor_name, string text1, ...)

Append the passed strings to the existing contents of the file opened for
writing by the passed file descriptor. See
open_file_descriptor_to_file_write() for further details.
/---
function append_file_descriptor_with_string() {
    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected one file descriptor name and one or more strings.'
    string file_descriptor_name__afdws="${1}"
    die_unless_file_descriptor_open_writable "${file_descriptor_name__afdws}"
    shift_arg

    # Append such strings.
    :string.output "${@}" >&${(P)file_descriptor_name__afdws}
}

# ....................{ CLOSERS                            }....................
:func.document <<'/---'
void close_file_descriptor(string file_descriptor_name)

Close the passed open file descriptor. If such descriptor is not open under the
current shell, throw an exception. See open_file_descriptor_to_file_write()
for further details.
/---
function close_file_descriptor() {
    # Validate sanity.
    die_unless_arg 'Expected one file descriptor name.'
    string fd_name__cfd="${1}"
    die_unless_file_descriptor_open "${fd_name__cfd}"

    # Close such descriptor.
    eval "exec {${fd_name__cfd}}>&-"
}

:func.document <<'/---'
void close_file_descriptor_if_open(string fd_name)

Close the passed file descriptor if open or return silently otherwise. See
open_file_descriptor_to_file_write() for further details.
/---
function close_file_descriptor_if_open() {
    # Validate sanity.
    die_unless_arg 'Expected one file descriptor name.'
    string fd_name__cfdio="${1}"

    # If such descriptor is open, close such descriptor.
    is_file_descriptor_open   "${fd_name__cfdio}" and
        close_file_descriptor "${fd_name__cfdio}"
}

:func.document <<'/---'
void close_file_descriptor_if_open_nonstandard(string fd_name)

Close the passed file descriptor if open _and_ *nonstandard* (i.e., _not_ opened
for reading or writing the standard input, output, or error streams of the
current shell) or return silently otherwise. Since closing standard file
descriptors is generally a poor idea, consider calling this function rather than
close_file_descriptor(). See such function for further details.
/---
function close_file_descriptor_if_open_nonstandard() {
    # Validate sanity.
    die_unless_arg 'Expected one file descriptor name.'
    string fd_name__cfdion="${1}"
    die_unless_file_descriptor "${fd_name__cfdion}"

    # If such descriptor is open and nonstandard, close such descriptor. Since
    # POSIX assigns standard error the largest file descriptor of the three
    # standard file descriptors, check against such descriptor.
    (( ${(P)fd_name__cfdion} > ${ZESHY_STDERR_FILE_DESCRIPTOR} )) and
        close_file_descriptor_if_open "${fd_name__cfdion}"
}

# --------------------( WASTELANDS                         )--------------------
# If such
#descriptor is not open under such shell, an exception is thrown.

#FUXME: Wait. This is inherently nonsensical. Getter functions are called from
#command substitutions, which *BY DEFINITION* fork a subshell. Hence, the path
#returned by this getter (but *NOT* the getter below, which is shell-agnostic)
#is pretty much guaranteed *NOT* to exist in the caller's shell. Hence, rename
#to set_string_to_file_descriptor_file() and adjust appropriately.

#FUXME: Rename to get_file_descriptor_file_device().
    # Write such strings. Bizarrely, zsh provides no corresponding ">>&"
    # operation. Instead, ">&" appends and *NO* operation writes. While
    # nonsensical, there's not terribly much we can do about it. So, we
    # stupidly fake it by silently removing the underlying file. Yes, this is
    # non-atomic and hence terrible. *shrug*
#   remove_file "$(get_file_descriptor_file "${file_descriptor_name__wfdws}")"
#   append_file_descriptor_with_string "${file_descriptor_name__wfdws}" "${@}"
# Don't bother calling the more expensive
    # die_unless_file_descriptor(), as functions this function transitively
    # calls already do so.
    # Avoid calling die_unless_file_descriptor(), as that calls this function.
#FUXME: Actually, these two functions imply different semantics. The latter
#*SHOULD* throw an exception if such variable does not exist; the former simply
#returns failure. Due to laziness, just grep the codebase and determine which we
#need. Excise the other (and corresponding exception handler above).
    # If such descriptor is *NOT* a standard file descriptor (i.e., 0, 1, or 2)
    # and already open, close before opening such descriptor. zsh fails with
    # non-zero exit status otherwise.
#   (( ${(P)file_descriptor_name__ofdtf} >= 3 )) and
#       is_file_descriptor_open "${file_descriptor_name__ofdtf}" and
#       close_file_descriptor   "${file_descriptor_name__ofdtf}"
#Write the passed strings to the passed file descriptor, overwriting the file
#such descriptor refers to with such strings

#allocated by the operating system to the passed file descriptor.
#FUXME: Make a new "file_descriptor" type, aliased to integers.
#FUXME: Define new open_file_descriptor_to_file_descriptor_write() and
#open_file_descriptor_to_stderr() functions.
# Such descriptor is shell specific and hence applies only to the current shell
#this functionality *CANNOT* be encapsulated in a getter function
#(e.g., "$(get_file_descriptor_writing_to_file black_koi "/yokan")"):

#FUXME: Rename to get_file_descriptor_path(). The current nomenclature is
#slightly more specific but *MUCH* less understandable.
#   >>> set_file_descriptor_to_write_file white_pony "/diamond/eyes"
# void write_file_with_string_descriptor(
#   string text1, string text2, ..., integer file_descriptor)
#
# Write the passed strings to the passed file descriptor. See
# set_integer_to_file_descriptor_writing_to_file() for examples.
#function write_file_with_string_descriptor() {
    # Validate sanity.
#    die_unless_args_2 'expected at least one string and one file descriptor'
#    string file_descriptor="${@[-1]}"
#    die_unless_file_descriptor_open_writable "${file_descriptor}"
#    pop_arg

    # Write such strings.
#}

#FUXME: Frankly, the whole reliance on file descriptor names greatly and entirely
#unnecessarily complicates all functionality below. I don't see why we can't
#just dynamically assign passed string integers to actual integers in function
#implementations, if needed. For example:
#function get_file_descriptor_writing_to_file() {
    # Validate sanity.
#    die_unless_arg 'expected one one filename'
#    string filename="${1}"

    # Allocate such file descriptor.
#    integer file_descriptor
#    exec {file_descriptor}>"${filename}"
#    :string.output "${file_descriptor}"
#}
