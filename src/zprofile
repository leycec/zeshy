#!/bin/zsh
# ====================[ zprofile                           ]====================
#                     [ Time-stamp: "2009-04-18 19:23:19 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Run after "zshenv" but before "zshrc" and "zlogin", for login shells.
#
# --------------------( VARIABLES                          )--------------------
# This script aggregates all environment variables into one file. Note that many
# distros dis-aggregate such environment variables into separate files under
# "/etc/env.d/", which they then programmatically aggregate into a composite
# "/etc/profile.env" file, which this script then sources. Since this tends to
# make for a rather clumsy and overly abstract means of defining environment
# variables, Zeshy prefers to "simply" clump such variables together, here.

# ....................{ PREAMBLE                           }....................
# Absolute path to the current script.
local zprofile_path="$(readlink --canonicalize-existing "${0}")"

# Directory having the current script.
[[ -n "${ZESHY_HOME}" ]] ||
    export ZESHY_HOME=$(readlink --canonicalize-existing $(dirname "${zprofile_path}"))

# Import Zeshy Core, if not already having done so.
[[ $(whence -w import) =~ ': function' ]] || source "${ZESHY_HOME}/zeshy/core"

# Inform the user that this script is being imported.
utter_import "${zprofile_path}"

# ....................{ DEPENDENCIES                       }....................
import zeshy/file
import zeshy/ssh

# ....................{ PROPERTIES                         }....................
# 077 would be more secure, but 022 is generally quite realistic.
umask 022

# ....................{ DEPENDENCIES                       }....................
# Add Zeshy's "site-functions/" to the function path, if that directory exists.
[[ -n "${ZESHY_HOME}" && -d "${ZESHY_HOME}/site-functions" ]] &&
    FPATH="${ZESHY_HOME}/site-functions:${FPATH}"

# Import all shell scripts under "/etc/profile.d/", if that directory exists.
# Unlike "/etc/env.d/" shell scripts, which perform simple variable assignments,
# these scripts perform more complex (and therefore time- and space-consumptive)
# functionality. Fortunately, however, there rarely tend to be many of them.
if [[ -d '/etc/profile.d' ]]; then
    SHELL_OPTIONS=${-}
    setopt nullglob
    local profile_script_path
    for PROFILE_SCRIPT in "/etc/profile.d"/*.sh; do
        [[ -r "${profile_script_path}" ]] && source "${profile_script_path}"
    done
    unsetopt nullglob
    set -${SHELL_OPTIONS}
    unset sh SHELL_OPTIONS
fi

# Import "/etc/profile.env", if that file exists. Some distributions
# programmatically aggregate this file as follows:
#
# * Under Gentoo, "env-update" from the files in "/etc/env.d/".
# * Under Exherbo, "eclectic env update" from the files in "/etc/env.d/".
[[ -e '/etc/profile.env' ]] && source '/etc/profile.env'

# ....................{ ROOT                               }....................
# Non-empty if the current user is root. Otherwise, empty.
IS_USER_ROOT=$([[ "${EUID}" == "0" || "${USER}" == "root" ]] && echo '1')

# ....................{ PATH                               }....................
# void PATH_append(char *PATHNAME, bool IS_NOT_TESTING_PATH)
#
# Add the passed pathname to this user's "$PATH", if: '
#
# * If "$IS_NOT_TESTING_PATH" is not passed or is passed but is empty, then if
#   that path exists, is readable by this user, and has not already been added.
# * If "$IS_NOT_TESTING_PATH" is passed and is non-empty, then that is
#   sufficient and we perform no path testing. (This should be used sparingly.)
PATH_append() {
    if [[ -z "${1}" ]]; then
        echo 'PATH_append: passed no path to append' 1>&2
        return
    fi
    
    if [[ -n "${2}" || ( -d "${1}" && -r "${1}" ) ]]; then
        if [[ -n "${PATH}" ]]
        then PATH+=":${1}"
        else PATH="${1}"
        fi
    fi
}

# void PATH_append_if_root(char *PATHNAME)
#
# Add the passed pathname to this user's "$PATH", if the above conditions hold
# and if this user is the superuser (i.e., root).
PATH_append_if_root() {
    [[ -n "${IS_USER_ROOT}" ]] && PATH_append "${@}"
}

# Record the prior value of PATH: typically, a user-specific PATH as defined by
# one or several of the dependencies, above.
if [[ -n "${IS_USER_ROOT}" ]]; then
    if [[ -n "${ROOTPATH}" ]]
    then USERPATH="${ROOTPATH}"
    else USERPATH="${PATH}"
    fi
else USERPATH="${PATH}"
fi

# Reset PATH to the empty string now that we've recorded its prior value.
PATH=

# Append all paths onto PATH.
PATH_append         "/usr/lib/colorgcc/bin"
PATH_append_if_root "/usr/local/sbin"
PATH_append         "/usr/local/bin"
PATH_append_if_root "/usr/sbin"
PATH_append         "/usr/bin"
PATH_append_if_root "/sbin"
PATH_append         "/bin"

# Append the prior value of PATH back onto PATH.
PATH+=":${USERPATH}"

# Append a user-specific path "~/bin" onto PATH.
PATH_append         "${HOME}/bin"

# ....................{ PATHS                              }....................
# Read X.Org application defaults from this path.
export XAPPLRESDIR="${HOME}/.X"

#FIXME: Hmm; and what, prey tell, is this?
#export XUSERFILESEARCHPATH="${XAPPLRESDIR}/%N"

# Make above directories, if not already made.
#make_directory_if_not_found "${XAPPLRESDIR}" "${XUSERFILESEARCHPATH}"
make_directory_if_not_found "${XAPPLRESDIR}"

# ....................{ *NIX                               }--------------------
# Enable Unicode support, if not already enabled.
[[ -n "${LANG}"   ]] || export LANG="en_US.utf8"
[[ -n "${LC_ALL}" ]] || export LC_ALL="en_US.utf8"

# Enable a default command-line editor and pager, if not already enabled.
[[ -n "${EDITOR}" ]] || export EDITOR=$(which_binaries_nonfatal emacs vim nano ed)
[[ -n "${PAGER}"  ]] || export PAGER=$(which_binaries_nonfatal less more)

#FIXME: Prefix these variable names with "ZESHY_".
# Export default grep options. (Note these options are not respected by grep
# binaries; they are specific to our grep aliases, defined elsewhere.)
#
# Do not define "GREP_OPTION"! When defined, all invocations of grep use these
# options. However, most such invocations do not expect grep to emit line
# numbers, colors, or other colorful noise. They expect grep -- plain grep, no
# ornamentation. (Let us avoid breaking the entire system, shall we?)
export GREPC_OPTIONS="-1 --color=always --line-number --no-messages --extended-regexp --with-filename"
export GREPI_OPTIONS="${GREP_OPTIONS} --ignore-case"

# ....................{ SYSTEM                             }--------------------
#FIXME: Make these functions in the Zeshy OS component.
# Grep the system's total available memory in Kb.
export ZESHY_SYSTEM_RAM_KB=$(cat '/proc/meminfo' | awk -F '[ ]+' '/^MemTotal/ { print $2 }')

# Mark systems having more than 1GB memory as high-end, and all others as low-
# end. This simple test permits conditional logic based on system quality.
export ZESHY_IS_SYSTEM_HIGH_END=$([[ "${ZESHY_SYSTEM_RAM_KB}" -gt 1000000 ]] && echo 1)

# ....................{ ZSH                                }....................
# Enable an in-memory cache of ZSH history; persist this history to some file.
export HISTSIZE=1024  # maintain this number of lines of history
export SAVEHIST=1024  # ..retain this number of lines of history between logins
export HISTFILE="${ZESHY_CACHE_HOME}/history"

# ....................{ NET                                }--------------------
# Disable Firefox's Pango-enabled font antialiasing on low-end machines.
export MOZ_DISABLE_PANGO=$([[ -n "${ZESHY_IS_SYSTEM_HIGH_END}" ]] || echo 1)

# Enable SSH over non-anonymous (i.e., non-pserver) CVS.
export CVS_RSH=ssh

# ....................{ MAIN                               }--------------------
# If "keychain" is runnable and no public/private key pairs have been cached
# yet (as indicated by the absence of a running "ssh-agent" process), do so.
if is_runnable keychain && ! is_running ssh-agent; then
    initialize_keychain
fi

# Lastly, export munged paths into our caller's shell environment.
export PATH MANPATH INFOPATH

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyleft 2007-2010 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
