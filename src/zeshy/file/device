#!/usr/bin/env zsh
# ====================[ device                             ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Disk, implementing filesystem-handling.
#
# --------------------( TODO                               )--------------------
# * Add support for disk cloning. To be blunt, it's highly non-trivial and
#   rather dangerous (an understatement); but, current Linux command-line
#   support for such cloning only excacerbates this issue by unsafely admitting
#   inherently damaging operations (e.g., "dd"-ing onto a mounted partition).
#   Disk cloning requires two separate actions:
#   1. First, cloning the partition(s) header(s) and ensuring the output disk or
#      partition is at least as large as the input disk or partition. Assuming
#      an output disk of /dev/sdb and input disk of /dev/sda, this is achievable
#      by running:
#      sfdisk -d /dev/sda | sfdisk /dev/sdb
#   2. Second, cloning the actual disk or partition ("dd" operates on either
#      transparently, since both are device files). This is somewhat complicated
#      by the lack of a progress bar for "dd" and the need to prevent "dd" from
#      committing blatantly damaging data deletion. Specifically:
#      1. If the output is a disk, validate that no partition of that disk is
#         currently mounted. If the output is a partition, validate that that
#         partition is currently unmounted. Note that this implicitly guards
#         against overwriting of the main hard drive in use.
#      2. Interactively confirm the user wishes to do so with ask_bool().
#      3. Perform the actual clone with "pv" (pipe view), providing a visual
#         progress bar: e.g.,
#         dd if=/dev/sda bs=32M | pv -s 512M | dd bs=32M of=/dev/sdb 
#         The "bs" (block size) argument is essential to provide decent
#         throughput. Being an archaic application, "dd" defaults to an absurd
#         512KB block size; anything from 4MB to 128MB appears to be the current 
#         preferred default. Since "pv" can't reasonably know the full size of
#         data being transferred, we provide it the explicit size with "-s".

# ....................{ DEPENDENCIES                       }....................
zimport zeshy/file/file
zimport zeshy/shell/terminal

# ....................{ PARTITIONS                         }....................
# char *print_partitions(char *device_file1, char *device_file2, ...)
#
# Print the partition table for each passed device or all available devices
# listed by "/proc/partitions" if no devices are passed.
alias print_partitions='fdisk -l'

# ....................{ DEVICES                            }....................
# char *format_device(char *device_file1, char *device_file2, ...)
#
# Print the partition table for each passed device or all available devices
# listed by "/proc/partitions" if no devices are passed.
format_device() {
    # Declare this function to be the top-level "script" for pretty output.
    ZESHY_SCRIPT_NAME='format'

    # Copy passed arguments to local variables and shift off the argument stack.
    die_unless_at_least_two_arguments\
        'expected one device file, filesystem type, optional label, and optional additional arguments'
    string device_file="${1}"
    string filesystem_type="${2}"
    string label="${3}"
    shift; shift; shift

    # Validate passed arguments.
    die_unless_device_file "${device_file}"
    string formatter="mkfs.${filesystem_type}"
    die_unless_installed "${formatter}"\
        "\"${filesystem_type}\" not a recognized filesystem type"

    # Astonishingly, "mkfs.*" commands do *NOT* ask interactive shell users to
    # confirm extremely destructive formats prior to doing so. (Really? Come on,
    # Linux! This isn't obtuse rocket science. It's common decency.)
    if ask_bool_hard "really format \"${device_file}\" as ${filesystem_type}?"; then
        print

        # Format under "-v" for forced verbosity.
        if is_set "${label}"
        then "${formatter}" -L "${label}" -v "${@}" "${device_file}"
        else "${formatter}"               -v "${@}" "${device_file}"
        fi
    fi
}

#FIXME: Obsolete.
#   utter "really format "${device_file}" as ${filesystem_type}? [yes/no] "
#   string is_sure
#   read   is_sure
#   if is "${is_sure}" == y || "${is_sure}" == ye || "${is_sure}" == yes si; then
#       utter      "formatting \"${device_file}\" as ${filesystem_type}..."
 
# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
