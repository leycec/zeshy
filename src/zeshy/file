#!/usr/bin/env zsh
# ====================[ file                               ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy File. This Zeshy component implements supplementary file- and path-
# handling functionality, over and above that already implemented by Zeshy Core.

# ....................{ ALIASES                            }....................
# Three letter.
alias mvt="move_to_temporary_directory"

# ....................{ FILES                              }....................
# char *which_files_nonfatal(char *filename1, *filename2, ...)
#
# Print the absolute path to the first filename in the list of passed filenames
# which exists: e.g.,
#
#     >>> which_files_nonfatal '/the_ancient.one' '/the_king_in.yellow' '/tmp'
#     /tmp
which_files_nonfatal() {
    [[ "${#}" -ge 1 ]] || die "expected at least one filename"
    
    # While there are more filenames to consider, shift the current filename to
    # be considered to a local variable "path".
    local filename
    while [[ -n "${1}" ]]; do
        filename="${1}"
        shift

        # If this filename exists and is readable, return it.
        if [[ -r "${filename}" ]]; then
            echo "${filename}"
            return ${ZESHY_SUCCESS_CODE}
        fi
    done
    
    # No filenames in the list of passed filenames exist. Return with failure.
    return ${ZESHY_FAILURE_CODE}
}

# ....................{ FILES ~ binaries                   }....................
# char *which_binaries_nonfatal(char *binary_name1, *binary_name2, ...)
#
# Print the absolute path to the first binary in the list of passed binaries
# which exists: e.g.,
#
#     >>> which_binaries_nonfatal Council_of_Nicea Constantinople zsh
#     /bin/zsh
# 
# This function is intended to automate selection of binaries, in descending
# order of preference. (In the above example, the hypothetical
# "Council_of_Nicea" binary would be selected before all following binaries on
# systems having the binary.)
which_binaries_nonfatal() {
    [[ "${#}" -ge 1 ]] || die "expected at least one binary name"
    
    # While there are more binaries to consider, shift the current binary to be
    # considered to a local variable "binary_name".
    local binary_name binary_path
    while [[ -n "${1}" ]]; do
        binary_name="${1}"
        shift

        # If this binary exists, return the absolute path to it.
        binary_path=$(which_binary_nonfatal "${binary_name}")
        if [[ ${?} -eq ${ZESHY_SUCCESS_CODE} ]]; then
            echo "${binary_path}"
            return ${ZESHY_SUCCESS_CODE}
        fi
    done
    
    # No binaries in the list of passed binaries exist. Return with failure.
    return ${ZESHY_FAILURE_CODE}
}

# ....................{ FILES ~ temporary                  }....................
# void move_to_temporary_directory(char *path1, char *path2, ...)
#
# Move the passed set of files and/or directories to the "/tmp" directory. For
# Additionally, this suffixing all files and
# paths that already exist in "/tmp/" with the current time. 
move_to_temporary_directory() {
    local target_path source_path source_basename
    for source_path in "${@}"; do
        source_basename=$(basename "${source_path}")
        target_path="/tmp/${source_basename}"
        
        [[ -e "${target_path}" ]] &&
            target_path="/tmp/$source_basename~"$(date +'%F_%H-%M-%S')
        
        try mv "${source_path}" "${target_path}"
    done
}

# char *which_temporary_path(char *prefix)
#
# Print the absolute path to a temporary path having the passed prefix: e.g.,
#
#     >>> which_temporary_path git_patches
#     /tmp/git_patches~2010-04-18_22-58-34  # assuming today is 2010-04-18
#
# While subtle race conditions may arise with concurrent processing, this path
# is generally unique. This should probably not be depended upon for mission
# critical ZSH scripts, however. (Of course, if you're coding such a mission
# critical script in ZSH, you've probably already gone too far.)
which_temporary_path() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one path prefix"
    
    local which_temporary_path
    while true; do
        which_temporary_path="/tmp/${1}.path~$(date +'%F_%H-%M-%S')"
        if [[ ! -d "${which_temporary_path}" ]]; then
            echo   "${which_temporary_path}"
            break
        fi
    done
}

# char *which_temporary_file(char *prefix)
#
# Print the absolute path to a temporary file having the passed prefix: e.g.,
#
#   # Prints "/tmp/git_patch_file~2010-12-01_18-37-41", for example.
#   which_temporary_file git_patch_file
#
# Subtle race conditions may arise, as above.
which_temporary_file() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one file prefix"
    
    local which_temporary_file
    while true; do
        which_temporary_file="/tmp/${1}.file~"$(date +'%F_%H-%M-%S')
        if [[ ! -f "${which_temporary_file}" ]]; then
            echo   "${which_temporary_file}"
            break
        fi
    done
}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyleft 2007-2010 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
