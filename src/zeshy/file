#!/usr/bin/env zsh
# ====================[ file                               ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy File. This Zeshy component implements supplementary file- and path-
# handling functionality, over and above that already implemented by Zeshy Core.

# ....................{ ALIASES                            }....................
# Three letter.
alias dus="print_disk_usage_sorted"
alias mvt="move_to_temporary_directory"

# Filesystem checking (fsck). Note we do not implicitly pass the "-a" or "-p"
# options to fsck, as fsck ignores some filesystem errors (e.g., superblock
# mount time in the future) when those options are passed.
export ZESHY_FSCK_OPTIONS="-C -M -T"
alias fsck="fsck ${ZESHY_FSCK_OPTIONS}"
alias fsck.ext2="fsck.ext2 ${ZESHY_FSCK_OPTIONS}"
alias fsck.ext3="fsck.ext3 ${ZESHY_FSCK_OPTIONS}"
alias fsck.vfat="fsck.vfat ${ZESHY_FSCK_OPTIONS}"

# ....................{ ALIASES ~ guis                     }....................
# Disk usage.
baobab()    { command baobab    "${@}" & }
filelight() { command filelight "${@}" & }

# ....................{ EXCEPTIONS                         }....................
# void die_unless_installed(char *command_name)
#
# Raise an exception unless the passed command exists.
die_unless_installed() {
    [[ ${#} -eq 1 ]] || die "expected exactly one path"
    local dirname="${1}"
    is_installed "${dirname}" || die "\"${dirname}\" not found"
}

# void die_unless_dir(char *dirname)
#
# Raise an exception unless the passed directory exists.
die_unless_dir() {
    [[ ${#} -eq 1 ]] || die "expected exactly one path"
    local dirname="${1}"
    is_dir "${dirname}" || die "\"${dirname}\" not found"
}

# ....................{ FILENAMES                          }....................
# bool is_path_absolute(char *path)
#
# Return success if the passed path is absolute (i.e., begins with a '/'
# character). Otherwise, failure.
is_path_absolute() {
    [[ ${#} -eq 1 ]] || die "expected exactly one path"
    [[ "${1[1]}" == / ]]
}

# char *get_basename_sans_filetype(char *filename)
#
# Get the basename sans filetype of the passed filename. If this filename has no
# filetype, this is the filename itself. Note this only excludes the rightmost
# filetype: e.g.,
#
#     >>> get_basename_sans_filetype('hastur.tar.gz')
#     hastur.tar
get_basename_sans_filetype() {
    [[ ${#} -eq 1 ]] || die "expected exactly one filename"
    echo "${1%.*}"
}

# char *get_filetype(char *filename)
#
# Get the filetype of the passed filename. If this filename has no filetype,
# this is the empty string. Note the only matches the rightmost filetype: e.g.,
#
#     >>> get_filetype('hastur.tar.gz')
#     gz
get_filetype() {
    [[ ${#} -eq 1 ]] || die "expected exactly one filename"
    local filename="${1}"
    local filetype="${filename##*.}"

    # If this filename has no filetype, then the above parameter expansion
    # matched the filename itself, in which case we test for and ignore this. 
    [[ "${filetype}" == "${filename}" ]] || echo "${filetype}"
}

# ....................{ FILETYPES                          }....................
# bool is_file_binary(char *filename)
#
# Return success if the passed filename corresponds to a binary file (i.e., not
# a text file). (If the passed filename corresponds to a directory instead, this
# function always returns failure.)
is_file_binary() {
    [[ ${#} -eq 1 ]] || die "expected exactly one filename"
    local filename="${1}"

    if [[ -f "${filename}" ]]
    then file --mime-encoding "${filename}" | grep --quiet ': binary$'
    else return "${ZESHY_FAILURE_CODE}"
    fi
}

# bool is_file_text(char *filename)
#
# Return success if the passed filename corresponds to a text file (i.e., not a
# binary file). (If the passed filename corresponds to a directory instead, this
# function always returns failure.)
is_file_text() {
    [[ ${#} -eq 1 ]] || die "expected exactly one filename"
    local filename="${1}"

    # Do not simply do "! is_file_binary", as that incorrectly returns success
    # on non-files.
    if [[ -f "${filename}" ]]
    then file --mime-encoding "${filename}" | grep --invert-match --quiet ': binary$'
    else return "${ZESHY_FAILURE_CODE}"
    fi
}

# ....................{ FILESIZES                          }....................
# Aliases.
alias df="df --human-readable --sync"
alias du="du --human-readable --total"
alias dup="print_disk_usage_paged"
alias dus="print_disk_usage_sorted"

print_disk_usage_paged() {
    du "${@}" | ${PAGER}
}

print_disk_usage_sorted() {
    du "${@}" | sort --human-numeric-sort --reverse 
#  [ -z "$1" ] && 1="."
#  \du --all --no-dereference $1 | sort --numeric-sort --reverse | less
}

# ....................{ MOUNT POINTS                       }....................
# bool is_directory_mount_point(char *dirname)
#
# Return success if the passed directory name is an existing mount point (i.e.,
# if "something" is currently mounted under this directory).
is_directory_mount_point() {
    [[ ${#} -eq 1 ]] || die "expected exactly one dirname"
    local mount_point="${1}"
    
    # If the passed pathname does not correspond to an existing directory, it
    # cannot correspond to a valid mount point.
    [[ -d "${mount_point}" ]] || return "${ZESHY_FAILURE_CODE}"

    # If the "mountpoint" binary is available, use that.
    if is_installed mountpoint
    then mountpoint -q "${mount_point}"
    # Otherwise, manually grep "${ZESHY_MOUNT_POINTS_FILE}".
    else grep -q "${mount_point}" "${ZESHY_MOUNT_POINTS_FILE}"
    fi
}

# void mount_iso(char *filename)
#
# Mount the passed ISO filename to the "${ZESHY_MOUNT_ISO_PATH}" directory. If
# something is already mounted to this path, this function iteratively appends
# numbers (starting at 1), until discovering a directory name to which nothing
# is currently mounted.
mount_iso() {
    # Ensure sanity.
    [[ ${#} -eq 1 ]] || die "expected exactly one ISO filename"
    local iso_filename="${1}"
    [[ "${iso_filename}" == *.iso ]] ||
        die "\"${iso_filename}\" not an ISO filename"
    [[ -f "${iso_filename}" ]] ||
        die "\"${iso_filename}\" not found"
    local ZESHY_SCRIPT_NAME='mount_iso'

    # Find a suitable mount path.
    local iso_mount_path_prefix="${ZESHY_MOUNT_ISO_PATH}"
    local iso_mount_path_suffix=0
    local iso_mount_path="${iso_mount_path_prefix}"
    utter "searching for an available mount point..."
    while is_directory_mount_point "${iso_mount_path}"; do
        iso_mount_path_suffix=$(( iso_mount_path_suffix + 1 ))
        iso_mount_path="${iso_mount_path_prefix}${iso_mount_path_suffix}"
    done
    
    # Mount the passed ISO filename to the desired mount path.
    #
    # Note that this does not pass the ",user" option when mounting, as doing so
    # would implicitly enables unhelpful mount options (e.g., "noexec").
    utter "mounting \"${iso_filename}\" to \"${iso_mount_path}\"..."
    run_as_superuser make_directory_if_not_found "${iso_mount_path}" 
    run_as_superuser mount -t iso9660 -o 'exec,loop'\
        "${iso_filename}" "${iso_mount_path}" ||
        die "\"${iso_filename}\" not mountable to \"${iso_mount_path}\""
}

# ....................{ FINDERS                            }....................
# char *which_files_nonfatal(char *filename1, *filename2, ...)
#
# Get the absolute path to the first filename in the list of passed filenames
# which exists: e.g.,
#
#     >>> which_files_nonfatal '/the_ancient.one' '/the_king_in.yellow' '/tmp'
#     /tmp
which_files_nonfatal() {
    [[ ${#} -ge 1 ]] || die "expected at least one filename"
    
    # While there are more filenames to consider, shift the current filename to
    # be considered to a local variable "path".
    local filename
    while [[ -n "${1}" ]]; do
        filename="${1}"
        shift

        # If this filename exists and is readable, return it.
        if [[ -r  "${filename}" ]]; then
            print "${filename}"
            return ${ZESHY_SUCCESS_CODE}
        fi
    done
    
    # No filenames in the list of passed filenames exist. Return with failure.
    return ${ZESHY_FAILURE_CODE}
}

# char *which_binaries_nonfatal(char *binary_name1, *binary_name2, ...)
#
# Get the absolute path to the first binary in the list of passed binaries
# which exists: e.g.,
#
#     >>> which_binaries_nonfatal Council_of_Nicea Constantinople zsh
#     /bin/zsh
# 
# This function is intended to automate selection of binaries, in descending
# order of preference. (In the above example, the hypothetical
# "Council_of_Nicea" binary would be selected before all following binaries on
# systems having the binary.)
which_binaries_nonfatal() {
    [[ ${#} -ge 1 ]] || die "expected at least one binary name"
    
    # While there are more binaries to consider, shift the current binary to be
    # considered to a local variable "binary_name".
    local binary_name binary_path
    while [[ -n "${1}" ]]; do
        binary_name="${1}"
        shift

        # If this binary exists, return the absolute path to it.
        binary_path=$(which_binary_nonfatal "${binary_name}")
        if [[ ${?} -eq ${ZESHY_SUCCESS_CODE} ]]; then
            print "${binary_path}"
            return ${ZESHY_SUCCESS_CODE}
        fi
    done
    
    # No binaries in the list of passed binaries exist. Return with failure.
    return ${ZESHY_FAILURE_CODE}
}

# ....................{ TEMPORARIES                        }....................
#FIXME: This is probably OS-specific, but perhaps good enough for now.
# char *which_temporary_dir(void)
#
# Get the absolute path to the temporary directory. This is, in descending order
# of preference:
#
# * "${HOME}/tmp", if the current user's home directory has such a subdirectory. 
# * "/tmp", otherwise.
which_temporary_dir() {
    [[ ${#} -eq 0 ]] || die "expected no arguments"
    
    local user_temporary_dir="${HOME}/tmp" root_temporary_dir="/tmp"
    if [[ -d   "${user_temporary_dir}" ]]
    then print "${user_temporary_dir}"
    elif [[ -d "${root_temporary_dir}" ]]
    then print "${root_temporary_dir}"
    else die "no temporary directory found; neither "\
        "\"${user_temporary_dir}\" or \"${root_temporary_dir}\" found"
    fi
}

# char *which_temporary_path(char *prefix)
#
# Get the absolute path to a temporary path having the passed prefix: e.g.,
#
#     >>> which_temporary_path git_patches
#     /tmp/git_patches~2011-04-18_22-58-34  # assuming today is 2011-04-18
#
# While subtle race conditions may arise with concurrent processing, this path
# is generally unique. This should probably not be depended upon for mission
# critical ZSH scripts, however. (Of course, if you're coding such a mission
# critical script in ZSH, you've probably already gone too far.)
which_temporary_path() {
    [[ ${#} -eq 1 ]] || die "expected exactly one path prefix"
    
    local which_temporary_path
    while true; do
        which_temporary_path="$(which_temporary_dir)/${1}.path~$(date +'%F_%H-%M-%S')"
        if [[ ! -d "${which_temporary_path}" ]]; then
            print  "${which_temporary_path}"
            break
        fi
    done
}

# char *which_temporary_file(char *prefix)
#
# Get the absolute path to a temporary file having the passed prefix: e.g.,
#
#   # Prints "/tmp/git_patch_file~2011-12-01_18-37-41", for example.
#   which_temporary_file git_patch_file
#
# Subtle race conditions may arise, as above.
which_temporary_file() {
    [[ ${#} -eq 1 ]] || die "expected exactly one file prefix"
    
    local which_temporary_file
    while true; do
        which_temporary_file="$(which_temporary_dir)/${1}.file~"$(date +'%F_%H-%M-%S')
        if [[ ! -f "${which_temporary_file}" ]]; then
            print  "${which_temporary_file}"
            break
        fi
    done
}

# ....................{ TEMPORARIES ~ mutators             }....................
# void move_to_temporary_directory(char *path1, char *path2, ...)
#
# Move the passed set of files and/or directories to the "/tmp" directory. For
# Additionally, this suffixing all files and
# paths that already exist in "/tmp/" with the current time. 
move_to_temporary_directory() {
    local target_path source_path source_basename
    for source_path in "${@}"; do
        source_basename=$(basename "${source_path}")
        target_path="/tmp/${source_basename}"
        [[ -e "${target_path}" ]] &&
            target_path="$(which_temporary_dir)/$source_basename~$(date +'%F_%H-%M-%S')"
        
        try mv "${source_path}" "${target_path}"
    done
}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2011 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
