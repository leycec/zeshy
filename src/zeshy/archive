#!/usr/bin/env zsh
# ====================[ archive                            ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Archive This Zeshy component implements archive compression and
# decompression functionality.

# ....................{ DEPENDENCIES                       }....................
#import zeshy/file

# ....................{ BZIP2                              }....................
# Aliases.
alias bzip2="bzip2 --keep --best"
alias bunzip2="bunzip2 --keep"
alias bzcatl="bzcat_less"

# char *bzcat_less(char *bzcat_option1, char *bzcat_option2, ...)
#
# Print the passed bz2-compressed filename under the current pager.
bzcat_less() {
    bzcat "${@}" | less
}

# char *bzhead(char *filename, char *head_option1, char *head_option2, ...)
#
# Print the first portion of the passed bz2-compressed filename according to the
# passed "head" options, defaulting to the first 1,000 file lines if no such
# options are specified.
bzhead() {
    [[ "${#}" -ge 1 ]] || die 'expected at least a filename'

    # Bz2 file to be shown.
    local bz2_file="${1}"
    shift

    # Options to be passed to "head".
    local head_options
          head_options=( "${@}" )
    [[ -n "${head_options[@]}" ]] || head_options=( "-1000" )

    # Do it. "Oh, yes."
    bzcat "${bz2_file}" | head ${head_options[@]} | less
}

# ....................{ TAR                                }....................
# Create an archive of specific type.
tar_dir() {
    archive_dir "${1}" tar.bz2 tar "-cjvf" tar "-tjvf"
}

# ....................{ ZIP                                }....................
# void zip_dir(char *dirname)
#
# Recursively zip the passed dirname into an archive having the same name but
# suffixed by ".zip" under the current directory.
zip_dir() {
    local SCRIPT_NAME='zip_dir'
    archive_dir "${1}" zip zip "-r" unzip "-l"
}

zip_file() {
    local SCRIPT_NAME='zip_file'
    while [[ -n "${1}" ]]; do
        archive_file "${1}" zip zip "" unzip "-l"
        shift
    done
}

# ....................{ GENERIC                            }....................
# void unpack(char *filename1, char *filename2, ...)
#
# Add ".lzo" and ".lzma" support. Also, offer to install unarchival software
# when needed, if not already installed on the current machine.
# Uncompress one or more compressed files of arbitrary type.
unpack() {
    [[ "${#}" -ge 1 ]] || die 'expected at least one filename'

    local archive_file
    for   archive_file in "${@}"; do
        # Obtain this archive's filetype. This is considerably more complex than it
        # should be, as "sed" seems to be incapable of obeying the following
        # substitution:
        #
        #   ... | sed -r 's/^.+\.(tar\.)?/\1/') 
        #
        # Specifically, "sed" refuses to substitute "\1" with "tar." when the
        # latter is found. If we remove the "?", then it does perform the
        # substitution, but (of course) fails on filenames not having the "tar."
        # extension. This is the best we can do, therefore; and it actually works.
        #
        # Oddly, Zsh also seems incapable of obeying the following PCRE:
        #
        #   ... =~ \.(tar\.)?(.+)
        # 
        # Thus, "sed" hackiness it is.
        local archive_filetype=$(echo "${archive_file}" | sed -r 's/^.+\.(tar\.)/tar~/' | sed -r 's/^.+\.//' | sed -r 's/tar~/tar./')

        # Alias alternative archive filetypes to their canonical filetype.
        case "${archive_filetype}" in
            cbz) archive_filetype="zip" ;;
            jar) archive_filetype="zip" ;;
            tbz) archive_filetype="tar.bz2" ;;
            tgz) archive_filetype="tar.gz" ;;
        esac

        case "${archive_filetype}" in
        7z)
            utter "un7ziping \"${archive_file}\"..."
            7z x "${archive_file}" ;;
        bz2)
            utter "unbzip2ing \"${archive_file}\"..."
            bunzip2 --keep "${archive_file}" ;;
        rar)
            utter "unraring \"${archive_file}\"..."
            unrar x "${archive_file}" ;;
        tar)
            utter "untaring \"${archive_file}\"..."
            tar -xvf "${archive_file}" ;;
        tar.bz2)
            utter "untaring \"${archive_file}\"..."
            tar -xvjf "${archive_file}" ;;
        tar.gz)
            utter "untaring \"${archive_file}\"..."
            tar -xvzf "${archive_file}" ;;
        gz)
            utter "ungziping \"${archive_file}\"..."
            gunzip "${archive_file}" --to-stdout > "${archive_file%.gz}";;
        zip)
            utter "unziping \"${archive_file}\"..."
            unzip "${archive_file}" ;;
        *)
            utter "${archive_filetype} for \"${archive_file}\" not a recognized archive filetype!" ;;
        esac
    done
}

# void archive_dir(char *dirname, char *filetype,
#     char *archive_command, char *archive_command_options, 
#     char *archive_list_command, char *archive_list_command_options)
#
# Archive the passed directory into a file of the passed filetype via the passed
# archive command.
archive_dir() {
    [[ "${#}" -eq 1 ]] || die 'expected exactly one dirname'

    # Name all caller-passed parameters.
    local dirname="${1}"
    local filetype="${2}"
    local archive_command="${3}"
    local archive_command_options="${4}"
    local archive_list_command="${5}"
    local archive_list_command_options="${6}"

    # Ensure sanity.
    [[ -d "${dirname}" ]] || die "\"${dirname}\" not a path"

    # Remove this path's trailing '/', if it has such a trailing '/'.
    dirname=$(echo "${dirname}" | sed 's/\/$//' -)
    
    local filename="${dirname}.${filetype}"
    utter "archiving \"${filename}\"..."
    ${archive_command} ${archive_command_options} "${filename}" "${dirname}"

    echo ""
    utter "listing \"${filename}\"..."
    ${archive_list_command} ${archive_list_command_options} "${filename}"
}

#FIXME: Revise to coincide with archive_dir().
# Creates an archive of arbitrary type and command.
archive_file() {
    if [[ -n "${1}" && -f "${1}" ]]; then
        # Remove this path's trailing '/', if it has such a trailing '/'.
        2=$(echo "${1}" | sed --regexp-extended 's/\.[^.]+$/.'${2}'/' -)
        
        utter "creating \"${2}\"..."
        ${3} ${4} "${2}" "${1}"

        echo ""
        utter "listing \"${2}\"..."
        ${5} ${6} "${2}"
    elif [[   -z "${1}" ]]; then die "no path passed"
    elif [[ ! -f "${1}" ]]; then die "\"${1}\" not a file"
    fi
}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyleft 2007-2010 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
