#!/usr/bin/env zsh
# ====================[ command                            ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Command. This Zeshy component implements external command-specific
# functionality, including:
#
# * Supplementary aliases, functions, and variables for all universal commands:
#   i.e., POSIX-compliant commands universally available on *NIX systems. This
#   includes the standard retinue of *NIX commands, like "awk", "grep", "sed", 
#   and so forth.

# ....................{ IMPORTS                            }....................
zimport zeshy/string

# void _zeshy_command(void)
#
# Conditionally Import Zeshy Command components. Specifically, import each such
# component if and only if the corresponding command has been installed on the
# current system (e.g., import "grep" if and only if "grep" is installed).
_zeshy_command() {
    # Match all non-dotfiles in the current directory via the "(^D)" modifier:
    # i.e., all files except this one.
    local command_script command_name
    for command_script in "$(dirname ${zeshy_script_path})"/*(^D); do
        command_name=$(basename "${command_script}")
        is_installed "${command_name}" && zimport "${command_script}"
    done
}

# ....................{ GREP                               }....................
# Export default grep options. (Note these options are not respected by grep
# binaries; they are specific to the grep aliases below.)
#
# Do not define "GREP_OPTION"! When defined, all invocations of grep use these
# options. However, most such invocations do not expect grep to emit line
# numbers, colors, or other colorful noise. They expect grep -- plain grep, no
# ornamentation. (Let us avoid breaking the entire system, shall we?)
ZESHY_GREP_OPTIONS=(
    -1
    --color=always
    --exclude-dir='.cvs'
    --exclude-dir='.git'
    --exclude-dir='.svn'
    --extended-regexp
    --line-number
    --no-messages
    --with-filename
)

# Aliases.
alias gr="grep ${ZESHY_GREP_OPTIONS}"
alias grg="grep_glob"
alias grr="grep_recursively"

# char *grep_glob(char *grep_pattern, char *glob_expression)
#
# Grep all files matching the passed glob expression (e.g., "*.txt") against the
# passed grep pattern (e.g., "^unity in faith$").
grep_glob() {
    [[ ${#} -eq 1 || ${#} -eq 2 ]] ||
        die "expected at least one regular expression"

    local grep_pattern="${1}"
    local glob_pattern="${2:-*.txt}"

    utter "grepping \"${glob_pattern}\"..."
    grep --recursive --include "${glob_pattern}"\
        ${=ZESHY_GREP_OPTIONS} "${grep_pattern}"
}

# char *grep_recursively(char *pattern, char *path)
#
# Recursively match all file contents under the passed path against the passed
# POSIX-style regular expression. If no path is passed, this recursively matches
# under the current path. Thusly, the simplest usage of this shell script is:
#
#   # Find all text files whose contents match "Wisdom ~ \d\d ~ Outlays".
#   >>> grep-recursively 'Wisdom ~ \d\d ~ Outlays'
grep_recursively() {
    [[ ${#} -ge 1 ]] || die "expected at least a regular expression"

    local grep_pattern="${1}"
    shift

    utter "grepping \"${@:-${PWD}}\"..."
    grep --recursive ${=ZESHY_GREP_OPTIONS}\
        "${grep_pattern}" "${@:-${PWD}}" |
        "${PAGER}"
}

# ....................{ GREP ~ insensitive                 }....................
ZESHY_GREP_INSENSITIVELY_OPTIONS=( "${ZESHY_GREP_OPTIONS[@]}" --ignore-case )

# Aliases.
alias gri="grep ${ZESHY_GREP_INSENSITIVELY_OPTIONS}"
alias grgi="grep_glob_insensitively"
alias grri="grep_recursively_insensitively"

# char *grep_glob_insensitively(char *grep_pattern, char *glob_expression)
#
# Grep all files matching the passed glob expression (e.g., "*.txt") against the
# passed grep pattern (e.g., "^unity in faith$") insensitively.
grep_glob_insensitively() {
    [[ ${#} -eq 1 || ${#} -eq 2 ]] ||
        die "expected at least one regular expression"

    local grep_pattern="${1}"
    local glob_pattern="${2:-*.txt}"

    utter "grepping \"${glob_pattern}\" case-insensitively..."
    grep --recursive --include "${glob_pattern}"\
        ${=ZESHY_GREP_INSENSITIVELY_OPTIONS} "${grep_pattern}"
}

# char *grep_recursively_insensitively(char *pattern, char *path)
#
# Recursively match all file contents under the passed path against the passed
# POSIX-style regular expression, case-insensitively.
grep_recursively_insensitively() {
    [[ ${#} -ge 1 ]] || die "expected at least a regular expression"
    local grep_pattern="${1}"
    shift

    utter "grepping \"${@:-${PWD}}\" case-insensitively..."
    grep --recursive ${=ZESHY_GREP_INSENSITIVELY_OPTIONS}
        "${grep_pattern}" "${@:-${PWD}}" |
        "${PAGER}"
}

# ....................{ PAGE                               }....................
# char *page(char *command)
#
# Page the passed command (i.e., pipe it through "less" or "more").
page() {
    [[ ${#} -ge 1 ]] || die "expected at least a command name"
    try "${@} | ${PAGER:-less}"
}

# ....................{ WC                                 }....................
# Aliases. 
alias wclr="get_line_count_recursively"

# int get_line_count_recursively(char *path)
#
# Get the total number of lines corresponding to the file(s) in the passed path,
# as follows:
#
# * If no path is passed, default to the current directory.
# * If this path is a directory, recursively sum the number of lines for files
#   in this path ignoring all binary files.
# * If this path is a file...
#   * ...and this file is a PDF, use "pdftotext" to count the number of text
#     lines in the rendered PDF; otherwise...
#   * ...sum the number of lines for this file.
get_line_count_recursively() {
    [[ "${#}" -le 1 ]] || die "expected exactly one path"
    local line_count_path="${1:-.}"

    if [[ -d "${line_count_path}" ]]; then
        utter "inspecting \"${line_count_path}\" as a directory, ignoring non-text files and dotfiles..."
        
        # Ignore:
        # 
        # * Dotfiles and dot directories via a regular expression.
        # * Non-files via a simple match.
        # * Binary files via an expression lifted from is_file_text().
        try "find '${line_count_path}' \
            \( ! -regex '.*/\..*' \)\
            -type f\
            -exec sh -c 'file --mime-encoding {} | grep --invert-match --quiet \": binary$\"' \;\
            -exec wc -l {} \; |\
            awk '{ total += \$1 } END { print total }' |\
            to_comma_separated_integer"
    elif [[ -f "${line_count_path}" ]]; then
        if [[ $(get_filetype "${line_count_path}") == pdf ]]; then
            utter "inspecting \"${line_count_path}\" as a PDF..."
            try "pdftotext '${line_count_path}' - | wc -l | to_comma_separated_integer"
        else
            utter "inspecting \"${line_count_path}\" as a text file..."
            is_file_text "${line_count_path}" ||
                die "\"${line_count_path}\" not a text file"
            try "wc -l '${line_count_path}' | to_comma_separated_integer"
        fi
    else die "\"${line_count_path}\" neither a directory or file"
    fi
}

# ....................{ MAIN                               }....................
_zeshy_command

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2011 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
