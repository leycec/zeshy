#!/usr/bin/env zsh
# ====================[ shell                              ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Shell. This Zeshy component implements shell-handling functionality.
# This includes:
#
# * Reflection functionality for dynamically inspecting functions and aliases as
#   "first-class constructs."

# --------------------( ALIASES                            )--------------------
# Mimes.
#FIXME: Still desirable?
#alias zsh_mime_load="zsh-mime-setup -f"
#alias zsh_mime_edit="${EDITOR} /etc/mailcap; zsh-mime-load"

# ....................{ TESTS                              }....................
# bool is_alias(char *alias)
#
# Return true if there exists an alias with the passed alias name.
is_alias() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one name"
    [[ $(whence -w "${1}") =~ ': alias$' ]]
}

# bool is_builtin(char *builtin)
#
# Return true if there exists a builtin with the passed alias name.
is_builtin() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one name"
    [[ $(whence -w "${1}") =~ ': builtin$' ]]
}

# bool is_function(char *function)
#
# Return true if there exists a function with the passed function name.
is_function() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one name"
    [[ $(whence -w "${1}") =~ ': function$' ]]
}

# ....................{ PASS-BY-VALUE                      }....................
#FIXME: Document!
return_value() {
    [[ "${#}" -ge 1 ]] || die "expected at least one value"
    echo "echo \"${@}\"; return ${ZESHY_SUCCESS_CODE}"
}

return_array() {
    #FIXME: Test to make sure the passed array name actually is. How?
    [[ "${#}" -ge 1 ]] || die "expected exactly one array name"
    local array_name="${1}"
    echo "echo \"${${(@qqkv)array_name}[@]}\"; return ${ZESHY_SUCCESS_CODE}"
}

obtain_array() {
    #FIXME: Test to make sure the passed array name actually is. How?
    [[ "${#}" -ge 2 ]] || die "expected one array name and one runnable command"
    local array_name="${1}"; shift
    local command="${@}"

    #FIXME: Die if return code is failure?
    echo "local _zeshy_obtained_array_as_scalar=\$(${command}); "
    echo "${array_name}=( "${(Q@)${(z)_zeshy_obtained_array_as_scalar}}" ); "
    echo "unset _zeshy_obtained_array_as_scalar"
}

# ....................{ UNSETTERS                          }....................
# void kill_callables(void)
#
# Destroy all existing aliases and functions. This is, of course, fairly
# destructive but does guard against desynchronization issues resulting from
# modification to this Zeshy installation (e.g., when upgrading).
kill_callables() {
    unalias    -m '*'
    unfunction -m '*'
}

# ....................{ SOURCES                            }....................
# void redot(void)
#
# Resource all Zsh startup scripts in the same order Zsh sources these scripts
# on initial login for the current user. This function is of principal use for
# Zeshy developers (making frequent changes to Zeshy itself) as well as Zsh
# dot-file hackers (making frequent changes to Zsh dot-files).
redot() {
    [[ "${#}" -eq 0 ]] || die 'expected no arguments'

    local ZESHY_SCRIPT_NAME='redot'
    utter "reloading user ${USER}..."

    # Force reimportation of all Zeshy components. Then, as the importations
    # below redefine all defined callables, destroy all such callables to
    # avoid desynchronization issues.
    #
    # Do this prior to calling the utter() function for obvious reasons.
    zeshy_initialize_imports
    kill_callables

    # void source_if_found(char *filename)
    #
    # Source the passed filename if found and readable by the current user.
    source_if_found() {
        [[ "${#}" -eq 1 ]] || die 'expected exactly one filename'
        local script_name="${1}"
        if [[ -f "${script_name}" && -r "${script_name}" ]]; then
            # Do not call the utter_import() function, as the above call to the
            # kill_callables() function already killed it.
            echo "redot: loading \"${script_name}\"..."
            source "${script_name}"
        fi
    }

    source_if_found '/etc/zsh/zprofile'
    source_if_found "${HOME}/.zprofile"
    source_if_found '/etc/zsh/zshrc'
    source_if_found "${HOME}/.zshrc"
    source_if_found '/etc/zsh/zlogin'
    source_if_found "${HOME}/.zlogin"
}

#FIXME: Obsolete?
# void redit(void)
#redit() {
#  if [ "$USER" = "root" ]
#  then sudo $EDITOR /etc/zsh/zshrc
#  else      $EDITOR $HOME/.zshrc
#  fi
#
#  redot
#}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyleft 2007-2010 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
