#!/usr/bin/env zsh
# ====================[ shell                              ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Shell. This Zeshy component implements shell-handling functionality.
# This includes:
#
# * Command-line argument parsing fuctionality for specifying and obtaining
#   shell script arguments. 
# * Reflection functionality for dynamically inspecting functions and aliases
#   like first-class constructs.

# --------------------( ALIASES                            )--------------------
# Mimes.
#FIXME: Still desirable?
#alias zsh_mime_load="zsh-mime-setup -f"
#alias zsh_mime_edit="${EDITOR} /etc/mailcap; zsh-mime-load"

# ....................{ TESTS                              }....................
# bool is_alias(char *alias)
#
# Return true if there exists an alias with the passed alias name.
is_alias() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one name"
    [[ $(whence -w "${1}") =~ ': alias$' ]]
}

# bool is_builtin(char *builtin)
#
# Return true if there exists a builtin with the passed alias name.
is_builtin() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one name"
    [[ $(whence -w "${1}") =~ ': builtin$' ]]
}

# bool is_function(char *function)
#
# Return true if there exists a function with the passed function name.
is_function() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one name"
    [[ $(whence -w "${1}") =~ ': function$' ]]
}

# ....................{ DEATH                              }....................
# void kill_callables(void)
#
# Destroy all existing aliases and functions. This is, of course, fairly
# destructive but does guard against desynchronization issues resulting from
# modification to this Zeshy installation (e.g., when upgrading).
kill_callables() {
    unalias    -m '*'
    unfunction -m '*'
}

# ....................{ REBIRTH                            }....................
# void redot(void)
#
# Resource all Zsh startup scripts in the same order Zsh sources these scripts
# on initial login for the current user. This function is of principal use for
# Zeshy developers (making frequent changes to Zeshy itself) as well as Zsh
# dot-file hackers (making frequent changes to Zsh dot-files).
redot() {
    [[ "${#}" -eq 0 ]] || die 'expected no arguments'

    local ZESHY_SCRIPT_NAME='redot'
    utter "reloading user ${USER}..."

    # Force reimportation of all Zeshy components. Then, as the importations
    # below redefine all defined callables, destroy all such callables to
    # avoid desynchronization issues.
    #
    # Do this prior to calling the utter() function for obvious reasons.
    zeshy_initialize_imports
    kill_callables

    # void source_if_found(char *filename)
    #
    # Source the passed filename if found and readable by the current user.
    source_if_found() {
        [[ "${#}" -eq 1 ]] || die 'expected exactly one filename'
        local script_name="${1}"
        if [[ -f "${script_name}" && -r "${script_name}" ]]; then
            # Do not call the utter_import() function, as the above call to the
            # kill_callables() function already killed it.
            echo "redot: loading \"${script_name}\"..."
            source "${script_name}"
        fi
    }

    source_if_found '/etc/zsh/zprofile'
    source_if_found "${HOME}/.zprofile"
    source_if_found '/etc/zsh/zshrc'
    source_if_found "${HOME}/.zshrc"
    source_if_found '/etc/zsh/zlogin'
    source_if_found "${HOME}/.zlogin"
}

# ....................{ REBIRTH ~ path                     }....................
# void PATH_init(void)
#
# Set the $PATH for the current user.
PATH_init() {
    # Prior $PATH, if any.
    local PATH_old=
    if [[ -n "${ROOTPATH}" ]] && is_superuser
    then PATH_old="${ROOTPATH}"
    else PATH_old="${PATH}"
    fi

    # Reset $PATH, having recorded the prior $PATH.
    PATH=

    # Append all user-agnostic paths.
    PATH_append '/usr/lib/colorgcc/bin'
    PATH_append '/usr/local/bin'
    PATH_append '/usr/bin'
    PATH_append '/bin'

    if is_superuser; then
        PATH_append '/usr/local/sbin'
        PATH_append '/usr/sbin'
        PATH_append '/sbin'
    fi

    # Append the prior $PATH.
    PATH+=":${PATH_old}"

    # Append the user-specific "~/bin/".
    PATH_append "${HOME}/bin"

    # Append Zeshy's "bin/".
    local zeshy_bin_dir="${ZESHY_HOME}/bin"
    PATH_append "${zeshy_bin_dir}"

    # Append each command in Zeshy's "bin/command/" installed on this machine,
    # matching all subdirectories of that directory via the "(/)" modifier.
    for zeshy_command_bin_dir in "${zeshy_bin_dir}/command"/*(/); do
        command_name=$(basename "${zeshy_command_bin_dir}")
        is_installed "${command_name}" && PATH_append "${zeshy_command_bin_dir}"
    done

    # Export!
    export PATH
}

# void PATH_append(char *dirname)
#
# Append the passed dirname onto the $PATH, if the corresponding directory
# exists, is readable, and has not already been appended.
PATH_append() {
    [[ "${#}" -eq 1 ]] || die 'expected exactly one argument'
    local dirname="${1}"

    if [[ -d "${dirname}" && -r "${dirname}" &&
        ! "${PATH}" =~ "(^|:)${dirname}($|:)" ]]; then
        if [[ -n "${PATH}" ]]
        then PATH+=":${dirname}"
        else PATH="${dirname}"
        fi
    fi
}

# ....................{ ARGUMENT PARSING                   }....................
# void parse_arguments(char *argument_spec1, char *argument_spec2, ...)
#
# Parse command-line arguments according to the passed list of argument
# specifications into the "${ARGS}" global associative array. For convenience,
# this function always registers the "-h" and "--help" options as valid options.
# This function delegates to the zparseopts() built-in function and thus expects
# argument specifications in the same (relatively simple) format: e.g.,
#
#   # Parse command-line options, with "--ad" a long option accepting no
#   # argument, "--crest" a long option requiring an argument, and "--wing" a
#   # long argument accepting an optional argument.
#   % set -- -d --ad --crest "glass arm shattering"
#   % parse_arguments d e -ad -crest: -wing::
#   % (( ${+ARGS[-d]} )) && echo 'option "-d" passed!'
#   option "-d" passed!
#   % (( ${+ARGS[-d]} + ${+ARGS[--ad]} )) &&
#   %     echo 'option "-d" AND/OR option "--ad" passed!'
#   option "-d" AND/OR option "--ad" passed!
#   % echo "-d: ${ARGS[-d]}\n--ad: ${ARGS[--crest]}\n--wing: ${ARGS[--wing]}"
#   -d:
#   --crest: glass arm shattering
#   --wing:
#
# For details, see the "zparseopts" section of "man zshmodules".
parse_arguments="zparseopts -D -E -A ARGS -- h -help" 

# void check_parsed_arguments(char *help_message)
#
# Check the set of all parsed arguments for unknown options. If the caller
# passed at least one unknown option OR the "-h" or "--help" options, die with
# the passed help message. This function expects to be called immediately after
# calling the parse_arguments() function.
check_parsed_arguments() {
    # If the immediately prior command failed, assume that was a call to the
    # parse_arguments() function and enable a boolean noting this fact.
    is_previous_command_succeeded && local is_parse_arguments_failed=1
    
    [[ ${#} -eq 1 ]] || die 'expected exactly one help string'
    local help_message="${1}"
    
    # If the caller passed the "-h" or "--help" options, die without error.
    if (( "${+ARGS[-h]}" + "${+ARGS[--help]}" )); then
        print "${help_message}"
        exit_with_success
    # If the caller passed unknown options, die without error.
    elif (( "${+is_parse_arguments_failed}" )); then
        print "${help_message}"
        exit_with_failure
    fi
}

# ....................{ PASS-BY-VALUE                      }....................
#FIXME: Document!
return_value() {
    [[ ${#} -ge 1 ]] || die 'expected at least one value'
    echo "echo \"${@}\"; return ${ZESHY_SUCCESS_CODE}"
}

return_array() {
    #FIXME: Test to make sure the passed array name actually is. How?
    [[ ${#} -ge 1 ]] || die 'expected exactly one array name'
    local array_name="${1}"
    echo "echo \"${${(@qqkv)array_name}[@]}\"; return ${ZESHY_SUCCESS_CODE}"
}

obtain_array() {
    #FIXME: Test to make sure the passed array name actually is. How?
    [[ ${#} -ge 2 ]] || die 'expected one array name and one runnable command'
    local array_name="${1}"; shift
    local command="${@}"

    #FIXME: Die if return code is failure?
    echo "local _zeshy_obtained_array_as_scalar=\$(${command}); "
    echo "${array_name}=( "${(Q@)${(z)_zeshy_obtained_array_as_scalar}}" ); "
    echo "unset _zeshy_obtained_array_as_scalar"
}

#FIXME: Obsolete.
# void PATH_append_if_root(char *pathname)
#
# Add the passed pathname to this user's "$PATH", if the above conditions hold
# and if this user is the superuser (i.e., root).
#PATH_append_if_root() {
#    is_superuser && PATH_append "${@}"
#}

# void redit(void)
#redit() {
#  if [ "$USER" = "root" ]
#  then sudo $EDITOR /etc/zsh/zshrc
#  else      $EDITOR $HOME/.zshrc
#  fi
#
#  redot
#}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2011 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
