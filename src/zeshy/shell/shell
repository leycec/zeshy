#!/usr/bin/env zsh
# ====================[ shell                              ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Shell, implementing shell-handling functionality: e.g.,
#
# * Command-line argument parsing fuctionality for specifying and obtaining
#   shell script arguments. 

# ....................{ DEPENDENCIES                       }....................
zimport zeshy/file/file
zimport zeshy/type/list
zimport zeshy/type/regex
zimport zeshy/type/string
zimport zeshy/type/type

# ....................{ SHUTDOWN                           }....................
# int exit_with_success(void)
# 
# Exit the current process with a successful return code.
exit_with_success() {
    die_unless_no_arguments
    exit ${ZESHY_SUCCESS_CODE}
}

# int exit_with_failure(void)
# 
# Exit the current process with a failure return code.
exit_with_failure() {
    die_unless_no_arguments
    exit ${ZESHY_FAILURE_CODE}
}

# ....................{ NAMESPACES                         }....................
# void disable_function(char *function_name)
#
# Globally disable the function with the passed name. This function remains
# defined but uncallable until reenabled with a call to enable_function().
alias disable_function='disable -f'

# void enable_function(char *function_name)
#
# Globally re-enable the function with the passed name, presumably previously
# disabled with a call to disable_function().
alias enable_function='enable -f'

#FIXME: Not fond of this name. Step away from the kill metaphor, Sir. How about
#something resembling "reset_shell_environment" or "revert_..." or
#"restore_..."? Also, destroy all Zeshy-specific globals excluding "ZESHY_HOME". 
# void kill_callables(void)
#
# Destroy all existing aliases and functions. This is, of course, fairly
# destructive but does guard against desynchronization issues resulting from
# modification to this Zeshy installation (e.g., when upgrading).
kill_callables() {
    unalias    -m '*'
    unfunction -m '*'
}

# ....................{ REDIRECTS                          }....................
# void quietly_as(char *username, char *command)
#
# Run the passed command as the passed user quietly (i.e., squelching output).
quietly_as() {
    run_as "${@}" 1>/dev/null 2>&1
#   run_as "${@}"
}

# char *stderr_to_stdout(char *command)
#
# Divert standard error to standard output.
stderr_to_stdout() {
    run "${(q)@}" 2>&1
}

# ....................{ ALIASES                            }....................
#FIXME: Technically, we can support interactive aliases on functions -- but only
#in somewhat roundabout fashion. We would need detect this to be an alias on a
#function (easy), then define a new function with the same implementation as the
#function to be replaced by such alias but with a new name, say,
#"${alias_name}____tmp" (perhaps easy; doesn't "which ${function_name}" provide
#us a function implementation which we could then eval into a new function with
#such placeholder name?), then replace the old with the new function name in the
#alias expansion (easy). It's a bit involved, but nothing too intractable.

# void interactive_alias(char *alias_specification)
#
# Declare the passed specification as an interactive alias, active only when the
# builtin or command to be aliased is run directly from an interactive shell.
# Due to implementation details, functions cannot currently be interactively
# aliased. Interactive aliases are inactive in non-interactive scripts and
# functions, and hence helpful for applying human-readable options on that
# builtin or command when run directly by a human. This function fails if the
# builtin or command to be aliased does not exist. See 
# interactive_alias_if_installed() for an alternative not failing in such cases.
#
# The alias specification format is identical to that of normal aliases: e.g.,
#
#   # Alias print() to sort arguments only when called interactively.
#   >>> print T M D
#   T M D
#   >>> interactive_alias print="print -o"
#   >>> print T M D
#   D M T
#   >>> print_indirectly() { print "${@}" }
#   >>> print_indirectly T M D
#   T M D
interactive_alias() {
    die_unless_arguments

    # Split the passed '='-divided alias specification into name and expansion.
    string alias_name alias_expansion
    split_first "${@}" 'alias_name' 'alias_expansion' '='
#   print "alias_name: ${alias_name}\nalias_expansion: ${alias_expansion}"

    # Die if the desired alias name is already a defined callable.
    is_callable "${alias_name}" and
        die "\"${alias_name}\" already defined as:\n"$(which "${alias_name}")

    #FIXME: This should be augmented to support builtins, as well.
    # If the builtin or command to be aliased does not exist, return with error.
    # To avoid costly exception handling on this frequently called helper
    # function, do not throw an exception.
    string command_name="$(get_first_word "${alias_expansion}")"
    if not is_installed "${command_name}"; then
        curse "\"${command_name}\" not installed"
        return_failure
    fi

    # Define the desired alias as a function of the same name, which:
    #
    # * Temporarily disables this function to prevent infinite recursion on
    #   subsequently calling a builtin or command of the same name.
    # * If:
    #   * This shell is interactive (thus excluding non-interactive scripts). 
    #   * This function was called directly from the command line (thus
    #     excluding non-interactive calls from function implementations). 
    #   Then runs the desired alias expansion.
    # * Otherwise, runs the desired builtin or command without aliasing.
    # * Reenables this function for subsequent use.
    eval "${alias_name}() {
    disable_function ${alias_name}
    if is_shell_interactive and is \${#funcstack} equals 1 si
    then ${alias_expansion} "\${@}"
    else ${command_name} "\${@}"
    fi
    enable_function ${alias_name}
}"
}

# void interactive_alias_if_installed(char *alias_specification)
#
# Declare the passed specification as an interactive alias only if the builtin
# or command to be aliased exists. This function is a no-nop if it does not.
interactive_alias_if_installed() { quietly interactive_alias "${@}" or true }

# ....................{ ARGUMENT PARSING                   }....................
# void parse_arguments(char *argument_spec1, char *argument_spec2, ...)
#
# Parse script (or function) arguments according to the passed zparseopts()-
# style argument specifications into map "ARGS". For details on specification
# format, search "man zshmodules" for "zparseopts". For convenience, "-h" and
# "--help" are always parsed as valid argument options: e.g.,
#
#   # Set fake command-line arguments.
#   >>> set -- -d --ad --crest "glass arm shattering"
#
#   # Parse such arguments as:
#   #
#   # * "--ad", a long option followed by no value.
#   # * "--crest", a long option followed by some value.
#   # * "--wing", a long option optionally followed by some value.
#   >>> parse_arguments d e -ad -crest: -wing::
#
#   # Validate such parsing.
#   >>> is_map_key 'ARGS' '-d' and print 'option "-d" parsed'
#   option "-d" parsed
#   >>> echo "-d: ${ARGS[-d]}\n--ad: ${ARGS[--crest]}\n--wing: ${ARGS[--wing]}"
#   -d:
#   --crest: glass arm shattering
#   --wing:
alias parse_arguments='zparseopts -D -E -A ARGS -- h -help' 

#FIXME: This no longer works as intended, due to TRAPZERR(). Contemplate. Ah.
#Yes. The simple solution is to require the parse_arguments() alias to pipe into
#this command: e.g.,
#   parse_arguments d e -ad -crest: -wing:: | check_arguments_with_help_string 'Help!'
#Bit awkward, but nothing too onerous. Alternatively, couldn't we define the
#parse_arguments() alias to simply temporarily disable TRAPZERR() by.... hmm; I
#don't believe the disable() builtin accepts a command to be run, unfortunately.

# void check_arguments_with_help_string(char *help_message)
#
# Check the set of all parsed arguments for unknown options. If the caller
# passed at least one unknown option OR the "-h" or "--help" options, die with
# the passed help message. This function expects to be called immediately after
# calling the parse_arguments() function.
check_arguments_with_help_string() {
    # If the immediately prior command failed, assume that was a call to the
    # parse_arguments() function and enable a boolean noting this fact.
    is_ok and bool is_parse_arguments_failed=1
    
    die_unless_one_argument 'expected exactly one help string'
    string help_message="${1}"
    
    # If the caller passed the "-h" or "--help" options, die without error.
    if (( "${+ARGS[-h]}" + "${+ARGS[--help]}" )); then
        print "${help_message}"
        exit_with_success
    # If the caller passed unknown options, die without error.
    elif (( "${+is_parse_arguments_failed}" )); then
        print "${help_message}"
        exit_with_failure
    fi
}

# ....................{ SOURCING                           }....................
#FIXME: Hmm. zimport() should probably do this by default for non-Zsh scripts.
# char *source_safely(char *script_filename)
#
# Safely source the passed shell script by emulating the shell environment
# expected by that script with default shell options and traps (e.g., a script
# "mandibles_of_joy.sh" expects a Bourne rather than Zsh shell environment).
source_safely() {
    die_unless_arguments 'expected at least one filename'

    # Localize and validate arguments. If the passed filename is not absolute,
    # resolve its absolute path by iteratively searching the current working
    # directory, "${PATH}", and "${FPATH}" (in that order).
    string script_filename="${1}"
    is_path_absolute "${script_filename}" or
        script_filename="$(which_script "${script_filename}")"
#   print "filetype: ${script_filetype}"

    # Identify the shell to be emulated. If the passed filename's type
    # identifies an emulatable shell, assume that. 
    string\
        script_filetype="$(get_filetype "${script_filename}")"\
        script_shell='zsh' script_shells='zsh|sh|ksh|csh'
    if is "${script_filetype}" == ${~script_shells} si; then
        script_shell="${script_filetype}"
    # Otherwise, attempt to match the passed file's first line for a shebang
    # referencing an emulatable shell. When no such match, default to "zsh".
    else
        string script_shebang_regex="^#.*[/ ](${script_shells})($| )"
        string script_shebang="$(head -1 "${script_filename}")"
        script_shell="$(match_first_group "${script_shebang_regex}" "${script_shebang}")" or true
#       print "regex::: ${script_shebang_regex}"
#       print "shebang: ${script_shebang}"
    fi
   
    # Safely source the passed shell script. Dismantled, this is:
    # 
    # * "-L", localizing the redefinition of TRAPZERR() to this function call.
    # * "-R", resetting shell options to the default expected by such shell.
    # * "TRAPZERR()", disabling error raising on builtin, command, and function
    #   failure, as expected by most scripts by default.
    # 
    # Do not redefine TRAPINT(), since printing stack traces on user interrupts
    # is universally useful and not conflicting with script expectations.
    emulate -LR "${script_shell}"
    TRAPZERR() { return $(( 128 + ${1} )) }
    PATH="${PATH}:${FPATH}" source "${@}"
}

# void redot(void)
#
# Resource all Zsh startup scripts in the same order Zsh sources these scripts
# on initial login for the current user. This function is of principal use for
# Zeshy developers (making frequent changes to Zeshy itself) as well as Zsh
# dot-file hackers (making frequent changes to Zsh dot-files).
redot() {
    die_unless_no_arguments
    string ZESHY_SCRIPT_NAME='redot'
    utter "reloading user ${USER}..."

    # Force reimportation of all Zeshy components. Then, as the importations
    # below redefine all defined callables, destroy all such callables to
    # avoid desynchronization issues.
    #
    # Do this prior to calling the utter() function for obvious reasons.
    zeshy_initialize_imports
    kill_callables

    # void source_if_found(char *filename)
    #
    # Source the passed filename if found and readable by the current user. Note
    # this function definition calls no Zeshy-specific aliases or functions; the
    # the above call to the kill_callables() function has already killed them.
    source_if_found() {
        string script_name="${1}"
        if [[ -f "${script_name}" && -r "${script_name}" ]]; then
            print "redot: loading \"${script_name}\"..."
            source "${script_name}"
        fi
    }

    source_if_found '/etc/zsh/zprofile'
    source_if_found "${HOME}/.zprofile"
    source_if_found '/etc/zsh/zshrc'
    source_if_found "${HOME}/.zshrc"
    source_if_found '/etc/zsh/zlogin'
    source_if_found "${HOME}/.zlogin"

    unfunction source_if_found
}

# ....................{ BIRTH ~ path                       }....................
# void PATH_init(void)
#
# Set the ${PATH} for the current user.
PATH_init() {
    die_unless_no_arguments

    # Store the prior ${PATH}, if any, for subsequent interpolation.
    string PATH_old=
    if is_nonempty "${ROOTPATH}" and is_superuser
    then PATH_old="${ROOTPATH}"
    else PATH_old="${PATH}"
    fi

    # Reset ${PATH} and conditionally append user-agnostic paths.
    PATH_append '/usr/lib/colorgcc/bin'
    PATH_append '/usr/local/bin'
    PATH_append '/usr/bin'
    PATH_append '/bin'

    # If root, conditionally append root-specific paths.
    if is_superuser; then
        PATH_append '/usr/local/sbin'
        PATH_append '/usr/sbin'
        PATH_append '/sbin'
    fi

    # Append the prior $PATH.
    PATH+=":${PATH_old}"

    # Append the user-specific "~/bin/".
    PATH_append "${HOME}/bin"

    # Append Zeshy's "bin/".
    string bin_dir="${ZESHY_HOME}/bin"
    PATH_append "${bin_dir}"

    # Append each command in Zeshy's "bin/command/" installed on this machine,
    # matching all subdirectories of that directory via the "(/)" modifier.
    string bin_command_dir bin_command_name
    for    bin_command_dir in "${bin_dir}/command"/*(/); do
        bin_command_name=$(basename "${bin_command_dir}")
        is_installed "${bin_command_name}" and PATH_append "${bin_command_dir}"
    done

    # Export!
    export PATH
}

# void PATH_append(char *dirname)
#
# Append the passed dirname onto the ${PATH}, if the corresponding directory
# exists, is readable, and has not already been appended.
PATH_append() {
    die_unless_one_argument 'expected exactly one dirname'
    string dirname="${1}"

    if is_dir "${dirname}" and\
        is -r "${dirname}" and not "${PATH}" =~ "(^|:)${dirname}($|:)" si; then
        if is_nonempty "${PATH}"
        then PATH+=":${dirname}"
        else PATH="${dirname}"
        fi
    fi
}

#FIXME: Obsolete.
#   die_unless_file "${script_filename}"
# elif is_file "${script_filename}"; then
#       match_first_group "${script_shebang_regex}" "${script_shebang}"

#
# * "-c", run the following command under such emulation.
#interactive_alias_if_installed au='aouauauauau'

#This is a no-op if the
# builtin or command to be aliased does not exist.
#
#   print "shell: ${script_shell}"
#   emulate -R ${script_shell} -c "ls"
#   emulate -R ${script_shell} -c "${@}"
#   emulate -LR "${script_shell}"
#   source ${@}

    # Disable shell strictness for the duration of the sourcing. External shell
    # scripts often assume laxness thus breaking under strictness.
#   setopt nounset            # attempting to expand unset parameters raises an error
#   setopt warn_create_global # attempting to set untyped parameters raises an error
 
    # Reenable shell strictness. 

#   of $(whence -w "${1}") =~ ': alias$' fo

#   if [[ "${type}" == none ]]; then
#       echo "not-found"
#   else
#   is "${variable_type}" or die "\"${1}\" not a variable"
#   if not is_array array; then local -A array; fi;
#   local array_name="${1:-array}"
#   die_unless_is_array "${array_name}"
#   echo "${(qqkv@P)array_name}"

#FIXME: Rename.
#alias Return_array='eval return_array'
#alias Obtain_array='eval obtain_array'
#alias Return_array='eval "$(return_array array)"'
#alias expand_stray_to_array='eval "$(obtain_array array ${stray})"'
#alias Obtain_array_from_command='eval "$(obtain_array array $(command))"'

    #FIXME: Die if return code is failure?
#   local command="${@}"
#   echo "local _zeshy_obtained_array_as_scalar=\$(${command}); "
#   echo "${array_name}=( "${(Q@)${(z)_zeshy_obtained_array_as_scalar}}" ); "
#   echo "unset _zeshy_obtained_array_as_scalar"

#   echo "${${(qqkv@P)array_name}[@]}"
#   echo "${${(@qqkvP)array_name}[@]}"
#   "echo \"${${(@qqkvP)array_name}[@]}\""
#   echo "echo \"${${(@qqkvP)array_name}[@]}\""   # ; return_success"

#   echo "string_array=${@}"
#   echo "${array_name}="'"'"${(z)@}"'"'
#   echo "${array_name}=( ${(Q)${(z)@}} )"
#   echo "${array_name}=( \"${(Q@)${(z)string_array}}\" )"
#   echo "${array_name}=( ${(Q@)${(z)string_array}} )"
#   echo "${array_name}=( "${(Q@)${(z)@}}" )"

#obtain_array_from_command() {
#    #FIXME: Test to make sure the passed array name actually is. How?
#    die_unless_at_least_two_arguments 'expected one array name and one runnable command'
#    local array_name="${1}"; shift
#    local command="${@}"
#
#    echo "${array_name}=( "${(Q@)${(z)_zeshy_obtained_array_as_scalar}}" ); "
#
#    #FIXME: Die if return code is failure?
#   echo "local _zeshy_obtained_array_as_scalar=\$(${command}); "
#   echo "${array_name}=( "${(Q@)${(z)_zeshy_obtained_array_as_scalar}}" ); "
#   echo "unset _zeshy_obtained_array_as_scalar"
#
#    # Let's dismantle this, one to two parameter expansion flags at a time:
#    # * 'z' splits the passed string into a numeric array of words.
#   echo "${array_name}=( ${(z)string_array} )"
#}

#oa() {
#    #FIXME: Test to make sure the passed array name actually is. How?
#    die_unless_at_least_two_arguments 'expected one array name and one stringified array'
#    local string_array="${@}"
#
#    # Let's dismantle this, one to two parameter expansion flags at a time:
#    # * 'z' splits the passed string into a numeric array of words.
#    echo "${array_name}=( ${(z)string_array} )"
#}

    # * '@' splits the array of such words into (still quote-protected!) words.
    # * 'Q' strips the single quotes protectively added by the prior 'qq' flag.
    # * The second '@' refers to the passed 
# ....................{ PASS-BY-VALUE                      }....................
#FIXME: Document!
#return_value() {
#   [[ ${#} -ge 1 ]] || die 'expected at least one value'
#   echo "echo \"${@}\"; return ${ZESHY_SUCCESS_CODE}"
#}

# void PATH_append_if_root(char *pathname)
#
# Add the passed pathname to this user's "$PATH", if the above conditions hold
# and if this user is the superuser (i.e., root).
#PATH_append_if_root() {
#    is_superuser && PATH_append "${@}"
#}

# void redit(void)
#redit() {
#  if [ "$USER" = "root" ]
#  then sudo $EDITOR /etc/zsh/zshrc
#  else      $EDITOR $HOME/.zshrc
#  fi
#
#  redot
#}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
