#!/usr/bin/env zsh
# ====================[ inspect                            ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Inspect. This Zeshy component implements inspection (i.e., "reflection")
# functionality for dynamically inspecting Zsh aliases, functions, variables,
# and all other first-class constructs.

# ....................{ TYPES                              }....................
# bool is_alias_or_function(char *name)
#
# Return true if there exists an alias or function with the passed name.
is_alias() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one name"
    [[ $(whence -w "${1}") =~ ': (alias|function)$' ]]
}

# bool is_alias(char *alias_name)
#
# Return true if there exists an alias with the passed alias name.
is_alias() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one alias name"
    [[ $(whence -w "${1}") =~ ': alias$' ]]
}

# bool is_function(char *function_name)
#
# Return true if there exists a function with the passed function name.
is_function() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one function name"
    [[ $(whence -w "${1}") =~ ': function$' ]]
}

#FIXME: A very interesting snippet demonstrating callstack inspection. Keep me.
# Return "${SCRIPT_NAME}", if defined; otherwise, return the string name of the
# function that called the function that called this function (i.e., the
# function two calls earlier in the function callstack). In the latter case, as
# this function is an internal function intended to be called only by the
# functions above, we are guaranteed of our caller being one of the functions
# above. Then the caller of that function is precisely the function two calls
# earlier in the callstack. (Insert magical handwaving here.)
    #FIXME: Hmm. How to reference the global $0 from within function scope?
    # If the current process is not ZSH itself, then it must be an external ZSH
    # script. In this case, the script name is the basename of the invoked file.
#   elif [[  $(basename "$0") != "zsh" ]]; then
#       echo $(basename "$0")
#   else
#       # Ignore all functions pertaining to I/O and error handling. Since the first
#       # element of "$funcstack" is the name of the current function (and we are
#       # not particularly interested in that), skip that by setting "I=2".
#       local I
#       for (( I=2; ${I} <= ${#funcstack}; I=${I}+1 )); do
#           case ${funcstack[${I}]} in
#               die*|curse*|utter*) continue ;;
#               *) break ;;
#           esac
#       done
#
#       # If after ignoring non-relevant functions there still exists at least one
#       # function on the callstack, print the function's name. (This is our man.)
#       if [[ ${I} -le ${#funcstack} ]]
#       then echo "${funcstack[${I}]}"
#       # Otherwise, print a placeholder function name.
#       else echo "zsh"
#       fi
#   fi

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyleft 2007-2010 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
