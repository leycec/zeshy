#!/usr/bin/env zsh
# ====================[ list                               ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy List, implementing map (i.e., associative array) and list (i.e.,
# array) functionality.
#
# --------------------( TODO                               )--------------------
# * Functions should probably be calling die_unless_map_or_list() to guarantee 
#   the passed arguments are of proper type.

# ....................{ DEPENDENCIES                       }....................
zimport zeshy/shell/shell

# ....................{ EXCEPTIONS                         }....................
# void die_unless_map_or_list(
#   char *map_or_list_name, char *error_message = 'not a map or list')
#
# Die unless the variable with the passed name is a map or list.
die_unless_map_or_list() {
    die_unless_one_or_two_arguments\
        'expected one map or list name and optional error message'
    is_map_or_list "${1}" or die "${2:-\"${1}\" not a map or list}"
}

# void die_unless_map(char *map_name, char *error_message = 'not a map')
#
# Die unless the variable with the passed name is a map.
die_unless_map() {
    die_unless_one_or_two_arguments\
        'expected one map name and optional error message'
    is_map "${1}" or die "${2:-\"${1}\" not a map}"
}

# void die_unless_list(char *list_name, char *error_message = 'not a list')
#
# Die unless the variable with the passed name is a list.
die_unless_list() {
    die_unless_one_or_two_arguments\
        'expected one map name and optional error message'
    is_list "${1}" or die "${2:-\"${1}\" not a list}"
}

# ....................{ REFLECTION                         }....................
# bool is_map_or_list(char *variable_name)
#
# Return true if the variable with the passed name is a map or list.
is_map_or_list() {
    die_unless_one_argument 'expected exactly one variable name'
    
    is $(get_type "${1}") == (list|array|association)* si
}

# bool is_map(char *variable_name)
#
# Return true if the variable with the passed name is a map (i.e.,
# associative array).
is_map() {
    die_unless_one_argument 'expected exactly one variable name'
    
    # Global maps have type "association" and local maps "association-local".
    # Match both.
    is $(get_type "${1}") == association* si
}

# bool is_list(char *variable_name)
#
# Return true if the variable with the passed name is a list (i.e., array).
is_list() {
    die_unless_one_argument 'expected exactly one variable name'
    
    # Global lists have type "list", local lists "list-local", and internal
    # structures (e.g., "${path}") "array" or "array-special". Match all.
    is $(get_type "${1}") == (list|array)* si
}

# ....................{ ACCESSORS                          }....................
alias get_map_size=get_map_or_list_size
alias get_list_size=get_map_or_list_size

# int get_map_or_list_size(char *map_or_list_name)
#
# Get the number of elements in the map or list corresponding to the passed 
# variable name.
get_map_or_list_size() {
    die_unless_one_argument 'expected exactly one map or list name'
    die_unless_map_or_list "${1}"

    # Dismantled, this is:
    #
    # * '1', the passed map or list name.
    # * 'P', the scalar name of the desired map or list in the caller's scope.
    # * '@', as a map or list rather than as a scalar name.
    # * '#', the size of this map or list.
    print "${#${(@P)1}}"
}

# ....................{ CONVERTERS                         }....................
# char *string_to_list(char *string, char *list_name, char separator = '')
#
# Split the passed string on the passed separating character defaulting to
# "${SH_WORD_SPLIT}" (typically, a space) into a list of the results: e.g.,
#
#     >>> list odj
#     >>> string_to_list 'Obseqious\Deep\Journeys' 'odj' '\'
#     >>> print "${odj[1]}"
#     Obseqious
string_to_list() {
    die_unless_two_or_three_arguments\
        'expected one string, list name, and optional separator'

    # Localize and validate arguments.
    string text="${1}" list_name="${2}" separator="${3}" 
    die_unless_list "${list_name}"
    is "${#separator}" -le 1 si or
        die "separator \"${separator}\" not a single character"

    # If the caller passed no separator, default to word-splitting.
    if is_unset "${separator}"
    then eval ${list_name}'=( ${=text} )'
    # If the separator is a colon, pass that to flag "s" delimited by periods.
    elif is "${separator}" == ':' si
    then eval ${list_name}'=( ${(s.:.)text} )'
    # Otherwise, dynamically construct and evaluate an expression passing the
    # separator to flag "s" delimited by colons.
    else eval ${list_name}'=( ${(s:'${separator}':)text} )'
    fi
}

# ....................{ PASS-BY-VALUE                      }....................
# char *return_list(char *list_name = 'list')
#
# Reduce the list corresponding to the passed list name to a scalar string.
# Functions may safely return this string to callers, who may losslessly expand
# the string back into its original list by calling either expand_List() or
# expand_list(): e.g.,
#
#   # A function returning a stringified list.
#   a_ray_of_unlit_hope() {
#     map map=( 'key 1' 'value 1' 'key 2' 'value 2' )
#     echo "original list: ${map[@]}"
#     return_map map
#   }
#
#   # A convenient function expanding this stringified list back into a list.
#   a_day_of_sunlit_sadness() {
#     string List="$(a_ray_of_unlit_hope)"'
#     expand_List
#     echo "returned list: ${list[@]}"  # identical to the original list!
#   }
#
#   # An equivalent function expanding the stringified list back into a list.
#   a_day_of_sunlit_sadness() {
#     local -A list
#     eval 'expand_list list "$(a_ray_of_unlit_hope)"'
#     echo "returned list: ${list[@]}"  # identical to the original list!
#   }
return_list() {
    die_unless_at_most_one_argument 'expected at most one list name'

    # Let's dismantle this, one to two parameter expansion flags at a time:
    #
    # * '1:-list' expands to the passed list name or 'list' if no such name
    #   was passed.
    # * 'P' transitively expands this name to the actual name of the desired
    #   associative list in the caller's scope.
    # * '@' interprets this expansion as a list rather than scalar.
    # * 'kv' reduces this list to a scalar string concatenating all list
    #   element names and values, delimited by whitespace.
    # * 'qq' protectively embeds all reserved shell characters in such names
    #   and values in single quotes.
    print "${(qqkv@P)1:-list}"
}

# void expand_List()
#
# Expands the stringified list "List" into the list "list". This alias is a
# convenience simplifying the more generalized expand_list() function. See the
# reduce_list() function for an example.
alias expand_List='
    is "${List}" or die "No \"List\" defined";
    eval "$(expand_list list ${List})"'

# void expand_list(char *list_name, char *string_list)
#
# Expands the second parameter, a scalar string produced by return_list(), into
# the list corresponding to the passed list name. Unlike return_list(), this
# function must by dynamically evaluated by the eval() built-in. See the
# expand_List() alias for a simple alternative.)
expand_list() {
    die_unless_at_least_two_arguments 'expected one list name and one stringified list'
    string list_name="${1}"; shift

    # Let's dismantle this, one parameter expansion flag at a time:
    # * '@' expands to all remaining passed parameters: the stringified list.
    # * 'z' splits the stringified list into a numeric list of words,
    #   effectively undoing the prior 'kv' flag.
    print "${list_name}=( ${(z)@} )"
}

# Map-specific analogues of the above list-specific functions.
alias return_map="return_list"
alias expand_map="expand_list"
alias expand_Map='
    is "${Map}" or die "No \"Map\" defined";
    eval "$(expand_map map ${Map})"'

#FIXME: Obsolete.
# ....................{ INITIALIZATION                     }....................
#   die_unless_two_to_three_arguments\
#       'expected one string name, one list name, and one optional separator'
#   string string_name="${1}" list_name="${2}" separator="${3}"

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
