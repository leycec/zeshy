#!/usr/bin/env zsh
# ====================[ string                             ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy String, implementing string-handling functionality.
#
# --------------------( SEE ALSO                           )--------------------
# "man zshexpn/FILENAME GENERATION"
#     Glob syntax details.

# ....................{ DEPENDENCIES                       }....................
zimport zeshy/type/type

# ....................{ EXCEPTIONS                         }....................
# void die_unless_string(char *map_name, char *error_message = 'not a string')
#
# Die unless the variable with the passed name is a string.
die_unless_string() {
    die_unless_one_or_two_arguments\
        'expected one variable name and optional error message'
    is_string "${1}" or die "${2:-\"${1}\" not a declared string}"
}

# void die_unless_char(char *map_name, char *error_message = 'not a character')
#
# Die unless the variable with the passed name is a single character.
die_unless_char() {
    die_unless_one_or_two_arguments\
        'expected one variable name and optional error message'
    is_char "${1}" or die "${2:-\"${1}\" not a declared character}"
}

# ....................{ TESTS                              }....................
# bool is_string(char *variable_name)
#
# Return true if the variable with the passed name is a string.
is_string() {
    die_unless_one_argument 'expected exactly one variable name'
    is $(get_type "${1}") == scalar* si
}

# bool is_char(char *variable_name)
#
# Return true if the variable with the passed name is a single character.
is_char() {
    die_unless_one_argument 'expected exactly one variable name'
    is_string "${1}" and is $(get_string_length "${(P)1}") -eq 1 si
}

# bool is_glob(char *string)
#
# Return true if the passed string resembles a glob expression (i.e.,
# contains at least one glob-reserved character).
is_glob() {
    die_unless_one_argument 'expected exactly one string'
    is "${1}" == *[\[\]\<\>\(\)\|+*?#~^]* si
}

# ....................{ GETTERS                            }....................
# int get_string_length(char *string)
#
# Get the length of the passed string in multibyte characters.
get_string_length() {
    die_unless_one_argument 'expected exactly one string'
    print "${#1}"
}

# int get_number_of_glob_matches(char *glob_expression, char *string)
#
# Return the number of glob matches in the passed string. Among other uses, this
# function counts occurrences of characters and substrings in strings: e.g.,
#
#     >>> get_number_of_glob_matches '[bsz]o' 'bosozoku'
#     3
#
# See also get_number_of_matches(), similar but slightly more efficient by
# matching via one regular rather than multiple glob expressions.
get_number_of_glob_matches() {
    die_unless_two_arguments\
        'expected exactly one glob expression and one string'
    string glob="${1}" text="${2}"

    # If the passed string is empty, print 0 to avoid nonsense.
    if is_empty "${text}"; then
        print 0
    # If the passed glob expression contains no glob-reserved characters (e.g.,
    # *, /), we optimize match counting by noting the size of each match to be
    # "${#glob}". The difference between the original string and a string with
    # all such matches removed divided by the length of each match yields the
    # number of matched substrings. This obscene logic comes courtesy
    # LinuxQuestions user "unSpawn" in the following thread:
    #
    #     http://www.linuxquestions.org/questions/linux-newbie-8/bash-command-to-count-particular-character-in-a-string-645005/
    elif not is_glob "${glob}"; then
        string text_matches_deleted="${text//${~glob}/}"
        print $(( (${#text} - ${#text_matches_deleted}) / ${#glob} ))
    # Otherwise, perform brute-force iteration.
    #
    # Sadly, neither sed, awk, grep, or zsh itself have any coherent means of
    # matching individual occurences of a substring. Fortunately, zsh does have
    # a simple mechanism for *ELIMINATING* such matches. Hence, we do so
    # iteratively until all such matches are eliminated.
    else
        string text_old= 
        integer matches=-1
        until is "${text_old}" == "${text}" si; do
            (( matches++ ))
            text_old="${text}"
            text="${text/${~glob}/}"
        done
        print "${matches}"
    fi
}

# ....................{ GETTERS ~ lines                    }....................
# char *get_first_line(char *string)
#
# Get the first line from the passed string.
alias get_first_line=get_line

# char *get_first_lines(char *string, int last_line_number = 1)
#
# Get lines [1, "last_line_number"] inclusive from the passed string.
get_first_lines() {
    die_unless_at_least_one_argument\
        'expected exactly one string and one line number'
    print "${1}" to head --lines="${2:-1}"
}

# char *get_line(char *string, int line_number = 1)
#
# Get the line corresponding to the passed line number from the passed string.
get_line() {
    die_unless_at_least_one_argument\
        'expected exactly one string and one line number'
    print "${1[(f)${2:-1}]}"
}

# char *get_line_length(char *string)
#
# Get the number of lines in the passed string.
get_line_length() {
    die_unless_one_argument 'expected exactly one string'
    print "${1}" | wc --lines 
}

# ....................{ GETTERS ~ words                    }....................
# char *get_first_word(char *string)
#
# Get the first word from the passed string.
alias get_first_word=get_word

# char *get_word(char *string, int word_number = 1)
#
# Get the word corresponding to the passed word number from the passed string.
get_word() {
    die_unless_at_least_one_argument\
        'expected one string and optional word number'
    print "${1[(w)${2:-1}]}"
}

# char *get_number_of_words(char *string)
#
# Get the number of words in the passed string.
get_number_of_words() {
    die_unless_one_argument 'expected exactly one string'
    print "${1}" | wc --words 
}

# ....................{ SPLITTING                          }....................
# void split_first(
#   char *string, char *variable_name1, char *variable_name2, char *separator)
#
# Split the passed string on the first substring of the passed separator into:
#
# * The string with the former name to the substring preceding such separator.
# * The string with the latter name to the substring following such separator.
#
# The separator may be of any non-zero length: e.g.,
#
#     >>> string prefix suffix
#     >>> split_first 'wolfs==head==society' 'prefix' 'suffix' '==' 
#     >>> print "prefix: ${prefix}\nsuffix: ${suffix}"
#     prefix: wolfs
#     suffix: head==society
# 
# See split_all() for alternative splitting on all substrings.
split_first() {
    die_unless_four_arguments\
        'expected exactly one input string, prefix and suffix output variable names, and separator'

    # Localize arguments.
    string source_text="${1}"\
        target_name_prefix="${2}" target_name_suffix="${3}" separator="${4}"

    # Validate arguments.
    die_unless_string "${target_name_prefix}"
    die_unless_string "${target_name_suffix}"

    # Fail if the passed string contains no such separator.
    is "${source_text}" == *"${separator}"* si or
        die "\"${source_text}\" contains no \"${separator}\" to be split on"

    # Split.
    eval "${target_name_prefix}=\"${source_text%%${separator}*}\""
    eval "${target_name_suffix}=\"${source_text#*${separator}}\""
}

# char *split_all(char *string, char *variable_name, char separator = ' ')
#
# Split the passed string on all substrings of the passed separating character
# into a list of the results. If no separator is passed, split words by default
# parsing (i.e., first by quote- and then whitespace-delimited words): e.g.,
#
#     >>> list array
#     >>> split_all 'Obseqious/Deep/Journeys' array '/'
#     >>> print "${array[1]}"
#     Obseqious
#     >>> split_all '"Contumely Hard" Climaxes' array
#     >>> print "${array[1]}"
#     Contumely Hard
#
# See split_first() for alternative splitting into string variables.
split_all() {
    die_unless_two_or_three_arguments\
        'expected one string, list variable name, and optional separator'

    #FIXME: We also should also validate the passed variable
    # Localize and validate arguments.
    string text="${1}" list_name="${2}" separator="${3}" 
    die_unless_list "${list_name}"
    die_unless_char 'separator'

    # If the caller passed no separator, default to word splitting.
    if is_empty "${separator}"
    then eval ${list_name}'=( ${(z)text} )'
    # If the separator is a colon, pass that to flag "s" delimited by periods.
    elif is "${separator}" == ':' si
    then eval ${list_name}'=( ${(s.:.)text} )'
    # Otherwise, dynamically construct and evaluate an expression passing the
    # separator to flag "s" delimited by colons.
    else eval ${list_name}'=( ${(s:'${separator}':)text} )'
    fi
}

# ....................{ CONVERTERS                         }....................
# char *to_lowercase(char *string)
#
# Convert the passed string to all lowercase: e.g.,
#
#     >>> to_lowercase "The Wind in the Pillows"
#     the wind in the pillows
to_lowercase() {
    die_unless_one_argument 'expected exactly one string'
    print "${(L)1}"
}

# char *to_uppercase(char *string)
#
# Convert the passed string to all uppercase: e.g.,
#
#     >>> to_uppercase "The Pyre of My Loins"
#     THE PYRE OF MY LOINS
to_uppercase() {
    die_unless_one_argument 'expected exactly one string'
    print "${(U)1}"
}

# ....................{ SETTERS                            }....................
# char *suffix_if_not_already(char *string, char *suffix)
#
# Suffix the passed string with the passed suffix, if not already: e.g.,
#
#     >>> suffix_if_not_already '/habitat/failing/flailing/habits' '/'
#     /habitat/failing/flailing/habits/
suffix_if_not_already() {
    die_unless_two_arguments 'expected exactly one string and one suffix'
    print "${1%${2}}${2}"
}

#FIXME: Obsolete.
#   is_set "${target_name_prefix}" or string ${target_name_prefix}
#   is_set "${target_name_suffix}" or string ${target_name_suffix}
#   is_set "${list_name}" or list "${list_name}"

#   die_unless_string "${target_name_prefix}"
#   die_unless_string "${target_name_suffix}"

#Compare the lengths of the original and resulting strings.
#   local string_matches_deleted="${string//${~glob}/}"
#   local glob_characters="${#glob//}"
#   print $(((${#string} - ${#string_matches_deleted}) / ${#glob}))
#   print "string_newlined: ${string_newlined}"

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
