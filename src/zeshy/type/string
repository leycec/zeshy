#!/usr/bin/env zsh
# ====================[ string                             ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy String, implementing string-handling functionality.
#
# --------------------( SEE ALSO                           )--------------------
# "man zshexpn/FILENAME GENERATION"
#     Glob syntax details.

# ....................{ REFLECTION                         }....................
# bool is_string(char *variable_name)
#
# Return true if the variable with the passed name is a string.
is_string() {
    die_unless_one_argument 'expected exactly one variable name'
    is $(get_type "${1}") == scalar* si
}

# bool is_char(char *string)
#
# Return true if the passed string is exactly one character long.
is_char() {
    die_unless_one_argument 'expected exactly one string'
    is $(get_string_length "${1}") -eq 1 si
}

# bool is_glob(char *string)
#
# Return true if the passed string resembles a glob expression (i.e.,
# contains at least one glob-reserved character).
is_glob() {
    die_unless_one_argument 'expected exactly one string'
    is "${1}" == *[\[\]\<\>\(\)\|+*?#~^]* si
}

# ....................{ ACCESSORS                          }....................
# int get_string_length(char *string)
#
# Get the length of the passed string in multibyte characters.
get_string_length() {
    die_unless_one_argument 'expected exactly one string'
    print "${#1}"
}

# ....................{ ACCESSORS ~ matches                }....................
# int get_number_of_glob_matches(char *glob_expression, char *string)
#
# Return the number of glob matches in the passed string. Among other uses, this
# function counts occurrences of characters and substrings in strings: e.g.,
#
#     >>> get_number_of_glob_matches '[bsz]o' 'bosozoku'
#     3
#
# See also get_number_of_matches(), similar but slightly more efficient by
# matching via one regular rather than multiple glob expressions.
get_number_of_glob_matches() {
    die_unless_two_arguments\
        'expected exactly one glob expression and one string'
    string glob="${1}" text="${2}"

    # If the passed string is empty, print 0 to avoid nonsense.
    if not is_nonempty "${text}"; then
        print 0
    # If the passed glob expression contains no glob-reserved characters (e.g.,
    # *, /), we optimize match counting by noting the size of each match is
    # guaranteed to be "${#glob}" and that, therefore, the lengths of the
    # original and resulting strings divided by the length of each match yields
    # the number of matched substrings. ("Voila!")
    #
    # This exceptionally clever (and frankly obscene) logic comes inspired by
    # LinuxQuestions user "unSpawn" via this thread:
    #
    #     http://www.linuxquestions.org/questions/linux-newbie-8/bash-command-to-count-particular-character-in-a-string-645005/
    elif not is_glob "${glob}"; then
#       print 'optimizing!'
        integer string_matches_deleted="${text//${~glob}/}"
        print $(( (${#text} - ${#text_matches_deleted}) / ${#glob} ))
    # Otherwise, we perform brute-force iteration.
    #
    # Sadly, neither sed, awk, grep, or zsh itself have any coherent means of
    # matching individual occurences of a substring. Fortunately, zsh does have
    # a simple mechanism for *ELIMINATING* such matches. Hence, we do so
    # iteratively until all such matches are eliminated.
    else
        integer text_old glob_matches='-1'
        until is "${text}" == "${text}" si do
            (( glob_matches++ ))
            text_old="${text}"
            text="${text/${~glob}/}"
        done
        print "${glob_matches}"
    fi
}

# ....................{ ACCESSORS ~ lines                  }....................
# Aliases.
alias get_first_line=get_line

# char *get_first_lines(char *string, int last_line_number = 1)
#
# Get lines [1, "last_line_number"] inclusive from the passed string.
get_first_lines() {
    die_unless_at_least_one_argument\
        'expected exactly one string and one line number'
    string text="${1}"
    integer last_line_number="${2:-1}"
    print "${text}" | head --lines="${last_line_number}"
}

# char *get_line(char *string, int line_number = 1)
#
# Get the line corresponding to the passed line number from the passed string.
get_line() {
    die_unless_at_least_one_argument\
        'expected exactly one string and one line number'
    string text="${1}"
    integer line_number="${2:-1}"
    print ${text[(f)${line_number}]}
}

# char *get_line_count(char *string)
#
# Get the number of lines in the passed string.
get_number_of_lines() {
    die_unless_one_argument 'expected exactly one string'
    print "${1}" | wc --lines 
}

# ....................{ ACCESSORS ~ words                  }....................
# Aliases.
alias get_first_word=get_word

# char *get_word(char *string, int word_number = 1)
#
# Get the word corresponding to the passed word number from the passed string.
get_word() {
    die_unless_at_least_one_argument\
        'expected exactly one string and one word number'
    string text="${1}"
    integer word_number="${2:-1}"
    print ${text[(w)${word_number}]}
}

# char *get_number_of_words(char *string)
#
# Get the number of words in the passed string.
get_number_of_words() {
    die_unless_one_argument 'expected exactly one string'
    print "${1}" | wc --words 
}

# ....................{ CONVERTERS ~ case                  }....................
# char *to_lowercase(char *string)
#
# Convert the passed string to all lowercase: e.g.,
#
#     >>> to_lowercase "The Wind in the Pillows"
#     the wind in the pillows
to_lowercase() {
    die_unless_one_argument 'expected exactly one string'
    print "${(L)1}"
}

# char *to_uppercase(char *string)
#
# Convert the passed string to all uppercase: e.g.,
#
#     >>> to_uppercase "The Pyre of My Loins"
#     THE PYRE OF MY LOINS
to_uppercase() {
    die_unless_one_argument 'expected exactly one string'
    print "${(U)1}"
}

# ....................{ MUTATORS                           }....................
# char *suffix_if_not_already(char *string, char *suffix)
#
# Suffix the passed string with the passed suffix, if not already: e.g.,
#
#     >>> suffix_if_not_already '/habitat/failing/flailing/habits' '/'
#     /habitat/failing/flailing/habits/
suffix_if_not_already() {
    die_unless_two_arguments 'expected exactly one string and one suffix'
    print "${1%${2}}${2}"
}

#FIXME: Obsolete.
#Compare the lengths of the original and resulting strings.
#   local string_matches_deleted="${string//${~glob}/}"
#   local glob_characters="${#glob//}"
#   print $(((${#string} - ${#string_matches_deleted}) / ${#glob}))
#   print "string_newlined: ${string_newlined}"

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
