#!/usr/bin/env zsh
# ====================[ exherbo                            ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Exherbo. This Zeshy component implements Exherbo Linux-specific
# functionality.

# ....................{ CONFIGURATION                      }....................
# Note that default command-line arguments for Paludis are defined via the
# ${PALUDIS_OPTIONS} environment variable, so as to expose these arguments to
# these aliases and functions as well as dependent wrappers.
export INQUISITIO_OPTIONS="\
--log-level warning \
--matcher pcre \
"

export PALUDIS_OPTIONS="\
--continue-on-failure if-satisfied \
--dl-blocks accumulate \
--dl-circular error \
--dl-downgrade warning \
--dl-new-slots always \
--dl-reinstall never \
--dl-reinstall-scm never \
--dl-reinstall-targets auto \
--dl-suggested show \
--dl-upgrade always \
--log-level warning \
--multitask \
--show-reasons summary \
--show-use-descriptions all \
--show-package-descriptions new \
--with-unused-dependencies \
"

# ....................{ ALIASES                            }....................
alias cavfc="cave fix-cache"
alias cavfl="cave fix-linkage --execute"
alias cavn="cave-news"
alias cavs="cave show"
alias cavse="cave search"
alias cavsy="cave sync"
alias cavi="cave resolve --execute"
alias cavii="cavi --uninstalls-may-break --permit-downgrade"
alias ec="eclectic"
alias ecci="eclectic config interactive"
alias pal="paludis"
#alias pali="paludis --install"
alias palo="paludis --owner"
alias pals="paludis --sync"
alias palu="paludis --uninstall"
alias palq="paludis-query"
alias palar="paludis-add-repository"
alias palib="pali --dl-blocks discard"
alias palip="pali --pretend"
alias palit="palric; pali"
alias palupuu="palu --permit-unsafe-uninstalls"
alias palsedr="paludis-sed-recursive"
alias palisupi="paludis-resume-install"
alias palisupt="paludis-resume-test"

# ....................{ ECLECTIC                           }....................
function eclectic-select-gcj()     { set_eclectic_jdk gcj }
function eclectic-select-icedtea() { set_eclectic_jdk icedtea }

# void set_eclectic_jdk(char *grep_pattern)
#
# Sets the currently selected JDK to the JDK matching the passed grep pattern.
set_eclectic_jdk() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one grep pattern"

    local JDK_NAME=$(get_eclectic_jdk_name ${*})
    utter "selecting ${JDK_NAME} as the current JDK..."
    try eclectic java-jdk set ${JDK_NAME}
    try eclectic java-jre set ${JDK_NAME}
}

# void get_eclectic_jdk_name(char *grep_pattern)
#
# Returns the name of a selectable JDK matching the passed grep pattern.
get_eclectic_jdk_name() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one grep pattern"
    eclectic --no-colour java-jdk list | \
        command grep --max-count=1 "${1}" | \
        command awk '{printf "%s", $2}'
}

# ....................{ CAVE                               }....................
cave-news() {
    eselect news read all | less
}

# ....................{ PALUDIS                            }....................
#FIXME: Rename all uses of "paludis-" with "exherbo-", and all uses of "pal"
#with "exh". (This generalizes the move away from Paludis to Cave.)

# void paludis-add-repository(char *repository_name)
# 
# Add a new Exherbo repository corresponding to the passed repository name.
#
# This function expects a repository name as listed by the following command:
# 
#     cave show -t package 'repository/*'
#
# That is, it expects the repository to be registered under either the
# "::unavailable" or "::unavailable-unofficial" pseudo-repositories. 
paludis-add-repository() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one repository name"
    cave resolve repository/"${1}" --execute
}

paludis-update-world() {
    paludis --install --dl-reinstall if-use-changed world
}

paludis-sed-recursive() {
    [[ "${#}" -eq 2 ]] ||
        die "expected exactly one search pattern and one replace pattern"

    set_git_globals
    mv-pcre -cr "${1}" "${2}" "${GIT_ROOT}"/{exlibs,packages}/**/*.{exlib,exheres-0}
}

# Query for a specific exheres.
paludis-query() {
    paludis --query --show-metadata $* | less
}

# Resume a failed install from the install phase, rather than from the
# beginning. This is generally safe - but should be used with caution. Also,
# note that, when Paludis fails, it generally emits a "Resume command." This is
# not what you think, however: calling this command actually does very little
# that the vanilla install command does not already do. Most saliently, this
# "Resume command" does not resume a failed install from the install phase. It
# bloody starts over! This has bit me several times, but no more.
paludis-resume-install() {
    utter "forcefully skipping to the install phase for '$1'..."
    paludis --install --skip-until-phase setup --abort-at-phase unpack "$1"
    paludis --install --skip-until-phase install "$1"
}

# Resume a failed install from the install phase, rather than from the
# beginning. This is generally safe - but should be used with caution.
paludis-resume-test() {
    utter "forcefully skipping to the test phase for '$1'..."
    paludis --install --skip-until-phase setup --abort-at-phase unpack "$1"
    paludis --install --skip-until-phase test "$1"
}

# Recache the ./Manifest file for some ebuild.
# 
# Note that, if that ebuild is fetch restricted (i.e., it contains a line
# RESTRICT="fetch" and supplies a "pkg_nofetch" function), you may need to
# disable the fetch restriction before calling this function.
paludis-recache-manifest() {
    utter "forcefully recaching Manifest entries for '$1'..."
    ebuild --force "$1" manifest
}

# Uninstall all unused ebuilds or exheres.
paludis-uninstall-unused() {
    utter "pretending to uninstall unused..."
    paludis --uninstall-unused --pretend
    utter "uninstalling unused..."
    paludis --uninstall-unused
}

# Upload a new exheres repository patch given the current exheres repository.
# This formats the patch via "git format-patch origin", then "pastes" (i.e.,
# uploads) the plaintext contents of the patch to the online "pastebin"
# service currently configured in "~/.wgetpaste.conf" or "/etc/wgetpaste.conf".
# This returns a URL suitable for submission to the "hacchi" IRC bot via the
# "#exherbo" channel on Freenode.
#
# Complex, we know. But it works.
paludis-paste-patch() {
    utter "pasting patch..."
    git-format-patch-stdout "${@}" | wgetpaste --language Bash --raw
}

#FIXME: Consider implementing an equivalent function to:
# qlist ${EXHERES_NAME} | xargs scanelf -L -n -q -F '%n #F' | tr , ' ' | xargs qfile -C | sort -u
#This emits all shared libraries listed as "DT_NEEDED" for the passed exheres:
#in other words, the set of all known dependencies for the exheres.

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyleft 2007-2010 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
