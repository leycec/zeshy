#!/usr/bin/env zsh
# ====================[ string                             ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy String. This Zeshy component implements string-handling functionality.
#
# --------------------( SEE ALSO                           )--------------------
# "man zshexpn/FILENAME GENERATION"
#     Glob syntax details.

# ....................{ GLOBBING                           }....................
# int get_number_of_glob_matches(...)
#
# Return the number of glob matches in the passed string. Among other uses, this
# function counts occurrences of characters and substrings in strings: e.g.,
#
#     >>> get_number_of_glob_matches '[bsz]o' 'bosozoku'
#     3
#
# See also the get_number_of_matches() function, which behaves similarly but
# more efficiently -- matching via one regular rather than multiple glob
# expressions.
get_number_of_glob_matches() {
    die_unless_two_arguments\
        'expected exactly one glob expression and one string'
    local glob="${1}" string="${2}" string_old glob_matches='-1'

    # If the passed string is empty, print 0 to avoid nonsense.
    is "${string}" || ( print 0 && return )

    # This exceptionally clever (and frankly obscene) logic comes inspired by
    # LinuxQuestions user "unSpawn" via this thread:
    #
    #     http://www.linuxquestions.org/questions/linux-newbie-8/bash-command-to-count-particular-character-in-a-string-645005/
    #
    # Sadly, neither sed, awk, grep, or zsh itself have any coherent means of
    # matching individual occurences of a substring. Fortunately, zsh does have
    # a simple mechanism for *ELIMINATING* such matches. Hence, we do so
    # iteratively until all such matches are eliminated.
    until [[ "${string}" == "${string_old}" ]] do
        (( glob_matches++ ))
        string_old="${string}"
        string="${string/${~glob}/}"
    done
    print "${glob_matches}"
}

# ....................{ LINES                              }....................
# Aliases.
alias get_first_line=get_line

# char *get_first_lines(char *string, int last_line_number = 1)
#
# Get lines [1, "last_line_number"] inclusive from the passed string.
get_first_lines() {
    die_unless_at_least_one_argument 'expected exactly one string and one line number'
    local string="${1}"
    local last_line_number="${2:-1}"
    print "${string}" | head --lines="${last_line_number}"
}

# char *get_line(char *string, int line_number = 1)
#
# Get the line corresponding to the passed line number from the passed string.
get_line() {
    die_unless_at_least_one_argument 'expected exactly one string and one line number'
    local string="${1}"
    local line_number="${2:-1}"
    print ${string[(f)${line_number}]}
}

# char *get_line_count(char *string)
#
# Get the number of lines in the passed string.
get_number_of_lines() {
    die_unless_one_argument 'expected exactly one string'
    print "${1}" | wc --lines 
}

# ....................{ WORDS                              }....................
# Aliases.
alias get_first_word=get_word

# char *get_word(char *string, int word_number = 1)
#
# Get the word corresponding to the passed word number from the passed string.
get_word() {
    die_unless_at_least_one_argument\
        'expected exactly one string and one word number'
    local string="${1}"
    local word_number="${2:-1}"
    print ${string[(w)${word_number}]}
}

# char *get_number_of_words(char *string)
#
# Get the number of words in the passed string.
get_number_of_words() {
    die_unless_one_argument 'expected exactly one string'
    print "${1}" | wc --words 
}

# ....................{ CONVERTERS ~ type                  }....................
# char *to_comma_separated_integer(int number)
#
# Convert the passed number to a comma-separated number: e.g.,
#
#     >>> to_comma_separated_integer 1776
#     1,776
# 
# For convenience, this function also accepts "stdin"-style piped input: e.g.,
#
#     >>> echo 1776 | to_comma_separated_integer
#     1,776
to_comma_separated_integer() {
    die_unless_one_argument 'expected exactly one number'
    local number="${1}"
    print "${number}" | awk "{ printf \"%'d\n\", \$1 }"
}

# ....................{ CONVERTERS ~ case                  }....................
# char *to_lowercase(char *string)
#
# Convert the passed string to all lowercase: e.g.,
#
#     >>> to_lowercase "The Wind in the Pillows"
#     the wind in the pillows
to_lowercase() {
    die_unless_one_argument 'expected exactly one string'
    print "${(L)1}"
}

# char *to_uppercase(char *string)
#
# Convert the passed string to all uppercase: e.g.,
#
#     >>> to_uppercase "The Pyre of My Loins"
#     THE PYRE OF MY LOINS
to_uppercase() {
    die_unless_one_argument 'expected exactly one string'
    print "${(U)1}"
}

# ....................{ MUTATORS                           }....................
# char *suffix_if_not_already(char *string, char *suffix)
#
# Suffix the passed string with the passed suffix, if not already: e.g.,
#
#     >>> suffix_if_not_already '/habitat/failing/flailing/habits' '/'
#     /habitat/failing/flailing/habits/
suffix_if_not_already() {
    die_unless_two_arguments 'expected exactly one string and one suffix'
    print "${1%${2}}${2}"
}

#FIXME: Compare the lengths of the original and resulting strings.
#   local string_matches_deleted="${string//${~glob}/}"
#   local glob_characters="${#glob//}"
#   print $(((${#string} - ${#string_matches_deleted}) / ${#glob}))
#   print "string_newlined: ${string_newlined}"

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2011 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
