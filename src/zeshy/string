#!/usr/bin/env zsh
# ====================[ string                             ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy String. This Zeshy component implements string-handling functionality.

# ....................{ ACCESSORS ~ lines                  }....................
# Aliases.
alias get_first_line=get_line

# char *get_first_lines(char *string, int last_line_number = 1)
#
# Get lines [1, "last_line_number"] inclusive from the passed string.
get_first_lines() {
    [[ "${#}" -ge 1 ]] || die 'expected exactly one string and one line number'
    local string="${1}"
    local last_line_number="${2:-1}"
    print "${string}" | head --lines="${last_line_number}"
}

# char *get_line(char *string, int line_number = 1)
#
# Get the line corresponding to the passed line number from the passed string.
get_line() {
    [[ "${#}" -eq 2 ]] || die 'expected exactly one string and one line number'
    local string="${1}"
    local line_number="${2:-1}"
    print ${string[(f)${line_number}]}
}

# char *get_line_count(char *string)
#
# Get the number of lines in the passed string.
get_line_count() {
    [[ "${#}" -eq 1 ]] || die 'expected exactly one string'
    print "${1}" | wc --lines 
}

# ....................{ ACCESSORS ~ words                  }....................
# Aliases.
alias get_first_word=get_word

# char *get_word(char *string, int word_number = 1)
#
# Get the word corresponding to the passed word number from the passed string.
get_word() {
    [[ "${#}" -ge 2 ]] || die 'expected exactly one string and one word number'
    local string="${1}"
    local word_number="${2:-1}"
    print ${string[(w)${word_number}]}
}

# char *get_word_count(char *string)
#
# Get the number of words in the passed string.
get_word_count() {
    [[ "${#}" -eq 1 ]] || die 'expected exactly one string'
    print "${1}" | wc --words 
}

# ....................{ CONVERTERS ~ type                  }....................
# char *to_comma_separated_integer(int number)
#
# Convert the passed number to a comma-separated number: e.g.,
#
#     >>> to_comma_separated_integer 1776
#     1,776
# 
# For convenience, this function also accepts "stdin"-style piped input: e.g.,
#
#     >>> echo 1776 | to_comma_separated_integer
#     1,776
to_comma_separated_integer() {
    # If no arguments were passed, attempt to read "stdin" for piped input.
    local number
    if [[ ${#} -eq 0 ]]; then
        number="$(< /dev/stdin)"
        set -- "${number}"
    fi

    [[ ${#} -eq 1 ]] || die 'expected exactly one number'
    number="${1}"
    print "${number}" | awk "{ printf \"%'d\n\", \$1 }"
}

# ....................{ CONVERTERS ~ case                  }....................
# char *to_lowercase(char *string)
#
# Convert the passed string to all lowercase: e.g.,
#
#     >>> to_lowercase "The Wind in the Pillows"
#     the wind in the pillows
to_lowercase() {
    [[ ${#} -eq 1 ]] || die 'expected exactly one string'
    print "${(L)1}"
}

# char *to_uppercase(char *string)
#
# Convert the passed string to all uppercase: e.g.,
#
#     >>> to_uppercase "The Pyre of My Loins"
#     THE PYRE OF MY LOINS
to_uppercase() {
    [[ ${#} -eq 1 ]] || die 'expected exactly one string'
    print "${(U)1}"
}

# ....................{ MUTATORS                           }....................
# char *suffix_if_not_already(char *string, char *suffix)
#
# Suffix the passed string with the passed suffix, if not already: e.g.,
#
#     >>> suffix_if_not_already '/habitat/failing/flailing/habits' '/'
#     /habitat/failing/flailing/habits/
suffix_if_not_already() {
    [[ ${#} -eq 2 ]] || die 'expected exactly one string and one suffix'
    print "${1%${2}}${2}"
}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2011 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
