#!/usr/bin/env zsh
# ====================[ regex                              ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Regex. This Zeshy component implements supplementary regular expression-
# handling functionality. Note that Zeshy Core already implements basic support
# for regular expressions.

# ....................{ IMPORTS                       }....................
zimport zeshy/string

# ....................{ MATCH ~ lines                      }....................
# int get_matching_lines(...)
#
# Return the number of lines matching the passed Perl-compatible regular
# expression (PCRE). Unlike many other Zeshy matching functions, this function
# uses "grep" rather than the "zsh/pcre" module. This is due to the fact that
# the latter provides no efficient mechanism for obtaining all non-overlapping
# matches.
#
# Unfortunately, this means that groups may *NOT* be obtained via the "${match}"
# array.
get_matching_lines() {
    die_unless_at_least_two_arguments\
        'expected at least one regular expression and one string'

    # Parse parameters.
    local regexp="${1}"
    local string="${2}"

    try "echo '${string}' | grep --perl-regexp '${regexp}'"
}

# int get_number_of_matching_lines(...)
#
# Return the number of lines matching the passed Perl-compatible regular
# expression (PCRE). Unlike many other Zeshy matching functions, this function
# uses "grep" rather than the "zsh/pcre" module. This is due to the fact that
# the latter provides no efficient mechanism for obtaining all non-overlapping
# matches.
#
# Unfortunately, this means that groups may *NOT* be obtained via the "${match}"
# array.
get_number_of_matching_lines() {
    try "get_matching_lines '${@}' | get_line_count"
}

# char *match_first_line(...)
#
# Match the passed string against the passed Perl-compatible regular expression
# (PCRE) and return the first matched line, if at least one such line matched,
# or the empty string otherwise.
#
# In all other respects, this function is identical to the match() function.
# In particular, note groups may still be obtained via the "${match}" array.
match_first_line() {
    die_unless_at_least_two_arguments\
        'expected at least one regular expression and one string'

    # Guarantee the passed regular expression roots itself to single rather than
    # multiple lines (i.e., begins with '^' and ends with '$').
    local regex="${1}"
    shift

    # No, I don't know why the former requires a '.' while the latter does not.
    # I'm sure there's a highly rational reason within the musty bowels of ZSH.
#   print "regex: "${regex}
    [[ "${regex}" == ^.* ]] || regex="^.*${regex}"
    [[ "${regex}" == *$  ]] || regex="${regex}.*$"
#   print "regex: "${regex}
    
    # Pack this modified regular expression back into the array of all passed
    # arguments, for convenience.
    set -- "${regex}" "${@}"

    # Perform the match.
    match_multiline "${@}" || return ${?}

    # Print the first matching line.
    local match_string_name="${3:-MATCH}"
    print "${(P)match_string_name}"
    return ${ZESHY_SUCCESS_CODE}
}

# ....................{ MATCH ~ groups                     }....................
# char *match_first_group(...)
#
# Match the passed string against the passed Perl-compatible regular expression
# (PCRE). If there exists at least one successful match group, return that;
# otherwise, return failure.
#
# In all other respects, this function is identical to the match() function.
# In particular, note groups may still be obtained via the "${match}" array.
match_first_group() {
    # Perform the match.
    match "${@}" || return ${?}

    # Parse parameters.
    local group_array_name="${4:-match}"

    #FIXME: Uncommenting this causes *HORRIBLE, UTTERLY IMPOSSIBLE TO DEBUG*
    #issues. And it shouldn't. But there it is.
    # Localize the group array.
#   typeset -Ag ${group_array_name}

    # Retrieve the first group.
    local first_group_name="${group_array_name}[1]"

    # If this match matched at least one group, return that. Otherwise, nil.
#   print "first_group_name: ${first_group_name}"
    local first_group="${(P)first_group_name}"
#   print "first_group: ${first_group}"

    # If there exists at least one group, print the first and return success;
    # otherwise, print nothing and return failure.
    [[ -n "${first_group}" ]] && print "${first_group}"
}

#FIXME: Does this actually work? And even if it does, we really should be using
#the ZSH "pcre" facility to guarantee as-expected interpretation of the regex.
# char *match_last_group(char *regular_expression, char *string)
#
# Match the passed string against the passed Perl-compatible regular expression
# (PCRE) and return the last matched group, if at least one such group matched.
match_last_group() {
    die_unless_at_least_two_arguments\
        'expected exactly one regular expression and one string'
        
    # Parse parameters.
    local regexp="${1}"
    local string="${2}"

    # Match. For simplicity, use "grep" rather than Zsh's "pcre" module.
    try "echo '${string}' | tac | grep --perl-regexp -m 1 '${regexp}'"
}

# void match_multiline_first_group(...)
#
# Match the passed string against the passed Perl-compatible regular expression
# (PCRE) in a multi-line fashion (e.g., matching '^' and '$' at both newline and
# the beginning and end of the string, respectively) and return the first
# matched group, if at least one such group matched, or the empty string
# otherwise. In all other respects, this function is identical to the
# match_multiline() function.
match_multiline_first_group() {
    local -a ZESHY_MATCH_OPTIONS
             ZESHY_MATCH_OPTIONS=( -m )
    match_first_group "${@}"
}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2011 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
