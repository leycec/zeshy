#!/usr/bin/env zsh
# ====================[ core                               ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Core. This Zeshy component implements core functionality upon which most
# other Zeshy functionality depends. Specifically, this means:
#
# * Autoload definitions.
# * Core Zsh modules and options.
# * Core I/O-, error-, file-, and path-handling functions.
#
# --------------------( TODO                               )--------------------
# * Add "$IS_CRON" support.
# * Use the "vcs_info" Zsh module for displaying VCS-specific metadata in a VCS-
#   agnostic fashion.
# * Incorporate ZSH-lovers fixes, including:
#   * Use "zparseopts" instead of "getopt" for script functions intended to be
#     called from the command-line as well as for external shell scripts. Nice!
#   * Use suffix aliases.

# ....................{ PATHS                              }....................
# Absolute path to the current script.
local zeshy_core_path=$(readlink --canonicalize-existing "${0}")

# Directory having the current script. This environment variable should have
# been permanently added to the current system on Zeshy installation. If it was
# not, however, ensure that it at least temporarily exists now.
[[ -n "${ZESHY_HOME}" ]] ||  
    export ZESHY_HOME=$(readlink --canonicalize-existing $(dirname "${zeshy_core_path}")"/..")

# Directory to which Zeshy caches Zsh metadata. Note that Zsh itself is unaware
# of this path until Zeshy explicitly instructs it to cache metadata here.
export ZESHY_CACHE_HOME="${HOME}/.zsh"

# Directory to which Zeshy caches Zsh completions.
export ZESHY_COMPLETION_CACHE_PATH="${ZESHY_CACHE_HOME}/zcompcache"

# File to which the compinit() function caches its configuration. 
export ZESHY_COMPINIT_DUMP_FILE="${ZESHY_CACHE_HOME}/zcompdump"

# Directory to which Zeshy mounts media.
export ZESHY_MOUNT_HOME='/media'

# ....................{ RETURN CODES                       }....................
# Success code, as returned by successful processes on process completion.
export ZESHY_SUCCESS_CODE=0

# Failure code, as returned by failed processes on process completion. Note
# that, technically, any return code greater than or equal to this value
# constitutes a process failure.
export ZESHY_FAILURE_CODE=1

# ....................{ AUTOLOADS                          }....................
# Autoload all autoloadable files. This permits all subsequent code to call
# autoloadable functions without having to manually autoload those functions:
# e.g.,
#
#     # Instead of this...
#     autoload -U zsh-mime-setup; zsh-mime-setup
#
#     # ...one now does this.
#     zsh-mime-setup
#
# This glob expression matches the basename of all non-executable readable files
# residing under every path in the function path list, "${fpath}". Via Zsh
# mandate, every such file basename corresponds to the autoloadable function
# name defined in the file. Thus, matching these basenames also matches all
# autoloadable function names.
#
# * "-.x" ignores non-executable files. While not strictly necessary, forum
#    posters suggest this beneficially permits you to ignore undesirable
#    autoloads by chmodding away their executable bit.
# * "-.r" ignores non-readable files. This is strictly necessary.
# * ":t" extracts the "tail" (i.e., basename) of the current file. This is a
#    history modifier extracting each file's filename sans absolute path.
# 
for autoload_function_name in $^fpath/*(N-.r:t); do
    autoload -U "${autoload_function_name}"
done

# Suffix aliases. (This enables BSD-style file opening, by associating file
# suffixes with an application responsible for opening files of that suffix.
# Thus, for example, you may open some PDF-file "/tmp/blandishment.pdf" by
# simply typing that filename at the shell prompt. You must, however, edit
# "/etc/mailcap" to add MIME-type handlers custom for your system: by adding,
# for example, a new "application/pdf;/usr/local/bin/acroread %s" line to
# this file, to open PDF-files with Adobe Acrobat.)
zsh-mime-setup

# zmv. "zmv" is a built-in shell function applying extended glob patterns to the
# usual "mv" command, thus allowing batch renaming of file- and path-names. (Use
# option "-n" before permanently applying any such pattern, so as to prete[n]d-
# apply the pattern as initial "trial run;" or, use option "-i" to force "zmv"
# to [i]nteractively ask your permission to perform each rename.) For example:
#     zmv -n '(*).txt' '$1.xtx'  # renames files ending in 'txt' to end in 'xtx'
#     zmv -i '(*).txt' '$1.xtx'  # renames files ending in 'txt' to end in 'xtx'
#
# Honestly, I prefer PCRE (Perl Compatible Regular Expression) over this
# extended glob pattern syntax; so I use Perl, rather than Zsh, to batch rename.
#autoload -U zmv

# ....................{ MODULES                            }....................
# Zsh modules are C-implemented shared libraries optionally loadable at runtime.
# Zeshy loads the following Zsh modules.

# Parameter module exposing Zsh's C-based internal hashes via Zsh-based
# associative arrays. We are particularly interested in the "$funcstack"
# associative array, for dynamically inspecting the function call stack.
zmodload zsh/parameter

# Perl-Compatible Regular Expression (PCRE) module. Note that, although enabling
# the "rematch_pcre" option below implicitly loads this module on the first use
# of the "=~" operator in a test, all code prior to that will not have access to
# methods exposed by this module. Thus, simply import it explicitly.
#
# See "String matching" below for use notes.
zmodload zsh/pcre

# Stat module wrapping the stat() system call with the zstat() Zsh function. Do
# not load this module via "zmodload zsh/stat", as that wraps the stat() system
# call with the default stat() Zsh function, which conflicts with "stat" binary.
zmodload -F zsh/stat b:zstat

# ....................{ OPTIONS                            }....................
# Command history.
setopt appendhistory     # share history between multiple ZSH sessions
setopt extendedhistory   # save timestamps in history
setopt histignorealldups # don't ignore dups in history
setopt histignoredups    # ignore consecutive dups in history
setopt histnostore       # don't store history related functions
setopt incappendhistory  # incrementally add items to history

# Path changing.
setopt autocd            # automatically cd to a directory if not cmd
setopt autopushd         # automatically pushd directories on dirstack
setopt pushdignoredups   # don't push dups on stack
setopt pushdsilent       # be quiet about pushds and popds

# File globbing.
setopt extendedglob      # use extended globbing (#, ~, ^)
setopt globdots          # don't require a dot ('.') to be specifically
setopt no_nomatch        # don't emit an error for non-matching globs

# I/O.
setopt interactivecomments  # allow '#' comments in interactive commands
setopt noflowcontrol     # don't use flow control (^S/^Q)
setopt printeightbit     # allow eight bit output for completion lists

# Process control.
setopt longlistjobs      # list jobs in long format
setopt nonotify          # report job status only before prompt printing

# Prompt.
#
# Enable variable substitution in prompt definitions. This dynamically re-
# expands each prompt definition and variables referenced in that definition
# immediately prior to displaying that prompt; by default, on the other hand,
# Zsh statically caches the expansion of each prompt definition for quick re-
# use when displaying those prompts. (While marginally faster, the latter is
# remarkably less useful as it requires redefining and exporting a prompt to
# alter the display of that prompt.)
setopt prompt_subst

# String matching.
#
# This enables Perl-Compatible Regular Expression (PCRE) matching via the "=~"
# test operator, by implicitly loading the "zsh/pcre" module when requested.
# This module matches the entire match into "${MATCH}" and each group match
# into array elements of "${match[@]}" where the first match is "${match[1]}".
# For additional documentation on the "zsh/pcre" module, see:
#     http://zsh.sourceforge.net/Doc/Release/Zsh-Modules.html#SEC192
#
# Note that traditional glob matching is always available via the "=="
# test operator: e.g.,
#     [[ $(whence -cp fahey) == *" not found" ]] && echo "Farewell."
setopt rematch_pcre      # prefer Perl-Compatible Regular Expression matching

# Tab completion.
setopt automenu          # use menu completion after 2 tabs
setopt completeinword    # complete inside words
setopt nolistambiguous   # only list matches if ambiguous

# ....................{ I/O SETTINGS                       }....................
# Disable flow control key bindings, as these increasingly conflict with those
# of popular CLI applications (e.g., irssi, rtorrent). Specifically, prevent
# <Ctrl-s> and <Ctrl-q> from disabling and re-enabling flow control.
stty -ixon -ixoff

# ....................{ SHELLS                             }....................
# bool is_shell_interactive(void)
#
# Return true if the current shell is interactive or is a login shell.
is_shell_interactive() {
    [[ -o interactive || -o login ]]
}

# ....................{ SCRIPTS                            }....................
# char *get_script_name(void)
#
# Get the script name for the current script. This is a string succinctly
# describing the script under execution, typically of one to two words.
#
# Scripts may safely redefine this function to return another name; in this
# case, scripts called by the script redefining this function will still call
# this original definition (since functions are not inherited via script calls).
get_script_name() {
    if [[ -n "${SCRIPT_NAME}" ]]; then
        echo "${SCRIPT_NAME}"
    else
        # If the current process is an interactive shell, then return the name
        # of the function that called this function excluding all intermediary
        # I/O- and error handling-specific function calls. Typically, that
        # function is the function that called the function that called this
        # function (i.e., the function two calls earlier in the function
        # callstack). Insert magical handwaving here.
        if is_shell_interactive; then
            # Ignore all intermediary I/O- and error handling-specific function
            # calls. As the first element of "${funcstack}" is the name of the
            # current function (and we are not particularly interested in that),
            # skip that by setting "I=2".
            local I
            for (( I=2; ${I} <= ${#funcstack}; I=${I}+1 )); do
                case ${funcstack[${I}]} in
                    die*|curse*|utter*) continue ;;
                    *) break ;;
                esac
            done
     
            # If after ignoring non-relevant functions there still exists at
            # least one function on the callstack, return that function's name.
            if [[ ${I} -le ${#funcstack} ]]
            then echo "${funcstack[${I}]}"
            # Otherwise, return a placeholder function name.
            else echo 'zeshy'
            fi
        # Otherwise, return of the basename of the script process that called
        # this function.
        else
            local current_process_basename=$(get_current_process_basename)
            [[ "${current_process_basename}" == 'zsh' ]] &&
                  current_process_basename='zeshy'
            echo "${current_process_basename}"
        fi
    fi
}

# ....................{ MESSAGES                           }....................
#FIXME: Add ANSI coloring to uttered messages if on an ANSI-capable terminal.

# void utter(char *message = '')
#
# Echo the passed message to the standard output stream. Specifically:
#
# * If a cronjob, echo to the notice stream of the cron logging facility.
# * Otherwise, echo to "stdout".
utter() {
    local message=$(get_script_name)": ${@}"

    if [[ -n "${IS_CRON}" ]]
    then logger -p cron.notice "${message}"
    else echo "${message}"
    fi
}

# void curse(char *message = '')
#
# Echo the passed message to the standard error stream. Specifically:
#
# * If a cronjob, echo to the error stream of the cron logging facility.
# * Otherwise, echo to "stderr".
curse() {
    local message=$(get_script_name)": ${@}"

    if [[ -n "${IS_CRON}" ]]
    then logger -p cron.err "${message}"
    else echo "${message}" 1>&2
    fi
}

# void utter_import(char *script_name)
#
# Echo a message informing the user that the passed script name is being
# imported. This function should be called prior to actually importing that
# script if feasible.
utter_import() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one script name"

    # If the caller has supplied no explicit "${SCRIPT_NAME}", supply a default.
    # Failing to do this encourages the utter() function to use the name of this
    # function as its script name, producing an unaesthetic result.
    [[ -n "${SCRIPT_NAME}" ]] || local SCRIPT_NAME='zeshy'
    utter "loading \"${1}\"..."
}

# ....................{ FATALITIES                         }....................
# void die(char *message = '')
#
# Echo the passed text according to the curse() function and exit the currently
# executed script with error.
die() {
    # If the return code of the prior command signifies an error, exit with that
    # return code; otherwise, exit with generic error code 1.
    local return_code
    if [[ ${?} -gt 0 ]]
    then return_code=${?}
    else return_code=1
    fi
    
    # A pox on ye, buggy fiend!
    curse "${@}"
    
    #FIXME: Pack the above return code into this exception.
    # If the script is actually a function called in a running interactive and/or
    # login shell process, exit the set of called functions rather than the shell
    # (i.e., unwind the call stack).
    if is_shell_interactive
    then throw ZeshyDieException
    # Otherwise, exit the current process.
    else exit ${return_code}
    fi
}

# void try(char *command)
#
# Run the passed command and, if it fails with error, terminate the current
# execution environment with the same error.
try() {
    run "${@}" || die
}

# ....................{ PROCESSES                          }....................
# bool is_runnable(char *binary_name)
#
# Return true if the passed binary name is runnable (i.e., is installed) on this
# system: e.g.,
#
#     >>> is_runnable bash && echo "Alas, but Bash is installed!"
#     Alas, but Bash is installed!
is_runnable() {
    which_binary_nonfatal "${@}" 1>/dev/null 2>&1
}

# bool is_running(char *binary_name)
#
# Return true if there exists a process running under the passed binary name:
# e.g.,
#
#     >>> is_running zsh && echo "The zealous zephyr has landed."
#     The zealous zephyr has landed.
is_running() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one binary name"
    try pidof -s "${1}" 1>/dev/null 2>&1
}

# void run_as_superuser(char *command)
#
# Run the passed command as the superuser.
run_as_superuser() {
    [[ "${#}" -ge 1 ]] || die 'expected a command'
    run_as root "${@}"
}

# void run_as(char *username, char *command)
#
# Run the passed command as the passed user.
run_as() {
    [[ "${#}" -ge 2 ]] ||
        die 'expected exactly one username followed by a command'

    # Locally set ${RUN_AS}. The run() function notes this variable as being set
    # and behaves accordingly.
    local RUN_AS="${1}"

    # Remove the passed user from the argument list and call "run" with all
    # remaining arguments: namely the command to be run.
    shift
    run "${@}"
}

# void run(char *command)
#
# Run the passed command. If this is a built-in shell command, just run it;
# otherwise, run it under "nice" and "ionice" so as to assist other running
# processes.
#
# Note, commands should be passed as quoted strings to prevent the calling shell
# from evaluating pipes, redirections, et al. prior to passing the command:
# e.g.,
#
#   # This is good.
#   run "screen -list | grep --count 'eschaton'"
#
#   # This is not.
#   run screen -list | grep --count 'eschaton'
#
# This cannot be fixed, due to the nature of shell evaluation.
run() {
    local return_code

    # The number of passed arguments after word-splitting those arguments.
    #
    # The '@' parameter expansion returns all such arguments.
    #
    # The '=' parameter expansion performs word-splitting: e.g., some string
    # "ls ~/peak-oil" expands to "ls" "~/peak-oil" under such word-splitting. The
    # latter is an executable command; the former is not.
    #
    # The '#' parameter expansion returns the number of such words. (Phew!)
    local argument_count=${#${=@}}
    [[ "${argument_count}" -ge 1 ]] || die 'expected exactly one command'
    
    # If the passed command to run actually exists, run it under it "nice" and
    # "ionice"; otherwise, the command is probably a builtin shell command and
    # must be run inside an eval() statement. (If the passed shell command is
    # run outside of such a statement, strange and horrible things happen.)
    if is_runnable "${1}"; then
        # If the caller requests this command be run under a different user,
        # attempt to do so.
        if [[ -n "${RUN_AS}" && "${RUN_AS}" != $(whoami) ]]; then
            # If the desired user is the superuser, use "sudo" to take advantage
            # of password caching.
            if [[ "${RUN_AS}" == 'root' ]] && is_runnable sudo; then
                sudo -E "${NICE} ${IONICE} ${@}"
            # Otherwise, use "su".
            else
                su --preserve-environment\
                   --command "${NICE} ${IONICE} ${@}"\
                   "${RUN_AS}"
            fi
        # Otherwise, run this command as the current user.
        else eval "${NICE} ${IONICE} ${@}"
        fi
    else eval "${@}"
    fi
}

# ....................{ PROCESSES ~ current                }....................
# int get_current_process_id(void)
#
# Get the PID (process ID) for the current process. This is an integer uniquely
# identifying this process.
get_current_process_id() {
    echo "${$}"
}

#FIXME: These functions are Linux-specific; generalize to other *nix.
# char *get_current_process_basename(void)
#
# Get the basename of the executable file from which the current process was
# executed.
get_current_process_basename() {
    [[ "${#}" -eq 0 ]] || die 'expected no arguments'
    local current_process_command_line="$(get_current_process_command_line)"
    
    #FIXME: This only strips one dash. How to strip more?
    # Strip prefixing dashes from this string to prevent the "basename" command
    # from intepreting such dashes as options to that command. This is actually
    # a real-world concern. By convention, for example, Linux prefixes login
    # shell command lines with one dash.
    current_process_command_line="${current_process_command_line#-}"
    
    # Subject this string to an inscrutable Zsh parameter expansion as follows:
    #
    # * "(0)" splits the command line on null bytes. This is the Linux
    #   convention, and probably not applicable to other *nix.
    # * "[1]" gets the first such split, the absolute OR relative path to the
    #   executable file from which this process was executed.
    #
    # Finally, get the basename of the above result.
    current_process_command_line_parts=( "${(0)current_process_command_line}" )
    basename "${current_process_command_line_parts[1]}"
}

# char *get_current_process_command_line(void)
#
# Get the command line under which the current process is executing. This is a
# single string having these parts:
#
# * Absolute OR relative path to the executable file from which the process was
#   executed. Note that, in the latter case, there is no reliable mechanism for
#   converting the relative path into an absolute path.
# * Set of all command line arguments passed to the above file, where each such
#   argument including the first is prefixed by a null delimiter (i.e., "\x00").
#
# Due to the above unreliabilities, this string is best used for displaying non-
# critical log and user interface labels rather than critical functionality.
get_current_process_command_line() {
    [[ "${#}" -eq 0 ]] || die 'expected no arguments'
    
    # Absolute path to the file having the command line for the current process.
    local current_process_command_line_path="/proc/$(get_current_process_id)/cmdline"
    [[ -r "${current_process_command_line_path}" ]] ||
        die "\"${current_process_command_line_path}\" not found"
    cat "${current_process_command_line_path}"
}

# ....................{ FILES                              }....................
# char *canonicalize_path(char *path)
#
# Get the canonicalized form of the passed absolute path. Canonicalization
# reduces this path to standard form, such that two canonical paths are equal if
# and only if they represent the same file. Note that this is not necessarily
# the case with non-canonical paths (e.g., "/tmp" and "/tmp/../tmp/./" are not
# equal but represent the same directory). Specifically, canonicalization:
#
# * Expands every pseudo-directory component (e.g., "./", "../") iteratively,
#   until the resulting path contains no pseudo-directory components.
# * Expands every symlink in every component of the passed path recursively,
#   until the resulting path contains no symlinks.
canonicalize_path() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one path"
    try readlink --canonicalize-existing "${1}"
}

# int get_path_mtime(char *path)
#
# Get the mtime (i.e., modification time) for the passed absolute path. The
# running kernel modifies this time as follows:
#
# * If this path corresponds to a file, then this time is updated to the current
#   time on each creation, filename change, permission change, or modification
#   of file contents.
# * If this path corresponds to a directory, then this time is updated to the
#   current time on each creation, pathname change, or permission change of this
#   directory as well as creation, filename change, or deletion of files in this
#   directory. Note that this time is not updated on permission change or
#   modification of file contents for files in this directory.
#
# The return value is an integer, suitable for testing with "-ge" and "-le".
get_path_mtime() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one path"
    try zstat +mtime "${1}"
}

# ....................{ FILES ~ binaries                   }....................
# char *which_binary(char *binary_name)
#
# Print the absolute path to the passed binary: e.g.,
#
#     >>> which_binary zsh
#     /bin/zsh
#
# If the passed binary is a string, all but the first whitespace-delimited word
# of the string is ignored: e.g.,
#
#     >>> which_binary "zsh -x -o shwordsplit scr"
#     /bin/zsh
#
# If the passed binary is not found, if multiple binaries are passed, or if no
# binary is passed, prints an error and dies.
which_binary() {
    binary_path=$(which_binary_nonfatal "${@}")
    [[ "${?}" -eq 0 ]] || die "\"${1}\" not found"
    echo "${binary_path}"
}

# char *which_binary_nonfatal(char *binary_name)
#
# Identical to the which_binary() function except that, if the passed binary
# does not exist, returns nothing rather than dies.
which_binary_nonfatal() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one binary name"
    
    local binary_name="${1[(w)1]}"    # first word of the first passed parameter
    local binary_path="$(whence -cp "${binary_name}")"
    
    # When the whence() built-in fails, it prints the name of the passed binary
    # followed by "not found". Thus, if it prints such a message, the passed
    # binary does not exist. Note that testing the return code is problematic
    # here, since setting a local variable always forces the return code to 0
    # (i.e., success). (ZSH = FAIL on that one.)
    if [[ "${binary_path}" == *" not found" ]]; then
        return ${ZESHY_FAILURE_CODE}
    else
        echo "${binary_path}"
        return ${ZESHY_SUCCESS_CODE}
    fi
}

# ....................{ DIRECTORIES                        }....................
# void make_parent_directory_if_not_found(char *path)
#
# Make the parent directory of the passed path, if not found.
make_parent_directory_if_not_found() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one path"
    make_directory_if_not_found $(dirname "${1}")
}

# void make_directory_if_not_found(char *dirname1, char *dirname2, ...)
#
# Examine each of the passed absolute paths and, for each non-existant path,
# make that path and all non-existant parent paths of that path.
make_directory_if_not_found() {
    [[ "${#}" -ge 1 ]] || die "expected at least one dirname"

    # While there are more paths to consider, shift the current path to be
    # considered to a local variable "new_path" and make it when not found.
    local new_path
    while [[ -n "${1}" ]]; do
        new_path="${1}"
        shift

        if [[ ! -d "${new_path}" ]]; then
            utter "making \"${new_path}\"..."
            try mkdir --parents "${new_path}"
        fi
    done
}

# ....................{ IMPORTS                            }....................
# void import(char *script_name)
# 
# Import the passed script name as a dependency of the current script.
# 
# Import, in this context, means: "if the ZSH script corresponding to the passed
# script name has not already been imported by this function or has been
# imported by this function but is modified since last imported, do so;
# otherwise, do not."
#
# This function thus mimics the "import" built-in in most high-level languages.
# Note that this function resolves the absolute path to this script via context-
# dependent precedence, as follows:
# 
# * If the passed script name is an absolute filename, try to find that file.
# * Otherwise assume the name is that file's basename. In this case, try to find
#   a file having this basename under Zeshy's root directory.
# * If none of the above are found, die.
import() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one script name"
    
    # Passed script name.
    local script_name="${1}" 

    # Absolute path to this script.
    local script_path 

    # If the passed script name is not an absolute filename, use it.
    if [[ "${script_name[1]}" == '/' ]]
    then script_path="${script_name}"
    # Otherwise, it is a basename. Resolve this into an absolute filename.
    else script_path="${ZESHY_HOME}/${script_name}"
    fi
    
    # If the absolute filename does not exist, die.
    [[ -f "${script_path}" ]] || die "\"${script_path}\" not found"
    
    # Canonicalize the passed path. Failing to do this could hypothetically
    # prevent the passed path from being successfully looked up in the path
    # dictionary, below.
    script_path="$(canonicalize_path "${script_path}")"
    
    # Modification time of this script.
    local script_mtime="$(get_path_mtime "${script_path}")"
    
    # If the script has not yet been imported or has been imported but has
    # changed since being imported, do so.
    if [[ -z "${IMPORTED_SCRIPT_PATH_TO_MTIME["${script_path}"]}" ||\
             "${IMPORTED_SCRIPT_PATH_TO_MTIME["${script_path}"]}" -ne\
             "${script_mtime}" ]]; then
        # Prior to doing so, record the script as being imported. This prevents
        # reimportation, should this script or another script imported by this
        # script attempt to import this script again.
        IMPORTED_SCRIPT_PATH_TO_MTIME["${script_path}"]="${script_mtime}"
         
        # Do so.
        utter_import "${script_path}"
        source "${script_path}"
    fi
}

# void initialize_imports(void)
#
# Initialize the imports dictionary, used by the import() function. This is a
# global dictionary mapping from imported script name to the mtime (i.e.,
# modification time) of the script at the time of importation. The import()
# function adds script names to this dictionary on importing those scripts so as
# to record having done so. This record keeping allows that function to avoid
# importing already imported scripts.
#
# The "-Ax" option to the "typeset" commands defines each such variable as an
# [A]ssociative array (i.e., a dictionary) and e[x]ported to the global
# environment for later access.
initialize_imports() {
    typeset -Ax IMPORTED_SCRIPT_PATH_TO_MTIME
    IMPORTED_SCRIPT_PATH_TO_MTIME=()
}
initialize_imports

# ....................{ MAIN                               }....................
# Inform the user that this script is being imported. This script is usually
# sourced via the Zsh source() built-in rather than the Zeshy import()
# function; thus, our failure to do this here would require callers do this
# there, prior to their sourcing this script.
utter_import "${zeshy_core_path}"

# Make cache directories, if not already made.
make_directory_if_not_found "${ZESHY_CACHE_HOME}" 
make_directory_if_not_found "${ZESHY_COMPLETION_CACHE_PATH}"

#FIXME: Obsolete.
#echo "PID: $$"
#echo "current_process_basename:"
#get_current_process_basename
#echo "current_process_command_line:"
#get_current_process_command_line

# Enable variable substitution in prompt expansions in a "synchronous" fashion.
# Enabling this re-evaluates each prompt expansion after perform each
# interactive command with the current values of those variables without
# having to manually recreate the prompt each time.
#setopt promptsubst

#The existence of this variable also
# serves to inform callers as to whether or not this script has been imported
# yet and, when it has, to avoid reimporting it.

# Directory above the directory having the current script. This environment
# variable should have been permanently added to the current system as well.
#[[ -n "${ZESHY_ROOT}" ]] ||  
#    export ZESHY_ROOT=$(readlink --canonicalize-existing "${ZESHY_HOME}/..")

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyleft 2007-2010 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
