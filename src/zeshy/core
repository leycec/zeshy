#!/usr/bin/env zsh
# ====================[ core                               ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Core. This Zeshy component implements core functionality upon which most
# other Zeshy functionality depends. Specifically, this means:
#
# * Autoload definitions.
# * Core Zsh modules and options.
# * Core I/O-, error-, file-, and path-handling functions.
#
# --------------------( TODO                               )--------------------
# * Add "$IS_CRON" support.
# * Use the "vcs_info" Zsh module for displaying VCS-specific metadata in a VCS-
#   agnostic fashion.
# * Incorporate ZSH-lovers fixes, including:
#   * Use suffix aliases.

# ....................{ PATHS                              }....................
# Absolute path to the current script.
local zeshy_core_path=$(readlink --canonicalize-existing "${0}")

# Directory having the current script. This environment variable should have
# been permanently added to the current system on Zeshy installation. If it was
# not, however, ensure that it at least temporarily exists now.
[[ -n "${ZESHY_HOME}" ]] ||
    export ZESHY_HOME=$(readlink --canonicalize-existing $(dirname "${zeshy_core_path}")"/../..")

# Directory to which Zeshy caches Zsh metadata. Note that Zsh itself is unaware
# of this path until Zeshy explicitly instructs it to cache metadata here.
#
# If "${HOME}" is the root directory, then this Zeshy process is probably
# running as a cronjob, in which case this directory should reside under the
# "/var" subsystem rather than the "/home" subsystem.
if [[ "${HOME}" == / ]]
then export ZESHY_CACHE_HOME="/var/cache/zeshy"
else export ZESHY_CACHE_HOME="${HOME}/.zsh"
fi

# Directory to which Zeshy caches Zsh completions.
export ZESHY_COMPLETION_CACHE_PATH="${ZESHY_CACHE_HOME}/zcompcache"

# File to which the compinit() function caches its configuration. 
export ZESHY_COMPINIT_DUMP_FILE="${ZESHY_CACHE_HOME}/zcompdump"

# Basename for all "main" Zeshy scripts. These are scripts Zeshy looks for when
# a caller attempts to import a path rather than a file: e.g.,
#
#     # Actually imports "zeshy/${ZESHY_MAIN_SCRIPT_BASENAME}", instead.
#     >>> zimport zeshy
export ZESHY_MAIN_SCRIPT_BASENAME='.main'

# ....................{ BOOLEANS                           }....................
# If non-empty, the current process is running as a cronjob. (Set below.)
export ZESHY_IS_CRONJOB=

# ....................{ INTEGERS                           }....................
# Success code, as returned by successful processes on process completion.
export ZESHY_SUCCESS_CODE=0

# Failure code, as returned by failed processes on process completion. Note
# that, technically, any return code greater than or equal to this value
# constitutes a process failure.
export ZESHY_FAILURE_CODE=1

# ....................{ STRINGS                            }....................
# Human-readable name of the current script. This is used only for output.
# Scripts are welcome to redefine it globally; likewise, functions are welcome
# to redefine it locally. (Set below.)
export ZESHY_SCRIPT_NAME=

# ....................{ AUTOLOADS                          }....................
# Autoload all autoloadable files. This permits all subsequent code to call
# autoloadable functions without having to manually autoload those functions:
# e.g.,
#
#     # Instead of this...  autoload -U zsh-mime-setup; zsh-mime-setup
#
#     # ...one now does this.  zsh-mime-setup
#
# This glob expression matches the basename of all non-executable readable
# files residing under every path in the function path list, "${fpath}". Via
# Zsh mandate, every such file basename corresponds to the autoloadable
# function name defined in the file. Thus, matching these basenames also
# matches all autoloadable function names.
#
# * "-.x" ignores non-executable files. While not strictly necessary, forum
# posters suggest this beneficially permits you to ignore undesirable autoloads
# by chmodding away their executable bit.  * "-.r" ignores non-readable files.
# This is strictly necessary.  * ":t" extracts the "tail" (i.e., basename) of
# the current file. This is a history modifier extracting each file's filename
# sans absolute path.
# 
for autoload_function_name in $^fpath/*(N-.r:t); do
    autoload -U "${autoload_function_name}"
done

# Suffix aliases. (This enables BSD-style file opening, by associating file
# suffixes with an application responsible for opening files of that suffix.
# Thus, for example, you may open some PDF-file "/tmp/blandishment.pdf" by
# simply typing that filename at the shell prompt. You must, however, edit
# "/etc/mailcap" to add MIME-type handlers custom for your system: by adding,
# for example, a new "application/pdf;/usr/local/bin/acroread %s" line to this
# file, to open PDF-files with Adobe Acrobat.)
zsh-mime-setup

# zmv. "zmv" is a built-in shell function applying extended glob patterns to
# the usual "mv" command, thus allowing batch renaming of file- and path-names.
# (Use option "-n" before permanently applying any such pattern, so as to
# prete[n]d- apply the pattern as initial "trial run;" or, use option "-i" to
# force "zmv" to [i]nteractively ask your permission to perform each rename.)
# For example: zmv -n '(*).txt' '$1.xtx'  # renames files ending in 'txt' to
# end in 'xtx' zmv -i '(*).txt' '$1.xtx'  # renames files ending in 'txt' to
# end in 'xtx'
#
# Honestly, I prefer PCRE (Perl Compatible Regular Expression) over this
# extended glob pattern syntax; so I use Perl, rather than Zsh, to batch
# rename.
#autoload -U zmv

# ....................{ MODULES                            }....................
# Zsh modules are C-implemented shared libraries optionally loadable at runtime.
# Zeshy loads the following Zsh modules by default, due to their common
# helpfulness.

# Module exposing Zsh's C-based internal dictionaries as Zsh-based associative
# arrays, including:
#
# * "$funcstack", having the current function call stack for user inspection.
# * "$functions", having the current set of all functions for redefinition and
#   later restoration of differing function definitions.
zmodload zsh/parameter

# Perl-Compatible Regular Expression (PCRE) module. Note that, although
# enabling the "rematch_pcre" option below implicitly loads this module on the
# first use of the "=~" operator in a test, all code prior to that will not
# have access to methods exposed by this module. Thus, simply import it
# explicitly.
#
# See "String matching" below for use notes.
zmodload zsh/pcre

# Stat module wrapping the stat() system call with the zstat() Zsh function. Do
# not load this module via "zmodload zsh/stat", as that wraps the stat() system
# call with the default stat() Zsh function, conflicting with the "stat"
# binary.
zmodload -F zsh/stat b:zstat

# Utility module adding additional built-ins, including:
#
# * "zparseopts", parsing command-line arguments. This built-in is similar in
#   function if not style to the "getopts" binary, and typically used like so:
#
#   >>> set -- -d --ad "glass arm shattering"
#   >>> zparseopts -A args -- d e -ad: -wing:
#   >>> echo "-d: ${args[-d]}\n--ad: ${args[--ad]}"
#   -d:
#   --ad: glass arm shattering
zmodload zsh/zutil

# ....................{ OPTIONS                            }....................
# Command history.
setopt appendhistory     # share history between multiple ZSH sessions
setopt extendedhistory   # save timestamps in history
setopt histignorealldups # don't ignore dups in history
setopt histignoredups    # ignore consecutive dups in history
setopt histnostore       # don't store history related functions
setopt incappendhistory  # incrementally add items to history

# Path changing.
setopt autocd            # automatically cd to a directory if not cmd
setopt autopushd         # automatically pushd directories on dirstack
setopt pushdignoredups   # don't push dups on stack
setopt pushdsilent       # be quiet about pushds and popds

# File globbing.
setopt extendedglob      # use extended globbing (#, ~, ^)
setopt globdots          # don't require a dot ('.') to be specifically
setopt no_nomatch        # don't emit an error for non-matching globs

# I/O.
setopt interactivecomments  # allow '#' comments in interactive commands
setopt noflowcontrol     # don't use flow control (^S/^Q)
setopt printeightbit     # allow eight bit output for completion lists

# Process control.
setopt longlistjobs      # list jobs in long format
setopt nonotify          # report job status only before prompt printing

# Prompt.
#
# Enable variable substitution in prompt definitions. This dynamically re-
# expands each prompt definition and variables referenced in that definition
# immediately prior to displaying that prompt; by default, on the other hand,
# Zsh statically caches the expansion of each prompt definition for quick re-
# use when displaying those prompts. (While marginally faster, the latter is
# remarkably less useful as it requires redefining and exporting a prompt to
# alter the display of that prompt.)
setopt prompt_subst

# String matching.
#
# This enables Perl-Compatible Regular Expression (PCRE) matching via the "=~"
# test operator, by implicitly loading the "zsh/pcre" module when requested.
# This module matches the entire match into "${MATCH}" and each group match
# into array elements of "${match[@]}" where the first match is "${match[1]}".
# For additional documentation on the "zsh/pcre" module, see:
# http://zsh.sourceforge.net/Doc/Release/Zsh-Modules.html#SEC192
#
# Note that traditional glob matching is always available via the "==" test
# operator: e.g.,
#     [[ $(whence -cp fahey) == *" not found" ]] && echo "Farewell."
setopt rematch_pcre      # prefer Perl-Compatible Regular Expression matching

# Tab completion.
setopt automenu          # use menu completion after 2 tabs
setopt completeinword    # complete inside words
setopt nolistambiguous   # only list matches if ambiguous

# ....................{ ALIASES                            }....................
# void noop(...)
#
# Perform parameter expansion on all passed parameters. This alias runs no
# commands and thus always returns success.
alias noop=':'

# ....................{ ENVIRONMENT                        }....................
# bool is_cronjob(void)
#
# Return success if the current shell is a cronjob (i.e., is the grandchild of
# a "cron" process).
is_cronjob() {
    [[ -n "${ZESHY_IS_CRONJOB}" ]]
}

# bool is_shell_interactive(void)
#
# Return success if the current shell is interactive or is a login shell.
is_shell_interactive() {
    [[ -o interactive || -o login ]]
}

# bool is_terminal(void)
#
# Return success if the current shell is outputting to a terminal (i.e., an
# interactive display). All calls to the "stty" binary should be wrapped in a
# test for an active terminal; otherwise, one receives the following error
# under non-terminals (e.g., under cron):
#
#     stty: standard input: Invalid argument
is_terminal() {
    [[ -t 0 ]]
}

# Disable flow control key bindings, as these increasingly conflict with those
# of popular CLI applications (e.g., irssi, rtorrent). Specifically, prevent
# <Ctrl-s> and <Ctrl-q> from disabling and re-enabling flow control.
is_terminal && stty -ixon -ixoff

# ....................{ SCRIPTS                            }....................
# char *get_script_name(void)
#
# Get the script name for the current script. This is a string succinctly
# describing the script under execution, typically of one to two words.
#
# Scripts may safely redefine this function to return another name; in this
# case, scripts called by the script redefining this function will still call
# this original definition (since functions are not inherited via script
# calls).
get_script_name() {
    if [[ -n "${ZESHY_SCRIPT_NAME}" ]]; then
        echo "${ZESHY_SCRIPT_NAME}"
    # If the current process is an interactive shell, then return the name of
    # the function that called this function excluding all intermediary I/O-
    # and error handling-specific function calls. Typically, that function is
    # the function that called the function that called this function (i.e.,
    # the function two calls earlier in the function callstack). Insert magical
    # handwaving here.
    elif is_shell_interactive; then
        # Ignore all intermediary I/O- and error handling-specific function
        # calls. As the first element of "${funcstack}" is the name of the
        # current function (and we are not particularly interested in that),
        # skip that by setting "I=2".
        local  I
        for (( I=2; ${I} <= ${#funcstack}; I=${I}+1 )); do
            case "${funcstack[${I}]}" in
                die*|curse*|run*|try*|utter*) continue ;;
                *) break ;;
            esac
        done
         
        # If after ignoring non-relevant functions there still exists at least
        # one function on the callstack, return that function's name.
        if [[ ${I} -le ${#funcstack} ]]
        then echo "${funcstack[${I}]}"
        # Otherwise, return the default name.
        else echo 'zeshy'
        fi
    # Otherwise, return the default name.
    else echo 'zeshy'
    fi
}

# ....................{ MESSAGES                           }....................
#FIXME: Add ANSI coloring to uttered messages if on an ANSI-capable terminal.
#Also, consider prefixing messages under cron with: "["$(date +'%F %T')"]

# void utter(char *message = '')
#
# Echo the passed message to the standard output stream. Specifically:
#
# * If a cronjob, echo to the notice stream of the cron logging facility.  *
# Otherwise, echo to "stdout".
utter() {
    # Message to utter. Yes, its definition must be on a separate line.
    local message
          message="$(get_script_name): ${@}"
    
    if [[ -n "${ZESHY_IS_CRONJOB}" ]]
    then logger -p cron.notice -- "${message}"
    else echo "${message}"
    fi
}

# Ascertain whether we are running as a cronjob and, if so, alter output
# appropriately. In particular, print the current date as a timestamp prior to
# printing all other output.

# void curse(char *message = '')
#
# Echo the passed message to the standard error stream. Specifically:
#
# * If a cronjob, echo to the error stream of the cron logging facility.
# * Otherwise, echo to "stderr".
curse() {
    # Unset the script name, if set. This forces the get_script_name() function
    # to obtain the name of the most recently called non-trivial function, which
    # is of considerably more assistance when an error occurs.
    local ZESHY_SCRIPT_NAME=

    # Message to curse. Yes, its definition must be on a separate line.
    local message
          message="$(get_script_name): ${@}"
    
    if [[ -n "${ZESHY_IS_CRONJOB}" ]]
    then logger -p cron.err -- "${message}"
    else echo "${message}" 1>&2
    fi
}

# void utter_import(char *script_name)
#
# Echo a message informing the user that the passed script name is being
# imported. This function should be called prior to actually importing that
# script if feasible.
utter_import() {
    [[ ${#} -eq 1 ]] || die "expected exactly one script name"

    # If the caller has supplied no explicit "${ZESHY_SCRIPT_NAME}", supply a
    # default.  Failing to do this encourages the utter() function to use the
    # name of this function as its script name, producing an unaesthetic
    # result.
    [[ -n "${ZESHY_SCRIPT_NAME}" ]] || local ZESHY_SCRIPT_NAME='zeshy'
    utter "loading \"${1}\"..."
}

# ....................{ ERRORS                             }....................
# void die(char *message = '')
#
# Echo the passed text according to the curse() function and exit the currently
# executed script with error.
die() {
    # If the return code of the prior command signifies an error, exit with
    # that return code; otherwise, exit with generic error code 1.
    local return_code
    if [[ "${?}" -ne "${ZESHY_SUCCESS_CODE}" ]]
    then return_code="${?}"
    else return_code="${ZESHY_FAILURE_CODE}"
    fi
    
    # A pox on ye, buggy fiend!
    curse "${@}"
    
    #FIXME: Pack the above return code into this exception.  If the script is
    #actually a function called in a running interactive and/or login shell
    #process, exit the set of called functions rather than the shell (i.e.,
    #unwind the call stack).
    if is_shell_interactive
    then throw ZeshyDieException
    # Otherwise, exit the current process.
    else exit ${return_code}
    fi
}

# ....................{ FUNCTIONS                          }....................
# bool is_callable(char *name)
#
# Return true if there exists an alias or function with the passed name.
is_callable() {
    [[ ${#} -eq 1 ]] || die "expected exactly one name"
    [[ $(whence -w "${1}") =~ ': (alias|builtin|function)$' ]]
}

# ....................{ COMMANDS                           }....................
# Aliases.
alias is_available=is_runnable
alias is_installed=is_runnable

# bool is_runnable(char *command)
#
# Return true if the passed binary name is runnable (i.e., is installed) on
# this system: e.g.,
#
#     >>> is_runnable bash && echo "Alas, but Bash is installed!"
#     Alas, but Bash is installed!
is_runnable() {
    # Do not call the quietly() function, as that calls the run() function which
    # calls *THIS* function which induces an infinitely recursive loop. Agathoth 
    # and Memnon!
    which_command_nonfatal "${@}" 1>/dev/null 2>&1
}

# void try_quietly_as(char *username, char *command)
#
# Run the passed command as the passed user quietly and, if it fails with error,
# terminate the current execution environment with the same error.
try_as() {
    [[ ${#} -ge 2 ]] || die 'expected exactly one username and one command'

    # Locally set "${ZESHY_RUN_AS}". The run() function notes this variable as
    # set and behaves accordingly...
    local ZESHY_RUN_AS="${1}"

    # Remove the passed user from the argument list and call "run" with all
    # remaining arguments: namely the command to be run.
    shift
    try "${@}"
}

# void run_as(char *username, char *command)
#
# Run the passed command as the passed user.
run_as() {
    [[ ${#} -ge 2 ]] || die 'expected exactly one username and one command'

    # Locally set "${ZESHY_RUN_AS}". The run() function notes this variable as
    # set and behaves accordingly...
    local ZESHY_RUN_AS="${1}"

    # Remove the passed user from the argument list and call "run" with all
    # remaining arguments: namely the command to be run.
    shift
    run "${(q)@}"
}

# void try(char *command)
#
# Run the passed command and, if it fails with error, terminate the current
# execution environment with the same error.
try() {
    run "${(q)@}" || die "\"${@}\" returned error code ${?}"
}

# void run(char *command)
#
# Run the passed command. If this is a built-in shell command, just run it;
# otherwise, run it under "nice" and "ionice" so as to assist other running
# processes.
#
# Note that commands should be passed as quote-protected strings to prevent the
# shell from parsing pipes, redirections, and other shell constructs before this
# command is run: e.g.,
#
#   # This is good. Manually quote-protect the passed string.
#   >>> run "screen -list | grep --count eschaton"
#   969
#
#   # This is also good. Automatically quote-protect the passed string with the
#   # "(q)" parameter expansion. (Note that *NOT* prefixing the string with this
#   # expansion induces subtle errors, occasionally. Do not forget, we beg!)
#   >>> local command=$(screen -list | grep --count singularity)
#   >>> run "${(q)command}"
#   696
#
#   # This is not.
#   >>> run screen -list | grep --count eschaton
#
# This cannot be fixed, due to the fixed order of shell evaluation.
#
# Note that *THIS IS A VERY FRAGILE FUNCTION* and the slightest wisp of light
# hackery is liable to lend your Zeshy install to its hasty grave.
run() {
    #FIXME: Prepend "${NICE}" "${IONICE}" onto "${@}"; maybe use:
    #'set -- "${NICE}" "${IONICE}" "${@}"', I suppose?
    # Command line to run, parsed from the passed parameters as follows:
    #
    # * "(Q)" strips one level of quote-protection from the passed parameters,
    #   and is largely safe. This helps undo prior "(q)" quote-protections.
    # * "(=)" splits these parameters into words: e.g., the string
    #   "ls ~/peak-oil" splits into 2 words, "ls" and "~/peak-oil".
    #   "ls ~/peak-oil" is not an executable command; "ls" is.
    local command
          command=( "${(Q)=@}" )

    # Number of passed arguments after word-splitting those arguments.
    local argument_count="${#command}"
    [[ "${argument_count}" -ge 1 ]] || die 'expected exactly one command'
    
    # Command name to run. This is the first word of the command line.
    local command_name="${(Q)command[1]}"
    
    # Absolute path to the command to be run or the command name if this command
    # is a built-in, alias, or function rather than an external command.
    local command_path
          command_path="$(whence "${command_name}")"
    
    # If the passed command does not exist, fail.
    if is_previous_command_failed; then
        die "\"${command_name}\" not found, so cannot run:\n\t${command}"
    # Otherwise, if the passed command has not been overridden by a shell alias
    # or function, run it as a command. Do not call the customary is_installed()
    # function, as that does not test whether or not a command is overridden.
    elif is_absolute_path "${command_path}"; then
        # If the caller requests this command be run under a different user,
        # attempt to do so.
        if [[ -n "${ZESHY_RUN_AS}" && "${ZESHY_RUN_AS}" != $(whoami) ]]; then
            # If the target user is the superuser, use "sudo" to take
            # advantage of password caching.
            #
            # Note that we do not use the "(@)" expansion in either of the
            # following two commands, as that would split the array into
            # discrete command arguments.
            if [[ "${ZESHY_RUN_AS}" == 'root' ]] && is_runnable sudo; then
                sudo -E "${command}"
            # Otherwise, use "su".
            else
#               echo "suing: ${command} ${ZESHY_RUN_AS}"
                su --preserve-environment\
                   --command "${command}" "${ZESHY_RUN_AS}"
        fi
        # Otherwise, run this command as the current user. Do use the "(@)"
        # expansion here, as calling the command manually requires we split the
        # array into discrete command arguments. Evaluate this command to ensure
        # the shell correctly handles shell constructs (e.g., "|").
        else eval "${command[@]}"
        fi
    # Otherwise, the passed command must be a shell built-in. Evaluate it!
    else
#       echo "evaling: ${command}"
        eval "${command[@]}"
    fi
}

# ....................{ COMMANDS ~ superuser               }....................
# bool is_superuser(void)
#
# Return success if the current user is the "superuser" (i.e., root).
is_superuser() {
    [[ "${EUID}" == 0 || "${USER}" == root ]]
}

# void try_as_superuser(char *command)
#
# Run the passed command as the superuser and, if it fails with error,
# terminate the current execution environment with the same error.
try_as_superuser() {
    run_as_superuser "${@}" || die
}

# void run_as_superuser(char *command)
#
# Run the passed command as the superuser.
run_as_superuser() {
    run_as root "${@}"
}

# ....................{ COMMANDS ~ quietly                 }....................
alias is=quietly

# int one_if(char *command)
#
# Run the passed command and, if it exits successfully, echo "1". Otherwise,
# nothing. To guarantee this, this function squelches all other output: e.g.,
#
#     >>> IS_MUTT_INSTALLED=$(one_if is_installed mutt)
#     >>> echo "${IS_MUTT_INSTALLED}"
#     1
#     >>> (( "${+IS_MUTT_INSTALLED}" )) && echo 'mutt\!'
#     mutt!
# 
# Note, commands should be passed as quoted strings to prevent the calling
# shell from evaluating pipes, redirections, et al. prior to passing the
# command. (See the run() function, above.)
one_if() {
    quietly "${@}"
    if [[ ${?} -eq ${ZESHY_SUCCESS_CODE} ]]
    then echo 1
    else echo
    fi
}

# void quietly_as(char *username, char *command)
#
# Run the passed command as the passed user quietly: i.e., squelching output.
# terminate the current execution environment with the same error.
quietly_as() {
    run_as "${@}" 1>/dev/null 2>&1
}

# void quietly(char *command)
#
# Run the passed command quietly: i.e.,, squelching output.
quietly() {
    run "${(q)@}" 1>/dev/null 2>&1
}

# void try_quietly(char *command)
#
# Run the passed command quietly and, if it fails with error, terminate the
# current execution environment with the same error.
try_quietly() {
    quietly try "${@}" || die "\"${@}\" returned error code ${?}"
}

# void try_quietly_as(char *username, char *command)
#
# Run the passed command as the passed user quietly and, if it fails with error,
# terminate the current execution environment with the same error.
try_quietly_as() {
    quietly try_as "${@}" || die "\"${@}\" returned error code ${?}"
}

# ....................{ COMMANDS ~ return codes            }....................
alias get_previous_command_return_code=is_previous_command_succeeded

# bool is_previous_command_failed(void)
#
# Return success if the previous command failed. Otherwise, return failure.
is_previous_command_failed() {
    [[ ${#} -eq 0 ]] || die "expected no arguments"
    if [[ ${?} -ne ${ZESHY_SUCCESS_CODE} ]]
    then return ${ZESHY_SUCCESS_CODE}
    else return ${ZESHY_FAILURE_CODE}
    fi
}

# bool is_previous_command_succeeded(void)
#
# Return success if the previous command succeeded. Otherwise, return failure.
is_previous_command_succeeded() {
    [[ ${#} -eq 0 ]] || die "expected no arguments"
    return ${?}
}

# ....................{ REGULAR EXPRESSIONS                }....................
# For additional regular expression functionality, see "zeshy/string".

# void match(
#   char *regular_expression, char *string=null,
#   char *match_variable_name='MATCH', char *group_array_name='match')
#
# Match the passed string against the passed Perl-compatible regular expression
# (PCRE). This function returns success when this string matches and failure
# when it does not. Also, when this function returns success it also sets:
#
# * The variable corresponding to the passed variable name to the whole match,
#   defaulting to the global variable "${MATCH}".
# * The array corresponding to the passed array name to the list of all matched
#   groups, defaulting to the global variable "${match}".
#
# This function also accepts a hidden "fifth parameter": the global variable
# "${ZESHY_MATCH_OPTIONS}", which when set causes this function to pass those
# options to the pcre_compile() built-in when compiling the passed pattern.
#
# If this regular expression matched at least one group, this function returns
# this group as a string for caller convenience... Else, this function returns
# nothing. In the former case, callers may retrieve the set of all groups via
# the global "${match}" array. (See above.)
#
# For convenience, this function also accepts "stdin"-style piped input rather
# than an explicit passed string: e.g.,
#
#     >>> echo 1776 | match '^\d'
#     >>> echo "${MATCH}" 
#     1
match() {
#   pcre_compile "${1}" || die "\"${1}\" not a valid regular expression"
#   pcre_match "${2}" || return ${?}
#   return ${ZESHY_SUCCESS_CODE}
    local string

    # If no string was passed, attempt to read "stdin" for piped input.
    if [[ ${#} -eq 1 ]]; then
        string="$(< /dev/stdin)"
        set -- "${1}" "${string}"
    fi
   
    # Parse parameters.
    [[ ${#} -ge 2 ]] ||
        die 'expected at least one regular expression and one string'
    local pattern="${1}"
          string="${2}"
    local match_variable_name="${3:-MATCH}"
    local group_array_name="${4:-match}"
#   print "pattern: ${pattern} | string: ${string} | match_variable_name: ${match_variable_name} | group_array_name: ${group_array_name} "
#   echo "mo: ${ZESHY_MATCH_OPTIONS[@]}"

    # Compile the match. (Yes, this is *ALWAYS* necessary.)
    if [[ -n "${ZESHY_MATCH_OPTIONS}" ]]; then 
#       print "ZESHY_MATCH_OPTIONS: ${ZESHY_MATCH_OPTIONS}"
#       pcre_compile -m "${pattern}" ||
        pcre_compile "${ZESHY_MATCH_OPTIONS[@]}" "${pattern}" ||
            die "\"${pattern}\" not a valid regular expression with match options \"${ZESHY_MATCH_OPTIONS[@]}\""
    else
        pcre_compile "${pattern}" ||
            die "\"${pattern}\" not a valid regular expression"
    fi

    # Perform the match and return.
    pcre_match -v "${match_variable_name}" -a "${group_array_name}" --\
        "${string}" || return ${?}
#   pcre_match "${string}" || return ${?}
    return ${ZESHY_SUCCESS_CODE}
}

# void match_multiline(...)
#
# Match the passed string against the passed Perl-compatible regular expression
# (PCRE) in a multi-line fashion (e.g., matching '^' and '$' at both newline and
# the beginning and end of the string, respectively). In all other respects,
# this function is identical to the match() function.
match_multiline() {
    local ZESHY_MATCH_OPTIONS
          ZESHY_MATCH_OPTIONS=( -m )
    match "${@}"
}

# ....................{ PROCESSES                          }....................
# int get_current_pid(void)
#
# Get the PID (process ID) for the current process. This is an integer uniquely
# identifying this process.
get_current_pid() {
    [[ "${argument_count}" -eq 0 ]] || die 'expected no arguments'
    echo "${$}"
}

# ....................{ FILES                              }....................
# bool is_absolute_path(char *path)
#
# Return success if the passed path is absolute (i.e., begins with an "/").
is_absolute_path() {
    [[ ${#} -eq 1 ]] || die "expected exactly one path"
    [[ "${1[1]}" == / ]]
}

# char *canonicalize_path(char *path)
#
# Get the canonicalized form of the passed absolute path. Canonicalization
# reduces this path to standard form, such that two canonical paths are equal
# if and only if they represent the same file. Note that this is not
# necessarily the case with non-canonical paths (e.g., "/tmp" and
# "/tmp/../tmp/./" are not equal but represent the same directory).
# Specifically, canonicalization:
#
# * Expands every pseudo-directory component (e.g., "./", "../") iteratively,
#   until the resulting path contains no pseudo-directory components.
# * Expands every symlink in every component of the passed path recursively,
#   until the resulting path contains no symlinks.
canonicalize_path() {
    [[ ${#} -eq 1 ]] || die "expected exactly one path"
    try readlink --canonicalize-existing "${1}"
}

# char *canonicalize_path_nonfatal(char *path)
#
# Get the canonicalized form of the passed absolute path. Unlike the
# canonicalize_path() function, this function does not raise an exception when
# the passed path does not exist; it simply canonicalizes as much of this path
# as exists.
canonicalize_path_nonfatal() {
    [[ ${#} -eq 1 ]] || die "expected exactly one path"
    try readlink --canonicalize-missing "${1}"
}

# int get_path_mtime(char *path)
#
# Get the mtime (i.e., modification time) for the passed absolute path. The
# running kernel modifies this time as follows:
#
# * If this path corresponds to a file, then this time is updated to the
#   current time on each creation, filename change, permission change, or
#   modification of file contents.
# * If this path corresponds to a directory, then this time is updated to the
#   current time on each creation, pathname change, or permission change of
#   this directory as well as creation, filename change, or deletion of files
#   in this directory. Note that this time is not updated on permission change
#   or modification of file contents for files in this directory.
#
# The return value is an integer, suitable for testing with "-ge" and "-le".
get_path_mtime() {
    [[ ${#} -eq 1 ]] || die "expected exactly one path"
    try zstat +mtime "${1}"
}

# ....................{ FILES ~ binaries                   }....................
# Aliases.
alias which_binary="which_command"
alias which_binary_nonfatal="which_command_nonfatal"

# char *which_command(char *command)
#
# Print the absolute path to the passed command: e.g.,
#
#     >>> which_command zsh /bin/zsh
#
# If the passed command is a string, all but the first whitespace-delimited word
# of the string is ignored: e.g.,
#
#     >>> which_command "zsh -x -o shwordsplit scr" /bin/zsh
#
# If the passed command is not found, if multiple binaries are passed, or if no
# command is passed, prints an error and dies.
which_command() {
    # Call the whence() built-in outside of "local" so as to retain the return
    # code. (ZSH == FAIL on that one.) 
    local command_path
          command_path=$(which_command_nonfatal "${@}")
    is_previous_command_succeeded || die "\"${1}\" not found"
    echo "${command_path}"
}

# char *which_command_nonfatal(char *command_name)
#
# Identical to the which_command() function except that, if the passed command
# does not exist, returns nothing rather than dies.
which_command_nonfatal() {
    [[ ${#} -eq 1 ]] || die "expected exactly one command name"
    
    # First word of the first passed parameter, and the absolute path to return.
    local command_name="${1[(w)1]}" command_path
    
    # Call the whence() built-in outside of "local" so as to retain the return
    # code. (ZSH == FAIL on that one.) 
    command_path="$(whence -cp "${command_name}")"
    
    if is_previous_command_succeeded; then
        echo "${command_path}"
        return ${ZESHY_SUCCESS_CODE}
    fi

    return ${ZESHY_FAILURE_CODE}
}

# ....................{ FILES ~ directories                }....................
# bool is_dir(char *path)
# 
# Return success if the passed path is an existing directory. Otherwise,
# failure.
is_dir() {
    [[ ${#} -eq 1 ]] || die "expected exactly one path"
    [[ -d "${1}" ]]
}

# bool is_file(char *path)
# 
# Return success if the passed path is an existing file. Otherwise, failure.
is_file() {
    [[ ${#} -eq 1 ]] || die "expected exactly one path"
    [[ -f "${1}" ]]
}

# void make_parent_directory_if_not_found(char *path)
#
# Make the parent directory of the passed path, if not found.
make_parent_directory_if_not_found() {
    [[ ${#} -eq 1 ]] || die "expected exactly one path"
    make_directory_if_not_found "$(dirname "${1}")"
}

# void make_directory_if_not_found(char *dirname1, char *dirname2, ...)
#
# Examine each of the passed absolute paths and, for each non-existant path,
# make that path and all non-existant parent paths of that path.
make_directory_if_not_found() {
    [[ ${#} -ge 1 ]] || die "expected at least one dirname"

    # While there are more paths to consider, shift the current path to be
    # considered to a local variable "new_path" and make it when not found.
    local new_path
    while [[ -n "${1}" ]]; do
        new_path="${1}"
        shift

        if [[ ! -d "${new_path}" ]]; then
            utter "making \"${new_path}\"..."
            try mkdir --parents "${new_path}"
        fi
    done
}

# ....................{ IMPORTS                            }....................
# void zimport(char *script_name, char *script_options)
# 
# Import the passed script name as a dependency of the current script, passing
# that script the passed options.
# 
# Import means: "If the Zeshy script corresponding to the passed script name has
# not already been imported by this function or has but has been externally
# modified since last imported, do so; else, do not."
#
# This function mimics the import() built-in in most high-level languages.
# Note that this function resolves the absolute path to this script via context-
# dependent precedence, as follows:
# 
# * If the passed script name is an absolute filename, try to find that file.
# * Otherwise assume the name is that file's basename. In this case, try to
#   find a file having this basename under Zeshy's root directory.
# * If none of the above are found, die.
#
# This function also accepts a directory rather than file, in which case it
# imports a file named ".main" under that directory: e.g.,
#
#     # Actually imports "zeshy/os/.main".
#     >>> zimport zeshy/os
#
# This function is named "zimport" so as not to conflict with ImageMagick's
# brashly named "import" command.
#
# --------------------( VARIABLES                          )--------------------
# This function defines local variables, which imported scripts may safely
# access for informative path metadata: namely,
#
# * "zeshy_script_name", having the relative path to the imported script under
#   "${ZESHY_HOME}/src".
# * "zeshy_script_path", having the absolute path to the imported script.
# * "zeshy_script_mtime", having the modification time of the imported script.
zimport() {
    [[ ${#} -ge 1 ]] || die "expected exactly one script name"
    
    # Passed script name. Shift it off the argument stack, to allow us to pass
    # this script the set of all remaining arguments on sourcing it below.
    local zeshy_script_name="${1}" 
    shift

    # Absolute path to this script.
    local zeshy_script_path 
    
    # If the passed script name is either an absolute path or existing relative
    # path, try to import it as is.
    if [[ "${zeshy_script_name[1]}" == '/' || -e "${zeshy_script_name}" ]]
    then zeshy_script_path="${zeshy_script_name}"
    # Otherwise, try to import a Zeshy component having that script name.
    else zeshy_script_path="${ZESHY_HOME}/src/${zeshy_script_name}"
    fi
    
    # If the absolute path refers to a directory, assume the caller wants a
    # script named "_main" under this directory.
    [[ -d "${zeshy_script_path}" ]] &&
        zeshy_script_path="${zeshy_script_path}/${ZESHY_MAIN_SCRIPT_BASENAME}"
    
    # If this path does not exist, die.
    [[ -f "${zeshy_script_path}" ]] || die "\"${zeshy_script_path}\" not found"
    
    # Canonicalize the path so as to ensure the dictionary lookup below
    # successfully compares it against a previously canonicalized path.
    zeshy_script_path="$(canonicalize_path "${zeshy_script_path}")"

    # Modification time of this script.
    local zeshy_script_mtime="$(get_path_mtime "${zeshy_script_path}")"
    
    # If the script has not yet been imported or has been imported but has
    # changed since being imported, do so.
    if [[ -z "${ZESHY_IMPORTED_PATH_TO_MTIME["${zeshy_script_path}"]}" ||\
        "${ZESHY_IMPORTED_PATH_TO_MTIME["${zeshy_script_path}"]}" -ne\
        "${zeshy_script_mtime}" ]]; then
        # Prior to doing so, record the script as being imported. This prevents
        # reimportation, should this script or another script imported by this
        # script attempt to import this script again.
        ZESHY_IMPORTED_PATH_TO_MTIME["${zeshy_script_path}"]="${zeshy_script_mtime}"
         
        # Do so.
        utter_import "${zeshy_script_path}"
        source "${zeshy_script_path}" "${@}"
    fi
}

# void zeshy_initialize_imports(void)
#
# Initialize the imports dictionary, used by the zimport() function. This is a
# global dictionary mapping from imported script name to the mtime (i.e.,
# modification time) of the script at the time of importation. The zimport()
# function adds script names to this dictionary on importing those scripts so
# as to record having done so. This record keeping allows that function to
# avoid importing already imported scripts.
#
# The "-Ax" option to the "typeset" commands defines each such variable as an
# [A]ssociative array (i.e., a dictionary) and e[x]ported to the global
# environment for later access.
zeshy_initialize_imports() {
    [[ ${#} -eq 0 ]] || die "expected no arguments"
    typeset -Ax ZESHY_IMPORTED_PATH_TO_MTIME
    ZESHY_IMPORTED_PATH_TO_MTIME=()
}

# ....................{ MAIN                               }....................
_zeshy_core() {
    # Initialize the imports dictionary used by the zimport() function.
    zeshy_initialize_imports
    
    # Add this script to the set of all imported scripts, to prevent subsequent
    # imports from (accidentally) reimporting it. Do not add this to the
    # initialize_imports() function, due to largely inexplicable dragons.
    ZESHY_IMPORTED_PATH_TO_MTIME["${zeshy_core_path}"]="$(get_path_mtime "${zeshy_core_path}")"
    
    #FIXME: Zsh-ify these matches, using the above match_multiline() function.
    # Determine whether or not this process is running is a cronjob. This is
    # adapted from this itworld.com article, "Am I being run by cron?":
    #        http://www.itworld.com/Comp/3380/nls_unixcron041209/index.html
    # 
    # Do this prior to uttering imports, as the utter() function requires this.
    local cron_pids="$(pgrep -x cron)"
    local grandparent_pid="$(ps -eo ppid,pid= | grep " ${PPID}$" | awk '{print $1}')"
    ZESHY_IS_CRONJOB="$(one_if match_multiline "^${cron_pids}$" "${grandparent_pid}")"
#   echo "cron: ${ZESHY_IS_CRONJOB}; cron_pids: ${cron_pids}; gpid: ${grandparent_pid}"

    # Inform the user that this script is being imported. This script is usually
    # sourced via the Zsh source() built-in rather than the Zeshy zimport()
    # function; thus, our failure to do this here would require callers do this
    # there, prior to their sourcing this script.
    #
    # Distinguish the former from the latter by noting whether the
    # "${script_mtime}" variable has been set or not; if it has, this script
    # was sourced via zimport() rather than source().
    [[ -n "${script_mtime}" ]] || utter_import "${zeshy_core_path}"
    
    # Set the default script name prior to all other logic, as any logic
    # raising an error requires this name for logging that error. Only do this
    # if the current process is not an interactive Zsh shell as, in that case,
    # the get_script_name() function dynamically inspects the script name from
    # the function call stack.
    if [[ -z "${ZESHY_SCRIPT_NAME}" ]] && ! is_shell_interactive; then
        # Import Zeshy components required below.
        zimport zeshy/os
        
        # Strip the filetype from the script name, if present.
        ZESHY_SCRIPT_NAME="$(get_current_process_basename)"
        ZESHY_SCRIPT_NAME="${ZESHY_SCRIPT_NAME%%.*}"

        # Default the script name to "zeshy", if "zsh".
        [[ "${ZESHY_SCRIPT_NAME}" == zsh ]] && ZESHY_SCRIPT_NAME=zeshy
    fi
    
    # Make cache directories, if not already made.
    make_directory_if_not_found "${ZESHY_CACHE_HOME}" 
    make_directory_if_not_found "${ZESHY_COMPLETION_CACHE_PATH}"
}
_zeshy_core

#FIXME: Obsolete.
    # When the whence() built-in fails, it prints the name of the passed command
    # followed by "not found". Thus, if it prints such a message, the passed
    # command does not exist. Note that testing the return code is problematic
    # here, since setting a local variable always forces the return code to 0
    # (i.e., success). 
#   if [[ "${command_path}" == *" not found" ]]; then
#       return ${ZESHY_FAILURE_CODE}
#   else
#       echo "${command_path}"
#       return ${ZESHY_SUCCESS_CODE}
#   fi

    # O.K., this is tricksy: if the eventual caller explicitly quote-protected
    # the passed command name, there exists another "layer" of quote-protection
    # to unravel. Do so, alas.
#   if ! is_installed "${command_name}" && is_installed "${(Q)command[1]}"; then
#       command_name="${(Q)command[1]}"
#   fi

    #echo "PID: $$"
    #echo "current_process_basename:"
    #get_current_process_basename
    #echo "current_process_command_line:"
    #get_current_process_command_line

# ....................{ GLOB EXPRESSIONS                   }....................
# char **glob_non_dotfiles_in(char *dirname)
#
# Glob all non-dotfiles (i.e., all files and directories whose first character
# is not a '.' dot) in the passed directory.
#glob_non_dotfiles_in() {
#    [[ ${#} -eq 1 ]] || die "expected exactly one directory name"
#    local dirname="${1}"
#    [[ -d "${dirname}" ]] || "\"${dirname}\" not a directory"
#
#    # Glob all non-dotfiles via the "(^D)" modifier.
#    echo "${dirname}"/*(^D)
#}

 # Enable variable substitution in prompt expansions in a "synchronous" fashion.
# Enabling this re-evaluates each prompt expansion after perform each
# interactive command with the current values of those variables without
# having to manually recreate the prompt each time.
#setopt promptsubst

#The existence of this variable also
# serves to inform callers as to whether or not this script has been imported
# yet and, when it has, to avoid reimporting it.

# Directory above the directory having the current script. This environment
# variable should have been permanently added to the current system as well.
#[[ -n "${ZESHY_ROOT}" ]] ||  
#    export ZESHY_ROOT=$(readlink --canonicalize-existing "${ZESHY_HOME}/..")

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2011 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
