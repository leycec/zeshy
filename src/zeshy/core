#!/usr/bin/env zsh
# ====================[ core                               ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Core. This Zeshy component implements core functionality upon which most
# other Zeshy functionality depends. Specifically, this means:
#
# * Autoload definitions.
# * Core Zsh modules and options.
# * Core I/O-, error-, file-, and path-handling functions.
#
# --------------------( SEE ALSO                           )--------------------
# http://zsh.sourceforge.net/Doc/Release/Functions.html
#   Detailed description of trap functions.
# http://www.bash2zsh.com/essays/essay1_file_manager.html
#   Concise introduction to suffix aliases, mime types, and file magic.
#
# --------------------( TODO                               )--------------------
# * Use the "vcs_info" Zsh module for displaying VCS-specific metadata in a VCS-
#   agnostic fashion.
# * Incorporate ZSH-lovers fixes, including:
#   * Use suffix aliases.
# * The new trap support obsoletes an astonishing quantity of prior
#   functionality (e.g., try()). Such functionality should be retained (???...
#   perhaps not), but exported out of this component into a new component: say,
#   "zeshy/shell/job".
# * zimport() can profitably be renamed require(). The latter captures the
#   intent and implementation much more succinctly and without the awkward
#   prefixing 'z'.
# * We only call a match_*() function once in this file. It's absurd to maintain
#   such complexity here; offload all match_*() functionality to
#   "zeshy/type/regex" and, if still required here, simply inline.

# ....................{ PATHS                              }....................
# Absolute path to the current script.
local zeshy_core_path=$(readlink --canonicalize-existing "${0}")

# Directory having the current script. This environment variable should have
# been permanently added to the current system on Zeshy installation. If it was
# not, however, ensure that it at least temporarily exists now.
[[ -n "${ZESHY_HOME}" ]] ||
    export ZESHY_HOME=$(readlink --canonicalize-existing $(dirname "${zeshy_core_path}")"/../..")

# Directory to which Zeshy caches Zsh metadata. Note that Zsh itself is unaware
# of this path until Zeshy explicitly instructs it to cache metadata here.
#
# If "${HOME}" is the root directory, then this Zeshy process is probably
# running as a cronjob, in which case this directory should reside under the
# "/var" subsystem rather than the "/home" subsystem.
if [[ "${HOME}" == '/' ]]
then export ZESHY_CACHE_HOME="/var/cache/zeshy"
else export ZESHY_CACHE_HOME="${HOME}/.zsh"
fi

# Directory to which Zeshy caches Zsh completions.
export ZESHY_COMPLETION_CACHE_PATH="${ZESHY_CACHE_HOME}/zcompcache"

# File to which the compinit() function caches its configuration. 
export ZESHY_COMPINIT_DUMP_FILE="${ZESHY_CACHE_HOME}/zcompdump"

# Basename for all "main" Zeshy scripts. These are scripts Zeshy looks for when
# a caller attempts to import a path rather than a file: e.g.,
#
#     # Actually imports "zeshy/${ZESHY_MAIN_SCRIPT_BASENAME}", instead.
#     >>> zimport zeshy
export ZESHY_MAIN_SCRIPT_BASENAME='.main'

# ....................{ BOOLEANS                           }....................
# If non-empty, the current process is running as a cronjob. (Set below.)
export ZESHY_IS_CRONJOB=

#FIXME: Shift to "zeshy/shell/shell", after confirming die()'s FIXME comment.
# ....................{ INTEGERS                           }....................
# Success code, as returned by successful processes on process completion.
export ZESHY_SUCCESS_CODE=0

# Failure code, as returned by failed processes on process completion. Note
# that, technically, any return code greater than or equal to this value
# constitutes a process failure.
export ZESHY_FAILURE_CODE=1

# ....................{ STRINGS                            }....................
# Human-readable name of the current script. This is used only for output.
# Scripts are welcome to redefine it globally; likewise, functions are welcome
# to redefine it locally. (Set below.)
export ZESHY_SCRIPT_NAME=

# ....................{ TESTS                              }....................
# bool is_shell_interactive(void)
#
# Return true if the current shell is interactive or is a login shell.
is_shell_interactive() {
    [[ ${#} -eq 0 ]] || die 'expected no arguments'
    [[ -o interactive || -o login ]]
}

# ....................{ CALL STACK                         }....................
# For safety, trap functions and functions transitively called by such functions
# require only Zsh functionality (i.e., no Zeshy-specific syntactic sugar). This
# comprises all functions defined up to and including the "TRAPS" section.

# char *get_script_name(void)
#
# Get the script name for the current script. This is a string succinctly
# describing the script under execution, typically of one to two words.
#
# Scripts may safely redefine this function to return another name; in this
# case, scripts called by the script redefining this function will still call
# this original definition (since functions are not inherited via script
# calls).
get_script_name() {
    [[ ${#} -eq 0 ]] || die 'expected no arguments'

    if [[ -n  "${ZESHY_SCRIPT_NAME}" ]]; then
        print "${ZESHY_SCRIPT_NAME}"
    # If the current process is an interactive shell, then return the name of
    # the function that called this function excluding all intermediary I/O-
    # and error handling-specific function calls. Typically, that function is
    # the function that called the function that called this function (i.e.,
    # the function two calls earlier in the function callstack). Insert magical
    # handwaving here.
    elif is_shell_interactive; then
        # Ignore all intermediary I/O- and error handling-specific function
        # calls. Skip the first stack frame corresponding to the current
        # function by starting at the second stack frame.
        integer i funcstack_size=${#funcstack}
        for (( i = 2; i <= funcstack_size; i++ )); do
            # Order ignorable function names by likelihood, for "efficiency."
            case "${funcstack[${i}]}" in
                try*|run*|die*|utter*|mutter*|curse*|ask_*) continue ;;
                *) break ;;
            esac
        done
         
        # If after ignoring non-relevant functions there still exists at least
        # one function on the callstack, return that function's name.
        if [[ ${i} -le ${funcstack_size} ]]
        then print "${funcstack[${i}]}"
        # Otherwise, return the default name.
        else print 'zeshy'
        fi
    # Otherwise, return the default name.
    else print 'zeshy'
    fi
}

# char *print_stack_trace(void)
#
# Print a stack trace of the current call stack (i.e., the sequence of all stack
# frames, excluding the call to this function). Each such frame signifies a
# previously called function, sourced file, or evaluated "eval". Each call
# stack of such frames signifies a stack trace of the complete code path from
# the most to least recently called function, source file, or evaluated "eval".
print_stack_trace() {
    [[ ${#} -eq 0 ]] || die 'expected no arguments'
 
    integer funcstack_size=${#funcstack} i 
    local frame_prefix='    \\_' string funcname filename fileline

    # Omit the current function call by starting from the second stack frame.
    # If there exists no such frame, curse a warning.
    if [[ ${funcstack_size} -le 1 ]]; then
        curse 'call stack empty'
        return 1
    fi

    # Print a prefixing empty header.
    print
    utter

    # Print the current call stack.
    for (( i = 2; i <= funcstack_size; i++ )); do
        # Split the current stack frame's funcfiletrace entry on the last colon
        # in that entry into that frame's filename and line number, thus
        # accounting for possible colons in filenames (e.g., from "colon:blow:7"
        # to filename "colon:blow" and line number 7).
        funcname="${funcstack[${i}]}"
        filename="${funcfiletrace[${i}]%:*}"
        fileline="${funcfiletrace[${i}]##*:}"

        # Print the current stack frame.
#       if "${funcstack[${i}]}" == "${funcfiletrace[${i}]}"
        print "${frame_prefix} ${funcname}() { ${filename}: ${fileline} }"
#       print "${frame_prefix} ${funcname}() {${filename}:${fileline}}"

        # Indent the next stack frame one space to the right.
        frame_prefix=" ${frame_prefix}"
    done
}

# ....................{ MESSAGES                           }....................
#FIXME: Add ANSI coloring to uttered messages if on an ANSI-capable terminal.
#Also, consider prefixing messages under cron with: "["$(date +'%F %T')"]

# void utter(char *message = '')
#
# Print the passed message suffixed by a trailing newline to the notice stream
# of the cron logging facility if a cron-job and to the standard output stream
# otherwise.
utter() {
    # Message to utter. (Yes, its definition must be in a separate command.)
    local message; message="$(get_script_name): ${@}"
    
    if [[ -n "${ZESHY_IS_CRONJOB}" ]]
    then logger -p cron.notice -- "${message}"
    else echo "${message}"
    fi
}

# void mutter(char *message = '')
#
# Print the passed message suffixed by no trailing newline to the notice stream
# of the cron logging facility if a cron-job and to the standard output stream
# otherwise.
mutter() {
    # Message to mutter. (Yes, its definition must be in a separate command.)
    local message; message="$(get_script_name): ${@}"
    
    if [[ -n "${ZESHY_IS_CRONJOB}" ]]
    then logger -p cron.notice -- "${message}"
    else echo -n "${message}"
    fi
}

# void curse(char *message = '')
#
# Echo the passed message to the standard error stream. Specifically:
#
# * If a cronjob, echo to the error stream of the cron logging facility.
# * Otherwise, to "stderr".
curse() {
    #FIXME: Given the new stack trace facilities, this probably no longer applies.
    # Unset the script name, if set. This forces the get_script_name() function
    # to obtain the name of the most recently called non-trivial function, which
    # is of considerably more assistance when an error occurs.
#   local ZESHY_SCRIPT_NAME=

    # Message to curse. (Yes, its definition must be in a separate command.)
    local message; message="$(get_script_name): ${@}"
    
    if [[ -n "${ZESHY_IS_CRONJOB}" ]]
    then logger -p cron.err -- "${message}"
    else echo "${message}" 1>&2
    fi
}

# ....................{ EXCEPTIONS                         }....................
# void die(char *message = '')
#
# Echo the passed text according to the curse() function and exit the currently
# executed script with error.
die() {
    # If the return code of the prior command signified an error, exit with
    # that return code; otherwise, exit with generic error code 1.
    integer return_code=${?}
    [[ ${return_code} -eq ${ZESHY_SUCCESS_CODE} ]] &&
              return_code=${ZESHY_FAILURE_CODE}
    
    # Print the passed error message and a complete stack trace.
    curse "${@}"
    print_stack_trace

    # Die with the prior return code.
    die_with ${return_code}
}

# void die_with(int return_code = 1)
#
# Exit the currently executed script or function with the passed return code.
die_with() {
    # If the current context is a function called from an interactive and/or
    # login shell, unwind the call stack; otherwise, kill the current process.
    if is_shell_interactive
    then throw ZeshyException
    else exit ${1:-${ZESHY_FAILURE_CODE}}
    fi
}

# ....................{ TRAPS                              }....................
# int TRAPINT(int signal_number = SIGINT)
#
# Trap SIGINT (i.e., signal interrupt, as after a user-driven <Ctrl-C> event).
TRAPINT() {
    print_stack_trace

    # Store the interrupted line in the history. By default, Zsh omits such
    # lines -- somewhat unhelpfully. Dismantled, this is:
    #
    # * "zle", true only if the history is currently active.
    # * "-s", output the interrupted line to the history rather than stdout.
    # * "-r", preserve escapes from "echo" command manipulation.
    # * "--", prevent dash prefixes in the interrupted line from being
    #   misinterpreted as "print" command options.
    # * "${BUFFER}", the interrupted line.
    zle && print -sr -- "${BUFFER}"
    
    # Arcane bit-munging. Exit codes are of size "char" (i.e., a single byte).
    # Non-zero exit codes with high bit set signify signal-driven fatal errors
    # and with high bit unset signify command-specific fatal errors. In the
    # former case, all bits excluding the high bit signify the signal number.
    # Hence, signal-driven exit codes are constructable by adding 128 to the
    # signal number.
    #
    # SIGINT signifies fatal error of signal number 2. Rather than hard-code
    # that constant, we note:
    #
    # * Zsh passes the signal number as the first argument to trap functions.
    # * Zsh continues handling trap function-trapped signals as if untrapped
    #   when receiving non-zero exit codes from such functions. In such cases,
    #   Zsh returns this exit code as the signal result to calling processes.
    # 
    # Since we prefer Zsh handle the actual interrupt as such with the same
    # exit code as it would customarily return, the result follows.
    return $(( 128+${1} ))
}

# int TRAPZERR(int signal_number = SIGZERR)
#
# Trap SIGZERR (i.e., signal error, as after Zsh functions or non-Zsh commands
# returning non-zero exit codes). This signal is Zsh-specific, as the function
# name directly implies.
TRAPZERR() {
    # Save the return code of the prior command prior to overwriting this code
    # by printing a stack trace.
    integer return_code=${?}
    print_stack_trace

    # Terminate the current shell, returning the non-zero exit code of the prior
    # command. This effectively enables "set -e" (i.e., the ERR_EXIT option,
    # terminating the current shell on SIGZERR signals).
    die_with ${return_code}
}

# ....................{ AUTOLOADS                          }....................
# Autoload all autoloadable files. This permits all subsequent code to call
# autoloadable functions without having to manually autoload those functions:
# e.g.,
#
#     # Instead of this...
#     autoload -U zsh-mime-setup; zsh-mime-setup
#
#     # ...one now does this.
#     zsh-mime-setup
#
# This glob expression matches the basename of all non-executable readable
# files residing under every path in the function path list, "${fpath}". Via
# Zsh mandate, every such file basename corresponds to the autoloadable
# function name defined in the file. Thus, matching these basenames also
# matches all autoloadable function names.
#
# * "-.x" ignores non-executable files. While not strictly necessary, forum
# posters suggest this beneficially permits you to ignore undesirable autoloads
# by chmodding away their executable bit.  * "-.r" ignores non-readable files.
# This is strictly necessary.  * ":t" extracts the "tail" (i.e., basename) of
# the current file. This is a history modifier extracting each file's filename
# sans absolute path.
# 
for autoload_function_name in ${^fpath}/*(N-.r:t); do
#   print "autoloading \"${autoload_function_name}\"..."
    autoload -U "${autoload_function_name}"
done

# zmv. "zmv" is a built-in shell function applying extended glob patterns to
# the usual "mv" command, thus allowing batch renaming of file- and path-names.
# (Use option "-n" before permanently applying any such pattern, so as to
# prete[n]d- apply the pattern as initial "trial run;" or, use option "-i" to
# force "zmv" to [i]nteractively ask your permission to perform each rename.)
# For example: zmv -n '(*).txt' '$1.xtx'  # renames files ending in 'txt' to
# end in 'xtx' zmv -i '(*).txt' '$1.xtx'  # renames files ending in 'txt' to
# end in 'xtx'
#
# Honestly, I prefer PCRE (Perl Compatible Regular Expression) over this
# extended glob pattern syntax; so I use Perl, rather than Zsh, to batch
# rename.
#autoload -U zmv

# ....................{ MODULES                            }....................
#FIXME: Hmm; these should be autoloaded, no?

# Zsh modules are C-implemented shared libraries optionally loadable at runtime.
# Zeshy loads the following Zsh modules by default, due to their common
# helpfulness.

# Module exposing Zsh's C-based internal dictionaries as Zsh-based associative
# arrays, including:
#
# * "$funcstack", having the current function call stack for user inspection.
# * "$functions", having the current set of all functions for redefinition and
#   later restoration of differing function definitions.
zmodload zsh/parameter

# Perl-Compatible Regular Expression (PCRE) module. Note that, although
# enabling the "rematch_pcre" option below implicitly loads this module on the
# first use of the "=~" operator in a test, all code prior to that will not
# have access to methods exposed by this module. Thus, simply import it
# explicitly.
#
# See "String matching" below for use notes.
zmodload zsh/pcre

# Stat module wrapping the stat() system call with the zstat() Zsh function. Do
# not load this module via "zmodload zsh/stat", as that wraps the stat() system
# call with the default stat() Zsh function, conflicting with the "stat"
# binary.
zmodload -F zsh/stat b:zstat

# Utility module adding additional built-ins, including the commonly called
# "zformat", "zparseopts", and "zstyle" functions.
zmodload zsh/zutil

# ....................{ OPTIONS                            }....................
# Command history.
setopt appendhistory     # share history between multiple ZSH sessions
setopt extendedhistory   # save timestamps in history
setopt histignorealldups # don't ignore dups in history
setopt histignoredups    # ignore consecutive dups in history
setopt histnostore       # don't store history related functions
setopt incappendhistory  # incrementally add items to history

# Path changing.
setopt autocd            # automatically cd to a directory if not cmd
setopt autopushd         # automatically pushd directories on dirstack
setopt pushdignoredups   # don't push dups on stack
setopt pushdsilent       # be quiet about pushds and popds

# File globbing.
setopt nocaseglob        # glob case-insensitively, as this is usually desirable
setopt extendedglob      # enable extended globbing (#, ~, ^)
setopt globdots          # ???
setopt no_nomatch        # don't print errors on non-matching globs

# I/O.
setopt interactivecomments  # allow '#' comments in interactive commands
setopt noflowcontrol     # don't use flow control (^S/^Q)
setopt printeightbit     # allow eight bit output for completion lists

# Process control.
setopt longlistjobs      # list jobs in long format
setopt nonotify          # report job status only before prompt printing

# Prompt.
#
# Enable variable substitution in prompt definitions. This dynamically re-
# expands each prompt definition and variables referenced in that definition
# immediately prior to displaying that prompt; by default, on the other hand,
# Zsh statically caches the expansion of each prompt definition for quick re-
# use when displaying those prompts. (While marginally faster, the latter is
# remarkably less useful as it requires redefining and exporting a prompt to
# alter the display of that prompt.)
setopt prompt_subst

# String matching.
#
# This enables Perl-Compatible Regular Expression (PCRE) matching via the "=~"
# test operator, by implicitly loading the "zsh/pcre" module when requested.
# This module matches the entire match into "${MATCH}" and each group match
# into array elements of "${match[@]}" where the first match is "${match[1]}".
# For additional documentation on the "zsh/pcre" module, see:
# http://zsh.sourceforge.net/Doc/Release/Zsh-Modules.html#SEC192
#
# Note that traditional glob matching is always available via the "==" test
# operator: e.g.,
#     [[ $(whence -cp fahey) == *" not found" ]] && echo "Farewell."
setopt rematch_pcre      # prefer Perl-Compatible Regular Expression matching

# Tab completion.
setopt automenu          # use menu completion after 2 tabs
setopt completeinword    # complete inside words
setopt nolistambiguous   # only list matches if ambiguous

# Variable expansion.
#
# Enforce strictness for safety as under conventional high-level languages.
setopt nounset           # attempting to expand unset parameters raises an error
setopt warn_create_global # attempting to set untyped parameters raises an error

# ....................{ DECLARATORS ~ aliases              }....................
# void global_alias(char *name, char *value)
#
# Declare a so-called "global alias" (i.e., an alias expandable anywhere in an
# expression, rather than merely in command position).
alias global_alias="alias -g"

# void suffix_alias(char *name, char *value)
#
# Declare a so-called "suffix alias" (i.e., an alias expandable by matching
# against the end of commands).
alias suffix_alias="alias -s"

# ....................{ DECLARATORS ~ variables            }....................
# Note Zsh already provides integer() and float() built-ins for declaring local
# integer (i.e., non-real) and float (i.e., real) variables.
#
# To integrate with the "global" modifier defined below, we intentionally call
# the typeset() rather than local() built-in when declaring types.

# void bool(char *name)
#
# Declare a boolean local to the current scope. Due to current inadequacies in
# Zsh, this only declares a scalar local to the current scope. Nonetheless, we
# encourage users use this function for clarity, forwards compatibility, and
# functional symmetry with the existing integer() and float() built-ins.
alias bool='typeset'

# void string(char *name)
#
# Declare a string local to the current scope. bool() caveats apply.
alias string='typeset'

# void map(char *name)
#
# Declare a map (i.e., associative array) local to the current scope. Due to
# current inadequacies in Zsh, this map must be externally initialized: e.g.,
#
#   map hash_map; hash_map=( 'key 1' 'value 1' 'key 2' 'value 2' )
alias map='typeset -A'

# void list(char *name)
#
# Declare a list (i.e., sequential array) local to the current scope. Due to
# current inadequacies in Zsh, this list must be externally initialized: e.g.,
#
#   list sequence; sequence=( 'value 1' 'value 2' 'value 3' 'value 4' )
alias list='typeset -a'

#FIXME: Hmm. Doesn't the "-U" option equally apply to maps? If so, this should
#probably simply be a global_alias resembling "global", below.
# void sett(char *name)
#
# Declare a set (i.e., list ignoring duplicate values) local to the current
# scope. To avoid conflict with the set() built-in, the type name is
# intentionally obfuscated to "sett". All list() caveats apply to this function.
alias sett='typeset -Ua'

# void list_tied_string(
#   char *string_name, char *list_name, char *separator = ':')
#
# Declare a string with the passed name "tied" to the list with the passed name.
# This resembles a Perl tie by joining the list's elements with the passed
# separator, defaulting to ":", into a string and updating that string on each
# update (i.e., change) to that list: e.g.,
#
#   list_tied_string arroyo array ' '
#   list array; array=( 'Cuidad' 'Juarez' )
#   print "${arroyo}"  # prints "Cuidad Juarez"
#   array=( 'El' 'Paso' )
#   print "${arroyo}"  # prints "El Paso"
#
# Importantly, note Zsh leaves the list-tied string initially unset -- even if
# the list to which it is tied is set! Hence, list-tied strings should usually
# be declared prior to the list to which they tie. Yes, this is unintuitive.
alias list_tied_string='typeset -T'

# ....................{ DECLARATORS ~ modifiers            }....................
# Mark the declared variable as global (i.e., exported). By Zsh convention,
# this and the variable type are ordered opposite to C order: e.g.,
#
#   list global two_hunters; two_hunters=( "ktulu" "orion" )  # or...
#   local -Ax   two_hunters; two_hunters=( "ktulu" "orion" )  # equivalent!
global_alias global='-x'

# Mark the declared variable as constant (i.e., read-only). By Zsh convention,
# this and the variable type are ordered opposite to C order: e.g.,
#
#   string const fwtbt="ride the lightning"  # or...
#   local -r     fwtbt="ride the lightning"  # equivalent!
global_alias const='-r'

# ....................{ OPERATORS                          }....................
# void noop(...)
#
# Perform parameter expansion on all passed parameters. This alias runs no
# commands and thus always returns successfully.
alias noop=':'

# ....................{ OPERATORS ~ boolean                }....................
# bool is(...)
#
# Syntactic sugar signifying the delimiting prefix for a boolean test: e.g.,
#
#   if is "patgod" == *god si; then print "Piper methysticum"; fi  # or...
#   if [[ "patgod" == *god ]]; then print "Piper methysticum"; fi  # equivalent!
global_alias is='[['

# void si(...)
#
# Syntactic sugar signifying the delimiting suffix for a boolean test.
global_alias si=']]'

# bool or(...)
#
# Return true if at least one of the passed command's returned successfully.
global_alias or='||'

# bool and(...)
#
# Return true if both of the passed command's returned successfully.
global_alias and='&&'

# bool not(...)
#
# Negate the passed command's return code.
alias not='!'

# ....................{ ARGUMENTS ~ tests                  }....................
# Define critical argument-specific aliases prior to defining functions
# expanding these aliases. Otherwise, error ensues.

#FIXME: The word "arguments" should probably be truncated to "args", here.
#Rewriting "arguments" every function is slightly silly (and cumbersome).

# bool is_no_arguments(void)
#
# Return true only if the caller was called with no arguments.
alias is_no_arguments='is ${#} -eq 0 si'

# bool is_arguments(void)
#
# Return true only if the caller was called with at least one argument.
alias is_arguments='is ${#} -ne 0 si'
alias is_at_least_one_argument=is_arguments

# bool is_at_least_two_arguments(void)
#
# Return true only if the caller was called with at least two arguments.
alias is_at_least_two_arguments='is ${#} -ge 2 si'

# bool is_one_argument(void)
#
# Return true only if the caller was called with exactly one argument.
alias is_one_argument='is ${#} -eq 1 si'

# bool is_two_arguments(void)
#
# Return true only if the caller was called with exactly two arguments.
alias is_two_arguments='is ${#} -eq 2 si'

# ....................{ ARGUMENTS ~ exceptions             }....................
# As a convenience, all argument aliases except die_unless_no_arguments() first
# attempt to read their argument from stdin when the caller passed no explicit
# argument. This implies all functions expanding these aliases implicitly "get"
# piped input support, which is nice.

# char *make_die_unless_alias(char *test_condition)
#
# Make a string suitable for use as the right-hand side of a "die_unless_*"-
# specific alias statement. This string parses standard input into function
# parameters if such input exists (i.e., if another function piped input to
# this function) and the caller passed insufficient parameters.
make_die_unless_alias() {
    print "is -p /dev/stdin && ! ( ${1} ) si and set -- "'"$(< /dev/stdin)"'"; is ${1} si or die"
}

# void die_unless_no_arguments(void)
#
# Die with a canonical message unless the caller passed no arguments.
alias die_unless_no_arguments='is ${#} -eq 0 si or die "expected no arguments"'

# void die_unless_arguments(char *error_message)
#
# Die with the passed message unless the caller passed at least one argument.
alias die_unless_arguments="$(make_die_unless_alias '${#} -ge 1')"

# void die_unless_one_argument(char *error_message)
#
# Die with the passed message unless the caller passed exactly one argument.
alias die_unless_one_argument="$(make_die_unless_alias '${#} -eq 1')"

# void die_unless_two_arguments(char *error_message)
#
# Die with the passed message unless the caller passed exactly two arguments.
alias die_unless_two_arguments="$(make_die_unless_alias '${#} -eq 2')"

# void die_unless_three_arguments(char *error_message)
#
# Die with the passed message unless the caller passed exactly three arguments.
alias die_unless_three_arguments="$(make_die_unless_alias '${#} -eq 3')"

# void die_unless_four_arguments(char *error_message)
#
# Die with the passed message unless the caller passed exactly four arguments.
alias die_unless_four_arguments="$(make_die_unless_alias '${#} -eq 4')"

# void die_unless_one_or_two_arguments(char *error_message)
#
# Die with the passed message unless the caller passed either one or two
# arguments.
alias die_unless_one_or_two_arguments="$(make_die_unless_alias '${#} -eq 1 || ${#} -eq 2')"

# void die_unless_two_or_three_arguments(char *error_message)
#
# Die with the passed message unless the caller passed either two or three
# arguments.
alias die_unless_two_or_three_arguments="$(make_die_unless_alias '${#} -eq 2 || ${#} -eq 3')"

# void die_unless_at_least_one_argument(char *error_message)
#
# Die with the passed message unless the caller passed at least one argument.
alias die_unless_at_least_one_argument="$(make_die_unless_alias '${#} -ge 1')"

# void die_unless_at_least_two_arguments(char *error_message)
#
# Die with the passed message unless the caller passed at least two arguments.
alias die_unless_at_least_two_arguments="$(make_die_unless_alias '${#} -ge 2')"

# void die_unless_at_least_three_arguments(char *error_message)
#
# Die with the passed message unless the caller passed at least three arguments.
alias die_unless_at_least_three_arguments="$(make_die_unless_alias '${#} -ge 3')"

# void die_unless_at_most_one_argument(char *error_message)
#
# Die with the passed message unless the caller passed at most one argument.
alias die_unless_at_most_one_argument="$(make_die_unless_alias '${#} -le 1')"

# void die_unless_at_most_two_arguments(char *error_message)
#
# Die with the passed message unless the caller passed at most two arguments.
alias die_unless_at_most_two_arguments="$(make_die_unless_alias '${#} -le 2')"

# void die_unless_at_most_three_arguments(char *error_message)
#
# Die with the passed message unless the caller passed at most three arguments.
alias die_unless_at_most_three_arguments="$(make_die_unless_alias '${#} -le 3')"

# Delete the temporary function used to construct the above aliases.
unfunction make_die_unless_alias

# ....................{ TESTS                              }....................
# bool is_set_nonempty(char *variable_name)
#
# Return true if the variable with the passed name is set and non-empty.
is_set_nonempty() {
    die_unless_one_argument 'expected exactly one variable name'
    is -n "${(P)1-}" si    # See below.
}

# bool is_set(char *variable_name)
#
# Return true if the variable with the passed name is set (i.e., declared).
is_set() {
    die_unless_one_argument 'expected exactly one variable name'

    # Decompacted:
    # 
    # * "1", the passed name.
    # * "(P)", the variable the passed name refers to.
    # * "+x", the value to expand this variable to if this variable is set.
    #   Since any non-empty value will due, we arbitrarily use "x".
    # * "-n", true only if this variable is "x" and hence set.
    is -n "${(P)1+x}" si
}

# bool is_unset(char *string)
#
# Return true if the  variable with the passed name is unset (i.e., undeclared).
is_unset() {
    die_unless_one_argument 'expected exactly one variable name'

    # Decompacted:
    # 
    # * "1", the passed name.
    # * "(P)", the variable the passed name refers to.
    # * "-", the value to expand this variable to if this variable is unset.
    #   For brevity, we use the empty string.
    # * "-z", true only if this variable is the empty string and hence unset.
    is -z "${(P)1-}" si
}

#FIXME: Rename is_nonzero(), in keeping with Zsh nomenclature.
# bool is_nonempty(char *string)
#
# Return true if the passed string is non-empty (i.e., not "").
is_nonempty() {
    die_unless_one_argument 'expected exactly one string'
    is -n "${1}" si
}

#FIXME: Rename is_zero(), in keeping with Zsh nomenclature.
# bool is_empty(char *string)
#
# Return true if the passed string is empty (i.e., "").
is_empty() {
    die_unless_one_argument 'expected exactly one string'
    is -z "${1}" si
}

# bool is_cronjob(void)
#
# Return true if the current shell is a cronjob (i.e., is the grandchild of
# a "cron" process).
is_cronjob() {
    die_unless_no_arguments
    is_nonempty "${ZESHY_IS_CRONJOB}"
}

# ....................{ COMMANDS                           }....................
# bool is_installed(char *command_name)
#
# Return true if the command with the passed name is installed on this system.
is_installed() {
    # Do not call the quietly() function, as that calls the run() function which
    # calls *THIS* function which induces an infinitely recursive loop. Agathoth 
    # and Memnon!
    which_command "${@}" 1>/dev/null 2>&1
}

# char *which_command(char *command_name)
#
# If found, print the absolute path to the command with the passed name;
# otherwise, return false. All but the first whitespace-delimited word of this
# string is ignored: e.g.,
#
#     >>> which_command zsh
#     /bin/zsh
#     >>> which_command "zsh -x -o shwordsplit scr"
#     /bin/zsh
which_command() {
    die_unless_one_argument 'expected exactly one command name'
    string command_path command_name="${1[(w)1]}"
    command_path="$(whence -cp "${command_name}")" and print "${command_path}"
}

# void run_as(char *username, char *command)
#
# Run the passed command as the passed user.
run_as() {
    die_unless_at_least_two_arguments\
        'expected exactly one username and one command'

    # Locally set "${ZESHY_RUN_AS}". The run() function notes this variable as
    # set and behaves accordingly...
    string ZESHY_RUN_AS="${1}"; shift

    # Call run() with all remaining arguments: the command to be run.
    run "${(q)@}"
}

#FIXME: This and try() now obsolete by TRAPZERR(). Excise everywhere.
# void try_quietly_as(char *username, char *command)
#
# Run the passed command as the passed user quietly and, if it fails with error,
# terminate the current execution environment with the same error.
try_as() {
    die_unless_at_least_two_arguments\
        'expected exactly one username and one command'

    # Locally set "${ZESHY_RUN_AS}". The run() function notes this variable as
    # set and behaves accordingly...
    string ZESHY_RUN_AS="${1}"; shift

    # Call try() with all remaining arguments: the command to be run.
    try "${(q)@}"
}

# void try(char *command)
#
# Run the passed command and, if it fails with error, terminate the current
# execution environment with the same error.
try() {
    run "${(q)@}" or die "\"${@}\" returned error code ${?}"
}

# void run(char *command)
#
# Run the passed command. If this is a built-in shell command, just run it;
# otherwise, run it under "nice" and "ionice" so as to assist other running
# processes.
#
# Note that commands should be passed as quote-protected strings to prevent the
# shell from parsing pipes, redirections, and other shell constructs before this
# command is run: e.g.,
#
#   # This is good. Manually quote-protect the passed string.
#   >>> run "screen -list | grep --count eschaton"
#   969
#
#   # This is also good. Automatically quote-protect the passed string with the
#   # "(q)" parameter expansion. (Note that *NOT* prefixing the string with this
#   # expansion induces subtle errors, occasionally. Do not forget, we beg!)
#   >>> local command=$(screen -list | grep --count singularity)
#   >>> run "${(q)command}"
#   696
#
#   # This is not.
#   >>> run screen -list | grep --count eschaton
#
# This cannot be fixed, due to the fixed order of shell evaluation.
#
# Note that *THIS IS A VERY FRAGILE FUNCTION* and the slightest wisp of light
# hackery is liable to lend your Zeshy install to its hasty grave.
run() {
    #FIXME: Prepend "${NICE}" "${IONICE}" onto "${@}"; maybe use:
    #'set -- "${NICE}" "${IONICE}" "${@}"', I suppose?
    # Command line to run, parsed from the passed parameters as follows:
    #
    # * "(Q)" strips one level of quote-protection from the passed parameters,
    #   and is largely safe. This helps undo prior "(q)" quote-protections.
    # * "(=)" splits these parameters into words: e.g., the string
    #   "ls ~/peak-oil" splits into 2 words, "ls" and "~/peak-oil".
    #   "ls ~/peak-oil" is not an executable command; "ls" is.
    string command; command=( "${(Q)=@}" )

    # Number of passed arguments after word-splitting those arguments.
    integer argument_count="${#command}"
    is "${argument_count}" -ge 1 si or die 'expected exactly one command'
    
    # Command name to run. This is the first word of the command line.
    string command_name="${(Q)command[1]}"
    
    # Absolute path to the command to be run or the command name if this command
    # is a built-in, alias, or function rather than an external command. If this
    # command does not exist, fail.
    string command_path
    command_path="$(whence "${command_name}")" or
        "\"${command_name}\" not found; cannot run \"${command}\""

    # Otherwise, if the passed command has not been overridden by a shell alias
    # or function, run it as a command. Do not call the customary is_installed()
    # function, as that does not test whether or not a command is overridden.
    if is_absolute_path "${command_path}"; then
        # If the caller requests this command be run under a different user,
        # attempt to do so.
        if is_set_nonempty 'ZESHY_RUN_AS' and
           is "${ZESHY_RUN_AS}" != "${USER}" si; then
            # If the target user is the superuser, use "sudo" to take
            # advantage of password caching.
            #
            # Note that we do not use the "(@)" expansion in either of the
            # following two commands, as that would split the array into
            # discrete command arguments.
            if is "${ZESHY_RUN_AS}" == 'root' si and is_installed sudo; then
                sudo -E "${command}"
            # Otherwise, use "su".
            else
#               echo "suing: ${command} ${ZESHY_RUN_AS}"
                su --preserve-environment\
                   --command "${command}" "${ZESHY_RUN_AS}"
        fi
        # Otherwise, run this command as the current user. Do use the "(@)"
        # expansion here, as calling the command manually requires we split the
        # array into discrete command arguments. Evaluate this command to ensure
        # the shell correctly handles shell constructs (e.g., "|").
        else eval "${command[@]}"
        fi
    # Otherwise, the passed command must be a shell built-in. Evaluate it!
    else
#       echo "evaling: ${command}"
        eval "${command[@]}"
    fi
}

# ....................{ COMMANDS ~ superuser               }....................
# void die_unless_superuser(char *error_message = 'not the superuser')
#
# Raise an exception unless the current user is the superuser.
die_unless_superuser() {
    die_unless_at_most_one_argument\
        'expected at most one optional error message'
    is_superuser or die "${1:-\"${USER}\" not the superuser}"
}

# bool is_superuser(void)
#
# Return success if the current user is the superuser (i.e., root).
is_superuser() {
    is "${EUID}" == 0 || "${USER}" == root si
}

# void try_as_superuser(char *command)
#
# Run the passed command as the superuser and, if it fails with error,
# terminate the current execution environment with the same error.
try_as_superuser() {
    run_as_superuser "${@}" or die
}

# void run_as_superuser(char *command)
#
# Run the passed command as the superuser.
run_as_superuser() {
    run_as root "${@}"
}

# ....................{ COMMANDS ~ return codes            }....................
# int get_last_return_code(void)
# 
# Return the return code returned by the previous command.
alias get_last_return_code='is_ok'

# bool is_ok(void)
#
# Return success if the previous command succeeded. Otherwise, return failure.
is_ok() {
    # Cache the prior command's return code, as our initial sanity check on
    # arguments replaces this code with its own.
    integer prior_command_return_code=${?}
    die_unless_no_arguments
    return ${prior_command_return_code}
}

# bool is_error(void)
#
# Return success if the previous command failed. Otherwise, return failure.
is_error() {
    # Cache the prior command's return code, as our initial sanity check on
    # arguments replaces this code with its own.
    integer prior_command_return_code=${?}
    die_unless_no_arguments
    is ${prior_command_return_code} -ne ${ZESHY_SUCCESS_CODE} si
}

# ....................{ COMMANDS ~ modifiers               }....................
# int one_if(char *command)
#
# Run the passed command and, if it exits successfully, echo "1". Otherwise,
# nothing. To guarantee this, this function squelches all other output: e.g.,
#
#     >>> IS_MUTT_INSTALLED=$(one_if is_installed mutt)
#     >>> echo "${IS_MUTT_INSTALLED}"
#     1
#     >>> (( "${+IS_MUTT_INSTALLED}" )) && echo 'mutt\!'
#     mutt!
# 
# Note, commands should be passed as quoted strings to prevent the calling
# shell from evaluating pipes, redirections, et al. prior to passing the
# command. (See the run() function, above.)
one_if() {
    quietly "${@}"
    if is_ok
    then echo 1
    else echo
    fi
}

# void quietly_as(char *username, char *command)
#
# Run the passed command as the passed user quietly: i.e., squelching output.
# terminate the current execution environment with the same error.
quietly_as() {
    run_as "${@}" 1>/dev/null 2>&1
}

# void quietly(char *command)
#
# Run the passed command quietly: i.e.,, squelching output.
quietly() {
    run "${(q)@}" 1>/dev/null 2>&1
}

# void try_quietly(char *command)
#
# Run the passed command quietly and, if it fails with error, terminate the
# current execution environment with the same error.
try_quietly() {
    quietly try "${@}" or die "\"${@}\" returned error code ${?}"
}

# void try_quietly_as(char *username, char *command)
#
# Run the passed command as the passed user quietly and, if it fails with error,
# terminate the current execution environment with the same error.
try_quietly_as() {
    quietly try_as "${@}" or die "\"${@}\" returned error code ${?}"
}

# ....................{ REGULAR EXPRESSIONS                }....................
# For additional regular expression functionality, see Zeshy Regex and String.

# void match(
#   char *regular_expression, char *string = null,
#   char *match_variable_name = "MATCH", char *group_array_name = "match")
#
# Match the passed string or stdin if no such string is passed against the
# passed Perl-compatible regular expression (PCRE). This function returns
# failure if this string does not match and success otherwise, as well as
# setting match group-specific variables in the latter case:
#
# * The name of the scalar variable to which this function puts the whole match,
#   defaulting to the global variable "${MATCH}".
# * The name of the array variable to which this function puts all match groups,
#   defaulting to the global variable "${match}".
#
# This function never prints output in either case. Hence if you require the
# exact text matched, you must either access the above match group-specific
# variables or call a helper function defined by Zeshy Regex.
#
# This function also accepts a hidden "fifth parameter": the global variable
# "${ZESHY_MATCH_OPTIONS}", which when set causes this function to pass those
# options to the pcre_compile() built-in when compiling the passed pattern.
#
# For convenience, this function also accepts "stdin"-style piped input rather
# than an explicit passed string: e.g.,
#
#     >>> print 1776 | match '^\d'
#     >>> print "${MATCH}" 
#     1
match() {
    # Parse parameters.
    die_unless_at_least_two_arguments\
        'expected at least one regular expression and one string'
    string regex="${1}" text="${2}"\
        match_variable_name="${3:-MATCH}" group_array_name="${4:-match}"
#   print "pattern: "${(q)regex}" | string: ${string} | match_variable_name: ${match_variable_name} | group_array_name: ${group_array_name} "
#   print "mo: ${ZESHY_MATCH_OPTIONS[@]}"

    # Compile the match. (Yes, Zsh requires this regardless of whether we intend
    # to actually reuse this match.)
    if is_set 'ZESHY_MATCH_OPTIONS'; then 
#       print "ZESHY_MATCH_OPTIONS: ${ZESHY_MATCH_OPTIONS}"
#       pcre_compile -m "${pattern}" ||
        pcre_compile "${ZESHY_MATCH_OPTIONS[@]}" "${regex}" or
            die "\"${regex}\" not a valid regular expression under match options \"${ZESHY_MATCH_OPTIONS[@]}\""
    else
        pcre_compile "${regex}" or
            die "\"${regex}\" not a valid regular expression"
    fi
    
    # Match.
    pcre_match -v "${match_variable_name}" -a "${group_array_name}" --\
        "${text}" or return ${?}
}

# void match_multiline(...)
#
# Match the passed string against the passed Perl-compatible regular expression
# (PCRE) in a multi-line fashion (e.g., matching '^' and '$' at both newline and
# the beginning and end of the string, respectively). In all other respects,
# this function is identical to the match() function.
match_multiline() {
    list ZESHY_MATCH_OPTIONS; ZESHY_MATCH_OPTIONS=( -m )
    match "${@}"
}

# ....................{ PROCESSES                          }....................
# int get_current_pid(void)
#
# Get the PID (process ID) for the current process. This is an integer uniquely
# identifying this process.
get_current_pid() {
    die_unless_no_arguments
    print "${$}"
}

# ....................{ FILES                              }....................
# bool is_absolute_path(char *path)
#
# Return success if the passed path is absolute (i.e., begins with an "/").
is_absolute_path() {
    die_unless_one_argument 'expected exactly one path'
    is "${1[1]}" == '/' si
}

# char *canonicalize_path(char *path)
#
# Get the canonicalized form of the passed absolute path. Canonicalization
# reduces this path to standard form, such that two canonical paths are equal
# if and only if they represent the same file. Note that this is not
# necessarily the case with non-canonical paths (e.g., "/tmp" and
# "/tmp/../tmp/./" are not equal but represent the same directory).
# Specifically, canonicalization:
#
# * Expands every pseudo-directory component (e.g., "./", "../") iteratively,
#   until the resulting path contains no pseudo-directory components.
# * Expands every symlink in every component of the passed path recursively,
#   until the resulting path contains no symlinks.
canonicalize_path() {
    die_unless_one_argument 'expected exactly one path'
    try readlink --canonicalize-existing "${1}"
}

# char *canonicalize_path_nonfatal(char *path)
#
# Get the canonicalized form of the passed absolute path. Unlike the
# canonicalize_path() function, this function does not raise an exception when
# the passed path does not exist; it simply canonicalizes as much of this path
# as exists.
canonicalize_path_nonfatal() {
    die_unless_one_argument 'expected exactly one path'
    try readlink --canonicalize-missing "${1}"
}

# int get_path_mtime(char *path)
#
# Get the mtime (i.e., modification time) for the passed absolute path. The
# running kernel modifies this time as follows:
#
# * If this path corresponds to a file, then this time is updated to the
#   current time on each creation, filename change, permission change, or
#   modification of file contents.
# * If this path corresponds to a directory, then this time is updated to the
#   current time on each creation, pathname change, or permission change of
#   this directory as well as creation, filename change, or deletion of files
#   in this directory. Note that this time is not updated on permission change
#   or modification of file contents for files in this directory.
#
# The return value is an integer, suitable for testing with "-ge" and "-le".
get_path_mtime() {
    die_unless_one_argument 'expected exactly one path'
    try zstat +mtime "${1}"
}

# ....................{ FILES ~ directories                }....................
#FIXME: Rename "make_dirs_recursively".
# void make_directory_if_not_found(char *dirname1, char *dirname2, ...)
#
# Examine each of the passed absolute paths and, for each non-existant path,
# make that path and all non-existant parent paths of that path.
make_directory_if_not_found() {
    die_unless_one_argument 'expected exactly one dirname'

    # While there are more paths to consider, shift the current path to be
    # considered to a local variable "new_path" and make it when not found.
    string new_path
    while is "${#@}" -ne 0 si; do
        new_path="${1}"; shift

        if is -f "${new_path}" si; then
            die "\"${new_path}\" already a file"
        elif is ! -d "${new_path}" si; then
            utter "making \"${new_path}\"..."
            try mkdir --parents "${new_path}"
        fi
    done
}

# ....................{ IMPORTS                            }....................
# void zimports(char *script_name1, ..., char *script_nameN)
# 
# Import all passed scripts.
zimports() {
    die_unless_at_least_one_argument 'expected at least one script name'

    string script_name
    for script_name in "${@}"; do
        zimport "${script_name}"
    done
}

# void zimport(char *pathname, char *arguments)
# 
# Conditionally import the passed file or directory, if not previously imported
# by this function or externally modified since such import. We pass the passed
# arguments to all files imported in this manner.
# 
# If the passed path is relative, we look for such path first under the current
# working directory and then Zeshy's root directory (e.g., "/usr/share/zeshy/").
# We then resolve the exact Zeshy script(s) to be imported as follows:
#
# * If the passed path is an existing file, import such file.
# * If the passed path is an existing directory:
#   * Containing a file named "${ZESHY_MAIN_SCRIPT_BASENAME}", import such file.
#   * Otherwise, import all files such directory contains.
# * Otherwise, die.
#
# This function mimics the import() built-in of most high-level languages. To
# avoid conflict with ImageMagick's "import" command, we prefer "zimport".
#
# --------------------( VARIABLES                          )--------------------
# This function defines local variables, which imported scripts may safely
# access for informative path metadata: namely,
#
# * "zeshy_script_name", having the relative path to the imported script under
#   "${ZESHY_HOME}/src".
# * "zeshy_script_path", having the absolute path to the imported script.
# * "zeshy_script_mtime", having the modification time of the imported script.
#
# --------------------( EXAMPLES                           )--------------------
#     # Implicitly imports the Zeshy script "zeshy/os/.main".
#     >>> zimport zeshy/os
zimport() {
    die_unless_at_least_one_argument\
        'expected one pathname and optional script options'
#   utter "zimporting ${1}..."

    # Passed script name. Shift it off the argument stack, to allow us to pass
    # this script the set of all remaining arguments on sourcing it below.
    string zeshy_script_name="${1}"; shift

    # Absolute path to this script.
    string zeshy_script_path 
    
    # If the passed script name is either an absolute path or existing relative
    # path, try to import it as is.
    if is "${zeshy_script_name[1]}" == '/' || -e "${zeshy_script_name}" si
    then zeshy_script_path="${zeshy_script_name}"
    #FIXME: Actually, first try the current working directory.
    # Otherwise, try to import a Zeshy component having that script name.
    else zeshy_script_path="${ZESHY_HOME}/src/${zeshy_script_name}"
    fi
    
    # Delegate to helper functions depending on path type.
    if is -d "${zeshy_script_path}" si
    then zimport_dir  "${zeshy_script_path}" "${@}"
    else zimport_file "${zeshy_script_path}" "${@}"
    fi
}

# void zimport_dir(char *dirname, char *arguments)
# 
# Conditionally import the passed directory. See zimport() for details.
zimport_dir() {
    die_unless_at_least_one_argument\
        'expected one dirname and optional import options'
    string zeshy_script_dir="${1}"; shift
    is -d "${zeshy_script_dir}" si or
        die "\"${zeshy_script_dir}\" not a directory or not found"
    string zeshy_main_script="${zeshy_script_dir}/${ZESHY_MAIN_SCRIPT_BASENAME}"

    # If this directory contains a main script, import only such script;
    # otherwise, import all children of such directory.
    if is -f "${zeshy_main_script}" si
    then zimport_file         "${zeshy_main_script}" "${@}"
    else zimport_dir_children "${zeshy_script_dir}" "${@}"
    fi
}

# void zimport_dir_children(char *dirname, char *arguments)
# 
# Conditionally import all files and directories under the passed directory.
zimport_dir_children() {
    die_unless_at_least_one_argument\
        'expected one dirname and optional import options'
    string zeshy_script_dir="${1}"; shift
    is -d "${zeshy_script_dir}" si or
        die "\"${zeshy_script_dir}\" not a directory or not found"

    # Import all non-dotfiles in this directory with the "(^D)" modifier (i.e.,
    # all files and directories *NOT* prefixed by a "."). Since Zeshy scripts
    # explicitly import dependencies, order of import is mostly insignificant.
    string zeshy_script_dir_child
    for    zeshy_script_dir_child in "${zeshy_script_dir}"/*(^D); do
        zimport "${zeshy_script_dir_child}" "${@}"
    done
}

# void zimport_file(char *filename, char *arguments)
# 
# Conditionally import the passed file. See zimport() for details.
zimport_file() {
    die_unless_at_least_one_argument\
        'expected one filename and optional import options'
    string zeshy_script_path="${1}"; shift
    is -f "${zeshy_script_path}" si or
        die "\"${zeshy_script_path}\" not a file or not found"
   
    # Canonicalize the path so as to ensure the dictionary lookup below
    # successfully compares it against a previously canonicalized path.
    zeshy_script_path="$(canonicalize_path "${zeshy_script_path}")"

    # Modification time of this script.
    string zeshy_script_mtime="$(get_path_mtime "${zeshy_script_path}")"
    
    # If the script has not yet been imported or has been imported but has
    # changed since being imported, do so.
#   if is_unset "ZESHY_IMPORTED_PATH_TO_MTIME["${zeshy_script_path}"]}" or\
    if is -z "${ZESHY_IMPORTED_PATH_TO_MTIME[(I)"${zeshy_script_path}"]}" ||\
        "${ZESHY_IMPORTED_PATH_TO_MTIME["${zeshy_script_path}"]}" -ne\
        "${zeshy_script_mtime}" si; then
        # If the script corresponds to a command-specific script under
        # "zeshy/command" excluding the top-level ".main" script, ensure this
        # command is actually installed.
        if is "${zeshy_script_path}" == */zeshy/command/* si; then
            string command_name="${zeshy_script_path#*/zeshy/command/}"

            if is "${command_name}" != '.main' si; then
                is_installed "${command_name}" or die\
                    "\"${command_name}\" not installed or not found on \$PATH"
            fi
        fi

        # Prior to doing so, record the script as being imported. This prevents
        # reimportation, should this script or another script imported by this
        # script attempt to import this script again.
        ZESHY_IMPORTED_PATH_TO_MTIME["${zeshy_script_path}"]="${zeshy_script_mtime}"
         
        # Do so.
        utter "loading \"${zeshy_script_path}\"..."
        source "${zeshy_script_path}" "${@}"
    fi
}

# void zeshy_initialize_imports(void)
#
# Initialize the imports dictionary, used by the zimport() function. This is a
# global dictionary mapping from imported script name to the mtime (i.e.,
# modification time) of the script at the time of importation. The zimport()
# function adds script names to this dictionary on importing those scripts so
# as to record having done so. This record keeping allows that function to
# avoid importing already imported scripts.
#
# Zeshy Shell requires we separate this initialization into a distinct function,
# for hitherto inexplicable reasons. (There be subtle dragons aboot.)
zeshy_initialize_imports() {
    die_unless_no_arguments
    map global ZESHY_IMPORTED_PATH_TO_MTIME
    
    # Explicitly empty the dictionary. This is irrelevant on the first call to
    # this function, but definitely matters on subsequent calls!
    ZESHY_IMPORTED_PATH_TO_MTIME=( )
}

# ....................{ MAIN                               }....................
_zeshy_core() {
    die_unless_no_arguments

    # Initialize the imports dictionary used by the zimport() function.
    zeshy_initialize_imports
    
    # Add this script to the set of all imported scripts, to prevent subsequent
    # imports from (accidentally) reimporting it. Do not add this to the
    # initialize_imports() function, due to largely inexplicable dragons.
    ZESHY_IMPORTED_PATH_TO_MTIME["${zeshy_core_path}"]="$(get_path_mtime "${zeshy_core_path}")"
    
    #FIXME: Zsh-ify these matches, using the above match_multiline() function.
    # Determine whether or not this process is running is a cronjob. This is
    # adapted from this itworld.com article, "Am I being run by cron?":
    #        http://www.itworld.com/Comp/3380/nls_unixcron041209/index.html
    # 
    # Do this prior to uttering imports, as the utter() function requires this.
    string cron_pids="$(pgrep -x cron)"
    integer grandparent_pid="$(ps -eo ppid,pid= | grep " ${PPID}$" | awk '{print $1}')"
    ZESHY_IS_CRONJOB="$(one_if match_multiline "^${cron_pids}$" "${grandparent_pid}")"
#   echo "cron: ${ZESHY_IS_CRONJOB}; cron_pids: ${cron_pids}; gpid: ${grandparent_pid}"

    # Inform the user that this script is being imported. This script is usually
    # sourced via the Zsh source() built-in rather than the Zeshy zimport()
    # function; thus, our failure to do this here would require callers do this
    # there, prior to their sourcing this script.
    #
    # Distinguish the former from the latter by noting whether the
    # "${zeshy_script_mtime}" variable has been set or not; if it has, this script
    # was sourced via zimport() rather than source().
    is_unset 'zeshy_script_mtime' or utter "loading \"${zeshy_core_path}\"..."
    
    # Set the default script name prior to all other logic, as any logic
    # raising an error requires this name for logging that error. Only do this
    # if the current process is not an interactive Zsh shell as, in that case,
    # the get_script_name() function dynamically inspects the script name from
    # the function call stack.
    if is_empty "${ZESHY_SCRIPT_NAME}" and not is_shell_interactive; then
        # Import Zeshy components required below.
        zimport zeshy/os
        
        # Strip the filetype from the script name, if present.
        ZESHY_SCRIPT_NAME="$(get_current_process_basename)"
        ZESHY_SCRIPT_NAME="${ZESHY_SCRIPT_NAME%%.*}"

        # Default the script name to "zeshy", if "zsh".
        is "${ZESHY_SCRIPT_NAME}" == zsh si and ZESHY_SCRIPT_NAME=zeshy
    fi
    
    # Make cache directories, if not already made.
    make_directory_if_not_found "${ZESHY_CACHE_HOME}" 
    make_directory_if_not_found "${ZESHY_COMPLETION_CACHE_PATH}"
}

# Call and then immediately unset (i.e., delete) _zeshy_core().
_zeshy_core
unfunction _zeshy_core

#FIXME: Obsolete.
#FIXME: This function appears to be functionally obsolete now. If so, kill and
#rename which_command() to this.
# Aliases.
#alias which_binary="which_command"
#alias which_binary_nonfatal="which_command"

# char *which_command(char *command)
#
# Print the absolute path to the passed command: e.g.,
#
#     >>> which_command zsh /bin/zsh
#
# If the passed command is a string, all but the first whitespace-delimited word
# of the string is ignored: e.g.,
#
#     >>> which_command "zsh -x -o shwordsplit scr" /bin/zsh
#
# If the passed command is not found, if multiple binaries are passed, or if no
# command is passed, prints an error and dies.
#which_command() {
#Call the whence() built-in outside of "local" so as to retain the return
    # code. (ZSH == FAIL on that one.) 
#    string command_path; command_path="$(which_command "${@}")"
#    die_unless_ok "\"${1}\" not found"
#    print "${command_path}"
#}
#
# Identical to the which_command() function except that, if the passed command
# does not exist, returns nothing rather than dies.

#FIXME: No longer meaningful under TRAPZERR(); excise.
# void die_unless_ok(char *error_message)
#
# Die with the passed error message unless the previous command succeeded.
#die_unless_ok() {
#    # Cache the prior command's return code, as our initial sanity check on
#    # arguments replaces this code with its own.
#    integer prior_command_return_code=${?}
#    die_unless_one_argument 'expected exactly one error message'
#    is ${prior_command_return_code} -eq ${ZESHY_SUCCESS_CODE} si or die "${1}"
#}

# void utter_import(char *script_name)
#
# Echo a message informing the user that the passed script name is being
# imported. This function should be called prior to actually importing that
# script if feasible.
#utter_import() {
#    die_unless_one_argument 'expected exactly one script name'
#
#    utter "loading \"${1}\"..."
#}

    # If the caller has supplied no explicit "${ZESHY_SCRIPT_NAME}", supply a
    # default.  Failing to do this encourages the utter() function to use the
    # name of this function as its script name, producing unaesthetic results.
#   "${ZESHY_SCRIPT_NAME:=zeshy}"

        # Print the passed error message followed by a complete backtrace.
#   curse "${@}"
#   print_stack_trace
 #
    # Shells differentiate
    # fatal from non-fatal errors by setting the high bit (i.e., 2^7 = 128).
    # According to "zshbuiltins", this forces Zsh to continue handling the
    # signal as if untrapped and hence returning the same exit status. Having no
    # arcanely carnal knowledge of the Linux signal implementation, it's unclear
    # why setting the high bit 

    #FIXME: Old.
    # If the passed path is a directory, only import filename
    # "${ZESHY_MAIN_SCRIPT_BASENAME}" in this directory.
#   is -d "${zeshy_script_path}" si and
#       zeshy_script_path="${zeshy_script_path}/${ZESHY_MAIN_SCRIPT_BASENAME}"
    
    # If this path does not exist, die.
#   is -f "${zeshy_script_path}" si or die "\"${zeshy_script_path}\" not found"
 #
#FIXME: Impossible to remember, I'm afraid. Perhaps "fail_if_error", instead?
# int fail_if_previous_command_failed(void)
# 
# Return from the current function with failure if the previous command or
# function also returned with failure.
#alias fail_if_previous_command_failed="is_ok || return ${ZESHY_FAILURE_CODE}"

#; ZESHY_IMPORTED_PATH_TO_MTIME=( )
#   typeset -Ax ZESHY_IMPORTED_PATH_TO_MTIME; ZESHY_IMPORTED_PATH_TO_MTIME=( )
 # The "-Ax" option to the "typeset" commands defines each such variable as an
# [A]ssociative array (i.e., a dictionary) and e[x]ported to the global
# environment for later access.

# Ascertain whether we are running as a cronjob and, if so, alter output
# appropriately. In particular, print the current date as a timestamp prior to
# printing all other output.

#   die_unless_at_least_one_argument 'expected at least one string'

#   # If no string was passed, attempt to read "stdin" for piped input.
#   if is_one_argument; then
#       set -- "${1}" "$(< /dev/stdin)"
#   fi

#   pcre_compile "${1}" || die "\"${1}\" not a valid regular expression"
#   pcre_match "${2}" || return ${?}
#   return ${ZESHY_SUCCESS_CODE}

# This function returns success 
# If this regular expression matched at least one group, this function returns
# this group as a string for caller convenience... Else, this function returns
# nothing. In the former case, callers may retrieve the set of all groups via
# the global "${match}" array. (See above.)

    # When the whence() built-in fails, it prints the name of the passed command
    # followed by "not found". Thus, if it prints such a message, the passed
    # command does not exist. Note that testing the return code is problematic
    # here, since setting a local variable always forces the return code to 0
    # (i.e., success). 
#   if [[ "${command_path}" == *" not found" ]]; then
#       return ${ZESHY_FAILURE_CODE}
#   else
#       echo "${command_path}"
#       return ${ZESHY_SUCCESS_CODE}
#   fi

    # O.K., this is tricksy: if the eventual caller explicitly quote-protected
    # the passed command name, there exists another "layer" of quote-protection
    # to unravel. Do so, alas.
#   if ! is_installed "${command_name}" && is_installed "${(Q)command[1]}"; then
#       command_name="${(Q)command[1]}"
#   fi

    #echo "PID: $$"
    #echo "current_process_basename:"
    #get_current_process_basename
    #echo "current_process_command_line:"
    #get_current_process_command_line

# ....................{ GLOB EXPRESSIONS                   }....................
# char **glob_non_dotfiles_in(char *dirname)
#
# Glob all non-dotfiles (i.e., all files and directories whose first character
# is not a '.' dot) in the passed directory.
#glob_non_dotfiles_in() {
#    [[ ${#} -eq 1 ]] || die "expected exactly one directory name"
#    local dirname="${1}"
#    [[ -d "${dirname}" ]] || "\"${dirname}\" not a directory"
#
#    # Glob all non-dotfiles via the "(^D)" modifier.
#    echo "${dirname}"/*(^D)
#}

 # Enable variable substitution in prompt expansions in a "synchronous" fashion.
# Enabling this re-evaluates each prompt expansion after perform each
# interactive command with the current values of those variables without
# having to manually recreate the prompt each time.
#setopt promptsubst

#The existence of this variable also
# serves to inform callers as to whether or not this script has been imported
# yet and, when it has, to avoid reimporting it.

# Directory above the directory having the current script. This environment
# variable should have been permanently added to the current system as well.
#[[ -n "${ZESHY_ROOT}" ]] ||  
#    export ZESHY_ROOT=$(readlink --canonicalize-existing "${ZESHY_HOME}/..")

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
