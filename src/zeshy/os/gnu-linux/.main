#!/usr/bin/env zsh
# ====================[ gnu-linux                          ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Linux. This Zeshy component implements GNU/Linux-specific functionality.

# ....................{ DEPENDENCIES                       }....................
zimport zeshy/file
zimport zeshy/os

# void _zeshy_os_gnu-linux(void)
#
# Import Zeshy components specific to the current Linux distribution.
_zeshy_os_gnu-linux() {
    string current_distro_dir="$(dirname "${zeshy_script_path}")/distro/$(get_distro_name)"
    is_file "${current_distro_dir}" and zimport "${current_distro_dir}"
}

# ....................{ DISTROS                            }....................
# void get_distro_name(void)
#
# Get the (strictly lowercase) name of the distro running on the current system:
# e.g.,
#
#     >>> get_distro_name
#     exherbo   # under Exherbo systems
#     gentoo    # under Gentoo systems
get_distro_name() {
    if   is_file '/etc/exherbo-release'
    then echo 'exherbo'
    elif is_file '/etc/gentoo'
    then echo 'gentoo'
    else get_os_name
    fi
}

# ....................{ PROCESSES ~ current                }....................
# char *get_current_process_basename(void)
#
# Get the basename of the binary corresponding to the current process.
get_current_process_basename() {
    die_unless_no_arguments
    string current_process_command_line="$(get_current_process_command_line)"
    
    #FIXME: This only strips one dash. How to strip more?
    # Strip prefixing dashes from this string to prevent the "basename" command
    # from intepreting such dashes as options to that command. This is actually
    # a real-world concern. By convention, for example, Linux prefixes login
    # shell command lines with one dash.
    current_process_command_line="${current_process_command_line#-}"
    
    # Array of strings split on null bytes from the above command-line string.
    # This is the Linux convention, and probably not applicable to other *nix.
    current_process_command_line_parts=( "${(0)current_process_command_line}" )
    
    # If the current process is a Zsh script (and it better be!), then the path
    # to this process is given by the third string in this array: e.g.,
    #
    #   # For a Zeshy script "h3110", this array resembles...
    #   current_process_command_line_parts=( zsh /usr/bin/zeshy h3110 )
    string current_process_path
    if is "${current_process_command_line_parts[1]}" == zsh si
    then current_process_path="${current_process_command_line_parts[3]}"
    else current_process_path="${current_process_command_line_parts[1]}"
    fi

    # Return the basename of this binary.
    basename "${current_process_path}"
}

# char *get_current_process_command_line(void)
#
# Get the command line under which the current process is executing. This is a
# single string having these parts:
#
# * Absolute OR relative path to the executable file from which the process was
#   executed. Note that, in the latter case, there is no reliable mechanism for
#   converting the relative path into an absolute path.
# * Set of all command line arguments passed to the above file, where each such
#   argument including the first is prefixed by a null delimiter (i.e., "\x00").
#
# Due to the above unreliabilities, this string is best used for displaying non-
# critical log and user interface labels rather than critical functionality.
get_current_process_command_line() {
    die_unless_no_arguments
    
    # Absolute path to the file having the command line for the current process.
    string current_process_command_line_path="/proc/$(get_current_pid)/cmdline"
    die_unless_dir "${current_process_command_line_path}"
    cat "${current_process_command_line_path}"
}

# ....................{ HARDWARE ~ udev                    }....................
# Aliases.
alias udevdi="udev_device_info"

# char *udev_device_info(char *filename)
#
# Display udev-specific device information for the passed filename, typically a
# device file under the /dev pseudo-filesystem. This function is particularly
# helpful for obtaining udev-associated "Product" and "Vendor" strings for a
# device, with which you may then write custom udev, X.org, etc. rules for
# dynamically configuring the device on hot-plug.
udev_device_info() {
    die_unless_one_argument 'expected exactly one filename'

    string device_file="${1}"
    die_unless_device_file "${device_file}"

    utter "displaying \"${device_file}\" device data..."
    run_as_superuser udevadm info --query=all --name="${device_file}"

    utter "displaying \"${device_file}\" recursive attributes..."
    run_as_superuser udevadm info --attribute-walk --name="${device_file}"
}

# ....................{ KERNEL                             }....................
#FIXME: Implement! Should, in order:
#* Accept either an absolute or relative pathname. If absolute, is assumed to be
#  a "tar.bz2" archive having the kernel to be upgraded to; otherwise, to be the
#  basename of a directory under "/usr/src/". In the former case, transparently
#  unpack that archive into "/usr/src/", without overwriting any existing data.
#* Copy the "/usr/src/linux/.config" file, if present, into the new kernel dir.
#* Cd to the new kernel dir.
#* Run "make oldconfig".
#* If successful, forcefully overwrite the "/usr/src/linux" symlink.
#* Cd back.

# void upgrade_kernel(char *kernel_name)
#upgrade_kernel() {
#}

# ....................{ MAIN                               }....................
# Call and then immediately unset (i.e., delete) _zeshy_os_gnu-linux().
_zeshy_os_gnu-linux
unset _zeshy_os_gnu-linux

#FIXME: Obsolete.
#   local udev_device_path="$(run_as_superuser udevadm info --query=path --name="${device_file}")"
#   run_as_superuser udevadm info --query=all --path="${udev_device_path}"
#   run_as_superuser udevadm info --attribute-walk --path="${udev_device_path}"

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
