#!/usr/bin/env zsh
# ====================[ exherbo                            ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Exherbo. This Zeshy component implements Exherbo Linux-specific
# functionality.

# ....................{ IMPORTS                            }....................
zimport zeshy/command

# ....................{ CONFIGURATION                      }....................
# Default "cave" options.
CAVE_OPTIONS=(
    --continue-on-failure if-satisfied
    --show-option-descriptions all
)

# Unsafe "cave" options (e.g., when installing unsafely).
CAVE_OPTIONS_UNSAFE=(
    --uninstalls-may-break '*/*'
    --permit-downgrade '*/*'
    --permit-old-version '*/*'
)

#FIXME: Remove.
export INQUISITIO_OPTIONS="\
--log-level warning \
--matcher pcre \
"

#FIXME: Remove.
# Note that default command-line arguments for Paludis are defined via the
# ${PALUDIS_OPTIONS} environment variable, so as to expose these arguments to
# these aliases and functions as well as dependent wrappers.
export PALUDIS_OPTIONS="\
--continue-on-failure if-satisfied \
--dl-blocks accumulate \
--dl-circular error \
--dl-downgrade warning \
--dl-new-slots always \
--dl-reinstall never \
--dl-reinstall-scm never \
--dl-reinstall-targets auto \
--dl-suggested show \
--dl-upgrade always \
--log-level warning \
--multitask \
--show-reasons summary \
--show-use-descriptions all \
--show-package-descriptions new \
--with-unused-dependencies \
"

# ....................{ ALIASES                            }....................
alias cav1="cave-install-lazy --preserve-world"
alias cavfc="cave fix-cache"
alias cavfl="cave-fix-linkage"
alias cavn="cave-news"
alias cavo="cave owner"
alias cavs="cave show"
alias cavse="cave search"
alias cavsy="cave sync"
alias cavi="cave-install-complete"
alias cavil="cave-install-lazy"
alias caviu="cave-install-unsafely"
alias cavr="cave-reinstall"
alias cavru="cave-reinstall-unsafely"
alias cavu="cave-uninstall"
alias cavwr="cave-world-remove"
alias ec="eclectic"
alias ecci="eclectic config interactive"
alias ecrc="eclectic rc"
alias pal="paludis"
alias pali="paludis --install"
alias palo="paludis --owner"
alias pals="paludis --sync"
alias palu="paludis --uninstall"
alias palq="paludis-query"
alias palar="paludis-add-repository"
alias palib="pali --dl-blocks discard"
alias palip="pali --pretend"
alias palit="palric; pali"
alias palupuu="palu --permit-unsafe-uninstalls"
alias palsedr="paludis-sed-recursive"
alias palisupi="paludis-resume-install"
alias palisupt="paludis-resume-test"

# ....................{ ECLECTIC                           }....................
function eclectic_java_select_gcj() { set_eclectic_jdk gcj }
function eclectic_java_select_sun() { set_eclectic_jdk sun }
function eclectic_java_select_icedtea() { set_eclectic_jdk icedtea }

# void set_eclectic_jdk(char *grep_pattern)
#
# Sets the currently selected JDK to the JDK matching the passed grep pattern.
set_eclectic_jdk() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one grep pattern"

    local JDK_NAME=$(get_eclectic_jdk_name ${*})
    utter "selecting ${JDK_NAME} as the current JDK..."
    try eclectic java-jdk set ${JDK_NAME}
    try eclectic java-jre set ${JDK_NAME}
}

# void get_eclectic_jdk_name(char *grep_pattern)
#
# Returns the name of a selectable JDK matching the passed grep pattern.
get_eclectic_jdk_name() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one grep pattern"
    try eclectic --no-colour java-jdk list |\
        grep --max-count=1 "${1}" |\
        awk '{printf "%s", $2}'
}

# ....................{ CAVE                               }....................
cave-fix-linkage() {
    try cave fix-linkage --execute -- \
        --permit-downgrade '*/*' \
        --permit-old-version '*/*' \
         "${CAVE_OPTIONS[@]}" "${@}"
}

cave-install-complete() {
    try cave resolve --complete --execute "${CAVE_OPTIONS[@]}" "${@}"
}

cave-install-lazy() {
    try cave resolve --lazy --execute "${CAVE_OPTIONS[@]}" "${@}"
}

cave-install-unsafely() {
    try cave-install-complete "${CAVE_OPTIONS_UNSAFE[@]}" "${@}"
}

cave-reinstall() {
    try cave resolve --everything --execute "${CAVE_OPTIONS[@]}" "${@}"
}

cave-reinstall-unsafely() {
    try cave-reinstall "${CAVE_OPTIONS_UNSAFE[@]}" "${@}"
}

cave-uninstall() {
    try cave uninstall --execute "${CAVE_OPTIONS[@]}" "${@}"
}

cave-news() {
    page eclectic news read all
}

# void cave-paste-patch(char *patch_range)
#
# Upload a new exheres repository patch given the current exheres repository.
# This formats the patch via "git format-patch origin", then "pastes" (i.e.,
# uploads) the plaintext contents of the patch to the online "pastebin"
# service currently configured in "~/.wgetpaste.conf" or "/etc/wgetpaste.conf".
# This returns a URL suitable for submission to the "hacchi" IRC bot via the
# "#exherbo" channel on Freenode.
#
# Complex, we know. But it works.
#
# Examples:
#
#     # Pastes the most recent commit.
#     cave-paste-patch -1
#     cave-paste-patch HEAD~1  # alternative syntax
#
#     # Pastes the most recent two commits.
#     cave-paste-patch -2
#     cave-paste-patch HEAD~2..HEAD  # alternative syntax
cave-paste-patch() {
    utter "pasting patch..."
    git-format-patch-stdout "${@}" | wgetpaste --language Bash --raw
}

cave-world-remove() {
    [[ "${#}" -ge 1 ]] || die "expected at least one exheres name"
    local exheres_name
    for   exheres_name in "${@}"; do
        utter "removing \"${exheres_name}\" from world..."
        cave update-world --remove "${exheres_name}"
    done
}

# ....................{ PALUDIS                            }....................
#FIXME: Rename all uses of "paludis-" with "exherbo-", and all uses of "pal"
#with "exh". (This generalizes the move away from Paludis to Cave.)

# void paludis-add-repository(char *repository_name)
# 
# Add a new Exherbo repository corresponding to the passed repository name.
#
# This function expects a repository name as listed by the following command:
# 
#     cave show -t package 'repository/*'
#
# That is, it expects the repository to be registered under either the
# "::unavailable" or "::unavailable-unofficial" pseudo-repositories. 
paludis-add-repository() {
    [[ "${#}" -eq 1 ]] || die "expected exactly one repository name"
    cave resolve repository/"${1}" --execute
}

paludis-update-world() {
    paludis --install --dl-reinstall if-use-changed world
}

paludis-sed-recursive() {
    [[ "${#}" -eq 2 ]] ||
        die "expected exactly one search pattern and one replace pattern"

    set_git_globals
    mv-pcre -cr "${1}" "${2}" "${GIT_ROOT}"/{exlibs,packages}/**/*.{exlib,exheres-0}
}

# Resume a failed install from the install phase, rather than from the
# beginning. This is generally safe - but should be used with caution. Also,
# note that, when Paludis fails, it generally emits a "Resume command." This is
# not what you think, however: calling this command actually does very little
# that the vanilla install command does not already do. Most saliently, this
# "Resume command" does not resume a failed install from the install phase. It
# bloody starts over! This has bit me several times, but no more.
paludis-resume-install() {
    utter "forcefully skipping to the install phase for '$1'..."
    paludis --install --skip-until-phase setup --abort-at-phase unpack "$1"
    paludis --install --skip-until-phase install "$1"
}

# Resume a failed install from the install phase, rather than from the
# beginning. This is generally safe - but should be used with caution.
paludis-resume-test() {
    utter "forcefully skipping to the test phase for '$1'..."
    paludis --install --skip-until-phase setup --abort-at-phase unpack "$1"
    paludis --install --skip-until-phase test "$1"
}

# Recache the ./Manifest file for some ebuild.
# 
# Note that, if that ebuild is fetch restricted (i.e., it contains a line
# RESTRICT="fetch" and supplies a "pkg_nofetch" function), you may need to
# disable the fetch restriction before calling this function.
paludis-recache-manifest() {
    utter "forcefully recaching Manifest entries for '$1'..."
    ebuild --force "$1" manifest
}

# Uninstall all unused ebuilds or exheres.
paludis-uninstall-unused() {
    utter "pretending to uninstall unused..."
    paludis --uninstall-unused --pretend
    utter "uninstalling unused..."
    paludis --uninstall-unused
}

#FIXME: Consider implementing an equivalent function to:
# qlist ${EXHERES_NAME} | xargs scanelf -L -n -q -F '%n #F' | tr , ' ' | xargs qfile -C | sort -u
#This emits all shared libraries listed as "DT_NEEDED" for the passed exheres:
#in other words, the set of all known dependencies for the exheres.

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyleft 2007-2010 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
