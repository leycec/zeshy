#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "LICENSE" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle *glob-matched fields* (i.e., substring-separated substrings on a line
# matched with glob or glob character classes).

# ....................{ ITERATORS                          }....................
# While there exists a for_string_line_fields_split_on_pcre() generalizing
# for_string_line_fields_split_on_pcre_class(), there exists no
# for_string_line_fields_split_on_glob() generalizing
# for_string_line_fields_split_on_glob_class_bounded(). The simplest explanation why is
# that globs have no equivalent to PCRE multiline mode. Without such mode,
# creating a column separator glob becomes an all but infeasible chore; and even
# where feasible risky, since such glob must be explicitly engineered to *NOT*
# match newlines. But that's not the only explanation why. Such a generalization
# requires some equivalent to PCRE negative lookahead assertions. While globs do
# support "(^...)"-driven glob negation, such negation consumes what it matches;
# hence, the closest glob equivalent for capturing a column would be
# "((^${~column_separator_glob})#)". However, notice the use of *TWO* capturing
# subpatterns. Since glob syntax provides no means of disabling match capturing,
# callers must ignore every other match. This becomes patently ridiculous
# quickly -- at which point it's difficult to justify the effort.

#FIXME: This has become slightly desynchronized with "pcre/field". In
#particular:
#
#* All fields should be optional.
#* An explicit count need not be passed: just parse the first line for the field
#  count.
#* An example should be provided.
#
#Honestly, it's a pain synchronizing these implementations. But nothing can
#be reasonably abstracted out into an even more general, lower-level function. I
#mean, "pcre/field" has already gone *REALLY* abstract. We'll just have to grit
#our teeth and do it. That, or just drop this function... Consider it.
#FIXME: What's with the "_bounded" nomenclature? Ideally, drop such phrase.

:func_ '<globbable> :string
    :for_string_line_fields_split_on_glob_class_bounded(
        :string text,
        :int_positive column_count,
        :string_nonempty column_separator_class,
        :string_nonempty command)' :func{
    #FIXME: Append *ALL* local variables by "__fslfsogcb".

    # Localize arguments.
    :string\
        text="${1}"\
        column_count="${2}"\
        column_separator_class="${3}"\
        command="${4}"\
        glob_column\
        glob_column_separator\
        glob_column_separated\
        glob_columns_sans_last\
        glob_columns\
        glob_column__sltsc

    #FIXME: Generalize into a new :die_if_string_matches_glob() function.

    # If such class matches newlines, throw an exception.
    if { :is_string_matches_glob\
        "${ZESHY_ASCII_NEWLINE}" "[${column_separator_class}]" } {
        :die 'Column separator character class "'${column_separator_class}'" matches newlines.'
    }

    # Glob expression matching any column prior to the desired column.
    glob_columns_prior="([^${ZESHY_ASCII_NEWLINE}${column_separator_class}]#(|(#e)))"

    # Glob expression matching the desired column. Dismantled, this is:
    #
    # * "(#b)", enabling back references (i.e., match groups) for all
    #   subsequent groups. Do this as late as possible to avoid capturing
    #   columns preceding such column.
    glob_column__sltsc="(#b)([^${column_separator_class__sltsc}]#)([${column_separator_class__sltsc}]|(#e))"

    # PCRE anchored to the beginning of either such string or each string line.
    glob_start="((#s)|${ZESHY_ASCII_NEWLINE})"

    # Construct a PCRE capturing all such columns on a single line. See
    # for_string_line_fields_split_on_pcre_class() for further details.
    glob_column="([^${ZESHY_ASCII_NEWLINE}${column_separator_class}]#)"
    glob_column_separator="[${column_separator_class__sltsc}]##"
    glob_column_separated="${glob_column}${glob_column_separator}"
    glob_columns_sans_last="$(repeat_string "${glob_column_separated}" "$(( column_count - 1 ))")"
    glob_remainder="([^${ZESHY_ASCII_NEWLINE}]#)"

    # To avoid capturing the beginning of each string line and hence disrupting
    # the column order as perceived by callers, begin capturing only *AFTER*
    # matching such beginning. Likewise, to avoid capturing the optional
    # trailing column separator, stop capturing *AFTER* matching the last
    # column. To capture the unmatched remainder of the current line, begin
    # capturing *AFTER* matching such optional trailing column separator.
    #
    # Surprisingly, this mostly works.
    glob_columns="${glob_start}(#b)${glob_columns_sans_last}${glob_column}(#B)(${glob_column_separator}(#b)${glob_remainder}|)"

    # Iterate such matches with such glob.
    for_string_matches_glob "${text}" "${glob_columns}" "${command}"
}:func <<'/---'
Run the passed command for each line of the passed string containing at most the
passed number of columns separated by substrings matching the passed glob
character class (e.g., `[:alnum:]`, matching alphanumeric-delimited columns).
Avoid delimiting such class with `[` and `]` characters _unless_ such class is a
named character class (e.g., `a-zA-Z0-9` rather than `[a-zA-Z0-9]`): e.g.,

.:for_string_line_fields_split_on_glob_class_bounded()
==========================================
[source]
------------------------------------------
------------------------------------------
==========================================

[WARNING]
If the passed glob character class matches newlines either explicitly (e.g.,
`\n\t\v `, `[:space:]`) or implicitly (e.g., `^a-z[:alpha:]`), an exception is
thrown. Permitting such classes would erroneously match a portion of the line
following the current line into the last column of such line.
/---

# --------------------( WASTELANDS                         )--------------------
    # :int.die_unless_positive "${column_count}"
    # die_unless_string_nonempty "${column_separator_class}"\
    #     'Column separator PCRE character class empty.'
    # die_unless_string_nonempty "${command}" 'Code empty.'
