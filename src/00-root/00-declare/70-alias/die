#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *alias declarer exception handlers* (i.e., functions throwing exceptions
resulting from alias declarers).
/---

# ....................{ EXCEPTIONS                         }....................
:func_ ':void ::alias.die(:string `exception_message)' :func{
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with ::func.die().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    local exception_message=${1} exception_prefix exception_suffix 

    # String prefixing such exception message.
    exception_prefix=$(::parcel.get_current)${ZESHY__ALIAS_TYPE-}' alias '

    # If at least one alias name has been matched from such prototype, prepend
    # such exception by the first such name.
    if [[ -n ${ZESHY__ALIAS_NAMES[1]-} ]] {
        exception_prefix+=${ZESHY__ALIAS_NAMES[1]-}'() '
    }

    # If such prototype has been declared, suffix such exception by such
    # prototype.
    if [[ -n ${ZESHY__ALIAS_PROTOTYPE-} ]] {
        local alias_prototype alias_type

        # Such type, capitalized for readability.
        ::alias.set_current_type_capitalized alias_type

        # Such prototype, indented for readability.
        alias_prototype=${ZESHY__ALIAS_PROTOTYPE}
        ::string.indent alias_prototype

        # Such suffix.
        exception_suffix=$'\n\n'${alias_type}' alias prototype:'$'\n'${alias_prototype}
    }

    # Throw such exception.
    :die ${exception_prefix}${exception_message}${exception_suffix}
}:func <<'/---'
Throw an exception with the passed message, presumably detailing a syntactic or
semantic error in the currently declared alias prototype. This private
exception handler is intended to be called _only_ by ::alias().

== Message Format ==

The passed message should be formatted as a lowercase sentence fragment (e.g.,
`prototype invalid`), which this function then:

* Prefixes by `Parcel ={parcel_name} alias ${alias_name}() `, where:
** `${parcel_name}` is the name of the parcel containing such alias.
** `${alias_name}` is the first alias name such prototype declares. (For
   simplicity, any subsequent alias name such prototype declares is ignored.)
* Suffixes by such prototype.
/---

# ....................{ EXCEPTIONS                         }....................
#FIXME: Create a similar ::func.die_of_redefinition() in ={*-func/die}.

:func_ ':void ::alias.die_of_redefinition(:string `alias_expansion)' :func{
    local alias_expansion=${1} alias_type alias_definition

    # Such type, capitalized for readability.
    ::alias.set_current_type_capitalized alias_type

    # Such expansion, indented for readability.
    ::string.indent alias_expansion

    # Throw such exception.
    ::alias.die\
        'already defined.'$'\n\n'${alias_type}' alias definition:'$'\n'${alias_expansion}
}:func <<'/---'
Throw an exception resulting from the currently declared alias erroneously
redefining an existing alias with the passed expansion. This private exception
handler is intended to be called _only_ by ::alias().
/---

# ....................{ SETTERS                            }....................
:func.document <<'/---'
:void ::alias.set_current_type_capitalized(^:string type_capitalized_name)

Set the passed string variable to the currently declared alias' *capitalized
type* (i.e., either `Command`, `General`, or `Suffix`). This private setter is
intended to be called _only_ by exception handlers called by ::alias().
/---
function ::alias.set_current_type_capitalized() {
    (( # == 1 )) || :die 'Expected one string name.'
    :string.set "${1}" "${(C)ZESHY__ALIAS_TYPE[1]-}${ZESHY__ALIAS_TYPE[2,-1]-}"
}

# --------------------( WASTELANDS                         )--------------------
    # If such prototype has been declared, suffix such exception by such
    # prototype, indented for readability.
    # if [[ -n ${ZESHY__ALIAS_PROTOTYPE-} ]] {
    #     exception_suffix=$'\n\n''Alias prototype:'$'\n''    '${ZESHY__ALIAS_PROTOTYPE//$'\n'/$'\n'    }
    # }

    # If such alias was declared in a parcel, prefix such exception message
    # by such parsel.
    # if [[ -n ${exception_prefix} ]] {
    #     exception_prefix+='alias '
    # } else {
    #     exception_prefix+='Alias '
    # }
