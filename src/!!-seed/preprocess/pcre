#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "COPYING" for additional details.

#FIXME: Convert into parcel documentation.
# --------------------( SYNOPSIS                           )--------------------
# Define PCREs required by preprocessors.

# ....................{ GLOBALS                            }....................
# PCRE globals defined below.
typeset -g\
    ZESHY__MACRO_PCRE

# ....................{ CLEARERS                           }....................
#FIXME: Document me.
# :void ::preprocessor_pcres.clear()
function ::preprocessor_pcres.clear() {
    (( # == 0 )) || :die 'Expected no arguments.'
    ZESHY__MACRO_PCRE=
}

# ....................{ MAKERS                             }....................
# :void ::preprocessor_pcres.make_if_needed()
function ::preprocessor_pcres.make_if_needed() {
    (( # == 0 )) || :die 'Expected no arguments.'
    [[ -n ${ZESHY__MACRO_PCRE} ]] || ::preprocessor_pcres.make
}

# :void ::preprocessor_pcres.make()
function ::preprocessor_pcres.make() {
    # Validate sanity. Since subsequent locals often depend on prior locals
    # locals, define one local per line below.
    (( # == 0 )) || :die 'Expected no arguments.'

    # One or more command-specific whitespace sequences (i.e., all substrings
    # connoting whitespace *NOT* terminating the current command), including
    # all whitespace except newlines *NOT* prefixed by "\". While "\"-prefixed
    # newlines are line continuations preserving the current command,
    # unprefixed newlines are effectively semicolons terminating such command.
    local pcre_spaces='(?:\h|\\\R)++'

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with ={*-soil/*-declare/*-pcre}.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Single-quoted string in zsh format and hence supporting escaped single
    # quotes (i.e., "''").
    local          pcre_quotes_single="'(?:[^']|'')*'"
    local pcre_quotes_single_grouped="'((?:[^']|'')*)'"

    # Double-quoted string in zsh format and hence supporting escaped double
    # quotes (i.e., '\"'). Unlike the prior PCRE, character class [^"] also
    # matches "\" and hence must be matched *AFTER* matching the latter.
    local          pcre_quotes_double='"(?:\\"|[^"])*"'
    local pcre_quotes_double_grouped='"((?:\\"|[^"])*)"'

    # Possibly recursively nested variable expansion.
    local pcre_var_expansion='$\{\}'

    # Arbitrary string of one or more characters excluding characters reserved
    # for strict zsh argument parsing. This includes:
    #
    # * Dollar signs.
    # * Single and double quotes.
    # * Whitespace.
    local pcre_sans_quotes_spaces='[^\s''"$]++'

    # Macro name, dynamically constructed from the current set of all declared
    # macro names. By macro design, such names are guaranteed to contain no
    # PCRE-reserved characters and hence require no escaping here. See :macro()
    # and :list.join_to_string_on_char().
    local pcre_macro_name='(?:'${(j:|:)ZESHY__MACRO_NAMES}')'

    # Customary argument for zsh commands, comprising one or more of the prior
    # syntactic constructs.
    local pcre_arg_command='(?:'${pcre_sans_quotes_spaces}'|'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_var_expansion}')+'

    #FIXME: Such "}" must be matched as prefixed by a newline (\R) followed by
    #the same exact horizontal whitespace as the initial macro. Hence, we
    #really can't match this outside of the full PCRE. *shrug* 

    # Block argument specific to zeshy macros.
    local pcre_arg_block=

    # Argument of any type.
    local pcre_arg='(?:'${pcre_arg_command}'|'${pcre_arg_block}')'

    #FIXME: Fairly sure we can simplify this quite a bit. We don't *NEED* to
    #match individual arguments on the initial match of the full macro string.
    #In fact, we're fairly sure we don't *EVER* need to match individual
    #arguments. Hence, we can probably generalize ${pcre_arg_command} above
    #with whitespace as follows:
    #
    #    local pcre_arg_command='(?:'${pcre_spaces}'|'${pcre_sans_quotes_spaces}'|'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_var_expansion}')+'
    #
    #Of course, that immediately suggests we combine ${pcre_spaces} and
    #${pcre_sans_quotes_spaces} -- probably by omitting "\s" from the
    #definition of the latter. (In any case, it's all for the morrow!)

    # One or more arguments of any type.
    local pcre_args='(?:'${pcre_arg}${pcre_spaces}')*'${pcre_arg}${pcre_spaces_optional}

    # PCRE capturing all macros (including names and block arguments) in
    # arbitrary code.
    ZESHY__MACRO_PCRE=${pcre_macro_name}${pcre_spaces}${pcre_args}
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Interestingly, this must be constructed at runtime, implying this
    #entire anonymous function should be converted into a named function
    #::preprocessor_pcres.make() called on *EACH* call to :macro(). Hmm. For
    #efficiency, perhaps:
    #
    #* :macro() should simply set ${ZESHY__MACRO_PCRE} to the empty string.
    #* :code.preprocess() should call ::preprocessor_pcres.make() if
    #  ${ZESHY__MACRO_PCRE} is the empty string.
    #
    #This permits multiple macros to be defined by a single parcel without
    #triggering multiple redundant PCRE compilations, which seems sensible.
    #FUXME: For usability, define a function ::preprocessor_pcres.clear() in
    #this parcel clearing such PCRE globals.

    # One or more such arguments.
    # Unquoted word in the strict zsh sense, comprising one or more characters
    # excluding whitespace and shell-reserved characters.
    # local pcre_word_unquoted='[^]'

    #FUXME: We *DO* need to match variables as well. Here's why:
    #
    #    >>> print ${:-
    #    ... :func
    #    ... }
    #
    #    :func
    #
    #Yes, that actually works. It's a hell of an edge case, but edge case
    #nonetheless. For robustness, we *MUST* account for all such cases.

    #FUXME: Minor issue. If the captured here-document word embeds quote
    #escapes (e.g., "ugh\"umu"), we have no sane means of matching the
    #corresponding terminator (e.g., in the prior example, we would need to
    #match 'ugh"umu' rather than the literally captured string). We're inclined
    #to ignore this, at the moment. (Indeed, fixing this may be infeasible!)
    #FUXME: Honestly, this is rather difficult to implement correctly. Given
    #such difficulty, we're inclined to instead 

    # local pcre_here_doc_prefix='<<-?\s*+(?|'${ZESHY_SYNTAX_QUOTES_SINGLE_GROUPED_PCRE}'|'${ZESHY_SYNTAX_QUOTES_DOUBLE_GROUPED_PCRE}'|(\S++)\n'
    # local pcre_here_doc_body='.*?'
    # local pcre_here_doc_suffix='\g{-1}'
    # local pcre_here_doc=${pcre_here_doc_prefix}${pcre_here_doc_body}${pcre_here_doc_suffix}

#FUXME: Document me.
# # PCRE globals defined below.
# typeset -g\
#     ZESHY_SYNTAX_QUOTES_SINGLE_PCRE\
#     ZESHY_SYNTAX_QUOTES_DOUBLE_PCRE\
#     ZESHY_SYNTAX_QUOTES_SINGLE_GROUPED_PCRE\
#     ZESHY_SYNTAX_QUOTES_DOUBLE_GROUPED_PCRE
# 
# # PCREs matching single-quoted strings in zsh format and hence supporting
# # escaped single quotes (i.e., "''").
#          ZESHY_SYNTAX_QUOTES_SINGLE_PCRE="'(?:[^']|'')*'"
# ZESHY_SYNTAX_QUOTES_SINGLE_GROUPED_PCRE="'((?:[^']|'')*)'"
# 
# # Double-quoted string in zsh format and hence supporting escaped double
# # quotes (i.e., '\"'). Unlike the prior PCRE, character class [^"] also
# # matches "\" and hence must be matched *AFTER* matching the latter.
#          ZESHY_SYNTAX_QUOTES_DOUBLE_PCRE='"(?:\\"|[^"])*"'
# ZESHY_SYNTAX_QUOTES_DOUBLE_GROUPED_PCRE='"((?:\\"|[^"])*)"'

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with ={*-soil/*-declare/*-pcre}.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
