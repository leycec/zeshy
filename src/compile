#!/usr/bin/env zsh
# ====================[ compile                            ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# (Re)compile the Zeshy codebase into the current user's Zeshy digest file.
#
# --------------------( SYMBOLS                            )--------------------
# In most programming languages, the symbols that language exports for external
# use (e.g., packages, classes, functions, globals) do not vary with system or
# user configuration. The same version of the same language unconditionally
# exports the same symbols, everywhere. This forms the core.
#
# As expected, Zeshy behaves different. Most symbols Zeshy exports for external
# use at the command line and within scripts conditionally vary with system and
# user state, including:
#
# * The output of the system-specific "lsb_release" and/or "uname" commands.
# * The contents of the user-specific Zeshy configuration at "~/.zeshy/config".
# * The contents of the user-specific ${PATH} (i.e., the set of currently
#   installed and accessible programs).
#
# Zeshy monitors such content for changes -- silently, efficiently, and entirely
# automatically. On detecting changes, Zeshy changes itself. As example:
#
# * On switching from a Linux to BSD operating system, Zeshy supplants the
#   Linux-specific symbols it exports with those specific to BSD.
# * On installing a new program "rtorrent" into the system-wide "/bin" directory
#   in the ${PATH}, Zeshy exports "rtorrent"-specific symbols.
#
# Zeshy symbols comprise Zeshy-specific zsh functions and, to a lesser extent,
# zsh aliases and globals. For efficiency, Zeshy exports the former as a single
# zsh digest file (i.e., a binary file in a zsh-specific format functionally
# analogous to that of C and C++-style shared libraries).
#
# Zeshy compiles *ONLY* that subset of itself specific to current system and
# user state into its digest file. Uncompiled code remains inaccessible until
# such state changes (e.g., installing "rtorrent" notifies Zeshy to compile
# start_rtorrent() and stop_rtorrent() functions into its digest file). For end
# user purposes, Zeshy *IS* its digest file.
#
# --------------------( OVERLAYS                           )--------------------
# To accomodate system- and user-specific Zeshy add-ons (e.g., plugins, themes),
# Zeshy divides itself into overlays: directories with the same structure as
# Zeshy's top-level "src" directory. Zeshy ignores all files and directories in
# an overlay except those with the following Zeshy-specific names:
#
# * "always", a subdirectory recursively containing only:
#   * Zeshy scripts, to be unconditionally compiled into Zeshy's digest file.
#     These scripts may reside directly in the mandatory "always" directory
#     or under optional subdirectories. In either case, Zeshy automatically
#     finds and compiles all zsh functions in all such files.
#   * Subdirectories with arbitrary names and nesting. (Zeshy automatically
#     finds all scripts in such subdirectories. Subdirectory structure is
#     insignificant and hence only for optional organization.)
# * "if_pathable", a subdirectory directly containing only:
#   * Zeshy scripts, each conditionally compiled into Zeshy's digest file *ONLY*
#     if an executable file of the same case-sensitive basename currently exists
#     in the user-specific ${PATH}.
#   * Subdirectories, each conditionally enabled as a Zeshy overlay and hence
#     subject to recursive processing (e.g., for an "always" subdirectory) only
#     if an executable file of the same case-sensitive basename currently exists
#     in the user-specific ${PATH}.
# * "if_distro", a subdirectory directly containing only:
#   * Subdirectories, each conditionally enabled as a Zeshy overlay *ONLY* if
#     the current system-specific Linux and/or BSD distribution has the same
#     lowercase name. At most one such subdirectory matches; Zeshy ignores the
#     remaining subdirectories.
# * "if_config", a subdirectory directly containing only:
#   * Zeshy configuration files, to be unconditionally copied into the user-
#     specific "~/.zeshy/config" directory if not already found.

#FIXME: Add support for sourcing all files directly under an overlay *IF* such
#overlay is not the main overlay. An important user convenience, particularly for
#smaller overlays not requiring a tree structure.
#FIXME: It'd be awesomely inspiring to print an in-place rotating ANSI-fueled
#progress sequence (i.e., "\-/|\-/|") during script sourcing. Namely, after
#sourcing each script, rotate such sequence a single character. Naturally,
#confine such logic to VT100-capable terminals. It's essential to do so
#without importing any heavyweight zsh modules or scripts; should be quite
#doable, no? I wouldn't be terribly surprised if the exact sequences to be
#printed are already readily Googleable.

# ....................{ GLOBALS                            }....................
# List of commands to be run immediately before compiling Zeshy's digest file.
export -Ua ZESHY_RUNNABLES_TO_CONSTRUCT_ZESHY

# ....................{ APPENDERS                          }....................
#FIXME: Rename to append_make_zeshy_command(). Much more natural (...the
#most important "make_zeshy" part comes first) and in keeping with nomenclature
#elsewhere.
document_function '
void append_command_to_make_zeshy(string command)

Append the passed command to the end of the definition of make_zeshy().
Zeshy calls such function and hence command immediately after compiling the
Zeshy digest file.
'
function append_command_to_make_zeshy() {
    (( # == 1 )) || die 'expected one command'
    ZESHY_RUNNABLES_TO_CONSTRUCT_ZESHY+="${1}"
}

# ....................{ COMPILERS                          }....................
document_function '
void compile_zeshy(void)

Compile Zeshy''s digest file from system-wide and user-specific Zeshy overlays.
'
function compile_zeshy() {
    # Validate sanity.
    (( # == 0 )) || die 'no arguments expected'

    # Lists of all Zeshy-specific aliases, functions, and globals. Defining such
    # lists globally:
    #
    # * Implicitly exports such lists to child shells, which on receiving such
    #   globals may use their contents to undefine aliases, functions, and other
    #   globals imported from the parent shell.
    # * Permits us to undefine such globals in a global context below. See the
    #   tail of this file.
    #
    # zsh treats suffix aliases differently from normal and global aliases, so
    # differentiate the former from the latter.
    export -Ua\
        ZESHY_ALIAS_NAMES\
        ZESHY_SUFFIX_ALIAS_NAMES\
        ZESHY_FUNCTION_NAMES\
        ZESHY_GLOBAL_NAMES
#   print '===ZESHY_FUNCTION_NAMES==='
#   typeset -p ZESHY_FUNCTION_NAMES

    # List of directories recursively containing zsh scripts containing
    # autoloadable functions to be compiled into Zeshy's digest file.
    local -Ua ZESHY_AUTOLOAD_DIRNAMES

    # List of zsh scripts containing autoloadable functions to be so compiled.
    local -Ua ZESHY_AUTOLOAD_FILENAMES

    # FIFO stack of Zeshy overlays.
    local -Ua ZESHY_OVERLAY_STACK

    # List of all currently declared aliases, functions, and globals declared
    # *BEFORE* sourcing and compiling Zeshy. See compile_zeshy_setup().
    local -a\
        ZESHY_ALIAS_NAMES_OLD\
        ZESHY_SUFFIX_ALIAS_NAMES_OLD\
        ZESHY_FUNCTION_NAMES_OLD\
        ZESHY_GLOBAL_NAMES_OLD

    # List of all currently declared aliases, functions, and globals declared
    # *AFTER* sourcing and compiling Zeshy. See compile_zeshy_teardown().
    local -a\
        ZESHY_ALIAS_NAMES_NEW\
        ZESHY_SUFFIX_ALIAS_NAMES_NEW\
        ZESHY_FUNCTION_NAMES_NEW\
        ZESHY_GLOBAL_NAMES_NEW

    # Lowercase name of the current *nix distribution.
    local ZESHY_DISTRO_NAME

    # Glob expression matching only Zeshy-specific zsh scripts.
    local ZESHY_SCRIPT_GLOB='*~*.swp(.)'

    # Glob expression matching canonical zsh globals.
    local ZSH_GLOBAL_NAMES_GLOB='REPLY|MATCH|MBEGIN|MEND|match|mbegin|mend'

    # Initialize such variables.
    compile_zeshy_setup

    # Source all Zeshy scripts applicable to the current system and user.
    #
    # *AVOID* expanding Zeshy aliases sourced by such function in any subsequent
    # function of this component; oddly, such expansions fail with an alias "not
    # defined" error.
    compile_zeshy_source

    # Finalize such variables.
    compile_zeshy_teardown

    # Compile all functions sourced above into Zeshy's digest file.
    compile_zeshy_digest
}

document_function '
void compile_zeshy_setup(void)

Perform initialization before sourcing the Zeshy codebase.
'
function compile_zeshy_setup() {
    # Validate sanity.
    (( # == 0 )) || die 'no arguments expected'

    # Since recursion is prohibitively expensive, perform a non-recursive depth-
    # first search of overlays starting from the following tree roots (in order):
    #
    # * The system-wide Zeshy root.
    # * The user-specific Zeshy root, if found.
    ZESHY_OVERLAY_STACK=( "${ZESHY_HOME}" )
    [[ -d "${ZESHY_DOT_OVERLAY_DIR}" ]] &&
        ZESHY_OVERLAY_STACK+="${ZESHY_DOT_OVERLAY_DIR}"

    # Record the names of all currently defined aliases, functions, and globals
    # not to be compiled into Zeshy's digest file.
    ZESHY_ALIAS_NAMES_OLD=( ${(f)"$(alias +)"} )
    ZESHY_SUFFIX_ALIAS_NAMES_OLD=( ${(f)"$(alias +s)"} )

    # Dismantled, this is:
    #
    # * "+f", listing newline-delimited function names.
    # * "(f)", splitting such list on newlines.
    ZESHY_FUNCTION_NAMES_OLD=( ${(f)"$(typeset +f)"} )

    # Dismantled, this is:
    #
    # * "+gx", listing newline-delimited globally exported variable names.
    # * "(f)", splitting such list on newlines.
    ZESHY_GLOBAL_NAMES_OLD=( ${(f)"$(typeset +gx)"} )
#   print -l "===ZESHY_GLOBAL_NAMES_OLD===" "${ZESHY_GLOBAL_NAMES_OLD[@]}"

    #FIXME: BSD installs no such command, so this clearly fails to suffice.
    #We'll probably want to just import the entire get_distro_name() command.
    #Or perhaps not. Is the logic simple, under BSD?

    # If the current *nix distribution provides the "lsb_release" command, run
    # such command to obtain the name of such distribution. While alternatives
    # to "lsb_release" do exist (e.g., globbing for filenames matching
    # /etc/*release), it hardly seems worth the effort so early in the bootstrap
    # process. Dismantled, this is:
    #
    # * "${:-lsb_release}", expanding to the string "lsb_release".
    # * "${...:c}", expanding to the absolute path of "lsb_release" if installed
    #   in the current $PATH or only "lsb_release" otherwise.
    # * "-x", returning true if such path is executable and hence installed.
    #   Unless the current directory contains an executable "lsb_release", this
    #   returns true only if ":c" expanded to an absolute path.
    [[ -x "${${:-lsb_release}:c}" ]] &&
        ZESHY_DISTRO_NAME="${(L)$(lsb_release -si)}"
}

document_function '
void compile_zeshy_source(void)

Source all scripts listed by ${ZESHY_AUTOLOAD_FILENAMES} and under directories
recursively listed by ${ZESHY_AUTOLOAD_DIRNAMES}. The set difference between the
lists of functions defined before and after such sourcing is the subset of Zeshy-
specific functions to be subsequently compiled into Zeshy''s digest file.
'
function compile_zeshy_source() {
    # Validate sanity.
    (( # == 0 )) || die 'no arguments expected'

    # Inform the current user of such recompilation.
    [[ -o interactive ]] &&
        if [[ -n "${ZESHY_DOT_DIR}" ]]
        then say "recompiling \"${ZESHY_DOT_DIGEST_FILE}\"..."
        else say "sourcing \"${ZESHY_HOME}\"..."
        fi

    # Perform a stack-based depth-first search beginning from:
    #
    # * The main system-wide Zeshy overlay (e.g., "/usr/share/zeshy/src").
    # * The main user-specific Zeshy overlay (e.g., "~/.zeshy/src").
    #
    # This search iteratively finds all applicable Zeshy scripts in all applicable
    # overlays into the current shell environment. Since we modify the stack while
    # iterating on it, loop dynamically (e.g., "for ((...))") rather than
    # statically (e.g., "for overlay_dir ("${ZESHY_HOME[@]})").
    for ((i = 1; i <= ${#ZESHY_OVERLAY_STACK}; i++)) {
        compile_zeshy_overlay "${ZESHY_OVERLAY_STACK[i]}"
    }

    # Recursively source all scripts residing under all overlays applicable to
    # the current user, thus defining all applicable Zeshy-specific aliases,
    # functions, and globals. Dismantled, this is:
    #
    # * "${^ZESHY_AUTOLOAD_DIRNAMES[@]}", expanding to each directory in the list.
    # * "/**/*",  recursively expanding to each file in such directory.
    # * "~*.swp", excluding temporary files.
    # * "(.)", excluding non-plain files.
    for script_filename (
        "${^ZESHY_AUTOLOAD_DIRNAMES[@]}"/**/${~ZESHY_SCRIPT_GLOB}
        "${ZESHY_AUTOLOAD_FILENAMES[@]}"
    ) {
        # Source such script.
#       say "sourcing \"${script_filename}\"..."
        source -- "${script_filename}"
#       say "sourced \"${autoload_function_filename}\"."
    }
}

document_function '
void compile_zeshy_teardown(void)

Perform finalization after sourcing the Zeshy codebase.
'
function compile_zeshy_teardown() {
    # Validate sanity.
    (( # == 0 )) || die 'no arguments expected'

    # Record the names of all currently defined aliases, functions, and globals.
    ZESHY_ALIAS_NAMES_NEW=( ${(f)"$(alias +)"} )
    ZESHY_SUFFIX_ALIAS_NAMES_NEW=( ${(f)"$(alias +s)"} )
    ZESHY_GLOBAL_NAMES_NEW=( ${(f)"$(typeset +gx)"} )
#   ZESHY_GLOBAL_NAMES_NEW=( ${${(f)"$(typeset +g +)"}##* } )

    # The lists of Zeshy-specific aliases and globals are the asymmetric
    # differences of the old from new lists of aliases and globals, which
    # make_zeshy() requires for synthesizing new functions. Delay
    # determining the list of Zeshy-specific functions until doing so.
    ZESHY_ALIAS_NAMES=(
        "${ZESHY_ALIAS_NAMES_NEW[@]:|ZESHY_ALIAS_NAMES_OLD}" )
    ZESHY_SUFFIX_ALIAS_NAMES=(
        "${ZESHY_SUFFIX_ALIAS_NAMES_NEW[@]:|ZESHY_SUFFIX_ALIAS_NAMES_OLD}" )
    ZESHY_GLOBAL_NAMES=(
        "${ZESHY_GLOBAL_NAMES_NEW[@]:|ZESHY_GLOBAL_NAMES_OLD}" )

    # Exclude canonical zsh globals from the list of Zeshy-specific globals.
    ZESHY_GLOBAL_NAMES=( "${ZESHY_GLOBAL_NAMES[@]:#${~ZSH_GLOBAL_NAMES_GLOB}}" )
#   print -l "===ZESHY_GLOBAL_NAMES===" "${ZESHY_GLOBAL_NAMES[@]}"
}

document_function '
void compile_zeshy_digest(void)

Compile Zeshy''s digest file, performing last-minute functionality immediately
before doing so. (Namely, dynamically synthesize all remaining functions to be
compiled into such digest.)
'
function compile_zeshy_digest() {
    # Validate sanity.
    (( # == 0 )) || die 'no arguments expected'

    # Call functions that
    # make_zeshy_startup_functions_defining_aliases_and_globals() makes at the
    # beginning of Zeshy startup, arbitrarily defining globals prior to aliases.
    # While order should not matter here, you never really know.
    prepend_command_to_zeshy_startup startup_zeshy_aliases
    prepend_command_to_zeshy_startup startup_zeshy_globals

    # Make startup_zeshy() and friends.
    append_command_to_make_zeshy make_zeshy_startup_functions

    # Make startup_zeshy_aliases() and startup_zeshy_globals() *AFTER DEFINING
    # ALL OTHER ZESHY-SPECIFIC FUNCTIONS*. This is a hard requirement, as this
    # function necessarily defines the list of such functions. (Fugly, fugly,
    # fugly. But there seem little sane alternatives, in this case.)
    append_command_to_make_zeshy\
        make_zeshy_startup_functions_defining_aliases_and_globals

    # Run all commands previously added to ${ZESHY_COMMANDS_TO_MAKE_ZESHY}.
    make_zeshy

    # If loading Zeshy's user directory, compile Zeshy-specific functions into
    # the digest file in such directory.
    [[ -n "${ZESHY_DOT_DIR}" ]] &&
        zcompile -c -- "${ZESHY_DOT_DIGEST_FILE}" "${ZESHY_FUNCTION_NAMES[@]}"
}

# ....................{ COMPILERS ~ overlays               }....................
document_function '
void compile_zeshy_overlay(string overlay_dirname)

Prepare the passed Zeshy overlay directory for digest compilation, as detailed
above in "OVERLAYS". For each:

* zsh script in such overlay containing autoloadable functions to be compiled
  into Zeshy''s digest file, append such script to the list of such files.
* Subdirectory in such overlay:
  * That is itself an overlay, append such subdirectory to the overlay stack.
  * Recursively containing zsh scripts containing autoloadable functions to be
    compiled into Zeshy''s digest file, append such subdirectory to the list of
    such subdirectories. (Subdirectories may either be overlays or directly
    contain zsh scripts, but not both.)
'
function compile_zeshy_overlay() {
    # Validate passed arguments.
    (( # == 1 )) || die 'expected one overlay dirname'
    local overlay_dir="${1}"
    [[ -d "${overlay_dir}" ]] || die "\"${overlay_dir}\" not a directory"

    # If the current user is a Zeshy developer and the current shell is
    # interactive, print such path to standard output.
    [[ -n "${ZESHY_IS_DEBUGGING-}" && -o interactive ]] &&
        say "overlaying \"${overlay_dir}\"..."
#   say "overlaying \"${overlay_dir}\"..."

    # Absolute paths of overlay subdirectories.
    local overlay_main_dir="${overlay_dir}/always"

    # ~~~~~~~~~~~~~~~~< IMPORTANT ~ order is significant   >~~~~~~~~~~~~~~~~~~~~
    # Order of operation is significant below. Later paths assume precedence
    # over prior paths in corresponding lists.

    # Source all configuration files in such overlay's configuration directory.
    # Do so prior to all other overlay logic depending on globals defined by
    # such files.
    compile_zeshy_overlay_configs "${overlay_dir}"

    # If such overlay is *NOT* the topmost system-wide overlay, append all
    # scripts in such overlay's directory. The topmost system-wide overlay
    # contains the current script among others and should *NOT* be resourced.
    [[ "${overlay_dir}" != "${ZESHY_HOME}" ]] &&
        ZESHY_AUTOLOAD_FILENAMES+=( "${overlay_dir}"/${~ZESHY_SCRIPT_GLOB} )

    # Append such overlay's main directory, if found.
    [[ -d "${overlay_main_dir}" ]] &&
        ZESHY_AUTOLOAD_DIRNAMES+="${overlay_main_dir}"

    # Append such overlay's command directory to appropriate lists, if found.
    compile_zeshy_overlay_commands "${overlay_dir}"

    # Append the subdirectory of such overlay's distro directory matching the
    # user's currently installed distro to the overlay stack, if found.
    #
    # Do this after all other overlay logic, allowing distro-specific
    # redefinition of generic functionality.
    [[ -n "${ZESHY_DISTRO_NAME}" ]] && {
        local overlay_distro_dir="${overlay_dir}/if_distro/${ZESHY_DISTRO_NAME}"
        [[ -d "${overlay_distro_dir}" ]] &&
            ZESHY_OVERLAY_STACK+="${overlay_distro_dir}"
    }
}

document_function '
void compile_zeshy_overlay_configs(string overlay_dirname)

Recursively copy all files from the "if_config" subdirectory of the passed
overlay directory to Zeshy''s user configuration directory, if not already found
in the latter; then source such files.
'
function compile_zeshy_overlay_configs() {
    # Validate passed arguments.
    (( # == 1 )) || die 'expected one overlay dirname'
    local overlay_config_dir="${1}/if_config"

    # If such overlay contains no configuration subdirectory, return silently.
    [[ -d "${overlay_config_dir}" ]] || return 0

    #FIXME: This'd be a nice place to add update handling for patching locally
    #modified config files against Zeshy-bundled config files on update.
    #FIXME: Hmmmm; no, actually. We want to implement the upgrade process as
    #a startup_zeshy_upgrade()-style function in the main Zeshy codebase. Why?
    #Firstly, such upgrade will inevitably become a bit heavyweight, with
    #functionality conditionally depending on which "diff"-style merge commands
    #are installed and available to the current user (e.g., "gdiff", "vimdiff").
    #Secondly, it's simply cleaner to defer upgrading until *AFTER* Zeshy
    #has fully bootstrapped itself. Since we already expand config globals
    #defensively (e.g., ${ZESHY_THEME:-vanilla}), this should pose no issues
    #even if we were to subsequently, say, rename ${ZESHY_THEME} to
    #${ZESHY_USER_THEME}.

    # For each configuration file in the passed overlay, globbed recursively...
    local filename_suffix target_filename
    for source_filename ("${overlay_config_dir}/"**/${~ZESHY_SCRIPT_GLOB}) {
        # If ignoring Zeshy's user directory, source such file from such overlay
        # without copying such file to such directory.
        [[ -n "${ZESHY_DOT_DIR}" ]] || {
            source -- "${source_filename}"
            continue
        }

        # Strip off the prefixing overlay configuration directory (e.g., from
        # "/usr/share/zeshy/src/if_config/if_shell_interactive/00-alias" to.
        # "if_shell_interactive/00-alias").
        filename_suffix="${source_filename#${overlay_config_dir}/}"

        # Set the target filename appended with such suffix.
        target_filename="${ZESHY_DOT_CONFIG_DIR}/${filename_suffix}"

        # If Zeshy's user configuration directory already contains such file,
        # continue to the next file without sourcing the current file. Zeshy's
        # sourcing of component "config" previously sourced such file, already.
        [[ -f "${target_filename}" ]] && continue

        # If the current user is a Zeshy developer and the current shell is
        # interactive, print such path to standard output.
        [[ -n "${ZESHY_IS_DEBUGGING-}" && -o interactive ]] &&
            say "defaulting \"${target_filename}\"..."
#       say "defaulting \"${target_filename}\"..."

        # Make such file's parent directory, if needed.
        command mkdir -p -- "${target_filename:h}"

        # Copy such file.
        command cp -- "${source_filename}" "${target_filename}"

        # Source such file.
#       say "sourcing \"${target_filename}\"..."
        source -- "${target_filename}"
    }
}

document_function '
void compile_zeshy_overlay_commands(string overlay_dirname)

Prepare command-specific zsh scripts in the passed Zeshy overlay directory.
Namely, append:

* All zsh scripts in this overlay''s command directory matching commands in the
  current user''s $PATH to the list of autoloadable files.
* All subdirectories in this overlay''s command directory matching such
  commands to the overlay stack.
'
function compile_zeshy_overlay_commands() {
    # Validate sanity.
    (( # == 1 )) || die 'expected one overlay dirname'
    local overlay_command_dir="${1}/if_pathable"
    [[ -d "${overlay_command_dir}" ]] || return 0

    # List of all paths in this overlay's command directory corresponding to a
    # currently installed executable file in the $PATH. Dismantled, this is:
    #
    # * "${ZESHY_AUTOLOAD_COMMAND_DIR}/"*, listing each file in Zeshy's
    #   command directory.
    # * "(e{[[ ... ]]})", excluding files failing the following test:
    #   * "$REPLY", the current file.
    #   * ":t", the basename of such file.
    #   * ":c", the absolute path to a command in the $PATH with such name.
    #   * "== /*", true only when ":c" succeeds in finding such a command.
    # * "or true", ignoring failure (if ":c" fails finding such a command).
    local -a overlay_command_paths; overlay_command_paths=(
        "${overlay_command_dir}/"*(e{'[[ $REPLY:t:c == /* ]]'})
    ) || true

    # Append all files in this directory to the list of autoloadable files.
    ZESHY_AUTOLOAD_FILENAMES+=( "${^overlay_command_paths[@]}"(.) )

    # Append all directories in this directory to the overlay stack.
    ZESHY_OVERLAY_STACK+=(      "${^overlay_command_paths[@]}"(/) )
}

# ....................{ MAKERS                             }....................
document_function '
void make_zeshy(void)

Before compiling Zeshy''s digest file, finalize all aliases, functions, and
globals to be compiled into such file. Specifically, run all commands added to
global list ${ZESHY_RUNNABLES_TO_CONSTRUCT_ZESHY} (e.g., by previous calls to
append_command_to_make_zeshy()).
'
function make_zeshy() {
    (( # == 0 )) || die 'no arguments expected'
    for command ("${ZESHY_RUNNABLES_TO_CONSTRUCT_ZESHY[@]}") run "${command}"
}

document_function '
void make_zeshy_startup_functions_defining_aliases_and_globals(void)

Dynamically synthesize the following functions:

* startup_zeshy_aliases(), defining regular, global, and suffix aliases.
* startup_zeshy_globals(), defining globally exported variables.

The subsequently synthesized startup_zeshy() calls both such functions before
calling all other startup functions.
'
function make_zeshy_startup_functions_defining_aliases_and_globals() {
    # Validate sanity.
    (( # == 0 )) || die 'no arguments expected'
    local aliases suffix_aliases globals
    local -a alias_names_quoted
#   print -l -- "===ZESHY_GLOBAL_NAMES===" "${ZESHY_GLOBAL_NAMES[@]}"
#   print -l -- "===ZESHY_FUNCTION_NAMES===" "${ZESHY_FUNCTION_NAMES[@]}"
#   print -l -- "===ZESHY_STARTUP_RUNNABLES===" "${ZESHY_STARTUP_RUNNABLES[@]}"

    # Avoid calling builtins on empty lists, as that typically causes such
    # builtins to exhaustively (and uselessly) print *EVERYTHING*.
    (( #ZESHY_ALIAS_NAMES )) &&
        aliases="$(alias -L "${ZESHY_ALIAS_NAMES[@]}")"
    (( #ZESHY_SUFFIX_ALIAS_NAMES )) &&
        suffix_aliases="$(alias -Ls "${ZESHY_SUFFIX_ALIAS_NAMES[@]}")"

    # Save the lists of Zeshy-specific suffix aliases, functions, and globals.
    # Subsequently recompiling the Zeshy digest file in either the current shell
    # or children of such shell requires such lists for deciding which suffix
    # aliases, functions, and globals to undefine prior to sourcing the Zeshy
    # codebase. See the "MAIN" section of this component below.
    #
    # Omit the list of Zeshy-specific aliases, whose alias names we safely,
    # manually interpolate into the definition of startup_zeshy_aliases() below.
    # Why? The reason is, of course, exceedingly subtle. Alias names include
    # global alias names (e.g., "or"), which zsh expands into the corresponding
    # global alias expansion *ANYWHERE* such names appear unquoted.
    # Unfortunately, the "typeset -p ZESHY_ALIAS_NAMES" command called below
    # fails to quote such names; hence, the "eval" statement evaluated below
    # expands a string resembling this:
    #
    #     typeset -gax ZESHY_ALIAS_NAMES
    #     ZESHY_ALIAS_NAMES=( is si or and not ... )
    #
    # into a string resembling this:
    #
    #     typeset -gax ZESHY_ALIAS_NAMES
    #     ZESHY_ALIAS_NAMES=( [[ ]] || && ! ... )
    #
    # This is clearly invalid zsh syntax.
    ZESHY_GLOBAL_NAMES+=(
        ZESHY_SUFFIX_ALIAS_NAMES
        ZESHY_FUNCTION_NAMES
        ZESHY_GLOBAL_NAMES
    )
#   print "aliases: ${aliases}\nsuffix_aliases: ${suffix_aliases}"

    # Make such functions, making a placeholder empty definition for
    # startup_zeshy_globals() to be replaced below. The reasons, as ever, are
    # insidious. The set of all Zeshy-specific globals includes list global
    # ${ZESHY_FUNCTION_NAMES}, which cannot be defined until after defining all
    # Zeshy-specific functions. Naturally, startup_zeshy_globals() is such a
    # function. To break such circularity, define such function empty initially.
    eval "function startup_zeshy_aliases() {
    ${aliases}
    ${suffix_aliases}
}"
    eval "function startup_zeshy_globals() {
}"

    # The list of Zeshy-specific functions is the asymmetric difference of the
    # old from new list of functions.
    ZESHY_FUNCTION_NAMES_NEW=( ${(f)"$(typeset +f)"} )
    ZESHY_FUNCTION_NAMES=(
        "${ZESHY_FUNCTION_NAMES_NEW[@]:|ZESHY_FUNCTION_NAMES_OLD}" )

    # The "typeset -p" command fails to print the "-g" modifier for global
    # variables. Since "typeset -x" commands do not imply such modifier under
    # zsh option "no_global_export", failing to print such modifier effectively
    # localizes such globals to the startup_zeshy_globals() function. Of course,
    # this constitutes a zsh bug. (Submit a report please.) In the meanwhile,
    # forcefully add the "-g" modifier to all output "typeset" commands.
    globals="${$(\
        typeset -p "${ZESHY_GLOBAL_NAMES[@]}")//typeset -/typeset -g}"

    # Manually add the definition of the list of Zeshy-specific aliases to such
    # string of global definitions, quote-protecting global alias names from
    # accidental expansion (as insinuated above).
    alias_names_quoted=( \"${^ZESHY_ALIAS_NAMES}\" )
    globals+="
typeset -gax ZESHY_ALIAS_NAMES
ZESHY_ALIAS_NAMES=( ${alias_names_quoted[@]} )"
#   print -r "globals: ${globals}"

    # Make the final Zeshy function. (Phew!)
    eval "function startup_zeshy_globals() {
    ${globals}
}"
}

# ....................{ MAIN                               }....................
# This component recompiles the Zeshy digest file by sourcing all components
# defining Zeshy-specific zsh objects (i.e., aliases, functions, and globals)
# specific to the current user and system and then compiling exactly such
# objects into such digest. To decide exactly which objects to compile, this
# component subtracts the set of all zsh objects defined *AFTER* sourcing such
# components from the set of all zsh objects defined *BEFORE* sourcing such
# components: the difference between the two sets is exactly the set of all
# Zeshy-specific objects to be compiled.
#
# By design, this requires no such objects to be defined before sourcing such
# components. If some (or all) such objects were defined before sourcing such
# components, the difference between the above two sets and hence the recompiled
# Zeshy digest file would be essentially empty. To avoid such issues, undefine
# Zeshy-specific objects defined by parent shells before such recompilation.
[[ -n "${ZESHY_ALIAS_NAMES-}" ]] &&
    unalias -- "${ZESHY_ALIAS_NAMES[@]}"
[[ -n "${ZESHY_FUNCTION_NAMES-}" ]] &&
    unfunction -- "${ZESHY_FUNCTION_NAMES[@]}"

# Undefine globals *AFTER* undefining all objects listed by the prior lists,
# which themselves are globals and hence undefined with the other globals here.
#
# Globals *MUST* be undefined in a global context to have meaningful effect.
# While aliases and functions may be meaningfully undefined in a local context,
# there seems little point in doing so elsewhere. Centralize all logic here.
# See undefine_variable() and unfreeze_variable() for details on undefining
# globals (namely, why we call typeset() prior to unset()).
[[ -n "${ZESHY_GLOBAL_NAMES-}" ]] && {
#   print -l "===ZESHY_GLOBAL_NAMES===" "${ZESHY_GLOBAL_NAMES[@]}"
    typeset +r -- "${ZESHY_GLOBAL_NAMES[@]}"
    unset      -- "${ZESHY_GLOBAL_NAMES[@]}"
#   typeset -p -m "${ZESHY_GLOBAL_NAMES[@]}"
}

# Recompile the Zeshy digest file.
compile_zeshy

# --------------------( WASTELANDS                         )--------------------
    # If such overlay is *NOT* an overlay root (i.e., is neither the topmost
    # system-wide or user-specific overlays), append all scripts in such
    # overlay's directory.
#   [[ "${overlay_dir}" != ("${ZESHY_HOME}"|"${ZESHY_DOT_OVERLAY_DIR}") ]] &&
#   for filename ("${overlay_dir}"/${~ZESHY_SCRIPT_GLOB}) {
#       print "autoload filename: ${filename}"
#   }
#FUXME: *UGH*. The ${ZESHY_UNIT_*} globals are no longer recorded as Zeshy
#globals. Hmm; I'm beginning to think we need, by default, to delete *ALL*
#globals matching ${ZESHY_*} *NOT* previously declared by "main", "config", or
#"autoload". Question is: how can we do this without incurring substantial
#complexity and/or fragility costs? You know, I think I'm happy to pay a slight
#efficiency cost here... but wait. You know, this is all symptomatic of a
#larger problem. If globals aren't being persisted correctly, it stands to
#reason neither are aliases or functions. Something subtly terrible is
#happening somewhere -- and we really need to fix it before releasing even an
#alpha version. To begin debugging, run "which startup_zeshy_globals"
#immediately after logging in (i.e., in a Zeshy login shell). What's the
#result? I half-guarantee it's substantially messed up. If that's *NOT* the
#case, then something may be going wrong during shell instantation and
#inheritance. Mmmhmmm.
# * On editing the "ZESHY_THEME" global in the "~/.zeshy/config/main"
#   configuration file from the default "vanilla" to, say, "cookiedough", Zeshy
#   supplants the default theme symbols it exports with those from the
#   "cookiedough" theme.
#       overlay_theme_dir="${overlay_dir}/if_theme/${ZESHY_THEME:-vanilla}"
    # Append the subdirectory of this overlay's theme directory matching the
    # user's currently configured theme to the overlay stack, if found.
#   [[ -d "${overlay_theme_dir}" ]] &&
#       ZESHY_OVERLAY_STACK+="${overlay_theme_dir}"

        # If Zeshy's user configuration directory does not already contain
        # such file, copy such file from such overlay to such directory.
#       [[ ! -f "${target_filename}" ]] && {
#to Zeshy's user-specific configuration directory
# Since upgrading occurs after digest
    #compilation but "~/.zeshy/config/zeshy" would already exist,
    #${ZESHY_USER_THEME} would not be found here, provoking a zsh error (e.g.,
    #"no such variable"). Simplest way to fix this:
    #
    #* Behave defensively. Never assume a global setting to exist (e.g., always
    #  append "-" to parameter expansions). This probably needs to happen
    #  anyway, for safety and robustness. Make it so!
#FUXME: It'd be nice to harmonize config dirs "/usr/share/zeshy/src/if_config"
#and "~/

#Prepare all user configuration files in the passed overlay directory. Namely:
#
#* Recursively copy all such files not found in Zeshy''s user-specific
#  configuration directory to such directory.
#* Source such files.
    #FUXME: Rather than print each overlay, it would be *MUCH* more concise and
    #hence reasonable to only print the set of all sourced overlays after the
    #fact. To do so, simply iterate local list ${ZESHY_OVERLAY_STACK} after
    #sourcing all such overlays. We never remove overlays from such stack, so
    #just iterate such stack after sourcing, ignoring the first two elements on
    #such stack (i.e., "/usr/share/zeshy/src" and "~/.zeshy/src"). For all other
    #elements:
    #
    #* Determine whether such overlay is a suboverlay of
    #  "/usr/share/zeshy/src" or "~/.zeshy/src".
    #* In either case, strip the prefixing 
    # "/usr/share/zeshy/src" or "~/.zeshy/src".
    #
    #FUXME: Nonsense. *WAY* too complex. O.K.; only spit this out if we're
    #debugging. There. DONE.
    #FUXME: Shift into a new function print_shell_variables().

    # Validate sanity.
    # Run each such command.
#Perform pre-compilation functionality subsequently defined in the main
#Zeshy overlay.

#document_function '
#void compile_zeshy_digest_to_make_zeshy(void)
#
#Perform last-minute functionality prior to compiling Zeshy''s digest file.
#In particular, make the final functions to be compiled into such file.
#'
#function compile_zeshy_digest_to_make_zeshy() {
#    # Validate sanity.
#    (( # == 0 )) || die 'no arguments expected'
#}

    # Perform post-compilation functionality subsequently defined in the main
    # Zeshy overlay.
#   append_command_to_make_zeshy make_zeshy_functions

    # Perform last-minute functionality prior to compiling Zeshy's digest file.
    # In particular, make the final functions to be compiled into such file.

#Prepare the current shell environment for digest compilation.
#Perform initialization prior to compiling Zeshy''s digest file.
#Dynamically synthesize functions to be compiled into the Zeshy digest file.
    # Synthesize the final set of Zeshy-specific functions.
#   make_zeshy_functions

#FUXME: Define document_function() here to strip the function name from the
#passed documentation, ignoring all prefixing whitespace. See "zeshy/help/help"
#for existing globs to assist doing so.
#FUXME: Actually run such commands -- somewhere near the tail of this file, yes?

    # If such documentation is prefixed by optional whitespace followed by
    # non-optional function prototype consisting of non-empty return type, non-
    # empty whitespace, non-empty function name, and left parens "(", match the
    # Get the function name prefixing such documentation.
    # Glob matching any number of non-newline characters followed by a newline,
    # thus matching the rest of a line.
    # If such documentation begins with optional whitespace followed by a
    # mandatory function prototype, match the function name from such
    # prototype.
#   line_glob="[^${newline}]#${newline}"
    # Newline character, abbreviated for readability.
#   local newline=$'\n'
#   [^$'\n']#$'\n'

# ....................{ GLOBALS                            }....................
    # * Source such file.
    # * Copy such file to Zeshy's user configuration directory, if not already
    #   containing such file.
    # If the current shell is interactive and loading the Zeshy user directory,

    #FIXME: Need to explicitly persist such maps to the current digest file.
    # Maps from Zeshy-specific aliases, functions, and globals to the absolute
    # paths of the Zeshy components defining such objects. While this Zeshy
    # component requires no such maps, others -- especially, the Zeshy help
    # component, do. Hence, this component sets such maps on behalf of other
    # components.
#   export -A\
#       ZESHY_ALIAS_NAME_TO_FILENAME\
#       ZESHY_SUFFIX_ALIAS_NAME_TO_FILENAME\
#       ZESHY_FUNCTION_NAME_TO_FILENAME\
#       ZESHY_GLOBAL_NAME_TO_FILENAME

#       compile_zeshy_digest_source "${script_filename}"
    #FIXME: Hmm; the last iteration of the above for loop sets such lists
    #already. 'tis a minor optimization at best, but... *shrug*

# void compile_zeshy_digest_source(string script_filename)
#
# Source the passed script as contributing to the current compilation of Zeshy's
# digest file. In particular, record all aliases, functions, and globals newly
# defined by such script.
#function compile_zeshy_digest_source() {
#   ZESHY_ALIAS_NAMES_NEW=( ${(f)"$(alias +)"} )
#   ZESHY_SUFFIX_ALIAS_NAMES_NEW=( ${(f)"$(alias +s)"} )
#   ZESHY_GLOBAL_NAMES_NEW=( ${(f)"$(typeset +gx)"} )

    # Source such script.
#   say "sourcing \"${script_filename}\"..."
#   source "${script_filename}"
#   say "sourced \"${autoload_function_filename}\"."

#   ZESHY_ALIAS_NAMES_NEW=( ${(f)"$(alias +)"} )
#   ZESHY_SUFFIX_ALIAS_NAMES_NEW=( ${(f)"$(alias +s)"} )
#   ZESHY_GLOBAL_NAMES_NEW=( ${(f)"$(typeset +gx)"} )

    # Obtain all aliases, functions, and globals newly defined by such script.
#   ZESHY_SCRIPT_ALIAS_NAMES=(
#       "${ZESHY_ALIAS_NAMES_NEW[@]:|ZESHY_ALIAS_NAMES_OLD}" )
#   ZESHY_SCRIPT_SUFFIX_ALIAS_NAMES=(
#       "${ZESHY_SUFFIX_ALIAS_NAMES_NEW[@]:|ZESHY_SUFFIX_ALIAS_NAMES_OLD}" )
#   ZESHY_SCRIPT_GLOBAL_NAMES=(
#       "${ZESHY_GLOBAL_NAMES_NEW[@]:|ZESHY_GLOBAL_NAMES_OLD}" )

    # Filter canonical zsh globals from the list of Zeshy-specific globals.
#   ZESHY_SCRIPT_GLOBAL_NAMES=( "${ZESHY_GLOBAL_NAMES[@]:#${~ZSH_GLOBAL_NAMES_GLOB}}" )

#   ZESHY_FUNCTION_NAME_TO_FILENAME[
#}

        # Source such script.
#       say "sourcing \"${script_filename}\"..."
#       source "${script_filename}"
#       say "sourced \"${autoload_function_filename}\"."

#       ZESHY_FUNCTION_NAME_TO_FILENAME[
        # Load the functions this file defines for subsequent compilation.
    # For each function declared in each file in the passed directory and
    # subdirectories of that directory, make a symbolical link in the digest
    # directory with that function name to that file.
#FIXME: Add support for storing defined globals and aliases in a single
#startup_zeshy_globals() function. Naturally, do so prior to calling
#make_zeshy_startup_functions().

#   {
#       print -rl -- "================[old function names]================" "${ZESHY_FUNCTION_NAMES_OLD[@]}"
#       print -rl -- "================[new function names]================" "${ZESHY_FUNCTION_NAMES_NEW[@]}"
#       print -rl -- "================[dif function names]================" "${ZESHY_FUNCTION_NAMES_NEW[@]:|ZESHY_FUNCTION_NAMES_OLD}"
#   } | less
    # The alias() builtin lists only regular and global names with option "+"
    # and only suffix alias names with option "+s". Split the output of both on
    # newlines to get all regular, global, and suffix aliases.

    # Delete all Zeshy-specific globals defined by and imported from the parent
    # shell, locally preserving global ${ZESHY_HOME} for subsequent use. Failure to
    # delete such globals results in a subtle issue when compiling the Zeshy digest
    # file, which persists such globals to startup_zeshy_globals() by differencing
    # the lists of globals defined before and after such compilation. Failing to
    # delete such globals ensures the two lists to be effectively identical, thus
    # preventing persistence of Zeshy globals into the Zeshy digest file.
    #
    # See undefine_variable_matching() for details on variable deletion.
    #local zeshy_home="${ZESHY_HOME-}"

    #FIXME: Hmm; should use unexported globals by default, I think.
    #Unfortunately, getting a list of unexported globals appears to be somewhat
    #more difficult. The following should work, assuming globals without
    #whitespace (which I believe may be prohibited by POSIX, yes?):

    # Zeshy declares globals to be globally exported (e.g., "typeset -gx") rather
    # than merely as globals or exports (i.e., "typeset -g" or "typeset -x"). For
    # disambiguity, list only the former.
#   ZESHY_GLOBAL_NAMES_OLD=( ${(f)"$(typeset +x)"} )
# to the current user and then compiles only such 
# selects which such aliases, functions, and globals 
# recompiles all aliases, functions, and globals defined only *AFTER*
# sourcing befor
#
# determines which currently defined zsh aliases, functions, and globals to The
# difference of 
# Zeshy decides
#
# If recompiling the Zeshy digest file and hence sourcing Zeshy scripts
# defining globals, undefine such globals prior to initializing Zeshy. Why?
# The reason may be subtle, but the logic flows like butter. Zeshy may and
# typically does declare globals to be read-only. Understandably, zsh fails on
# attempting to redefine such globals. The subsequent call to startup_zeshy()
# and hence startup_zeshy_globals() does just that, requiring such globals be
# undefined prior to such calls. Oh, 'tis all a tad silly and worm-bitten, but
# so goes life in the tranche of code trenches.
    #FIXME: Unsure this much matters, now.
    # Recompilation optimizations require Zeshy to *NOT* have been autoloaded at
    # this point... Throw an exception if Zeshy has been. While this should
    # never be the case, one can't be too careful in a bitwise world.
#   typeset -f get_zeshy_version &>/dev/null and
#       die "get_zeshy_version() and hence Zeshy already autoloaded"

    # Undefine all globals defined by sourcing Zeshy. Why? The reason is subtle;
    # the logic flows like butter. Zeshy may (and usually does) declare some
    # such globals to be read-only. Understandably, zsh prints errors on
    # attempting to redefine such globals. However, Zeshy's subsequent calling
    # of startup_zeshy() and hence startup_zeshy_globals() attempts to do just
    # that! Undefining such globals here permits there subsequent redefinition.
    # ('tis all a tad silly, but so goes life in the tranche of code trenches.)
#   undefine_global "${ZESHY_GLOBAL_NAMES[@]}"
#   typeset -p ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY
#   [[ -n "${ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY+x}" ]] and print 'hmmmmm'
    #FIXME: Fairly certain we don't want to export. No point, really. "main"
    #just blows away all imported Zeshy globals, anyway. Just revert to '+g' in
    #"alias", yes?

#   $(join_list_on_newline ZESHY_ALIAS_NAMES)
#   $(join_list_on_newline ZESHY_GLOBAL_NAMES)
    # Convert global lists of commands to be run on startup into newline-
    # delimited strings to be interpolated into the functions created below.
#   string startup_zeshy_aliases startup_zeshy_globals
#   startup_zeshy_aliases="$(join_list_on_newline ZESHY_ALIAS_NAMES)"
#   startup_zeshy_globals="$(join_list_on_newline ZESHY_GLOBAL_NAMES)"

    # Make such functions.
#   eval "function startup_zeshy_aliases() {
#   ${startup_zeshy_aliases}
#}"
#   eval "function startup_zeshy_globals() {
#   ${startup_zeshy_globals}
#}"

    # List of all currently declared aliases, functions, and exported variables
    # declared after sourcing and compiling the Zeshy codebase.
    # Synthesize additional functions after sourcing all Zeshy scripts
    # applicable to the current user (above) but before compiling the Zeshy
    # digest file (below). Such functions have dynamic definitions dependent on
    # global variables set while sourcing such scripts.
# (i.e., subsequent to
    # recursively sourcing Zeshy and hence declaring Zeshy functions)
#   is -d "${ZESHY_HOME}" si or
#       die "Zeshy home \"${ZESHY_HOME}\" not found"

#       "${^ZESHY_AUTOLOAD_DIRNAMES[@]}"/**/*~*.swp(.)
    #FIXME: Add new get_list_difference() and get_list_intersection() functions
    #to "type/function", leveraging die_unless_list() and return_list(). (Yep!)
    #Hmm; wait. We're probably better off with difference_lists_into() and
    #intersect_lists_into() functions accepting a third arg: the target list.

    # Append:
    #
    # * All subdirectories in this overlay's command directory matching commands
    #   in the user's current $PATH to the overlay stack.
    # * All files in this overlay's command directory matching such commands to
    #   the list of autoloadable files.
#   is -d "${overlay_command_dir}" si and {
        # List of all paths in this overlay's command directory corresponding to a
        # currently installed executable file in the $PATH. Dismantled, this is:
        #
        # * "${ZESHY_AUTOLOAD_COMMAND_DIR}/"*, listing each file in Zeshy's
        #   command directory.
        # * "(e{[[ ... ]]})", excluding files failing the following test:
        #   * "$REPLY", the current file.
        #   * ":t", the basename of such file.
        #   * ":c", the absolute path to a command in the $PATH with such name.
        #   * "== /*", true only when ":c" succeeds in finding such a command.
        # * "or true", ignoring failure (if ":c" fails finding such a command).
#       list overlay_command_paths; overlay_command_paths=(
#           "${overlay_command_dir}/"*(e{'[[ $REPLY:t:c == /* ]]'})
#       ) or true

#       # Append all files in this directory to the list of autoloadable files.
#       ZESHY_AUTOLOAD_FILENAMES+=( "${^overlay_command_paths[@]}"(.) )

#       # Append all directories in this directory to the overlay stack.
#       ZESHY_OVERLAY_STACK+=( "${^overlay_command_paths[@]}"(/) )
#   }

#FIXME: Sourcing configuration files *REALLY* needs to happen prior to
#compilation, for obvious reasons. O.K.; so, that's taken care of. But we need
#to also ensure that if we *DON'T* perform compilation we still source such files.
#Do:
#    source "${ZESHY_DOT_CONFIG_DIR}/"*

    # If "lsb_release" is installed, run it to obtain the distro name of the
    # current operating system. Most modern distros provide such executable
    # for exactly this purpose. While crude alternatives to "lsb_release" do
    # exist (e.g., globbing for filenames matching /etc/*release), it hardly
    # seems worth the buggy effort so early in the bootstrap process.
    # Dismantled, this is:
    #
    # * "${:-lsb_release}", expanding to the string "lsb_release".
    # * "${...:c}", expanding to the absolute path of "lsb_release" if installed
    #   in the current $PATH or only "lsb_release" otherwise.
    # * "-x", returning true if such path is executable and hence installed.
    #   Unless the current directory contains an executable "lsb_release", this
    #   returns true only if ":c" expanded to an absolute path.
#   if is -x "${${:-lsb_release}:c}" si; then
        # Lowercase the distro name for dirname comparison.
#       string distro_name autoload_distro_dir
#       distro_name="${(L)$(lsb_release -si)}"
#       autoload_distro_dir="${ZESHY_AUTOLOAD_DISTRO_DIR}/${distro_name}"
#       print "autoload_distro_dir: ${autoload_distro_dir}"

        # If Zeshy provides distro-specific components, append distro-
        # specific dirnames and filenames to the corresponding lists.
#       if is -d "${autoload_distro_dir}" si; then
#           ZESHY_AUTOLOAD_DIRNAMES+="${autoload_distro_dir}/always"
#           ZESHY_AUTOLOAD_FILENAMES+=(
#               "${autoload_distro_dir}/if_pathable/"*(e{'[[ $REPLY:t:c == /* ]]'})
#           ) or true
#       fi
#   fi
    # List of directories recursively containing zsh scripts containing
    # autoloadable functions to be compiled into Zeshy's digest file.
#   ZESHY_AUTOLOAD_DIRNAMES+="${ZESHY_AUTOLOAD_CORE_DIR}"

#   string overlay_dir="${1}"
#   is -d "${overlay_dir}" si or
#       die "\"${overlay_dir}\" not found or not a directory"
#   string source_filename="${1}" target_filename basename
#   is -f "${source_filename}" si or
#       die "\"${source_filename}\" not found or not a file"
#   basename="$(basename "${source_filename}")"
#   target_filename="${ZESHY_DOT_CONFIG_DIR}/${basename}"

    # If not found, make the user-specific Zeshy configuration (and hence dot)
    # directory and file.
#   is -d "${ZESHY_DOT_CONFIG_DIR}" si or mkdir -p "${ZESHY_DOT_CONFIG_DIR}"
#   is -f "${target_filename}" si or {
#       say "fabricating \"${target_filename}\"..."
#       cp "${source_filename}" "${ZESHY_DOT_CONFIG_DIR}/"
#   }

    #FIXME: We need to do this in "src/import", instead. Probably just:
    #source "${ZESHY_DOT_CONFIG_DIR}/"*
    # Import such file, hopefully defining all globals declared above.
#   source "${target_filename}"
    # List of directories recursively containing zsh scripts containing
    # autoloadable functions to be compiled into Zeshy's digest file.
#   list ZESHY_OVERLAYS
#   ZESHY_OVERLAYS=( "${ZESHY_AUTOLOAD_CORE_DIR}" )

    # Recursively compile the Zeshy codebase specific to current system and user
    # state starting from (in order):
#compile_zeshy_theme() {
#}

    # List of Zeshy overlays (i.e., system- and user-specific directories
    # obeying the same structure as Zeshy's top-level "./src" directory). All
    # files and directories in a Zeshy overlay are ignored except those with the
    # following Zeshy-specific names:
    #
    # * "always", a directory recursively containing only:
    #   * Subdirectories with arbitrary names and nesting, purely for
    #     organizational purposes. (Optional.)
    #   * Zeshy scripts, to be unconditionally compiled into Zeshy's digest
    #     file. Scripts may reside directly in the top-level "always" directory
    #     or under optional subdirectories. In either case, Zeshy automatically
    #     finds and compiles all zsh functions in all such files.
    #
    # recursively containing zsh scripts containing
    # autoloadable functions to be compiled into Zeshy's digest file.

    #FIXME: O.K.; technically, this works -- but not here, as we have yet to
    #autoload Zeshy. This is a fairly complex operation. (Can we reduce it to
    #more efficient zsh builtins and ideally simply glob matching?)
    # Determine whether or not this process is running is a cronjob. This is
    # adapted from this itworld.com article, "Am I being run by cron?":
    #        http://www.itworld.com/Comp/3380/nls_unixcron041209/index.html
    #
    # Do this prior to saying imports, as the say() function requires this.
#    string cron_pids="$(pgrep -x cron)"
#    integer grandparent_pid="$(ps -eo ppid,pid= | grep " ${PPID}$" | awk '{print $1}')"
#    ZESHY_IS_CRONJOB="$(one_if match_multiline "^${cron_pids}$" "${grandparent_pid}")"
#   echo "cron: ${ZESHY_IS_CRONJOB}; cron_pids: ${cron_pids}; gpid: ${grandparent_pid}"

# All monitoring and modification is silent, efficient, and entirely automatic.
# to accomodate
# such changes. Such are silent, efficient, and entirely automatic.
# efficiently monitors such state for changes,      # * "${distro_command:c}", expanding to the absolute path of
    #   "lsb_release" if installed or only "lsb_release" otherwise.
#   string distro_command='lsb_release'
#   if is -x "${distro_command:c}" si; then
#FIXME: This is concise enough now to be merged back into "module", which should
#incidentally be renamed "load" (...I suppose).

    #FIXME: Test for pathological cases: namely, if there *IS* a Zeshy function
    #currently declared that shouldn't be (e.g., get_zeshy_version()). In such
    #case, I'm unsure what the proper response is. We currently th
    #FIXME: See "gwydden/output" for "TODO" comments on substantially
    #improving the theme support.

# ....................{ AUTOLOADS                          }....................
#FIXME: Keep the old method about, for a bit.
    # List set of autoloadable function names defined in such listed files.
#   list_set autoload_function_names
#   say "recursively sourcing \"${ZESHY_HOME}\"..."

    # Load "mapfile", a core zsh module mapping file contents to map values.
    # It's both brilliant and efficient, an unhappily rare combination. It's
    # also remarkably dangerous, since accidentally unsetting keys from this
    # map deletes the corresponding files. Hence, we immediately unload this
    # module after use.
#   zmodload zsh/mapfile

    #FIXME: Terrible! Utterly. When enabled, this sporadically fails with an
    #inscrutible error resembling:
    #    "(anon):82: bad math expression: operand expected at `/usr/share...'"
    #File a bug report if this is still the case under recent zsh versions.
    # Forcibly prevent harmful ${mapfile} and hence filesystem changes.
#       typeset -r mapfile
#       print ${mapfile[/tmp/config]}
#       print -rl -- ${(f)mapfile[/usr/share/zeshy/src/autoload/if_pathable/7z]}

    # For each function declared in each file in the passed directory and
    # subdirectories of that directory, make a symbolical link in the digest
    # directory with that function name to that file. Dismantled, this is:
    #
    # * "${^ZESHY_AUTOLOAD_DIRNAMES[@]}", expanding to each directory in the list.
    # * "/**/*",  recursively expanding to each file of this directory.
    # * "~*.swp", excluding temporary files.
    # * "(.L+0)", including only non-empty plain files. "mapfile" currently
    #   fails with error on attempting to expand an empty plain file,
    #   arguably a bug. Nonetheless, respect its wishes.
#   for autoload_function_filename (
#       "${^ZESHY_AUTOLOAD_DIRNAMES[@]}"/**/*~*.swp(.L+0)
#       "${ZESHY_AUTOLOAD_FILENAMES[@]}"
#   ) {
        # Load the functions this file defines for subsequent compilation.
#           say "sourcing \"${autoload_function_filename}\"..."
#       source "${autoload_function_filename}"

        # Append to the list of autoloadable functions all:
        #
        # * Explicitly defined functions of form "${function_name}() {".
        # * Implicitly defined interactive aliases of form
        #   "interactive_alias ${alias_name}=${alias_expansion}".
        #
        # Dismantled, this is:
        #
        # * "${(f)mapfile[...]}", expanding to each line of this file.
        # * "${(M)", ":#", and "}", excluding lines not matching the
        #   following extended glob expression:
        #   * "\(\) \{", followed by "() {", signifying a function.
        #   * "[[:alnum:]_-]##", greedily matching a substring of one or
        #     more alphanumeric, underscore, and hyphen characters.
        # * "${" and "%%\(*}", excluding the "() {" suffixing such lines.
        # * "=?*", greedily matching "=" followed by one or more characters.
        #
        # Note: *DO NOT QUOTE THIS EXPRESSION*. Doing so silently expands
        # this expression to the empty string, though we have no idea why!
        # Also, do not quote the expansion of ${autoload_function_file} in
        # this expression. Doing so causes "mapfile" to interpret such
        # quotes as prefixing and suffixing such filename, thus raising an
        # exception on not finding such "munged" filename.
#       autoload_function_names+=(
#           ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|interactive_alias [[:alnum:]_-]##=?)*}#interactive_alias }%%[(=]*}
#               ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|interactive_alias [[:alnum:]_-]##=?)*}#interactive_alias }%%[(=]*}
#       )
#           say "sourced \"${autoload_function_filename}\"."
#   }

    # Unload "mapfile", for safety.
#   zmodload -u zsh/mapfile

    #FIXME: Not quite right. If the user disables
    #${ZESHY_IS_WRAPPING_CORE_RUNNABLES}, then some interactive aliases will not
    #actually be defined. zcompile() *FAILs* when fed non-extant function names.
    #To rectify this, we really want to make the prior loop sourcing each file
    #and matching "autoload_function_names" much, much smarter. First, stop
    #grepping file contents. If you consider it, all you really need to do is:
    #
    #* Before sourcing such file, stuff the set of all function names into a list.
    #* After! sourcing such file, diff! the set of all function names against
    #  such list. A new subtract_list_from_list() function would be of help,
    #  here. The resulting list is the set of all function names such file
    #  defined. This method may or may not be slower, depending on zsh. What's
    #  clear, however, is that it's *MUCH* more resilient and *MUCH* less hacky.
    #
    #Ah-ha! zsh 5.0 bundles a "${left_list:|right_list}" operator subtracting
    #the two lists. This implies a hard dependency.
#   is "$(whence -w -- "${1}")" == *': function' si
#   list ZESHY_FUNCTION_NAMES_OLD; ZESHY_FUNCTION_NAMES_OLD=( $(typeset -f +) )

    # Recompile all such loaded function definitions into the digest file.
#       print "autoload function names: ${autoload_function_names[@]}"
#       say "compiling \"${ZESHY_DOT_DIGEST_FILE}\"..."
#   zcompile -c "${ZESHY_DOT_DIGEST_FILE}" "${autoload_function_names[@]}"

# ....................{ WASTELANDS                         }....................
        #FIXME: This should be a "list_set" rather than "list", for a slight
        #efficiency (and clarity (and stability!)) improvement.
#
        # For clarity, temporarily set the script name to Zeshy.
#       string ZESHY_SCRIPT_NAME='zeshy'

#       zcompile "${ZESHY_DOT_DIGEST_FILE}" "${ZESHY_DOT_DIGEST_DIR}"/**/*(@)
#               ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|interactive_alias [[:alnum:]_-]##=?)*}#interactive_alias }%%( \(|\=)*}
            #FIXME: I believe these two mappings can be condensed into one.
#               ${(f)mapfile[/usr/share/zeshy/src/autoload/if_pathable/7z]}
#               ${(f)mapfile[${autoload_function_filename}]}
#               ${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|interactive_alias [[:alnum:]_-]##=?)*}
#               ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|interactive_alias [[:alnum:]_-]##=?)*}#interactive_alias }%%( \(|=)*}
#               ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#interactive_alias [[:alnum:]_-]##=?*}#interactive_alias }%%\=*}
#               ${${(M)${(f)mapfile[${autoload_function_filename}]}:#[[:alnum:]_-]##\(\) \{}%%\(*}
#               ${${${(M)${(f)mapfile[/usr/share/zeshy/src/autoload/if_pathable/7z]}:#interactive_alias [[:alnum:]_-]##=?*}#interactive_alias }%%\=*}
#           print "interactive_aliases:"
#           print -rl -- ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#interactive_alias [[:alnum:]_-]##=*}#interactive_alias }%%\=*}

# --------------------( TODO                               )--------------------
# * Ultimately, Zeshy should auto-compile the recursive entirety of all Zeshy
#   function definitions into a single so-called "digest" file at, say,
#   "~/.zeshy/digest.zwc". Such a file is autoloadable by:
#       
#       # ...implicitly autoloading such digest.
#       fpath=( "~/.zeshy/digest.zwc" "${fpath[@]}" )
#
#       # ...explicitly autoloading such digest.
#       autoload -Uw "~/.zeshy/digest.zwc"
#
#   I'm unsure if the former supercedes the latter. (Probably not, no.) Both
#   required, perhaps.
#
#   What's nice about this is that such a digest file appears to come prepended
#   with a list of all functions defined by such digest, thus rendering
#   autoloading of digest files terrifically fast. Auto-generating such a digest
#   on any change to any Zeshy file or directory is, unfortunately, not quite so
#   easy. We'll need to write something resembling:
#
#       if is "$(get_path_mtime "~/.zeshy/digest.zwc") equals SOMETHING si; then
#           zcompile "~/.zeshy/digest.zwc" "${ZESHY_HOME}/src/"**/*(.)
#       fi
#
#   However, it's unclear just how aggregating multiple files into one handles
#   initialization code. Clearly, it either doesn't or does but simply lumps all
#   initialization together. Either case is bad. We'll need to rewrite Zeshy to:
#
#   * Perform all non-costly initialization up-front in Zeshy .main or core.
#   * Perform all costly initialization in the functions requiring such
#     initialization as the first line of such functions. You know that grind...
# * Ugh. Current symlink technique doesn't quite work. It's quite close, though.
#   A working system either:
#   * Harvests the set of all function names using the current technique *AND*
#     manually recursively sources all Zeshy files (easy) *AND* uses the "-c"
#     flag to zcompile to compile all such function names into the digest
#     (easy). This isn't quite perfect, but it seems pretty darn close.
#   * Alternatively, create new temporary files in "~/.zeshy/digest/" defining
#     each such function separately by matching out the definition of such
#     functions from the existing files. This is somewhat more work, and
#     demonstrably of no greater benefit than the prior method. I reck'n it'd
#     work, but I'd rather try to pick the prior low-hanging fruit, first.


    #     zrecompile -p\
    #         -R ~/.zshrc --\
    #         -M ~/.zcompdump --\
    #         ~/zsh/comp.zwc ~/zsh/Completion/*/_*
    #
    #This does everything for us. Swag, no? Memory map everything, of course.
    #Oh, and the latter line is the one that applies to us. To quote: "re-create
    #the file ~/zsh/comp.zwc if any of the files matching the given pattern is
    #newer than it." We'll need to dynamically construct the arguments to be
    #passed for the command-specific directories. Shouldn't be hard:
    #
    #     list zrecompile_args
    #     zrecompile_args=( "${generic_dir}.zwc" "${generic_dir}"/**/*(.) )
    #     for command_dir in "src/auto/command"/*(/); do
    #         zrecompile_args+=( "${command_dir}.zwc" "${command_dir}"/**/*(.) )
    #     done
    #     print "za: ${zrecompile_args[@]}"

    # Automatically recompile all compiled files in function path "${FPATH}" whose
    # corresponding uncompiled files have since changed.
    #autoload -U zrecompile
#   zrecompile -p

        # Make the digest directory, if needed.
#       say "composing \"${ZESHY_DOT_DIGEST_DIR}\"..."
#       mkdir -p "${ZESHY_DOT_DIGEST_DIR}"

        # Remove all existing symbolic links in the digest directory, if needed.
#       list digest_symlinks; digest_symlinks=( "${ZESHY_DOT_DIGEST_DIR}/"*(@) )
#       is -n "${digest_symlinks}" si and rm "${digest_symlinks[@]}"


#           print "autoload_function_file=${autoload_function_file}"
#           for autoload_function_name\
#               ( ${${(M)${(f)mapfile[${autoload_function_file}]}:#[[:alnum:]_-]##\(\) \{}%%\(*} ) {
#               ln -s\
#                   "${autoload_function_file}"\
#                   "${ZESHY_DOT_DIGEST_DIR}/${autoload_function_name}"
#           }

#       is_shell_terminal and print 'Yum!'
#       zcompile -c "${ZESHY_DOT_DIGEST_FILE}" is_shell_terminal

#   zstat +mtime "${1}"
    # Dismantled, this is:
    #
    # * "${pathname}"/**/*, all files and subdirectories of this directory.
    # * "om", such files and subdirectories in ascending order by mtime.
    # * "[1]", the first and hence newest such file or subdirectory.
#   zstat +mtime "${pathname}"/**/*(om[1])

#   touch -m --date=@"${mtime}" "${pathname}"

# void _populate_zeshy_digest_dir_with(string dirname)
#
# Populate Zeshy's digest directory with one symbolic link for each autoloadable
# function in each file of the passed directory, recursively.
#_populate_zeshy_digest_dir_with() {
#    die_unless_one_arg 'expected exactly one dirname'
#
#    # For each function declared in each file in the passed directory and
#    # subdirectories of that directory, make a symbolical link in the digest
#    # directory with that function name to that file. Dismantled, this is:
#    #
#    # * "/**/*", recursively expanding to each file and subdirectory of the
#    #   passed directory.
#    # * "~*.(swp)", excluding temporary files.
#    # * "(.)", including only plain files.
#    for autoload_function_file\
#        ( "${ZESHY_AUTOLOAD_ALWAYS_DIR}"/**/*~*.(swp)(.) ) {
#        # Dismantled, this is:
#        #
#        # * "${(f)mapfile["${autoload_function_file}"]}", iteratively
#        #   expanding to each line of this file.
#        # * "${(M)", ":#", and "}", excluding lines not matching the
#        #   following extended glob expression:
#        #   * "[[:alnum:]_-]##", greedily matching a substring of one or
#        #     more alphanumeric, underscore, and hyphen characters.
#        #   * "\(\) \{", followed by "() {", signifying a function.
#        # * "${" and "%%\(*}", excluding the "() {" suffixing such lines.
#        for autoload_function_name\
#            ( "${${(M)${(f)mapfile["${autoload_function_file}"]}:#[[:alnum:]_-]##\(\) \{}%%\(*}" ) {
#            ln -s\
#                "${autoload_function_file}"\
#                "${ZESHY_DOT_DIGEST_DIR}/${autoload_function_name}"
#        }
#    }
#}

#       for autoload_command_filename\
#           ( "${ZESHY_COMMAND_DIR}/"*(e{'[[ $REPLY:t:c == /* ]]'}) ) {
#           ZESHY_AUTOLOAD_FILENAMES+=( "${autoload_command_filename}" )
#       }

        #FIXME: Replace with an "rm -rf" once confident this works.
#           mv "${ZESHY_DOT_DIGEST_DIR}" "${ZESHY_DOT_DIR}/tmp/$(date +'%N')"

#_zeshy_autoload_digest_old() {
    #FIXME: This only applies to developer systems. In production, Zeshy
    #requires only one initial compilation, thus eliminating the cost of such
    #recompilation. Ah; I wonder. Wouldn't a "zrecompile -p" immediately after
    #declaring the "fpath" do this, assuming we'd first compiled all necessary
    #digests? If so, that would suggest we'd only need a simple test for
    #
    #    if not is_file "${ZESHY_DOT_DIGEST_FILE}"; then
    #       # Compile everything anew here! Don't bother checking mtimes.
    #    fi
    #
    #Then, a zrecompile should handle the rest, yes? That would be considerably
    #more efficient, given zsh's C-backed implementation. Ah; O.K., it gets even
    #better. We can entirely reduce this if-conditional to a zrecompile() call
    #resembling the given example:
    #
    #     zrecompile -p\
    #         -R ~/.zshrc --\
    #         -M ~/.zcompdump --\
    #         ~/zsh/comp.zwc ~/zsh/Completion/*/_*
    #
    #This does everything for us. Swag, no? Memory map everything, of course.
    #Oh, and the latter line is the one that applies to us. To quote: "re-create
    #the file ~/zsh/comp.zwc if any of the files matching the given pattern is
    #newer than it." We'll need to dynamically construct the arguments to be
    #passed for the command-specific directories. Shouldn't be hard:
    #
    #     list zrecompile_args
    #     zrecompile_args=( "${generic_dir}.zwc" "${generic_dir}"/**/*(.) )
    #     for command_dir in "src/auto/command"/*(/); do
    #         zrecompile_args+=( "${command_dir}.zwc" "${command_dir}"/**/*(.) )
    #     done
    #     print "za: ${zrecompile_args[@]}"
#    say "detecting \"${ZESHY_DOT_DIGEST_FILE}\"..."
#    integer zeshy_mtime=$(get_path_mtime_recursive "${ZESHY_SRC_HOME}")
#    if not is_file "${ZESHY_DOT_DIGEST_FILE}" or
#        (( zeshy_mtime != $(get_path_mtime "${ZESHY_DOT_DIGEST_FILE}") )); then
#        say "compiling \"${ZESHY_DOT_DIGEST_FILE}\"..."
#        # ...the "-." matches all files and symbolic links to files.
#        zcompile "${ZESHY_DOT_DIGEST_FILE}" "${ZESHY_SRC_HOME}"/**/*~*.(swp|zwc)(-.)

#        # Set the mtime of the compiled script to that of the uncompiled
#        # script to ensure the above conditional fails on future imports.
#        set_path_mtime "${ZESHY_DOT_DIGEST_FILE}" "${zeshy_mtime}"
#    fi

    # Declare all functions provided by the digest file to be autoloadable.
#    autoload -w "${ZESHY_DOT_DIGEST_FILE}"

    # Prefix "${FPATH}" with the absolute path to the digest file, ensuring zsh
    # searches such file for the definition of such functions first. Oddly, zsh
    # has no means of directly associating the two.
#    fpath=( "${ZESHY_DOT_DIGEST_FILE}" "${fpath[@]}" )
#}
