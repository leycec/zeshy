#!/usr/bin/env zsh
# ====================[ compile                            ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# (Re)compile the Zeshy codebase into the current user's Zeshy digest file.
#
# --------------------( SYMBOLS                            )--------------------
# In most programming languages, the symbols that language exports for external
# use (e.g., packages, classes, functions, globals) do not vary with system or
# user configuration. The same version of the same language unconditionally
# exports the same symbols, everywhere. This forms the core.
#
# As expected, Zeshy behaves different. Most symbols Zeshy exports for external
# use at the command line and within scripts conditionally vary with system and
# user state, including:
#
# * The output of the system-specific "lsb_release" and/or "uname" commands.
# * The contents of the user-specific Zeshy configuration at "~/.zeshy/config".
# * The contents of the user-specific ${PATH} (i.e., the set of currently
#   installed and accessible programs).
#
# Zeshy monitors such content for changes -- silently, efficiently, and entirely
# automatically. On detecting changes, Zeshy changes itself. As example:
#
# * On switching from a Linux to BSD operating system, Zeshy supplants the
#   Linux-specific symbols it exports with those specific to BSD.
# * On editing the "ZESHY_THEME" global in the "~/.zeshy/config/main"
#   configuration file from the default "vanilla" to, say, "cookiedough", Zeshy
#   supplants the default theme symbols it exports with those from the
#   "cookiedough" theme.
# * On installing a new program "rtorrent" into the system-wide "/bin" directory
#   in the ${PATH}, Zeshy exports "rtorrent"-specific symbols.
#
# Zeshy symbols comprise Zeshy-specific Zsh functions and, to a lesser extent,
# Zsh aliases and globals. For efficiency, Zeshy exports the former as a single
# Zsh digest file (i.e., a binary file in a Zsh-specific format functionally
# analogous to that of C and C++-style shared libraries).
#
# Zeshy compiles *ONLY* that subset of itself specific to current system and
# user state into its digest file. Uncompiled code remains inaccessible until
# such state changes (e.g., installing "rtorrent" notifies Zeshy to compile
# start_rtorrent() and stop_rtorrent() functions into its digest file). For end
# user purposes, Zeshy *IS* its digest file.
#
# --------------------( OVERLAYS                           )--------------------
# To accomodate system- and user-specific Zeshy add-ons (e.g., plugins, themes),
# Zeshy divides itself into overlays: directories with the same structure as
# Zeshy's top-level "src" directory. Zeshy ignores all files and directories in
# an overlay except those with the following Zeshy-specific names:
#
# * "always", a subdirectory recursively containing only:
#   * Zeshy scripts, to be unconditionally compiled into Zeshy's digest file.
#     These scripts may reside directly in the mandatory "always" directory
#     or under optional subdirectories. In either case, Zeshy automatically
#     finds and compiles all Zsh functions in all such files.
#   * Subdirectories with arbitrary names and nesting. (Zeshy automatically
#     finds all scripts in such subdirectories. Subdirectory structure is
#     insignificant and hence only for optional organization.)
# * "if_installed", a subdirectory directly containing only:
#   * Zeshy scripts, each conditionally compiled into Zeshy's digest file *ONLY*
#     if an executable file of the same case-sensitive basename currently exists
#     in the user-specific ${PATH}.
#   * Subdirectories, each conditionally enabled as a Zeshy overlay and hence
#     subject to recursive processing (e.g., for an "always" subdirectory) only
#     if an executable file of the same case-sensitive basename currently exists
#     in the user-specific ${PATH}.
# * "if_distro", a subdirectory directly containing only:
#   * Subdirectories, each conditionally enabled as a Zeshy overlay *ONLY* if
#     the current system-specific Linux and/or BSD distribution has the same
#     lowercase name. At most one such subdirectory matches; Zeshy ignores the
#     remaining subdirectories.
# * "if_config", a subdirectory directly containing only:
#   * Zeshy configuration files, to be unconditionally copied into the user-
#     specific "~/.zeshy/config" directory if not already found.

#FIXME: *UGH*. The ${ZESHY_UNIT_*} globals are no longer recorded as Zeshy
#globals. Hmm; I'm beginning to think we need, by default, to delete *ALL*
#globals matching ${ZESHY_*} *NOT* previously declared by "main", "config", or
#"autoload". Question is: how can we do this without incurring substantial
#complexity and/or fragility costs? You know, I think I'm happy to pay a slight
#efficiency cost here... but wait. You know, this is all symptomatic of a
#larger problem. If globals aren't being persisted correctly, it stands to
#reason neither are aliases or functions. Something subtly terrible is
#happening somewhere -- and we really need to fix it before releasing even an
#alpha version. To begin debugging, run "which startup_zeshy_globals"
#immediately after logging in (i.e., in a Zeshy login shell). What's the
#result? I half-guarantee it's substantially messed up. If that's *NOT* the
#case, then something may be going wrong during shell instantation and
#inheritance. Mmmhmmm.

# ....................{ COMPILERS                          }....................
# void compile_zeshy(void)
#
# Compile Zeshy's digest file from system-wide and user-specific Zeshy overlays.
function compile_zeshy() {
    # Validate sanity.
    (( # == 0 )) || die 'no arguments expected'

    # Lists of all Zeshy-specific aliases, functions, and globals. Defining such
    # lists globally:
    #
    # * Implicitly exports such lists to child shells, which on receiving such
    #   globals may use their contents to undefine aliases, functions, and other
    #   globals imported from the parent shell.
    # * Permits us to undefine such globals in a global context below. See the
    #   tail of this file.
    #
    # Zsh treats suffix aliases differently from normal and global aliases, so
    # differentiate the former from the latter.
    export -a\
        ZESHY_ALIAS_NAMES\
        ZESHY_SUFFIX_ALIAS_NAMES\
        ZESHY_FUNCTION_NAMES\
        ZESHY_GLOBAL_NAMES
#   print '===ZESHY_FUNCTION_NAMES==='
#   typeset -p ZESHY_FUNCTION_NAMES

    # List of directories recursively containing Zsh scripts containing
    # autoloadable functions to be compiled into Zeshy's digest file.
    local -a ZESHY_AUTOLOAD_DIRNAMES

    # List of Zsh scripts containing autoloadable functions to be so compiled.
    local -a ZESHY_AUTOLOAD_FILENAMES

    # FIFO stack of Zeshy overlays.
    local -a ZESHY_OVERLAY_STACK

    # List of all currently declared aliases, functions, and globals declared
    # *BEFORE* sourcing and compiling Zeshy.
    local -a\
        ZESHY_ALIAS_NAMES_OLD\
        ZESHY_SUFFIX_ALIAS_NAMES_OLD\
        ZESHY_FUNCTION_NAMES_OLD\
        ZESHY_GLOBAL_NAMES_OLD

    # List of all currently declared aliases, functions, and globals declared
    # *AFTER* sourcing and compiling Zeshy. See compile_zeshy() for details.
    local -a\
        ZESHY_ALIAS_NAMES_NEW\
        ZESHY_SUFFIX_ALIAS_NAMES_NEW\
        ZESHY_FUNCTION_NAMES_NEW\
        ZESHY_GLOBAL_NAMES_NEW

    # Lowercase name of the current *nix distribution.
    local ZESHY_DISTRO_NAME

    # Glob expression matching only Zeshy-specific Zsh scripts.
    local ZESHY_SCRIPT_GLOB='*~*.swp(.)'

    # Glob expression matching canonical Zsh globals.
    local ZSH_GLOBAL_NAMES_GLOB='REPLY|MATCH|MBEGIN|MEND|match|mbegin|mend'

    # Initialize such variables.
    compile_zeshy_startup

    # Iteratively source all applicable functions in all applicable overlays
    # into the current shell environment. Since we modify the stack while
    # iterating on it, loop dynamically (e.g., "for ((...))") rather than
    # statically (e.g., "for overlay_dir ("${ZESHY_HOME[@]})").
    for ((i = 1; i <= ${#ZESHY_OVERLAY_STACK}; i++)) {
        compile_zeshy_overlay "${ZESHY_OVERLAY_STACK[i]}"
    }

    # Compile the Zeshy digest from the function definitions sourced above.
    compile_zeshy_digest
}

# void compile_zeshy_startup(void)
#
# Prepare the current shell environment for digest compilation.
function compile_zeshy_startup() {
    # Validate sanity.
    (( # == 0 )) || die 'no arguments expected'

    # Since recursion is prohibitively expensive, perform a non-recursive depth-
    # first search of overlays starting from the following tree roots (in order):
    #
    # * The system-wide Zeshy root.
    # * The user-specific Zeshy root, if found.
    ZESHY_OVERLAY_STACK=( "${ZESHY_HOME}" )
    [[ -d "${ZESHY_DOT_OVERLAY_DIR}" ]] &&
        ZESHY_OVERLAY_STACK+="${ZESHY_DOT_OVERLAY_DIR}"

    # Record the names of all currently defined aliases, functions, and globals
    # not to be compiled into Zeshy's digest file.
    ZESHY_ALIAS_NAMES_OLD=( ${(f)"$(alias +)"} )
    ZESHY_SUFFIX_ALIAS_NAMES_OLD=( ${(f)"$(alias +s)"} )

    # Dismantled, this is:
    #
    # * "+f", listing newline-delimited function names.
    # * "(f)", splitting such list on newlines.
    ZESHY_FUNCTION_NAMES_OLD=( ${(f)"$(typeset +f)"} )

    # Dismantled, this is:
    #
    # * "+gx", listing newline-delimited globally exported variable names.
    # * "(f)", splitting such list on newlines.
    ZESHY_GLOBAL_NAMES_OLD=( ${(f)"$(typeset +gx)"} )
#   print -l "===ZESHY_GLOBAL_NAMES_OLD===" "${ZESHY_GLOBAL_NAMES_OLD[@]}"

    #FIXME: BSD installs no such command, so this clearly fails to suffice.
    #We'll probably want to just import the entire get_distro_name() command.
    #Or perhaps not. Is the logic simple, under BSD?
    # If the current *nix distribution provides the "lsb_release" command, run
    # such command to obtain the name of such distribution. While alternatives
    # to "lsb_release" do exist (e.g., globbing for filenames matching
    # /etc/*release), it hardly seems worth the effort so early in the bootstrap
    # process. Dismantled, this is:
    #
    # * "${:-lsb_release}", expanding to the string "lsb_release".
    # * "${...:c}", expanding to the absolute path of "lsb_release" if installed
    #   in the current $PATH or only "lsb_release" otherwise.
    # * "-x", returning true if such path is executable and hence installed.
    #   Unless the current directory contains an executable "lsb_release", this
    #   returns true only if ":c" expanded to an absolute path.
    [[ -x "${${:-lsb_release}:c}" ]] &&
        ZESHY_DISTRO_NAME="${(L)$(lsb_release -si)}"
}

# void compile_zeshy_digest(void)
#
# Compile Zeshy's digest file by sourcing all Zsh scripts listed by
# ${ZESHY_AUTOLOAD_FILENAMES} and Zsh scripts in directories listed by
# ${ZESHY_AUTOLOAD_DIRNAMES}. The set difference between the sets of functions
# defined prior to and after such sourcing is the subset of Zeshy-specific
# functions to be compiled into the digest. (Without compunction, compile it!)
function compile_zeshy_digest() {
    # Validate sanity.
    (( # == 0 )) || die 'no arguments expected'

    # Inform the current user of such recompilation.
    [[ -o interactive ]] &&
        if [[ -n "${ZESHY_IS_LOADING_USER_DIR}" ]]
        then say "recompiling \"${ZESHY_DOT_DIGEST_FILE}\"..."
        else say "sourcing \"${ZESHY_HOME}\"..."
        fi

    # Recursively source all scripts residing under all overlays applicable to
    # the current user, thus defining all applicable Zeshy-specific aliases,
    # functions, and globals. Dismantled, this is:
    #
    # * "${^ZESHY_AUTOLOAD_DIRNAMES[@]}", expanding to each directory in the list.
    # * "/**/*",  recursively expanding to each file in such directory.
    # * "~*.swp", excluding temporary files.
    # * "(.)", excluding non-plain files.
    for script_filename (
        "${^ZESHY_AUTOLOAD_DIRNAMES[@]}"/**/${~ZESHY_SCRIPT_GLOB}
        "${ZESHY_AUTOLOAD_FILENAMES[@]}"
    ) {
        # Source such script.
#       say "sourcing \"${script_filename}\"..."
        source "${script_filename}"
#       say "sourced \"${autoload_function_filename}\"."
    }

    # Record the names of all currently defined aliases, functions, and globals.
    ZESHY_ALIAS_NAMES_NEW=( ${(f)"$(alias +)"} )
    ZESHY_SUFFIX_ALIAS_NAMES_NEW=( ${(f)"$(alias +s)"} )
    ZESHY_GLOBAL_NAMES_NEW=( ${(f)"$(typeset +gx)"} )
#   ZESHY_GLOBAL_NAMES_NEW=( ${${(f)"$(typeset +g +)"}##* } )

    # The lists of Zeshy-specific aliases and globals are the asymmetric
    # differences of the old from new lists of aliases and globals, which the
    # make_zeshy_functions() requires for synthesizing new functions. Delay
    # determining the list of Zeshy-specific functions until doing so.
    ZESHY_ALIAS_NAMES=(
        "${ZESHY_ALIAS_NAMES_NEW[@]:|ZESHY_ALIAS_NAMES_OLD}" )
    ZESHY_SUFFIX_ALIAS_NAMES=(
        "${ZESHY_SUFFIX_ALIAS_NAMES_NEW[@]:|ZESHY_SUFFIX_ALIAS_NAMES_OLD}" )
    ZESHY_GLOBAL_NAMES=(
        "${ZESHY_GLOBAL_NAMES_NEW[@]:|ZESHY_GLOBAL_NAMES_OLD}" )

    # Exclude canonical Zsh globals from the list of Zeshy-specific globals.
    ZESHY_GLOBAL_NAMES=( "${ZESHY_GLOBAL_NAMES[@]:#${~ZSH_GLOBAL_NAMES_GLOB}}" )
#   print -l "===ZESHY_GLOBAL_NAMES===" "${ZESHY_GLOBAL_NAMES[@]}"

    # Synthesize the final set of Zeshy-specific functions.
    make_zeshy_functions

    # If loading Zeshy's user directory, compile Zeshy-specific functions into
    # the digest file in such directory.
    [[ -n "${ZESHY_IS_LOADING_USER_DIR}" ]] &&
        zcompile -c -- "${ZESHY_DOT_DIGEST_FILE}" "${ZESHY_FUNCTION_NAMES[@]}"
}

# ....................{ COMPILERS ~ overlays               }....................
# void compile_zeshy_overlay(string overlay_dirname)
#
# Prepare the passed Zeshy overlay directory for digest compilation, as detailed
# above in "OVERLAYS". For each:
#
# * Zsh script in such overlay containing autoloadable functions to be compiled
#   into Zeshy's digest file, append such script to the list of such files.
# * Subdirectory in such overlay:
#   * That is itself an overlay, append such subdirectory to the overlay stack.
#   * Recursively containing Zsh scripts containing autoloadable functions to be
#     compiled into Zeshy's digest file, append such subdirectory to the list of
#     such subdirectories. (Subdirectories may either be overlays or directly
#     contain Zsh scripts, but not both.)
function compile_zeshy_overlay() {
    # Validate passed arguments.
    (( # == 1 )) || die 'expected one overlay dirname'
    local overlay_dir="${1}"
    [[ -d "${overlay_dir}" ]] || die "\"${overlay_dir}\" not a directory"
    [[ -o interactive ]] && say "overlaying \"${overlay_dir}\"..."

    # Absolute paths of overlay subdirectories.
    local\
        overlay_main_dir="${overlay_dir}/always"\
        overlay_theme_dir="${overlay_dir}/if_theme/${ZESHY_THEME:-vanilla}"

    # ~~~~~~~~~~~~~~~~< IMPORTANT ~ order is significant   >~~~~~~~~~~~~~~~~~~~~
    # Order of operation is significant below. Later files and directories take
    # precedence over prior files and directories in the corresponding lists.

    # Source all configuration files in this overlay's configuration directory.
    #
    # Do this prior to all other overlay logic depending on globals defined by
    # such files (e.g., ${ZESHY_THEME}).
    compile_zeshy_overlay_configs "${overlay_dir}"

    # Append this overlay's main directory as autoloadable, if found.
    [[ -d "${overlay_main_dir}" ]] &&
        ZESHY_AUTOLOAD_DIRNAMES+="${overlay_main_dir}"

    # Append this overlay's command directory to appropriate lists, if found.
    compile_zeshy_overlay_commands "${overlay_dir}"

    # Append the subdirectory of this overlay's theme directory matching the
    # user's currently configured theme to the overlay stack, if found.
    [[ -d "${overlay_theme_dir}" ]] &&
        ZESHY_OVERLAY_STACK+="${overlay_theme_dir}"

    # Append the subdirectory of this overlay's distro directory matching the
    # user's currently installed distro to the overlay stack, if found.
    #
    # Do this after all other overlay logic, allowing distro-specific
    # redefinition of generic functionality.
    [[ -n "${ZESHY_DISTRO_NAME}" ]] && {
        local overlay_distro_dir="${overlay_dir}/if_distro/${ZESHY_DISTRO_NAME}"
        [[ -d "${overlay_distro_dir}" ]] &&
            ZESHY_OVERLAY_STACK+="${overlay_distro_dir}"
    }
}

# void compile_zeshy_overlay_configs(string overlay_dirname)
#
# Prepare all user configuration files in the passed overlay directory. Namely:
#
# * Copy such files from such directory to Zeshy's user configuration directory
#   for Zeshy, if not already there.
# * Source such files from such directory, thus allowing the user opportunity to
#   change such files.
function compile_zeshy_overlay_configs() {
    # Validate passed arguments.
    (( # == 1 )) || die 'expected one overlay dirname'
    local overlay_config_dir="${1}/if_config"
    [[ -d "${overlay_config_dir}" ]] || return 0

    #FIXME: This'd be a nice place to add update handling for patching locally
    #modified config files against Zeshy-bundled config files on update.
    # Handle each configuration file in the passed overlay.
    local basename target_filename
    for source_filename ("${overlay_config_dir}/"${~ZESHY_SCRIPT_GLOB}) {
        basename="$(basename -- "${source_filename}")"
        target_filename="${ZESHY_DOT_CONFIG_DIR}/${basename}"

        # Source such script.
#       say "sourcing \"${target_filename}\"..."
        source -- "${source_filename}"

        # If loading Zeshy's user configuration directory and such directory
        # does not already contain such script, copy such script from such
        # overlay to such directory for subsequent user-specific editing.
        [[ ! -f "${target_filename}" && -n "${ZESHY_IS_LOADING_USER_DIR}" ]] && {
            [[ -o interactive ]] && say "defaulting \"${target_filename}\"..."
            command cp -- "${source_filename}" "${target_filename}"
        }
    }
}

# void compile_zeshy_overlay_commands(string overlay_dirname)
#
# Prepare command-specific Zsh scripts in the passed Zeshy overlay directory.
# Namely, append:
#
# * All Zsh scripts in this overlay's command directory matching commands in the
#   current user's $PATH to the list of autoloadable files.
# * All subdirectories in this overlay's command directory matching such
#   commands to the overlay stack.
function compile_zeshy_overlay_commands() {
    # Validate sanity.
    (( # == 1 )) || die 'expected one overlay dirname'
    local overlay_command_dir="${1}/if_installed"
    [[ -d "${overlay_command_dir}" ]] || return 0

    # List of all paths in this overlay's command directory corresponding to a
    # currently installed executable file in the $PATH. Dismantled, this is:
    #
    # * "${ZESHY_AUTOLOAD_COMMAND_DIR}/"*, listing each file in Zeshy's
    #   command directory.
    # * "(e{[[ ... ]]})", excluding files failing the following test:
    #   * "$REPLY", the current file.
    #   * ":t", the basename of such file.
    #   * ":c", the absolute path to a command in the $PATH with such name.
    #   * "== /*", true only when ":c" succeeds in finding such a command.
    # * "or true", ignoring failure (if ":c" fails finding such a command).
    local -a overlay_command_paths; overlay_command_paths=(
        "${overlay_command_dir}/"*(e{'[[ $REPLY:t:c == /* ]]'})
    ) || true

    # Append all files in this directory to the list of autoloadable files.
    ZESHY_AUTOLOAD_FILENAMES+=( "${^overlay_command_paths[@]}"(.) )

    # Append all directories in this directory to the overlay stack.
    ZESHY_OVERLAY_STACK+=(      "${^overlay_command_paths[@]}"(/) )
}

# ....................{ MAKERS                             }....................
# void make_zeshy_functions(void)
#
# Dynamically synthesize functions to be compiled into the Zeshy digest file.
function make_zeshy_functions() {
    # Validate sanity.
    (( # == 0 )) || die 'no arguments expected'

    # Call functions that
    # make_zeshy_startup_functions_defining_aliases_and_globals() makes at the
    # beginning of Zeshy startup, arbitrarily defining globals prior to aliases.
    # While order should not matter here, you never really know.
    prepend_zeshy_startup_command startup_zeshy_aliases
    prepend_zeshy_startup_command startup_zeshy_globals

    # Make startup_zeshy() and friends.
    make_zeshy_startup_functions

    # Make startup_zeshy_aliases() and startup_zeshy_globals() *AFTER DEFINING
    # ALL OTHER ZESHY-SPECIFIC FUNCTIONS*. This is a hard requirement, as this
    # function necessarily defines the list of such functions. (Fugly, fugly,
    # fugly. But there seem little sane alternatives, in this case.)
    make_zeshy_startup_functions_defining_aliases_and_globals
}

# void make_zeshy_startup_functions_defining_aliases_and_globals(void)
#
# Dynamically synthesize the following functions:
#
# * startup_zeshy_aliases(), defining regular, global, and suffix aliases.
# * startup_zeshy_globals(), defining globally exported variables.
#
# The subsequently synthesized startup_zeshy() calls both such functions before
# calling all other startup functions.
function make_zeshy_startup_functions_defining_aliases_and_globals() {
    # Validate sanity.
    (( # == 0 )) || die 'no arguments expected'
    local aliases suffix_aliases globals
    local -a alias_names_quoted
#   print -l -- "===ZESHY_GLOBAL_NAMES===" "${ZESHY_GLOBAL_NAMES[@]}"
#   print -l -- "===ZESHY_FUNCTION_NAMES===" "${ZESHY_FUNCTION_NAMES[@]}"
#   print -l -- "===ZESHY_STARTUP_COMMANDS===" "${ZESHY_STARTUP_COMMANDS[@]}"

    # Avoid calling builtins on empty lists, as that typically causes such
    # builtins to exhaustively (and uselessly) print *EVERYTHING*.
    (( #ZESHY_ALIAS_NAMES )) &&
        aliases="$(alias -L "${ZESHY_ALIAS_NAMES[@]}")"
    (( #ZESHY_SUFFIX_ALIAS_NAMES )) &&
        suffix_aliases="$(alias -Ls "${ZESHY_SUFFIX_ALIAS_NAMES[@]}")"

    # Save the lists of Zeshy-specific suffix aliases, functions, and globals.
    # Subsequently recompiling the Zeshy digest file in either the current shell
    # or children of such shell requires such lists for deciding which suffix
    # aliases, functions, and globals to undefine prior to sourcing the Zeshy
    # codebase. See the "MAIN" section of this component below.
    #
    # Omit the list of Zeshy-specific aliases, whose alias names we safely,
    # manually interpolate into the definition of startup_zeshy_aliases() below.
    # Why? The reason is, of course, exceedingly subtle. Alias names include
    # global alias names (e.g., "or"), which Zsh expands into the corresponding
    # global alias expansion *ANYWHERE* such names appear unquoted.
    # Unfortunately, the "typeset -p ZESHY_ALIAS_NAMES" command called below
    # fails to quote such names; hence, the "eval" statement evaluated below
    # expands a string resembling this:
    #
    #     typeset -gax ZESHY_ALIAS_NAMES
    #     ZESHY_ALIAS_NAMES=( is si or and not ... )
    #
    # into a string resembling this:
    #
    #     typeset -gax ZESHY_ALIAS_NAMES
    #     ZESHY_ALIAS_NAMES=( [[ ]] || && ! ... )
    #
    # This is clearly invalid Zsh syntax.
    ZESHY_GLOBAL_NAMES+=(
        ZESHY_SUFFIX_ALIAS_NAMES
        ZESHY_FUNCTION_NAMES
        ZESHY_GLOBAL_NAMES
    )
#   print "aliases: ${aliases}\nsuffix_aliases: ${suffix_aliases}"

    # Make such functions, making a placeholder empty definition for
    # startup_zeshy_globals() to be replaced below. The reasons, as ever, are
    # insidious. The set of all Zeshy-specific globals includes list global
    # ${ZESHY_FUNCTION_NAMES}, which cannot be defined until after defining all
    # Zeshy-specific functions. Naturally, startup_zeshy_globals() is such a
    # function. To break such circularity, define such function empty initially.
    eval "function startup_zeshy_aliases() {
    ${aliases}
    ${suffix_aliases}
}"
    eval "function startup_zeshy_globals() {
}"

    # The list of Zeshy-specific functions is the asymmetric difference of the
    # old from new list of functions.
    ZESHY_FUNCTION_NAMES_NEW=( ${(f)"$(typeset +f)"} )
    ZESHY_FUNCTION_NAMES=(
        "${ZESHY_FUNCTION_NAMES_NEW[@]:|ZESHY_FUNCTION_NAMES_OLD}" )

    # The "typeset -p" command fails to print the "-g" modifier for global
    # variables. Since "typeset -x" commands do not imply such modifier under
    # Zsh option "no_global_export", failing to print such modifier effectively
    # localizes such globals to the startup_zeshy_globals() function. Of course,
    # this constitutes a Zsh bug. (Submit a report please.) In the meanwhile,
    # forcefully add the "-g" modifier to all output "typeset" commands.
    globals="${$(\
        typeset -p "${ZESHY_GLOBAL_NAMES[@]}")//typeset -/typeset -g}"

    # Manually add the definition of the list of Zeshy-specific aliases to such
    # string of global definitions, quote-protecting global alias names from
    # accidental expansion (as insinuated above).
    alias_names_quoted=( \"${^ZESHY_ALIAS_NAMES}\" )
    globals+="
typeset -gax ZESHY_ALIAS_NAMES
ZESHY_ALIAS_NAMES=( ${alias_names_quoted[@]} )"
#   print -r "globals: ${globals}"

    # Make the final Zeshy function. (Phew!)
    eval "function startup_zeshy_globals() {
    ${globals}
}"
}

# ....................{ MAIN                               }....................
# This component recompiles the Zeshy digest file by sourcing all components
# defining Zeshy-specific Zsh objects (i.e., aliases, functions, and globals)
# specific to the current user and system and then compiling exactly such
# objects into such digest. To decide exactly which objects to compile, this
# component subtracts the set of all Zsh objects defined *AFTER* sourcing such
# components from the set of all Zsh objects defined *BEFORE* sourcing such
# components: the difference between the two sets is exactly the set of all
# Zeshy-specific objects to be compiled.
#
# By design, this requires no such objects to be defined before sourcing such
# components. If some (or all) such objects were defined before sourcing such
# components, the difference between the above two sets and hence the recompiled
# Zeshy digest file would be essentially empty. To avoid such issues, undefine
# Zeshy-specific objects defined by parent shells before such recompilation.
[[ -n "${ZESHY_ALIAS_NAMES-}" ]] &&
    unalias -- "${ZESHY_ALIAS_NAMES[@]}"
[[ -n "${ZESHY_FUNCTION_NAMES-}" ]] &&
    unfunction -- "${ZESHY_FUNCTION_NAMES[@]}"

# Undefine globals *AFTER* undefining all objects listed by the prior lists,
# which themselves are globals and hence undefined with the other globals here.
#
# Globals *MUST* be undefined in a global context to have meaningful effect.
# While aliases and functions may be meaningfully undefined in a local context,
# there seems little point in doing so elsewhere. Centralize all logic here.
# See undefine_variable() and unfreeze_variable() for details on undefining
# globals (namely, why we call typeset() prior to unset()).
[[ -n "${ZESHY_GLOBAL_NAMES-}" ]] && {
#   print -l "===ZESHY_GLOBAL_NAMES===" "${ZESHY_GLOBAL_NAMES[@]}"
    typeset +r -- "${ZESHY_GLOBAL_NAMES[@]}"
    unset      -- "${ZESHY_GLOBAL_NAMES[@]}"
#   typeset -p -m "${ZESHY_GLOBAL_NAMES[@]}"
}

# Recompile the Zeshy digest file.
compile_zeshy

# --------------------( WASTELANDS                         )--------------------
    # * Source such file.
    # * Copy such file to Zeshy's user configuration directory, if not already
    #   containing such file.
    # If the current shell is interactive and loading the Zeshy user directory,

    #FIXME: Need to explicitly persist such maps to the current digest file.
    # Maps from Zeshy-specific aliases, functions, and globals to the absolute
    # paths of the Zeshy components defining such objects. While this Zeshy
    # component requires no such maps, others -- especially, the Zeshy help
    # component, do. Hence, this component sets such maps on behalf of other
    # components.
#   export -A\
#       ZESHY_ALIAS_NAME_TO_FILENAME\
#       ZESHY_SUFFIX_ALIAS_NAME_TO_FILENAME\
#       ZESHY_FUNCTION_NAME_TO_FILENAME\
#       ZESHY_GLOBAL_NAME_TO_FILENAME

#       compile_zeshy_digest_source "${script_filename}"
    #FIXME: Hmm; the last iteration of the above for loop sets such lists
    #already. 'tis a minor optimization at best, but... *shrug*

# void compile_zeshy_digest_source(string script_filename)
#
# Source the passed script as contributing to the current compilation of Zeshy's
# digest file. In particular, record all aliases, functions, and globals newly
# defined by such script.
#function compile_zeshy_digest_source() {
#   ZESHY_ALIAS_NAMES_NEW=( ${(f)"$(alias +)"} )
#   ZESHY_SUFFIX_ALIAS_NAMES_NEW=( ${(f)"$(alias +s)"} )
#   ZESHY_GLOBAL_NAMES_NEW=( ${(f)"$(typeset +gx)"} )

    # Source such script.
#   say "sourcing \"${script_filename}\"..."
#   source "${script_filename}"
#   say "sourced \"${autoload_function_filename}\"."

#   ZESHY_ALIAS_NAMES_NEW=( ${(f)"$(alias +)"} )
#   ZESHY_SUFFIX_ALIAS_NAMES_NEW=( ${(f)"$(alias +s)"} )
#   ZESHY_GLOBAL_NAMES_NEW=( ${(f)"$(typeset +gx)"} )

    # Obtain all aliases, functions, and globals newly defined by such script.
#   ZESHY_SCRIPT_ALIAS_NAMES=(
#       "${ZESHY_ALIAS_NAMES_NEW[@]:|ZESHY_ALIAS_NAMES_OLD}" )
#   ZESHY_SCRIPT_SUFFIX_ALIAS_NAMES=(
#       "${ZESHY_SUFFIX_ALIAS_NAMES_NEW[@]:|ZESHY_SUFFIX_ALIAS_NAMES_OLD}" )
#   ZESHY_SCRIPT_GLOBAL_NAMES=(
#       "${ZESHY_GLOBAL_NAMES_NEW[@]:|ZESHY_GLOBAL_NAMES_OLD}" )

    # Filter canonical Zsh globals from the list of Zeshy-specific globals.
#   ZESHY_SCRIPT_GLOBAL_NAMES=( "${ZESHY_GLOBAL_NAMES[@]:#${~ZSH_GLOBAL_NAMES_GLOB}}" )

#   ZESHY_FUNCTION_NAME_TO_FILENAME[
#}

        # Source such script.
#       say "sourcing \"${script_filename}\"..."
#       source "${script_filename}"
#       say "sourced \"${autoload_function_filename}\"."

#       ZESHY_FUNCTION_NAME_TO_FILENAME[
        # Load the functions this file defines for subsequent compilation.
    # For each function declared in each file in the passed directory and
    # subdirectories of that directory, make a symbolical link in the digest
    # directory with that function name to that file.
#FIXME: Add support for storing defined globals and aliases in a single
#startup_zeshy_globals() function. Naturally, do so prior to calling
#make_zeshy_startup_functions().

#   {
#       print -rl -- "================[old function names]================" "${ZESHY_FUNCTION_NAMES_OLD[@]}"
#       print -rl -- "================[new function names]================" "${ZESHY_FUNCTION_NAMES_NEW[@]}"
#       print -rl -- "================[dif function names]================" "${ZESHY_FUNCTION_NAMES_NEW[@]:|ZESHY_FUNCTION_NAMES_OLD}"
#   } | less
    # The alias() builtin lists only regular and global names with option "+"
    # and only suffix alias names with option "+s". Split the output of both on
    # newlines to get all regular, global, and suffix aliases.

    # Delete all Zeshy-specific globals defined by and imported from the parent
    # shell, locally preserving global ${ZESHY_HOME} for subsequent use. Failure to
    # delete such globals results in a subtle issue when compiling the Zeshy digest
    # file, which persists such globals to startup_zeshy_globals() by differencing
    # the lists of globals defined before and after such compilation. Failing to
    # delete such globals ensures the two lists to be effectively identical, thus
    # preventing persistence of Zeshy globals into the Zeshy digest file.
    #
    # See undefine_variable_matching() for details on variable deletion.
    #local zeshy_home="${ZESHY_HOME-}"

    #FIXME: Hmm; should use unexported globals by default, I think.
    #Unfortunately, getting a list of unexported globals appears to be somewhat
    #more difficult. The following should work, assuming globals without
    #whitespace (which I believe may be prohibited by POSIX, yes?):

    # Zeshy declares globals to be globally exported (e.g., "typeset -gx") rather
    # than merely as globals or exports (i.e., "typeset -g" or "typeset -x"). For
    # disambiguity, list only the former.
#   ZESHY_GLOBAL_NAMES_OLD=( ${(f)"$(typeset +x)"} )
# to the current user and then compiles only such 
# selects which such aliases, functions, and globals 
# recompiles all aliases, functions, and globals defined only *AFTER*
# sourcing befor
#
# determines which currently defined Zsh aliases, functions, and globals to The
# difference of 
# Zeshy decides
#
# If recompiling the Zeshy digest file and hence sourcing Zeshy scripts
# defining globals, undefine such globals prior to initializing Zeshy. Why?
# The reason may be subtle, but the logic flows like butter. Zeshy may and
# typically does declare globals to be read-only. Understandably, Zsh fails on
# attempting to redefine such globals. The subsequent call to startup_zeshy()
# and hence startup_zeshy_globals() does just that, requiring such globals be
# undefined prior to such calls. Oh, 'tis all a tad silly and worm-bitten, but
# so goes life in the tranche of code trenches.
    #FIXME: Unsure this much matters, now.
    # Recompilation optimizations require Zeshy to *NOT* have been autoloaded at
    # this point... Throw an exception if Zeshy has been. While this should
    # never be the case, one can't be too careful in a bitwise world.
#   typeset -f get_zeshy_version &>/dev/null and
#       die "get_zeshy_version() and hence Zeshy already autoloaded"

    # Undefine all globals defined by sourcing Zeshy. Why? The reason is subtle;
    # the logic flows like butter. Zeshy may (and usually does) declare some
    # such globals to be read-only. Understandably, Zsh prints errors on
    # attempting to redefine such globals. However, Zeshy's subsequent calling
    # of startup_zeshy() and hence startup_zeshy_globals() attempts to do just
    # that! Undefining such globals here permits there subsequent redefinition.
    # ('tis all a tad silly, but so goes life in the tranche of code trenches.)
#   undefine_global "${ZESHY_GLOBAL_NAMES[@]}"
#   typeset -p ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY
#   [[ -n "${ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY+x}" ]] and print 'hmmmmm'
    #FIXME: Fairly certain we don't want to export. No point, really. "main"
    #just blows away all imported Zeshy globals, anyway. Just revert to '+g' in
    #"alias", yes?

#   $(join_list_on_newline ZESHY_ALIAS_NAMES)
#   $(join_list_on_newline ZESHY_GLOBAL_NAMES)
    # Convert global lists of commands to be run on startup into newline-
    # delimited strings to be interpolated into the functions created below.
#   string startup_zeshy_aliases startup_zeshy_globals
#   startup_zeshy_aliases="$(join_list_on_newline ZESHY_ALIAS_NAMES)"
#   startup_zeshy_globals="$(join_list_on_newline ZESHY_GLOBAL_NAMES)"

    # Make such functions.
#   eval "function startup_zeshy_aliases() {
#   ${startup_zeshy_aliases}
#}"
#   eval "function startup_zeshy_globals() {
#   ${startup_zeshy_globals}
#}"

    # List of all currently declared aliases, functions, and exported variables
    # declared after sourcing and compiling the Zeshy codebase.
    # Synthesize additional functions after sourcing all Zeshy scripts
    # applicable to the current user (above) but before compiling the Zeshy
    # digest file (below). Such functions have dynamic definitions dependent on
    # global variables set while sourcing such scripts.
# (i.e., subsequent to
    # recursively sourcing Zeshy and hence declaring Zeshy functions)
#   is -d "${ZESHY_HOME}" si or
#       die "Zeshy home \"${ZESHY_HOME}\" not found"

#       "${^ZESHY_AUTOLOAD_DIRNAMES[@]}"/**/*~*.swp(.)
    #FIXME: Add new get_list_difference() and get_list_intersection() functions
    #to "type/function", leveraging die_unless_list() and return_list(). (Yep!)
    #Hmm; wait. We're probably better off with difference_lists_into() and
    #intersect_lists_into() functions accepting a third arg: the target list.

    # Append:
    #
    # * All subdirectories in this overlay's command directory matching commands
    #   in the user's current $PATH to the overlay stack.
    # * All files in this overlay's command directory matching such commands to
    #   the list of autoloadable files.
#   is -d "${overlay_command_dir}" si and {
        # List of all paths in this overlay's command directory corresponding to a
        # currently installed executable file in the $PATH. Dismantled, this is:
        #
        # * "${ZESHY_AUTOLOAD_COMMAND_DIR}/"*, listing each file in Zeshy's
        #   command directory.
        # * "(e{[[ ... ]]})", excluding files failing the following test:
        #   * "$REPLY", the current file.
        #   * ":t", the basename of such file.
        #   * ":c", the absolute path to a command in the $PATH with such name.
        #   * "== /*", true only when ":c" succeeds in finding such a command.
        # * "or true", ignoring failure (if ":c" fails finding such a command).
#       list overlay_command_paths; overlay_command_paths=(
#           "${overlay_command_dir}/"*(e{'[[ $REPLY:t:c == /* ]]'})
#       ) or true

#       # Append all files in this directory to the list of autoloadable files.
#       ZESHY_AUTOLOAD_FILENAMES+=( "${^overlay_command_paths[@]}"(.) )

#       # Append all directories in this directory to the overlay stack.
#       ZESHY_OVERLAY_STACK+=( "${^overlay_command_paths[@]}"(/) )
#   }

#FIXME: Sourcing configuration files *REALLY* needs to happen prior to
#compilation, for obvious reasons. O.K.; so, that's taken care of. But we need
#to also ensure that if we *DON'T* perform compilation we still source such files.
#Do:
#    source "${ZESHY_DOT_CONFIG_DIR}/"*

    # If "lsb_release" is installed, run it to obtain the distro name of the
    # current operating system. Most modern distros provide such executable
    # for exactly this purpose. While crude alternatives to "lsb_release" do
    # exist (e.g., globbing for filenames matching /etc/*release), it hardly
    # seems worth the buggy effort so early in the bootstrap process.
    # Dismantled, this is:
    #
    # * "${:-lsb_release}", expanding to the string "lsb_release".
    # * "${...:c}", expanding to the absolute path of "lsb_release" if installed
    #   in the current $PATH or only "lsb_release" otherwise.
    # * "-x", returning true if such path is executable and hence installed.
    #   Unless the current directory contains an executable "lsb_release", this
    #   returns true only if ":c" expanded to an absolute path.
#   if is -x "${${:-lsb_release}:c}" si; then
        # Lowercase the distro name for dirname comparison.
#       string distro_name autoload_distro_dir
#       distro_name="${(L)$(lsb_release -si)}"
#       autoload_distro_dir="${ZESHY_AUTOLOAD_DISTRO_DIR}/${distro_name}"
#       print "autoload_distro_dir: ${autoload_distro_dir}"

        # If Zeshy provides distro-specific components, append distro-
        # specific dirnames and filenames to the corresponding lists.
#       if is -d "${autoload_distro_dir}" si; then
#           ZESHY_AUTOLOAD_DIRNAMES+="${autoload_distro_dir}/always"
#           ZESHY_AUTOLOAD_FILENAMES+=(
#               "${autoload_distro_dir}/if_installed/"*(e{'[[ $REPLY:t:c == /* ]]'})
#           ) or true
#       fi
#   fi
    # List of directories recursively containing Zsh scripts containing
    # autoloadable functions to be compiled into Zeshy's digest file.
#   ZESHY_AUTOLOAD_DIRNAMES+="${ZESHY_AUTOLOAD_CORE_DIR}"

#   string overlay_dir="${1}"
#   is -d "${overlay_dir}" si or
#       die "\"${overlay_dir}\" not found or not a directory"
#   string source_filename="${1}" target_filename basename
#   is -f "${source_filename}" si or
#       die "\"${source_filename}\" not found or not a file"
#   basename="$(basename "${source_filename}")"
#   target_filename="${ZESHY_DOT_CONFIG_DIR}/${basename}"

    # If not found, make the user-specific Zeshy configuration (and hence dot)
    # directory and file.
#   is -d "${ZESHY_DOT_CONFIG_DIR}" si or mkdir -p "${ZESHY_DOT_CONFIG_DIR}"
#   is -f "${target_filename}" si or {
#       say "fabricating \"${target_filename}\"..."
#       cp "${source_filename}" "${ZESHY_DOT_CONFIG_DIR}/"
#   }

    #FIXME: We need to do this in "src/import", instead. Probably just:
    #source "${ZESHY_DOT_CONFIG_DIR}/"*
    # Import such file, hopefully defining all globals declared above.
#   source "${target_filename}"
    # List of directories recursively containing Zsh scripts containing
    # autoloadable functions to be compiled into Zeshy's digest file.
#   list ZESHY_OVERLAYS
#   ZESHY_OVERLAYS=( "${ZESHY_AUTOLOAD_CORE_DIR}" )

    # Recursively compile the Zeshy codebase specific to current system and user
    # state starting from (in order):
#compile_zeshy_theme() {
#}

    # List of Zeshy overlays (i.e., system- and user-specific directories
    # obeying the same structure as Zeshy's top-level "./src" directory). All
    # files and directories in a Zeshy overlay are ignored except those with the
    # following Zeshy-specific names:
    #
    # * "always", a directory recursively containing only:
    #   * Subdirectories with arbitrary names and nesting, purely for
    #     organizational purposes. (Optional.)
    #   * Zeshy scripts, to be unconditionally compiled into Zeshy's digest
    #     file. Scripts may reside directly in the top-level "always" directory
    #     or under optional subdirectories. In either case, Zeshy automatically
    #     finds and compiles all Zsh functions in all such files.
    #
    # recursively containing Zsh scripts containing
    # autoloadable functions to be compiled into Zeshy's digest file.

    #FIXME: O.K.; technically, this works -- but not here, as we have yet to
    #autoload Zeshy. This is a fairly complex operation. (Can we reduce it to
    #more efficient Zsh builtins and ideally simply glob matching?)
    # Determine whether or not this process is running is a cronjob. This is
    # adapted from this itworld.com article, "Am I being run by cron?":
    #        http://www.itworld.com/Comp/3380/nls_unixcron041209/index.html
    #
    # Do this prior to saying imports, as the say() function requires this.
#    string cron_pids="$(pgrep -x cron)"
#    integer grandparent_pid="$(ps -eo ppid,pid= | grep " ${PPID}$" | awk '{print $1}')"
#    ZESHY_IS_CRONJOB="$(one_if match_multiline "^${cron_pids}$" "${grandparent_pid}")"
#   echo "cron: ${ZESHY_IS_CRONJOB}; cron_pids: ${cron_pids}; gpid: ${grandparent_pid}"

# All monitoring and modification is silent, efficient, and entirely automatic.
# to accomodate
# such changes. Such are silent, efficient, and entirely automatic.
# efficiently monitors such state for changes,      # * "${distro_command:c}", expanding to the absolute path of
    #   "lsb_release" if installed or only "lsb_release" otherwise.
#   string distro_command='lsb_release'
#   if is -x "${distro_command:c}" si; then
#FIXME: This is concise enough now to be merged back into "module", which should
#incidentally be renamed "load" (...I suppose).

    #FIXME: Test for pathological cases: namely, if there *IS* a Zeshy function
    #currently declared that shouldn't be (e.g., get_zeshy_version()). In such
    #case, I'm unsure what the proper response is. We currently th
    #FIXME: See "gwydden/output" for "TODO" comments on substantially
    #improving the theme support.

# ....................{ AUTOLOADS                          }....................
#FIXME: Keep the old method about, for a bit.
    # List set of autoloadable function names defined in such listed files.
#   list_set autoload_function_names
#   say "recursively sourcing \"${ZESHY_HOME}\"..."

    # Load "mapfile", a core Zsh module mapping file contents to map values.
    # It's both brilliant and efficient, an unhappily rare combination. It's
    # also remarkably dangerous, since accidentally unsetting keys from this
    # map deletes the corresponding files. Hence, we immediately unload this
    # module after use.
#   zmodload zsh/mapfile

    #FIXME: Terrible! Utterly. When enabled, this sporadically fails with an
    #inscrutible error resembling:
    #    "(anon):82: bad math expression: operand expected at `/usr/share...'"
    #File a bug report if this is still the case under recent Zsh versions.
    # Forcibly prevent harmful ${mapfile} and hence filesystem changes.
#       typeset -r mapfile
#       print ${mapfile[/tmp/config]}
#       print -rl -- ${(f)mapfile[/usr/share/zeshy/src/autoload/if_installed/7z]}

    # For each function declared in each file in the passed directory and
    # subdirectories of that directory, make a symbolical link in the digest
    # directory with that function name to that file. Dismantled, this is:
    #
    # * "${^ZESHY_AUTOLOAD_DIRNAMES[@]}", expanding to each directory in the list.
    # * "/**/*",  recursively expanding to each file of this directory.
    # * "~*.swp", excluding temporary files.
    # * "(.L+0)", including only non-empty plain files. "mapfile" currently
    #   fails with error on attempting to expand an empty plain file,
    #   arguably a bug. Nonetheless, respect its wishes.
#   for autoload_function_filename (
#       "${^ZESHY_AUTOLOAD_DIRNAMES[@]}"/**/*~*.swp(.L+0)
#       "${ZESHY_AUTOLOAD_FILENAMES[@]}"
#   ) {
        # Load the functions this file defines for subsequent compilation.
#           say "sourcing \"${autoload_function_filename}\"..."
#       source "${autoload_function_filename}"

        # Append to the list of autoloadable functions all:
        #
        # * Explicitly defined functions of form "${function_name}() {".
        # * Implicitly defined interactive aliases of form
        #   "interactive_alias ${alias_name}=${alias_expansion}".
        #
        # Dismantled, this is:
        #
        # * "${(f)mapfile[...]}", expanding to each line of this file.
        # * "${(M)", ":#", and "}", excluding lines not matching the
        #   following extended glob expression:
        #   * "\(\) \{", followed by "() {", signifying a function.
        #   * "[[:alnum:]_-]##", greedily matching a substring of one or
        #     more alphanumeric, underscore, and hyphen characters.
        # * "${" and "%%\(*}", excluding the "() {" suffixing such lines.
        # * "=?*", greedily matching "=" followed by one or more characters.
        #
        # Note: *DO NOT QUOTE THIS EXPRESSION*. Doing so silently expands
        # this expression to the empty string, though we have no idea why!
        # Also, do not quote the expansion of ${autoload_function_file} in
        # this expression. Doing so causes "mapfile" to interpret such
        # quotes as prefixing and suffixing such filename, thus raising an
        # exception on not finding such "munged" filename.
#       autoload_function_names+=(
#           ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|interactive_alias [[:alnum:]_-]##=?)*}#interactive_alias }%%[(=]*}
#               ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|interactive_alias [[:alnum:]_-]##=?)*}#interactive_alias }%%[(=]*}
#       )
#           say "sourced \"${autoload_function_filename}\"."
#   }

    # Unload "mapfile", for safety.
#   zmodload -u zsh/mapfile

    #FIXME: Not quite right. If the user disables
    #${ZESHY_IS_WRAPPING_CORE_COMMANDS}, then some interactive aliases will not
    #actually be defined. zcompile() *FAILs* when fed non-extant function names.
    #To rectify this, we really want to make the prior loop sourcing each file
    #and matching "autoload_function_names" much, much smarter. First, stop
    #grepping file contents. If you consider it, all you really need to do is:
    #
    #* Before sourcing such file, stuff the set of all function names into a list.
    #* After! sourcing such file, diff! the set of all function names against
    #  such list. A new subtract_list_from_list() function would be of help,
    #  here. The resulting list is the set of all function names such file
    #  defined. This method may or may not be slower, depending on Zsh. What's
    #  clear, however, is that it's *MUCH* more resilient and *MUCH* less hacky.
    #
    #Ah-ha! Zsh 5.0 bundles a "${left_list:|right_list}" operator subtracting
    #the two lists. This implies a hard dependency.
#   is "$(whence -w -- "${1}")" == *': function' si
#   list ZESHY_FUNCTION_NAMES_OLD; ZESHY_FUNCTION_NAMES_OLD=( $(typeset -f +) )

    # Recompile all such loaded function definitions into the digest file.
#       print "autoload function names: ${autoload_function_names[@]}"
#       say "compiling \"${ZESHY_DOT_DIGEST_FILE}\"..."
#   zcompile -c "${ZESHY_DOT_DIGEST_FILE}" "${autoload_function_names[@]}"

# ....................{ WASTELANDS                         }....................
        #FIXME: This should be a "list_set" rather than "list", for a slight
        #efficiency (and clarity (and stability!)) improvement.
#
        # For clarity, temporarily set the script name to Zeshy.
#       string ZESHY_SCRIPT_NAME='zeshy'

#       zcompile "${ZESHY_DOT_DIGEST_FILE}" "${ZESHY_DOT_DIGEST_DIR}"/**/*(@)
#               ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|interactive_alias [[:alnum:]_-]##=?)*}#interactive_alias }%%( \(|\=)*}
            #FIXME: I believe these two mappings can be condensed into one.
#               ${(f)mapfile[/usr/share/zeshy/src/autoload/if_installed/7z]}
#               ${(f)mapfile[${autoload_function_filename}]}
#               ${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|interactive_alias [[:alnum:]_-]##=?)*}
#               ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|interactive_alias [[:alnum:]_-]##=?)*}#interactive_alias }%%( \(|=)*}
#               ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#interactive_alias [[:alnum:]_-]##=?*}#interactive_alias }%%\=*}
#               ${${(M)${(f)mapfile[${autoload_function_filename}]}:#[[:alnum:]_-]##\(\) \{}%%\(*}
#               ${${${(M)${(f)mapfile[/usr/share/zeshy/src/autoload/if_installed/7z]}:#interactive_alias [[:alnum:]_-]##=?*}#interactive_alias }%%\=*}
#           print "interactive_aliases:"
#           print -rl -- ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#interactive_alias [[:alnum:]_-]##=*}#interactive_alias }%%\=*}

# --------------------( TODO                               )--------------------
# * Ultimately, Zeshy should auto-compile the recursive entirety of all Zeshy
#   function definitions into a single so-called "digest" file at, say,
#   "~/.zeshy/digest.zwc". Such a file is autoloadable by:
#       
#       # ...implicitly autoloading such digest.
#       fpath=( "~/.zeshy/digest.zwc" "${fpath[@]}" )
#
#       # ...explicitly autoloading such digest.
#       autoload -Uw "~/.zeshy/digest.zwc"
#
#   I'm unsure if the former supercedes the latter. (Probably not, no.) Both
#   required, perhaps.
#
#   What's nice about this is that such a digest file appears to come prepended
#   with a list of all functions defined by such digest, thus rendering
#   autoloading of digest files terrifically fast. Auto-generating such a digest
#   on any change to any Zeshy file or directory is, unfortunately, not quite so
#   easy. We'll need to write something resembling:
#
#       if is "$(get_path_mtime "~/.zeshy/digest.zwc") equals SOMETHING si; then
#           zcompile "~/.zeshy/digest.zwc" "${ZESHY_HOME}/src/"**/*(.)
#       fi
#
#   However, it's unclear just how aggregating multiple files into one handles
#   initialization code. Clearly, it either doesn't or does but simply lumps all
#   initialization together. Either case is bad. We'll need to rewrite Zeshy to:
#
#   * Perform all non-costly initialization up-front in Zeshy .main or core.
#   * Perform all costly initialization in the functions requiring such
#     initialization as the first line of such functions. You know that grind...
# * Ugh. Current symlink technique doesn't quite work. It's quite close, though.
#   A working system either:
#   * Harvests the set of all function names using the current technique *AND*
#     manually recursively sources all Zeshy files (easy) *AND* uses the "-c"
#     flag to zcompile to compile all such function names into the digest
#     (easy). This isn't quite perfect, but it seems pretty darn close.
#   * Alternatively, create new temporary files in "~/.zeshy/digest/" defining
#     each such function separately by matching out the definition of such
#     functions from the existing files. This is somewhat more work, and
#     demonstrably of no greater benefit than the prior method. I reck'n it'd
#     work, but I'd rather try to pick the prior low-hanging fruit, first.


    #     zrecompile -p\
    #         -R ~/.zshrc --\
    #         -M ~/.zcompdump --\
    #         ~/zsh/comp.zwc ~/zsh/Completion/*/_*
    #
    #This does everything for us. Swag, no? Memory map everything, of course.
    #Oh, and the latter line is the one that applies to us. To quote: "re-create
    #the file ~/zsh/comp.zwc if any of the files matching the given pattern is
    #newer than it." We'll need to dynamically construct the arguments to be
    #passed for the command-specific directories. Shouldn't be hard:
    #
    #     list zrecompile_args
    #     zrecompile_args=( "${generic_dir}.zwc" "${generic_dir}"/**/*(.) )
    #     for command_dir in "src/auto/command"/*(/); do
    #         zrecompile_args+=( "${command_dir}.zwc" "${command_dir}"/**/*(.) )
    #     done
    #     print "za: ${zrecompile_args[@]}"

    # Automatically recompile all compiled files in function path "${FPATH}" whose
    # corresponding uncompiled files have since changed.
    #autoload -U zrecompile
#   zrecompile -p

        # Make the digest directory, if needed.
#       say "composing \"${ZESHY_DOT_DIGEST_DIR}\"..."
#       mkdir -p "${ZESHY_DOT_DIGEST_DIR}"

        # Remove all existing symbolic links in the digest directory, if needed.
#       list digest_symlinks; digest_symlinks=( "${ZESHY_DOT_DIGEST_DIR}/"*(@) )
#       is -n "${digest_symlinks}" si and rm "${digest_symlinks[@]}"


#           print "autoload_function_file=${autoload_function_file}"
#           for autoload_function_name\
#               ( ${${(M)${(f)mapfile[${autoload_function_file}]}:#[[:alnum:]_-]##\(\) \{}%%\(*} ) {
#               ln -s\
#                   "${autoload_function_file}"\
#                   "${ZESHY_DOT_DIGEST_DIR}/${autoload_function_name}"
#           }

#       is_shell_terminal and print 'Yum!'
#       zcompile -c "${ZESHY_DOT_DIGEST_FILE}" is_shell_terminal

#   zstat +mtime "${1}"
    # Dismantled, this is:
    #
    # * "${pathname}"/**/*, all files and subdirectories of this directory.
    # * "om", such files and subdirectories in ascending order by mtime.
    # * "[1]", the first and hence newest such file or subdirectory.
#   zstat +mtime "${pathname}"/**/*(om[1])

#   touch -m --date=@"${mtime}" "${pathname}"

# void _populate_zeshy_digest_dir_with(string dirname)
#
# Populate Zeshy's digest directory with one symbolic link for each autoloadable
# function in each file of the passed directory, recursively.
#_populate_zeshy_digest_dir_with() {
#    die_unless_one_arg 'expected exactly one dirname'
#
#    # For each function declared in each file in the passed directory and
#    # subdirectories of that directory, make a symbolical link in the digest
#    # directory with that function name to that file. Dismantled, this is:
#    #
#    # * "/**/*", recursively expanding to each file and subdirectory of the
#    #   passed directory.
#    # * "~*.(swp)", excluding temporary files.
#    # * "(.)", including only plain files.
#    for autoload_function_file\
#        ( "${ZESHY_AUTOLOAD_ALWAYS_DIR}"/**/*~*.(swp)(.) ) {
#        # Dismantled, this is:
#        #
#        # * "${(f)mapfile["${autoload_function_file}"]}", iteratively
#        #   expanding to each line of this file.
#        # * "${(M)", ":#", and "}", excluding lines not matching the
#        #   following extended glob expression:
#        #   * "[[:alnum:]_-]##", greedily matching a substring of one or
#        #     more alphanumeric, underscore, and hyphen characters.
#        #   * "\(\) \{", followed by "() {", signifying a function.
#        # * "${" and "%%\(*}", excluding the "() {" suffixing such lines.
#        for autoload_function_name\
#            ( "${${(M)${(f)mapfile["${autoload_function_file}"]}:#[[:alnum:]_-]##\(\) \{}%%\(*}" ) {
#            ln -s\
#                "${autoload_function_file}"\
#                "${ZESHY_DOT_DIGEST_DIR}/${autoload_function_name}"
#        }
#    }
#}

#       for autoload_command_filename\
#           ( "${ZESHY_COMMAND_DIR}/"*(e{'[[ $REPLY:t:c == /* ]]'}) ) {
#           ZESHY_AUTOLOAD_FILENAMES+=( "${autoload_command_filename}" )
#       }

        #FIXME: Replace with an "rm -rf" once confident this works.
#           mv "${ZESHY_DOT_DIGEST_DIR}" "${ZESHY_DOT_DIR}/tmp/$(date +'%N')"

#_zeshy_autoload_digest_old() {
    #FIXME: This only applies to developer systems. In production, Zeshy
    #requires only one initial compilation, thus eliminating the cost of such
    #recompilation. Ah; I wonder. Wouldn't a "zrecompile -p" immediately after
    #declaring the "fpath" do this, assuming we'd first compiled all necessary
    #digests? If so, that would suggest we'd only need a simple test for
    #
    #    if not is_file "${ZESHY_DOT_DIGEST_FILE}"; then
    #       # Compile everything anew here! Don't bother checking mtimes.
    #    fi
    #
    #Then, a zrecompile should handle the rest, yes? That would be considerably
    #more efficient, given Zsh's C-backed implementation. Ah; O.K., it gets even
    #better. We can entirely reduce this if-conditional to a zrecompile() call
    #resembling the given example:
    #
    #     zrecompile -p\
    #         -R ~/.zshrc --\
    #         -M ~/.zcompdump --\
    #         ~/zsh/comp.zwc ~/zsh/Completion/*/_*
    #
    #This does everything for us. Swag, no? Memory map everything, of course.
    #Oh, and the latter line is the one that applies to us. To quote: "re-create
    #the file ~/zsh/comp.zwc if any of the files matching the given pattern is
    #newer than it." We'll need to dynamically construct the arguments to be
    #passed for the command-specific directories. Shouldn't be hard:
    #
    #     list zrecompile_args
    #     zrecompile_args=( "${generic_dir}.zwc" "${generic_dir}"/**/*(.) )
    #     for command_dir in "src/auto/command"/*(/); do
    #         zrecompile_args+=( "${command_dir}.zwc" "${command_dir}"/**/*(.) )
    #     done
    #     print "za: ${zrecompile_args[@]}"
#    say "detecting \"${ZESHY_DOT_DIGEST_FILE}\"..."
#    integer zeshy_mtime=$(get_path_mtime_recursive "${ZESHY_SRC_HOME}")
#    if not is_file "${ZESHY_DOT_DIGEST_FILE}" or
#        (( zeshy_mtime != $(get_path_mtime "${ZESHY_DOT_DIGEST_FILE}") )); then
#        say "compiling \"${ZESHY_DOT_DIGEST_FILE}\"..."
#        # ...the "-." matches all files and symbolic links to files.
#        zcompile "${ZESHY_DOT_DIGEST_FILE}" "${ZESHY_SRC_HOME}"/**/*~*.(swp|zwc)(-.)

#        # Set the mtime of the compiled script to that of the uncompiled
#        # script to ensure the above conditional fails on future imports.
#        set_path_mtime "${ZESHY_DOT_DIGEST_FILE}" "${zeshy_mtime}"
#    fi

    # Declare all functions provided by the digest file to be autoloadable.
#    autoload -w "${ZESHY_DOT_DIGEST_FILE}"

    # Prefix "${FPATH}" with the absolute path to the digest file, ensuring Zsh
    # searches such file for the definition of such functions first. Oddly, Zsh
    # has no means of directly associating the two.
#    fpath=( "${ZESHY_DOT_DIGEST_FILE}" "${fpath[@]}" )
#}
