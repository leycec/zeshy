#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# (Re)compile the `zeshy` codebase into the current user's `zeshy` digest file.
#
# --------------------( SYMBOLS                            )--------------------
# In most programming languages, the symbols that language exports for external
# use (e.g., packages, classes, functions, globals) do not vary with system or
# user configuration. The same version of the same language unconditionally
# exports the same symbols, everywhere. This forms the core.
#
# As expected, `zeshy` behaves different. Most symbols `zeshy` exports for external
# use at the command line and within scripts conditionally vary with system and
# user state, including:
#
# * The output of the system-specific "lsb_release" and/or "uname" commands.
# * The contents of the user-specific `zeshy` configuration at "~/.zeshy/config".
# * The contents of the user-specific ${PATH} (i.e., the set of currently
#   installed and accessible programs).
#
# zeshy monitors such content for changes -- silently, efficiently, and entirely
# automatically. On detecting changes, `zeshy` changes itself. As example:
#
# * On switching from a Linux to BSD operating system, `zeshy` supplants the
#   Linux-specific symbols it exports with those specific to BSD.
# * On installing a new program "rtorrent" into the system-wide "/bin" directory
#   in the ${PATH}, `zeshy` exports "rtorrent"-specific symbols.
#
# `zeshy` symbols comprise `zeshy`-specific zsh functions and, to a lesser extent,
# zsh aliases and globals. For efficiency, `zeshy` exports the former as a single
# zsh digest file (i.e., a binary file in a zsh-specific format functionally
# analogous to that of C and C++-style shared libraries).
#
# `zeshy` compiles *ONLY* that subset of itself specific to current system and
# user state into its digest file. Uncompiled code remains inaccessible until
# such state changes (e.g., installing "rtorrent" notifies `zeshy` to compile
# start_rtorrent() and stop_rtorrent() functions into its digest file). For end
# user purposes, `zeshy` *IS* its digest file.
#
# --------------------( OVERLAYS                           )--------------------
# To accomodate system- and user-specific `zeshy` add-ons (e.g., plugins, themes),
# `zeshy` divides itself into overlays: directories with the same structure as
# `zeshy`'s top-level "src" directory. `zeshy` ignores all files and directories in
# an overlay except those with the following `zeshy`-specific names:
#
# * `always`, a subdirectory recursively containing only:
#   * `zeshy` scripts, to be unconditionally compiled into `zeshy`\'s digest file.
#     These scripts may reside directly in the mandatory "always" directory
#     or under optional subdirectories. In either case, `zeshy` automatically
#     finds and compiles all zsh functions in all such files.
#   * Subdirectories with arbitrary names and nesting. (`zeshy` automatically
#     finds all scripts in such subdirectories. Subdirectory structure is
#     insignificant and hence only for optional organization.)
# * `if_pathable`, a subdirectory directly containing only:
#   * `zeshy` scripts, each conditionally compiled into `zeshy`\'s digest file
#     _only_ if an executable file of the same case-sensitive basename currently
#     exists in the user-specific ${PATH}.
#   * Subdirectories, each conditionally enabled as a `zeshy` overlay and hence
#     subject to recursive processing (e.g., for an `always` subdirectory) only
#     if an executable file of the same case-sensitive basename currently exists
#     in the user-specific ${PATH}.
# * `if_distro`, a subdirectory directly containing only:
#   * Subdirectories, each conditionally enabled as a `zeshy` overlay _only_ if
#     the current system-specific Linux and/or BSD distribution has the same
#     lowercase name. At most one such subdirectory matches; `zeshy` ignores the
#     remaining subdirectories.
# * `if_config`, a subdirectory directly containing only:
#   * `zeshy` configuration files, to be unconditionally copied into the user-
#     specific `~/.zeshy/config` directory if not already found.

#FIXME: compile_zeshy_overlay_configuration() would be a nice place to add
#update handling for patching locally modified config files against zeshy-
#bundled config files on update.
#FIXME: Hmmmm; no, actually. We want to implement the upgrade process as
#a startup_zeshy_upgrade()-style function in the main zeshy codebase. Why?
#Firstly, such upgrade will inevitably become a bit heavyweight, with
#functionality conditionally depending on which "diff"-style merge commands
#are installed and available to the current user (e.g., "gdiff", "vimdiff").
#Secondly, it's simply cleaner to defer upgrading until *AFTER* zeshy
#has fully bootstrapped itself. Since we already expand config globals
#defensively (e.g., ${ZESHY_THEME:-vanilla}), this should pose no issues
#even if we were to subsequently, say, rename ${ZESHY_THEME} to
#${ZESHY_USER_THEME}.
#FIXME: I should note that upgrading user-specific configuration files
#requires some care. On each zeshy precompilation, we should cache MD5 sums for
#all *SOURCE* configuration files copied from a zeshy overlay to
#"${ZESHY_USER_CONFIG_DIR}" as values of a new map global -- say,
#${ZESHY_CONFIG_FILE_TO_MD5_SUM}: e.g.,
#
#  ZESHY_CONFIG_FILE_TO_MD5_SUM[posix]='595f44fec1e92a71d3e9e77456ba80d2'
#
#Clearly, the filenames should be relative to "if_config/" subdirectories.
#
#Naturally, computing file hashes suggests a new function get_file_md5_sum().
#Such function's implementation is fairly straightforward: if "md5sum" is
#pathable (i.e., the typical Unix command), run such command; else if "md5"
#is pathable (i.e., the BSD equivalent), run such command; else die. Since
#basically *ALL* OSes are guaranteed to supply one of the two commands, I
#don't see the harm in just shoving it in a new parcel "always/path/file/hash".
#For those very reasons, we probably won't have to bother supporting other
#hashing schemes as a backup (e.g., CRC, "sha256sum"): MD5 utilities are
#ubiquitous.
#
#In any case, why save MD5 sums of source config files? Simple. On upgrade,
#we compare the stored MD5 sums against:
#
#* The corresponding new upgraded config file in "/usr/share/zeshy". Files
#  *NOT* matching such sums were changed in the upgrade.
#* The corresponding config file in "~/.zeshy/config". Files *NOT* matching
#  such sums were changed by the user.
#
#For config files changed in the upgrade but *NOT* by the user, silently
#overwrite the corresponding config file in "~/.zeshy/config" with such upgraded
#config file. However, for config files changed in the upgrade *AND* by the
#user, request the user manually merge such changes -- ideally, by invoking a
#merge utility (e.g., "vimdiff").
#
#For config files *NOT* changed in the upgrade but by the user, silently ignore
#such files. That concludes all possible permutations.
#
#Sweet, no?
#FIXME: Incidentally, the above map should also be used to detect the deletion
#of config files from a zeshy "if_config/" directory. For such files, the user
#should be warned that the corresponding file in "~/.zeshy/config" is obsolete
#and should be moved aside or deleted altogether.

#FIXME: It's not *IMMEDIATELY* pressing, but there probably exist race
#conditions in the event two zeshy shells startup at a similar time and the
#digest file requires recompilation. We should probably perform advisory file
#locking (see "path/database/kvs/dir", I believe, for relevant documentation) on
#the *DIGEST FILE* itself. Basically, if such file is locked, then some other
#zeshy shell is (hopefully) compiling zeshy. Such file should be locked... when?
#Well, for true atomicity, we'd probably need each zeshy shell to lock the
#digest immediately before calling is_zeshy_digest_outdated() and unlock the
#digest immediately after either compiling such digest (or if not compiling such
#digest immediately after calling is_zeshy_digest_outdated()). This effectively
#serves as a critical section -- and, yes, if you think about it, we do need to
#lock before calling is_zeshy_digest_outdated(). Why? Because if the digest is
#in fact locked, we must check for such lock and hence determine whether or not
#the digest is currently locked and hence being compiled *BEFORE* testing such
#digest's mtime. (Fairly obvious, I suppose.)
#FIXME: Naturally, only lock the digest file if it actually exists. If it
#doesn't exist, then it's effectively "unlocked."
#FIXME: This means we'll need to shift file locking functionality to parcel
#"digest". *shrug*

#FIXME: "if_distro" is fairly shoddy. Operation systems authored by the terrible
#twosome (i.e., Microsoft and Apple) provide no choice and hence no
#distributions; as such, "if_distro" should be renamed "if_os" and restructured
#as follows:
#
#if_os/
#  linux/
#  linux.arch/
#  linux.fedora/
#  linux.gentoo/
#  linux.ubuntu/
#  osx/
#  windows/
#
#So, the idea is to construct a dot-delimited topology of operating systems.
#(Avoid using underscores instead of dots here, as underscores typically
#supplant spaces rather than serving as internal structure.) Should be quite
#efficient to construct a function producing the string conforming to such
#topology specific to the current system. The function consuming such string
#should then split such string on "." and, for each matching prefix (e.g.,
#"linux" and "linux.arch" under Arch Linux), append such directory to the
#overlay stack.

#FIXME: Preserve "src/if_pathable" and make a new "src/if_pathables" directory
#containing pseudo-code resembling:
#
#* src/if_pathables/"sox or lame or mpg123"
#* src/if_pathables/"vlc and (sox or lame or mpg123)"
#
#For implementation purposes, there exist three possible cases for each subpath
#of such directory:
#
#* Such subpath matches glob "*(' or '*' and '|' and '*' or ')*", implying that
#  such subpath contains a mix of disjunction and conjunction operators. In such
#  case, it isn't really feasible for Zeshy to manually parse such subpath and
#  perform the resulting implied test. (There are too many possible combinations
#  for a simple regex to suffice, implying the need for a non-regular CFL parser,
#  clearly outside the scope of even Zeshy digest compilation.) Instead, perform
#  the following:
#  * If such subpath matches glob "*[^[:alnum:]-_ ()]*", such subpath contains a
#    shell-reserved character and hence must be rejected. *THROW AN EXCEPTION*.
#    This is critical. Since we "eval" such subpath below, unsafely evaluating
#    any arbitrary filename could have dramatic consequences. (Imagine a third-
#    party Zeshy plugin installing "src/if_pathables/$(command rm -R ~/)").
#    * This *MAY* not actually be necessary. Examining the heuristics below, it
#      looks like we never evaluate such strings in a command context: we simply
#      expand ${MATCH} to the corresponding string without evaluating,
#      executing, or otherwise running such string. Right. No safety concerns
#      here, I believe. Don't bother testing or throwing exceptions. Sweet, no?
#  * Perform the following glob replacements on such subpath in order:
#    * "//[[:space:]]##or[[:space:]]##/ || ", replacing " or " with " || ".
#    * "//[[:space:]]##and[[:space:]]##/ && ", replacing " and " with " && ".
#    * "//(#m)[[:alnum:]-_]##/[[ ${MATCH:c} == '/'* ]]", replacing command names
#      with an efficient shell test for whether such command exists.
#  * The resulting expression should be a valid zsh test for whether such
#    commands exist. Evaluate such expression, squelching standard output and
#    error. If the result is true, source such file; otherwise, do not.
#* Else, such subpath contains only all " or " or all " and " operators. In
#  either case, perform a single, compact, safe, and efficient test, ideally in
#  a single zsh statement using lists, implementing the corresponding boolean
#  expression. Zing!
#FIXME: Actually, just *ALWAYS* do the first, more generalized approach above.
#Merely testing for whether to perform the optimized test reduces such
#optimization's efficiency. Given the short length of such strings, I can't see
#the harm is always electing to go the foolproof route, which still appears to
#be reasonably efficient. Yes!
#FIXME: Compilation is currently a bit... fragile. If *ANYTHING* goes wrong
#during Zeshy codebase sourcing (particularly precompilation, which now performs
#quite a bit of functionality), the digest file is never created or created
#corrupted, which is arguably worse. We should
#probably be catching exceptions and somehow also printing stack traces (...ugh;
#I'm unsure that's possible, actually) when sourcing source and configuration
#files and when calling precompile_zeshy(). Convert exception messages into
#warning messages and try to silently continue. Ah; right. Stack traces *SHOULD*
#be printed by die(), so we're good to go, yes? That's not necessarily how it
#works under conventional high-level languages, but... fuck it. That's how it
#works here.
#FIXME: It'd be awesomely inspiring to print an in-place rotating ANSI-fueled
#progress sequence (i.e., "\-/|\-/|") during script sourcing. Namely, after
#sourcing each script, rotate such sequence a single character. Naturally,
#confine such logic to VT100-capable terminals. It's essential to do so
#without importing any heavyweight zsh modules or scripts; should be quite
#doable, no? I wouldn't be terribly surprised if the exact sequences to be
#printed are already readily Googleable.

# ....................{ MODULES                            }....................
# Load all zsh modules required by this parcel or parcels this parcel sources.
# Since this only applies to digest file compilation, we still retain autoload
# declarations for all such modules in "zsh/module".

# Bind "libpcre" functions to zsh builtins, thus exposing Perl-compatible
# Regular Expression (PCRE) functionality during digest file compilation. In
# particular, alias and function declaration requires such functionality for
# matching the admittedly obtuse prototype syntax prefixing help strings.
zmodload zsh/pcre

# ....................{ GLOBALS                            }....................
#FIXME: Document, when time and love permit.

# Lists of all zeshy-specific aliases, functions, and globals. Defining such
# lists globally:
#
# * Implicitly exports such lists to child shells, which on receiving such
#   globals may use their contents to undefine aliases, functions, and other
#   globals imported from the parent shell.
# * Permits us to undefine such globals in a global context below. See the
#   tail of this file.
#
# zsh treats suffix aliases differently from normal and global aliases, so
# differentiate the former from the latter.
typeset -Uag ZESHY_ALIAS_NAMES

typeset -Uag ZESHY_ALIAS_SUFFIX_NAMES

typeset -Uag ZESHY_FUNCTION_NAMES

typeset -Uag ZESHY_GLOBAL_NAMES

ZESHY_CORE_HELP_GLOBALS+='
list_set ZESHY_HOOKS_RUN_ON_ZESHY_PRECOMPILE

List of commands to be run before compiling `zeshy`\''s user digest file.
'
typeset -Uag ZESHY_HOOKS_RUN_ON_ZESHY_PRECOMPILE

# ....................{ GLOBALS ~ glob                     }....................
ZESHY_CORE_HELP_GLOBALS+='
string ZESHY_SCRIPT_NAME_GLOB

Glob expression matching only *`zeshy` scripts* (i.e., plain files or symbolic
links to such files, excluding ignorable temporary files).
'
typeset -g ZESHY_SCRIPT_NAME_GLOB='*~*.swp(-.)'

ZESHY_CORE_HELP_GLOBALS+='
string ZESHY_GLOBAL_NAMES_ZSH_GLOB

Glob expression matching the names of all canonical `zsh` global variables.
'
typeset -g ZESHY_GLOBAL_NAMES_ZSH_GLOB='(REPLY|MATCH|MBEGIN|MEND|match|mbegin|mend|(chpwd|preexec)_functions)'

# ....................{ GLOBALS ~ path                     }....................
ZESHY_CORE_HELP_GLOBALS+='
string ZESHY_USER_ENTITY_NAMES_FILE

Absolute path of the user-specific `zsh` script declaring and defining list
globals containing the names of all `zeshy` aliases, functions, and globals.
'
typeset -g ZESHY_USER_ENTITY_NAMES_FILE="${ZESHY_USER_CACHE_DIR}/names"

# ....................{ GLOBALS ~ local                    }....................
# For safety, compile_zeshy_source() localizes rather than globalizes the
# following variables. Since such variables nonetheless behave as and are
# expanded throughout the zeshy codebase as globals, document such variables
# here.

#FIXME: Actually, whatever source_script*() functions we define should also use
#this global. Discovering the current shell script name is intolerably obtuse
#under both bash and zsh. This global cleanly solves that. Use it *EVERYWHERE*!
ZESHY_CORE_HELP_GLOBALS+='
string ZESHY_SCRIPT_NAME

Absolute path of the `zeshy` script currently sourced by compile_zeshy_source().
For safety, such function unsets this global immediately after sourcing all
`zeshy` scripts to be compiled into the user digest file.
'

# ....................{ RUNNERS                            }....................
ZESHY_CORE_HELP_FUNCTIONS+='
void run_hook_on_zeshy_precompile(string command)

Run the passed command immediately before compiling `zeshy`\''s user digest
file.
'
function run_hook_on_zeshy_precompile() {
    (( # == 1 )) || die 'expected one command'
    ZESHY_HOOKS_RUN_ON_ZESHY_PRECOMPILE+="${1}"
#   print "registering precompilation hook \"${1}\""
}

# ....................{ SOURCERS                           }....................
ZESHY_CORE_HELP_FUNCTIONS+='
void source_zeshy_configuration(void)

Source all configuration files in `zeshy`\''s user configuration directory,
creating such directory if needed.
'
function source_zeshy_configuration() {
    # Validate sanity. Unless loading Zeshy's user directory and Zeshy's user
    # configuration directory exists, return silently.
    (( # )) && die 'expected no arguments'
    [[ -n "${ZESHY_DOT_DIR}" && -d "${ZESHY_USER_CONFIG_DIR}" ]] || return 0

    # Source such files, localizing each to ${ZESHY_SCRIPT_NAME} to guarantee
    # behavior elsewhere expecting such string variable to contain the currently
    # sourced script name (e.g., declare_parcel_as_script()).
    local ZESHY_SCRIPT_NAME
    for   ZESHY_SCRIPT_NAME (
        "${ZESHY_USER_CONFIG_DIR}/"**/${~ZESHY_SCRIPT_NAME_GLOB}) {
        is_zeshy_verbose_and print "zeshy: conflating \"${ZESHY_SCRIPT_NAME}\"..."
        source -- "${ZESHY_SCRIPT_NAME}"
    }
}

# ....................{ COMPILERS                          }....................
ZESHY_CORE_HELP_FUNCTIONS+='
void compile_zeshy(void)

Compile `zeshy`\''s digest file from system-wide and user-specific `zeshy`
overlays.
'
function compile_zeshy() {
    # Validate sanity.
    (( # )) && die 'expected no arguments'

    # String lists of all zeshy-specific aliases, functions, and globals.
#   export ZESHY_GLOBAL_NAMES
#   print '===ZESHY_FUNCTION_NAMES==='
#   typeset -p ZESHY_FUNCTION_NAMES

    # List of directories recursively containing zsh scripts containing
    # autoloadable functions to be compiled into zeshy's digest file.
    local -Ua ZESHY_AUTOLOAD_DIRNAMES

    # List of zsh scripts containing autoloadable functions to be so compiled.
    local -Ua ZESHY_AUTOLOAD_FILENAMES

    # FIFO stack of absolute paths of zeshy overlays applicable to the current
    # user and system, as incrementally discovered by a depth-first first search
    # through the subdirectories of the initial zeshy overlays. For safety,
    # declare such stack to be a list set.
    local -Ua ZESHY_OVERLAY_DIRNAME_STACK

    # List of all currently declared aliases, functions, and globals declared
    # *BEFORE* sourcing and compiling zeshy. See compile_zeshy_setup().
    local -a\
        ZESHY_ALIAS_NAMES_OLD\
        ZESHY_ALIAS_SUFFIX_NAMES_OLD\
        ZESHY_FUNCTION_NAMES_OLD\
        ZESHY_GLOBAL_NAMES_OLD

    # List of all currently declared aliases, functions, and globals declared
    # *AFTER* sourcing and compiling zeshy. See compile_zeshy_teardown().
    local -a\
        ZESHY_ALIAS_NAMES_NEW\
        ZESHY_ALIAS_SUFFIX_NAMES_NEW\
        ZESHY_FUNCTION_NAMES_NEW\
        ZESHY_GLOBAL_NAMES_NEW

    # Lowercase name of the current *nix distribution.
    local ZESHY_DISTRO_NAME

    # Initialize such variables.
    compile_zeshy_setup

    # Source all zeshy scripts applicable to the current system and user.
    #
    # *AVOID* expanding zeshy aliases sourced by such function in any subsequent
    # function of this component; oddly, such expansions fail with an alias "not
    # defined" error.
    compile_zeshy_source

    # Finalize such variables.
    compile_zeshy_teardown

    # Compile all functions sourced above into zeshy's user digest file.
    compile_zeshy_digest
}

ZESHY_CORE_HELP_FUNCTIONS+='
void compile_zeshy_setup(void)

Perform initialization before sourcing the `zeshy` codebase.
'
function compile_zeshy_setup() {
    # Validate sanity.
    (( # )) && die 'expected no arguments'

    # Since recursion is prohibitively expensive, perform a non-recursive depth-
    # first search of overlays starting from the following tree roots (in order):
    #
    # * The system-wide zeshy root.
    # * The user-specific zeshy root, if found.
    ZESHY_OVERLAY_DIRNAME_STACK=( "${ZESHY_OVERLAY_DIR}" )
    [[ -d "${ZESHY_USER_OVERLAY_DIR}" ]] &&
        ZESHY_OVERLAY_DIRNAME_STACK+="${ZESHY_USER_OVERLAY_DIR}"

    # Record the names of all currently defined aliases, functions, and globals
    # *NOT* to be compiled into zeshy's user digest file.

    # See get_alias_names() for further details.
    ZESHY_ALIAS_NAMES_OLD=(        ${(f)"$(alias +)"} )
    ZESHY_ALIAS_SUFFIX_NAMES_OLD=( ${(f)"$(alias +s)"} )

    # See get_function_names() for further details.
    ZESHY_FUNCTION_NAMES_OLD=( ${(f)"$(typeset +f)"} )

    # See get_variable_names_global() for further details. Do *NOT* quote the
    # outermost expansion. (Trust us.)
    ZESHY_GLOBAL_NAMES_OLD=( ${${${(f)"$(typeset +g +)"}:#* local *}##* } )
#   print -l "===ZESHY_GLOBAL_NAMES_OLD===" "${ZESHY_GLOBAL_NAMES_OLD[@]}"
#   { print 'old globals:'; typeset -g + } | less

    #FIXME: BSD installs no such command, so this clearly fails to suffice.
    #We'll probably want to just import the entire get_distro_name() command.
    #Or perhaps not. Is the logic simple, under BSD?

    # If the current *nix distribution provides the "lsb_release" command, run
    # such command to obtain the name of such distribution. While alternatives
    # to "lsb_release" do exist (e.g., globbing for filenames matching
    # /etc/*release), it hardly seems worth the effort so early in the bootstrap
    # process. Dismantled, this is:
    #
    # * "${:-lsb_release}", expanding to the string "lsb_release".
    # * "${...:c}", expanding to the absolute path of "lsb_release" if installed
    #   in the current $PATH or only "lsb_release" otherwise.
    # * "-x", returning true if such path is executable and hence installed.
    #   Unless the current directory contains an executable "lsb_release", this
    #   returns true only if ":c" expanded to an absolute path.
    [[ -x "${${:-lsb_release}:c}" ]] &&
        ZESHY_DISTRO_NAME="${(L)$(lsb_release -si)}"
}

ZESHY_CORE_HELP_FUNCTIONS+='
void compile_zeshy_teardown(void)

Perform finalization after sourcing the `zeshy` codebase.
'
function compile_zeshy_teardown() {
    # Validate sanity.
    (( # )) && die 'expected no arguments'

    #FIXME: Actually, why *DO* we defer recording function names to later?
    # Record the names of all currently defined aliases, functions, and globals.
    ZESHY_ALIAS_NAMES_NEW=( ${(f)"$(alias +)"} )
    ZESHY_ALIAS_SUFFIX_NAMES_NEW=( ${(f)"$(alias +s)"} )
    ZESHY_GLOBAL_NAMES_NEW=( ${${${(f)"$(typeset +g +)"}:#* local *}##* } )

    # Remove canonical zsh globals from the list of zeshy-specific globals. See
    # set_list_to_list_nonmatches() for further details.
    ZESHY_GLOBAL_NAMES_NEW=(
        "${ZESHY_GLOBAL_NAMES_NEW[@]:#${~ZESHY_GLOBAL_NAMES_ZSH_GLOB}}"
    )

    # The lists of zeshy-specific aliases and globals are the asymmetric
    # differences of the old from new lists of aliases and globals, which
    # precompile_zeshy() requires for synthesizing new functions. Delay
    # determining the list of zeshy-specific functions until doing so.
    ZESHY_ALIAS_NAMES=(
        "${ZESHY_ALIAS_NAMES_NEW[@]:|ZESHY_ALIAS_NAMES_OLD}" )
    ZESHY_ALIAS_SUFFIX_NAMES=(
        "${ZESHY_ALIAS_SUFFIX_NAMES_NEW[@]:|ZESHY_ALIAS_SUFFIX_NAMES_OLD}" )
    ZESHY_GLOBAL_NAMES=(
        "${ZESHY_GLOBAL_NAMES_NEW[@]:|ZESHY_GLOBAL_NAMES_OLD}" )
#   print -lr "===ZESHY_GLOBAL_NAMES_OLD===" "${ZESHY_GLOBAL_NAMES_OLD[@]}"
#   print -lr "===ZESHY_GLOBAL_NAMES_NEW===" "${ZESHY_GLOBAL_NAMES_NEW[@]}"
#   print -lr "===ZESHY_GLOBAL_NAMES==="     "${ZESHY_GLOBAL_NAMES[@]}"
}

ZESHY_CORE_HELP_FUNCTIONS+='
void compile_zeshy_source(void)

Source all scripts listed by ${ZESHY_AUTOLOAD_FILENAMES} and under directories
recursively listed by ${ZESHY_AUTOLOAD_DIRNAMES}. The set difference between the
lists of functions defined before and after such sourcing is the subset of Zeshy-
specific functions to be subsequently compiled into Zeshy''s digest file.
'
function compile_zeshy_source() {
    # Validate sanity.
    (( # )) && die 'expected no arguments'

    # Inform the current user of such recompilation.
    if [[ -o interactive ]] {
        if [[ -n "${ZESHY_DOT_DIR}" ]] {
            print "zeshy: recompiling \"${ZESHY_USER_DIGEST_FILE}\"..."
        } else {
            print "zeshy: sourcing \"${ZESHY_OVERLAY_DIR}\"..."
        }
    }

    # For each overlay root, perform a stack-based depth-first search of the
    # subdirectories under such root for all zeshy scripts applicable to the
    # current user and system. Such roots commonly include:
    #
    # * The main system-wide zeshy overlay (e.g., "/usr/share/zeshy").
    # * The main user-specific zeshy overlay (e.g., "~/.zeshy/src").
    #
    # Such roots commonly contain additional overlays as subdirectories (e.g.,
    # "/usr/share/zeshy/if_pathable/X"). On finding such overlays, such searches
    # push such overlays onto the same stack of iterated overlays. To facilitate
    # this safely, iterate dynamically (e.g., with "for ((...))") rather than
    # statically (e.g., with "for overlay_dir (...)").
    integer i
    for (( i = 1; i <= ${#ZESHY_OVERLAY_DIRNAME_STACK}; i++ )) {
        compile_zeshy_overlay "${ZESHY_OVERLAY_DIRNAME_STACK[i]}"
    }

    # Recursively source all scripts residing under all overlays applicable to
    # the current user, thus defining all applicable zeshy-specific aliases,
    # functions, and globals. Dismantled, this is:
    #
    # * "${^ZESHY_AUTOLOAD_DIRNAMES[@]}", expanding to each directory in the
    #   list.
    # * "/**/*",  recursively expanding to each file in such directory.
    # * "~*.swp", excluding temporary files.
    # * "(.)", excluding non-plain files.
    #
    # See above for such local variable's documentation as a masqueraded global.
    local ZESHY_SCRIPT_NAME
    for   ZESHY_SCRIPT_NAME (
#       "${ZESHY_OVERLAY_DIR}"/always/00-startup/**/${~ZESHY_SCRIPT_NAME_GLOB}
        "${^ZESHY_AUTOLOAD_DIRNAMES[@]}"/**/${~ZESHY_SCRIPT_NAME_GLOB}
        "${ZESHY_AUTOLOAD_FILENAMES[@]}"
    ) {
        # Source such script.
#       print "sourcing \"${script_filename}\"..."
        source -- "${ZESHY_SCRIPT_NAME}"
#       print "sourced \"${autoload_function_filename}\"."
    }

    # Source zeshy's user configuration files:
    #
    # * *AFTER* sourcing the main zeshy codebase, ensuring such files may expand
    #   standard aliases (e.g., string_export_global<>).
    # * *BEFORE* calling compile_zeshy_teardown() obtaining the list of newly
    #   declared globals, ensuring serialization of globals such files defined
    #   into zeshy's user digest file.
    #
    # The latter point is particularly important. Serializing configuration-
    # specific globals into the user digest suggests that the configuration need
    # *NOT* be sourced on every zeshy startup but only during recompilation, an
    # efficiency improvement.
#   which string_global_export
    source_zeshy_configuration
}

ZESHY_CORE_HELP_FUNCTIONS+='
void compile_zeshy_digest(void)

Compile `zeshy`\''s digest file, performing last-minute functionality immediately
before doing so. (Namely, dynamically synthesize all remaining functions to be
compiled into such digest.)
'
function compile_zeshy_digest() {
    # Validate sanity.
    (( # )) && die 'expected no arguments'

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #ORDER IS SUBTLY IMPORTANT HERE (i.e., cranky graemlins slumber within).
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Finalize all aliases, functions, and globals to be compiled into zeshy's
    # user digest file *BEFORE* compiling such file and prepending commands to
    # startup_zeshy(). The latter ensures startup_zeshy_aliases() and
    # startup_zeshy_globals() to *ALWAYS* be the first functions called by
    # startup_zeshy(), ensuring aliases and globals to always be defined at the
    # "start" of zeshy startup, ensuring subsequent functions may always safely
    # expand any zeshy alias or global.
    precompile_zeshy

    # Cache digest dependencies *AFTER* calling all customary precompilation
    # functions above. Such functions typically add such dependencies.
    precompile_zeshy_digest_dependency_paths

    # Call functions precompile_zeshy_functions_startup_aliases_and_globals()
    # creates at the start of zeshy startup, initializing globals *BEFORE*
    # aliases. Order is insignificant, here. Initializing aliases defines global
    # aliases (e.g., "or", "is"). If globals were accidentally initialized after
    # aliases, then any list elements or map keys or values equal to such global
    # alias names would be silently expanded to such aliases' expansion.
    # Needless to say, that would be horribly bad.
    run_hook_on_zeshy_startup_first startup_zeshy_globals
    run_hook_on_zeshy_startup_first startup_zeshy_aliases

    # Define top-level zeshy startup functions (e.g., startup_zeshy()).
    precompile_zeshy_functions_startup

    # Define mid-level zeshy startup functions startup_zeshy_aliases() and
    # startup_zeshy_globals() *AFTER* defining all other zeshy functions. The
    # latter function defines a global listing all zeshy functions and hence
    # must be the last function to define such functions. Subtle dragons lie.
    precompile_zeshy_functions_startup_aliases_and_globals
#   print -r -- "ZESHY_HOOKS_RUN_ON_STARTUP: ${ZESHY_HOOKS_RUN_ON_STARTUP[@]}"

    # If loading zeshy's user directory, compile all zeshy functions excluding
    # those defined by top-level components (e.g., "main", "digest") into
    # zeshy's user digest file.
    [[ -n "${ZESHY_DOT_DIR}" ]] && {
        is_zeshy_verbose_and print "zeshy: compiling \"${ZESHY_USER_DIGEST_FILE}\"..."
        zcompile -c -- "${ZESHY_USER_DIGEST_FILE}" "${ZESHY_FUNCTION_NAMES[@]}"
    }
}

# ....................{ COMPILERS ~ overlays               }....................
ZESHY_CORE_HELP_FUNCTIONS+='
void compile_zeshy_overlay(string overlay_dirname)

Prepare the passed `zeshy` overlay directory for digest compilation, as detailed
above in "OVERLAYS". For each:

* `zsh` script in such overlay containing autoloadable functions to be compiled
  into `zeshy`\''s digest file, append such script to the list of such files.
* Subdirectory in such overlay:
  * That is itself an overlay, append such subdirectory to the overlay stack.
  * Recursively containing `zsh` scripts containing autoloadable functions to be
    compiled into `zeshy`\''s digest file, append such subdirectory to the list of
    such subdirectories. (Subdirectories may either be overlays or directly
    contain `zsh` scripts, but not both.)
'
function compile_zeshy_overlay() {
    # Validate passed arguments.
    (( # == 1 )) || die 'expected one overlay dirname'
    local overlay_dirname="${1}"
    [[ -d "${overlay_dirname}" ]] || die "\"${overlay_dirname}\" not a directory"

    # If the current user is a Zeshy developer and the current shell is
    # interactive, print such path to standard output.
    is_zeshy_verbose_and print "zeshy: overlaying \"${overlay_dirname}\"..."
#   print "overlaying \"${overlay_dirname}\"..."

    # Absolute paths of overlay subdirectories.
    local overlay_main_dirname="${overlay_dirname}/always"

    # ~~~~~~~~~~~~~~~~< IMPORTANT ~ order is significant   >~~~~~~~~~~~~~~~~~~~~
    # Order of operation is significant below. Later paths assume precedence
    # over prior paths in corresponding lists.

    # Source all configuration files in such overlay's configuration directory.
    # Do so prior to all other overlay logic depending on globals defined by
    # such files.
    compile_zeshy_overlay_configuration "${overlay_dirname}"

    # If such overlay is *NOT* the topmost system-wide overlay, append all
    # scripts in such overlay's directory. The topmost system-wide overlay
    # contains the current script among others and should *NOT* be resourced.
    [[ "${overlay_dirname}" != "${ZESHY_OVERLAY_DIR}" ]] &&
        ZESHY_AUTOLOAD_FILENAMES+=(
            "${overlay_dirname}"/${~ZESHY_SCRIPT_NAME_GLOB} )

    # Append such overlay's main directory, if found.
    [[ -d "${overlay_main_dirname}" ]] &&
        ZESHY_AUTOLOAD_DIRNAMES+="${overlay_main_dirname}"

    # Append such overlay's command directory to appropriate lists, if found.
    compile_zeshy_overlay_commands "${overlay_dirname}"

    # Append the subdirectory of such overlay's distro directory matching the
    # user's currently installed distro to the overlay stack, if found.
    #
    # Do this after all other overlay logic, allowing distro-specific
    # redefinition of generic functionality.
    if [[ -n "${ZESHY_DISTRO_NAME}" ]] {
        local overlay_distro_dirname="${overlay_dirname}/if_distro/${ZESHY_DISTRO_NAME}"
        if [[ -d "${overlay_distro_dirname}" ]] {
            ZESHY_OVERLAY_DIRNAME_STACK+="${overlay_distro_dirname}"
        }
    }
}

ZESHY_CORE_HELP_FUNCTIONS+='
void compile_zeshy_overlay_configuration(string overlay_dirname)

Recursively copy all files from the `if_config` subdirectory of the passed
overlay directory to `zeshy`\''s user configuration directory, if not already
found in the latter.
'
function compile_zeshy_overlay_configuration() {
    # Validate passed arguments. If such overlay contains no configuration
    # subdirectory, return silently.
    (( # == 1 )) || die 'expected one overlay dirname'
    local overlay_config_dirname="${1}/if_config" source_filename
    [[ -d "${overlay_config_dirname}" ]] || return 0

    # If ignoring zeshy's user directory, source such files from such overlay
    # without copying such files to such directory.
    if [[ -z "${ZESHY_DOT_DIR}" ]] {
        for source_filename (
            "${overlay_config_dirname}/"**/${~ZESHY_SCRIPT_NAME_GLOB}) {
            source -- "${source_filename}"
        }
        return 0
    }

    # For each configuration file in the passed overlay, globbed recursively...
    local filename_suffix target_filename
    for source_filename (
        "${overlay_config_dirname}/"**/${~ZESHY_SCRIPT_NAME_GLOB}) {
        # Strip off the prefixing overlay configuration directory (e.g., from
        # "/usr/share/zeshy/src/if_config/if_shell_interactive/00-alias" to.
        # "if_shell_interactive/00-alias").
        filename_suffix="${source_filename#${overlay_config_dirname}/}"

        # Set the target filename appended with such suffix.
        target_filename="${ZESHY_USER_CONFIG_DIR}/${filename_suffix}"

        # If zeshy's user configuration directory already contains such file,
        # continue to the next file without sourcing the current file. zeshy's
        # sourcing of component "config" previously sourced such file, already.
        [[ -f "${target_filename}" ]] && continue

        # If the current user is a zeshy developer and the current shell is
        # interactive, print such path to standard output.
        is_zeshy_verbose_and print "zeshy: defaulting \"${target_filename}\"..."
#       print "defaulting \"${target_filename}\"..."

        # Make such file's parent directory, if needed.
        command mkdir -p -- "${target_filename:h}"

        # Copy such file. Do *NOT* source such file: most configuration files
        # require aliases subsequently declared under the main zeshy codebase.
        command cp -- "${source_filename}" "${target_filename}"
    }
}

ZESHY_CORE_HELP_FUNCTIONS+='
void compile_zeshy_overlay_commands(string overlay_dirnamename)

Prepare command-specific zsh scripts in the passed `zeshy` overlay directory.
Namely, append:

* All `zsh` scripts in this overlay''s command directory matching commands in
  the current user''s $PATH to the list of autoloadable files.
* All subdirectories in this overlay''s command directory matching such
  commands to the overlay stack.
'
function compile_zeshy_overlay_commands() {
    # Validate sanity.
    (( # == 1 )) || die 'expected one overlay dirname'
    local overlay_command_dirname="${1}/if_pathable"
    [[ -d "${overlay_command_dirname}" ]] || return 0

    # List of all paths in this overlay's command directory corresponding to a
    # currently installed executable file in the $PATH. Dismantled, this is:
    #
    # * "${ZESHY_AUTOLOAD_COMMAND_DIR}/"*, listing each file in Zeshy's
    #   command directory.
    # * "(e{[[ ... ]]})", excluding files failing the following test:
    #   * "$REPLY", the current file.
    #   * ":t", the basename of such file.
    #   * ":c", the absolute path to a command in the $PATH with such name.
    #   * "== /*", true only when ":c" succeeds in finding such a command.
    # * "or true", ignoring failure (if ":c" fails finding such a command).
    local -a overlay_command_paths; overlay_command_paths=(
        "${overlay_command_dirname}/"*(e{'[[ $REPLY:t:c == /* ]]'})
    ) || true

    # Append all files in this directory to the list of autoloadable files.
    ZESHY_AUTOLOAD_FILENAMES+=( "${^overlay_command_paths[@]}"(.) )

    # Append all directories in this directory to the overlay stack.
    ZESHY_OVERLAY_DIRNAME_STACK+=(      "${^overlay_command_paths[@]}"(/) )
}

# ....................{ PRECOMPILERS                       }....................
ZESHY_CORE_HELP_FUNCTIONS+='
void precompile_zeshy(void)

Finalize all `zeshy`-specific aliases, functions, and globals to be compiled
into `zeshy`\''s user digest file immediately before compiling such file.
Specifically, run all commands in list ${ZESHY_HOOKS_RUN_ON_ZESHY_PRECOMPILE}
(e.g., as added by prior calls to append_precompile_zeshy_command()).
'
function precompile_zeshy() {
    (( # )) && die 'expected no arguments'
    local hook
    for   hook ("${ZESHY_HOOKS_RUN_ON_ZESHY_PRECOMPILE[@]}") {
#       print "running precompilation hook \"${command}\""
        run_command "${hook}"
    }
}

ZESHY_CORE_HELP_FUNCTIONS+='
void precompile_zeshy_digest_dependency_paths(void)

Cache the list of paths on which `zeshy`\''s user digest file depends. See
${ZESHY_DIGEST_DEPENDENCY_PATHNAMES} for further details.
'
function precompile_zeshy_digest_dependency_paths() {
    # See write_file_with_variable() for further details. Since
    # get_zsh_shebang_line() has yet to be defined, avoid writing a shebang
    # line. (Since only this parcel sources such script, this is acceptable.)
    (( # )) && die 'expected no arguments'
    typeset -p -- ZESHY_DIGEST_DEPENDENCY_PATHNAMES\
        >!"${ZESHY_CACHE_DIGEST_DEPENDENCIES_FILE}"
}

#FIXME: Compiling lists of alias, function, and global names into the digest is
#inherently silly. For one, we no longer need to do so, so it unnecessarily
#increases both compilation and startup time. It'd be a loss to simply unset
#such globals, however; ideally, they should simply be serialized to disk
#(e.g., "~/.zeshy/cache/names.zsh", a zsh script containing all such lists).
#This shouldn't be terribly difficult, so see to it.

#FIXME: I'm exceedingly tired of *ALL* of the rather stupid timing problems
#inherent in this function. One simple thing that can be done to eliminate such
#issues is to add placeholder calls to define_function() for all functions to be
#newly defined as the *VERY* first thing this function does. Then shift the
#initialization of ZESHY_FUNCTION_NAMES to the sensible place. Naturally, such
#functions would need be redefined (as we currently do with one of them already).
#FIXME: Actually, shift define_function() calls even earlier -- ideally, to the
#first line of compile_zeshy_teardown(). Doing so then permits us to shift the
#initialization of ZESHY_FUNCTION_NAMES into such function as well. Do we create
#any other functions dynamically?
#FIXME: Oh. Wait. Shouldn't *ALL* such set differencing be performed *AFTER*
#running all precompilation hooks, not merely after sourcing the zeshy codebase?
#After all, such hooks might attempt to dynamically create new aliases,
#functions, or globals, in which case we need to pick up on that. Right. Simple
#fix, anyway. Rename compile_zeshy_teardown() to something more sensible and
#call such function *AFTER* completing precompilation. (Oh! There's an even more
#critical reason to do this: maps from alias, function, and global names to help
#strings should absolutely *NOT* be serialized to disk. Doing so significantly
#slows down shell startup and is simply a bad idea in general.)
#FIXME: I'm fairly certain we don't need the ${alias_names_quoted} nonsense
#anymore. Testing whether this is the case is fairly simple: disable such block
#of code and append ZESHY_ALIAS_SUFFIX_NAMES to ZESHY_GLOBAL_NAMES earlier.

#FIXME: This function has become lengthy enough to warrant splitting into
#numerous subfunctions. See to it, young stalwart lad!

ZESHY_CORE_HELP_FUNCTIONS+='
void precompile_zeshy_functions_startup_aliases_and_globals(void)

Dynamically synthesize the following functions:

* startup_zeshy_aliases(), defining regular, global, and suffix aliases.
* startup_zeshy_globals(), defining globally exported variables.

Subsequently synthesized function startup_zeshy() calls both such functions
before calling all other startup functions.
'
function precompile_zeshy_functions_startup_aliases_and_globals() {
    # Validate sanity.
    (( # )) && die 'expected no arguments'
    local aliases suffix_aliases
    local -a alias_names_quoted
#   print -l -- "===ZESHY_GLOBAL_NAMES===" "${ZESHY_GLOBAL_NAMES[@]}"
#   print -l -- "===ZESHY_FUNCTION_NAMES===" "${ZESHY_FUNCTION_NAMES[@]}"
#   print -l -- "===ZESHY_STARTUP_RUNNABLES===" "${ZESHY_STARTUP_RUNNABLES[@]}"

    # Avoid calling builtins on empty lists, as that typically causes such
    # builtins to exhaustively (and uselessly) print *EVERYTHING*.
    (( ${#ZESHY_ALIAS_NAMES} )) &&
        aliases="$(alias -L "${ZESHY_ALIAS_NAMES[@]}")"
    (( ${#ZESHY_ALIAS_SUFFIX_NAMES} )) &&
        suffix_aliases="$(alias -Ls "${ZESHY_ALIAS_SUFFIX_NAMES[@]}")"

#   print -rl -- "globals to be compiled:" "${ZESHY_GLOBAL_NAMES[@]}" | less
#   print "aliases: ${aliases}\nsuffix_aliases: ${suffix_aliases}"

    # Make such functions, making a placeholder empty definition for
    # startup_zeshy_globals() to be replaced below. The reasons, as ever, are
    # insidious. The set of all zeshy-specific globals includes list global
    # ${ZESHY_FUNCTION_NAMES}, which cannot be defined until after defining all
    # zeshy-specific functions. Naturally, startup_zeshy_globals() is such a
    # function. To break such circularity, define such function empty initially.
    define_function startup_zeshy_aliases "${aliases}
    ${suffix_aliases}"
    define_function startup_zeshy_globals ""

    # The list of zeshy-specific functions is the asymmetric difference of the
    # old from new list of functions.
    ZESHY_FUNCTION_NAMES_NEW=( ${(f)"$(typeset +f)"} )
    ZESHY_FUNCTION_NAMES=(
        "${ZESHY_FUNCTION_NAMES_NEW[@]:|ZESHY_FUNCTION_NAMES_OLD}" )

    #FIXME: This function could use significant refactoring. *sigh*

    # Serialize the lists of zeshy-specific aliases, suffix aliases, functions,
    # and globals to a zsh script in the current user's cache directory. Such
    # lists are both too resource consumptive and too infrequently accessed
    # post-compilation to warrant serialization into startup_zeshy_globals()
    # with customary zeshy globals.
    write_file_with_variable\
        "${ZESHY_USER_ENTITY_NAMES_FILE}"\
        ZESHY_ALIAS_NAMES\
        ZESHY_ALIAS_SUFFIX_NAMES\
        ZESHY_FUNCTION_NAMES\
        ZESHY_GLOBAL_NAMES\

    #FIXME: We should probably throw exceptions or print warnings if *ANY*
    #zeshy globals to be compiled into the digest are exported. I suspect we'll
    #probably catch a few errant strays.

    # The "typeset -p" command fails to annotate global variable declarations
    # with option "-g", thus localizing all such globals to
    # startup_zeshy_globals(). Of course, this constitutes a horrible zsh bug.
    # (Submit a report please.) In the meanwhile, forcefully add such option
    # immediately after any line output by "typeset -p" starting with "typeset".
    # To do so, first split such output into lines and for each such line
    # perform such insertion with array glob replacement. Dismantled, this is:
    #
    # * "(f)", splitting such output on newline.
    # * "/", performing such replacement at most once for each output line.
    # * "(#s)", matching only at the start of each such line.
    #
    # Do *NOT* quote the outermost expansion. See get_variable_binding() and
    # set_list_to_string_lines() for further details.
    local -a global_declarations; global_declarations=(
        ${${(f)"$(typeset -p -- "${ZESHY_GLOBAL_NAMES[@]}")"}/(#s)typeset /typeset -g }
    )

    # Join such lines on newline back into a string. See join_list_on_newline()
    # for further details.
    local globals; globals="$(print -lr -- "${global_declarations[@]}")"

    # Manually add the definition of the list of zeshy-specific aliases to such
    # string of global definitions, quote-protecting global alias names from
    # accidental expansion (as insinuated above).
    alias_names_quoted=( \"${^ZESHY_ALIAS_NAMES}\" )
    globals+="
typeset -ga ZESHY_ALIAS_NAMES
ZESHY_ALIAS_NAMES=( ${alias_names_quoted[@]} )"
#   print -r -- "globals: ${globals}"|less

    # Undefine all previously defined zeshy aliases. The reasons why are,
    # unsurprisingly, subtle. The subsequent definition of
    # startup_zeshy_globals() may attempt to declare nonscalar globals
    # containing unquoted elements equal to zeshy-specific global alias names
    # (e.g., "is", "or"), in which case such call will fail with an unhelpful
    # parse error if such global aliases exist. Undefining *ALL* aliases also
    # undefines such problematic global aliases, as desired.
    #
    # Interestingly, undefining such aliases does *NOT* induce errors on zeshy
    # functions expanding such aliases (as demonstrated by the call to
    # redefine_function() below). Since zsh expands aliases in function bodies
    # at function definition definition rather than call time, *ALL* zeshy
    # functions may still be called without error despite such undefinition.
    if [[ -n "${ZESHY_ALIAS_NAMES-}" ]] {
        unalias -- "${ZESHY_ALIAS_NAMES[@]}"
    }

    #FIXME: The following call dies with an unhelpful parse error if *ANY* list
    #element or map key or value in the string ${globals} equals a reserved
    #keyword (e.g., "&&"). Why? Because the above "typeset -p" command fails to
    #quote such elements, and there's currently no way to enforce such quoting.
    #Doing so manually is certainly feasible, but *EXTREMELY* inefficient and
    #hence effectively infeasible. Fortunately, a simpler (though still annoying
    #solution) presents itself. Run the following command at the *VERY* start of
    #the function body of startup_zeshy_globals():
    #
    #    disable -r --\
    #       do done esac then elif else fi for case if while function\
    #       repeat time until select coproc nocorrect foreach end ! [[ { }
    #
    #Naturally, we'd need to insert a corresponding "enable -r --" command at the
    #end of such function body -- perhaps in an "} always { ... }" block for
    #safety.

    # Make the final zeshy function. (Phew!)
    redefine_function startup_zeshy_globals "${globals}"
}

# ....................{ MAIN                               }....................
# Recompile zeshy's user digest file.
compile_zeshy

# --------------------( WASTELANDS                         )--------------------
    # Save the lists of zeshy-specific suffix aliases, functions, and globals.
    # Subsequently recompiling zeshy's user digest file in either the current
    # shell or a child of such shell requires such lists for deciding which
    # suffix aliases, functions, and globals to undefine prior to sourcing the
    # zeshy codebase. See the "MAIN" section of this component below.
    #
    # Omit the list of zeshy-specific aliases, whose alias names we safely,
    # manually interpolate into the definition of startup_zeshy_aliases() below.
    # Why? The reason is, of course, exceedingly subtle. Alias names include
    # global alias names (e.g., "or"), which zsh expands into the corresponding
    # global alias expansion *ANYWHERE* such names appear unquoted.
    # Unfortunately, the "typeset -p ZESHY_ALIAS_NAMES" command called below
    # fails to quote such names; hence, the "eval" statement evaluated below
    # expands a string resembling this:
    #
    #     typeset -gax ZESHY_ALIAS_NAMES
    #     ZESHY_ALIAS_NAMES=( is si or and not ... )
    #
    # into a string resembling this:
    #
    #     typeset -gax ZESHY_ALIAS_NAMES
    #     ZESHY_ALIAS_NAMES=( [[ ]] || && ! ... )
    #
    # This is clearly invalid zsh syntax.
#   ZESHY_GLOBAL_NAMES+=(
#       ZESHY_ALIAS_SUFFIX_NAMES
#       ZESHY_FUNCTION_NAMES
#       ZESHY_GLOBAL_NAMES
#   )

#ZESHY_CORE_HELP_GLOBALS+='
#string ZESHY_USER_ENTITY_NAMES_DIR
#
#Absolute path of the user-specific directory caching `zsh` scripts declaring and
#defining list globals containing the names of all `zeshy` entities of a
#particular type (e.g., aliases, functions, globals).
#'
#typeset -g ZESHY_USER_ENTITY_NAMES_DIR="${ZESHY_USER_CACHE_DIR}/names"

#   local globals; globals="${"$(\
#       typeset -p -- "${ZESHY_GLOBAL_NAMES[@]}")"// #typeset /typeset -g }"
#       typeset -p -- "${ZESHY_GLOBAL_NAMES[@]}")"//typeset /typeset -g }"
#       typeset -p -- "${ZESHY_GLOBAL_NAMES[@]}")"/(#s)[[:space]]#typeset /$'\t'typeset -g }"
#       typeset -p -- "${ZESHY_GLOBAL_NAMES[@]}")}"
#       typeset -p -- "${ZESHY_GLOBAL_NAMES[@]}")/(#s)(#m)[[:space]]#typeset /${match[1]}-g }"
#       ${${(f)"$(typeset -p -- "${ZESHY_GLOBAL_NAMES[@]}")"}/(#s)(#m)[[:space]]#typeset /${match[1]}-g }

    # The "typeset -p" command fails to print the "-g" modifier for global
    # variables. Since "typeset -x" commands do not imply such modifier under
    # zsh option "no_global_export", failing to print such modifier effectively
    # localizes such globals to the startup_zeshy_globals() function. Of course,
    # this constitutes a zsh bug. (Submit a report please.) In the meanwhile,
    # forcefully add the "-g" modifier to all output "typeset" commands.
#   local globals; globals="${$(\
#       typeset -p "${ZESHY_GLOBAL_NAMES[@]}")//typeset /typeset -g}"

    #FUXME: Tie *ALL* of the prior aliases to strings like so:
    #
    #   export -T ZESHY_GLOBAL_NAMES_STRINGS ZESHY_GLOBAL_NAMES
    #
    #Then under the last section "MAIN" below, if each such string global
    #exists, tie such global back into a temporary local (which we delete
    #immediately after use, I should think). For simplicity, reuse the *SAME*
    #local for each such conditional, making sure to empty it after each use.
    #First just get this working for globals; then extend to the other types.
    #FUXME: Agh! I can hardly believe it, but zsh fails to escape colons
    #embedded in tied list elements, which means that list ties are pretty much
    #unusable for general purpose work. That's pretty shoddy, but... well, it is
    #what it is. It means we need to explicitly convert such lists to strings at
    #the latest possible point -- probably
    #precompile_zeshy_functions_startup_aliases_and_globals(), yes? Such strings
    #should of course be exported as below.
    #FUXME: After careful thought, I've come to the obvious conclusion that it's
    #*STUPID* to export globals by default. No, really: why? We don't need to,
    #at all, aside from the $(typeset +gx) issue. Which is a tangible issue,
    #but... well, it's not worth the other headaches. It's just not. Which means
    #we'll need to implement a new function (probably) setting a list to all
    #currently declared globals. Such function will need to parse
    #$(typeset +g +) output -- annoying, but *CERTAINLY* doable. How about:
    #
    #   ZESHY_GLOBAL_NAMES=( ${(f)"$(typeset +g +)"##* } )
    #
    #Actually, that looks pretty efficient to me. It's a one-liner, so no
    #function needed. We'll need to actually *TRY* it of course. But, so far...
    #looks good. Damn. Why didn't I do this initially?

# This component recompiles the zeshy digest file by sourcing all components
# defining zeshy-specific zsh objects (i.e., aliases, functions, and globals)
# specific to the current user and system and then compiling exactly such
# objects into such digest. To decide exactly which objects to compile, this
# component subtracts the set of all zsh objects defined *AFTER* sourcing such
# components from the set of all zsh objects defined *BEFORE* sourcing such
# components: the difference between the two sets is exactly the set of all
# zeshy-specific objects to be compiled.
#
# By design, this requires no such objects to be defined before sourcing such
# components. If some (or all) such objects were defined before sourcing such
# components, the difference between the above two sets and hence the recompiled
# zeshy digest file would be essentially empty. To avoid such issues, undefine
# zeshy-specific objects defined by parent shells before such recompilation.

#FUXME: By design, zeshy no longer exports globals. I'm fairly certain neither
#aliases or functions are inherited by child shells (as confirmed by a thorough
#Googling), so... Really, just cut this. It's cruft, and unwieldy cruft at that.
#That said, we'll need to test this first (of course). Simple way is to just
#start a new unzeshified zsh shell under a running zeshy shell. Nothing should
#be inherited. (Double check!)
#FUXME: If we do cut this, there's a similar block of logic in "main" that
#probably needs cutting as well. *shrug*

#FUXME: Woops! We need to "unalias -s" everything in global map
#${ZESHY_ALIAS_SUFFUX_NAMES}, too.

#if (( ${+ZESHY_ALIAS_NAMES} )) {
#    unalias -- "${ZESHY_ALIAS_NAMES[@]}"
#}
#if (( ${+ZESHY_FUNCTION_NAMES} )) {
#    unfunction -- "${ZESHY_FUNCTION_NAMES[@]}"
#}

#FUXME: O.K.; I've pretty much had it with this approach. It's simply *TOO*
#unreliable, and has caused untold difficult-to-debug suffering. Why the
#unreliability? Well, child shells appear to inherit exported scalar but *NOT*
#list or map globals, meaning that ${ZESHY_GLOBAL_NAMES} will not be accessible
#to children but other scalar globals will be. There are two alternatives:
#
#* The conservative (and probably better) solution is to tie a string global to
#  ${ZESHY_GLOBAL_NAMES} -- say, ${ZESHY_GLOBAL_NAMES_STRING}. Children will
#  inherit such global. Then use the latter global here rather than former.
#  We'll have to do a bit of string splitting, but that's no worry.
#
#O.K.; yeah. I won't even bother documenting the more heavy-handed approach.
#Give the above a try and see where that gets us, eh?
#FUXME: Right. We'll need to extend the same solution to aliases and functions,
#above. Efficiency shouldn't be a problem, given the string tying approach.

# String and list of all alias, function, and global names temporarily tied
# together below.
#local IMPORTED_NAMES
#local -a imported_names

# Undefine globals *AFTER* undefining all objects listed by the prior lists,
# which themselves are globals and hence undefined with the other globals here.
#
# Globals *MUST* be undefined in a global context to have meaningful effect.
# While aliases and functions may be meaningfully undefined in a local context,
# there seems little point in doing so elsewhere. Centralize all logic here.
# See undefine_variable() and unfreeze_variable() for details on undefining
# globals (namely, why we call typeset() prior to unset()).
#if [[ -n "${ZESHY_GLOBAL_NAMES-}" ]] {
#   print -l "===ZESHY_GLOBAL_NAMES===" "${ZESHY_GLOBAL_NAMES}"

    #FUXME: Hell, this is silly. For consistency, just do everything the same.

    # Split such string on colons by retying such string and list. By zsh
    # mandate, global names *CANNOT* contain colons, rendering tying
    #
    # While there
    # exist alternative implementations (e.g., ${IFS}-based string splitting as
    # under set_list_to_string_split_on_character()), such implementations are
    # complicated by the fact that alias and function names can contain. See
    # string_and_list_tied_on_character() for further details.
#   local -T IMPORTED_NAMES="${ZESHY_GLOBAL_NAMES}" imported_names

    # Undefine such globals.
#    typeset +r -- "${ZESHY_GLOBAL_NAMES[@]}"
#    unset      -- "${ZESHY_GLOBAL_NAMES[@]}"
#   typeset +r -- "${imported_names[@]}"
#   unset      -- "${imported_names[@]}"
#   typeset -p -m "${imported_names[@]}"
#}

# Undefine such locals.
#unset -- IMPORTED_NAMES imported_names

    # Remove canonical zsh globals from such list. See
    # set_list_to_list_nonmatches() for further details.
#   ZESHY_GLOBAL_NAMES=( "${ZESHY_GLOBAL_NAMES[@]:#(chpwd|preexec)_functions}" )

    # Dismantled, this is:
    #
    # * "+f", listing newline-delimited function names.
    # * "(f)", splitting such list on newlines.

    # Dismantled, this is:
    #
    # * "+gx", listing newline-delimited globally exported variable names.
    # * "(f)", splitting such list on newlines.
#   ZESHY_GLOBAL_NAMES_OLD=( ${(f)"$(typeset +gx)"} )

    # Split such string on colons by retying such string and list. While there
    # exist alternative implementations (e.g., ${IFS}-based string splitting as
    # under set_list_to_string_split_on_character()), such implementations are
    # complicated by the fact that alias and function names can contain. See
    # Split such string on colons by retying such string and list. Note that not
    # initializing such string to itself erroneously induces such declaration to
    # initialize such string to the empty string. (Oh, zsh.) See
    # string_and_list_tied_on_character() for further details.
#   local -T ZESHY_GLOBAL_NAMES="${ZESHY_GLOBAL_NAMES}" ZESHY_GLOBAL_NAMES
    # See set_list_to_string_split_on_character() for further details.
#   IFS=':' read -r -d '' -A "${list_name__sltssoc1om}" <<<"${text__sltssoc1om}"

#FUXME: While we can of course continue to serialize this list of names,
#Lists cannot be

# Such files include:
#
#* All plain files in such directory.
#* If the current shell is interactive, all plain files in subdirectory
#  `if_interactive` of such directory.

#FUXME: This brings to mind a related problem with the proposed idea of *ALWAYS*
#sourcing "if_config/" parcels, even if the corresponding "~/.zeshy/config/"
#parcel already exists: documentation duplication. We'll need
#to explicitly ignore documentation declarations in all "zeshy.user.config://"
#parcels *IF* such entity (e.g., alias, function) has already been declared.
#FUXME: Hmmm. Yes. The more I genuinely consider it, sourcing "if_config/"
#parcels, even if the corresponding "~/.zeshy/config/" parcel already exists,
#seems increasingly a terrible idea. They're named "if_config" for a reason.

#FUXME: This snippet used to reside in "if_config/posix" until I found it
#sufficiently embarrassing. Frankly, we won't be implementing any functionality
#using this anytime soon. Nonetheless, store it here for the moment:
# ....................{ PREFERRED                          }....................
# Preferred terminal multiplexer. If commented, Zeshy selects the first such
# multiplexer installed on the current machine, if any.
#ZESHY_TERMINAL_MULTIPLEXER='tmux'
#ZESHY_TERMINAL_MULTIPLEXER='screen'
#ZESHY_TERMINAL_MULTIPLEXER='dtach'
#FUXME: This doesn't... seem quite right. Shouldn't this be uncommented. But,
#again, it's clearly incorrect. Another half-implemented feature, eh?
#ZESHY_TERMINAL_MULTIPLEXER="ZESHY_TERMINAL_MULTIPLEXER$(get_pathable_path_first tmux screen dtach)"

#Append the passed command to the end of the definition of precompile_zeshy(), called
#immediately before compiling Zeshy''s user digest file.
#FUXME: Rename to run_hook_on_zeshy_compile() and similarly everwhere else.
#(Make is *FAR* too ambiguous a verb here, frankly. Compile is quite concise and
#much more explanatory.)
# Dismantled, this is:
    #
    # * "**/*(-.)", recursively matching all plain files after resolving
    #   symbolic links.

        # If ignoring Zeshy's user directory, source such file from such overlay
        # without copying such file to such directory.
#       [[ -n "${ZESHY_DOT_DIR}" ]] || {
#           source -- "${source_filename}"
#           continue
#       }

    # Append Zeshy functions defined at the top level but redefined by the main
    # codebase (e.g., say(), defined by "main" and "always/io/output/say/say")
    # to the list of Zeshy-specific functions, if not already present. Not doing
    # so prevents the redefinitions of such functions from being compiled into
    # Zeshy's user digest file, thus exposing only the original definit version of such functions
    # defined at the top level.
    #
    # Ideally, no functions defined at the top level should be redefined by the main
    # codebase. In practice, doing so 

    # List of all configuration files. Dismantled, this is:
    #
    # * "**/*(-.)", recursively matching all plain files after resolving
    #   symbolic links.
#   local -a config_filenames; config_filenames=(
#       "${ZESHY_USER_CONFIG_DIR}/"**/*(-.) )
#   [[ -o interactive ]] && config_filenames+=(
#       "${ZESHY_USER_CONFIG_DIR}/if_shell_interactive/"*(-.) )

    # If at least one such script exists, source such scripts; else, avoid
    # calling source_zeshy_script() with no arguments throwing an exception.
#   (( ${#config_filenames} )) &&
#       for config_filename ("${config_filenames[@]}") {
#           say "sourcing configuration file \"${config_filename}\"..."
#           source -- "${config_filename}"
#       }

#FUXME: *GENIUS*. I've been gradually shifting to the following realization, and
#unsure why it took me quite so long to glom: *SOURCE CONFIGURATION FILES !ONLY!
#DURING DIGEST RECOMPILATION*. This should dramatically improve runtime
#efficiency, effectively caching all config file globals to
#zeshy_startup_globals() for subsequent restoration. Man, *MAKE THIS HAPPEN*.

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#Apallingly, failing to call the function defining alias
#is_zeshy_verbose_and<> at the topmost level before calling functions
#expanding such alias below results in such alias temporarily reverting to its
#default definition only in such functions. (This is insanity, zsh.)
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# ....................{ ALIASES ~ variable                 }....................
# Zeshy's user configuration files only export globals. While such files can
# declare locals and non-exported globals via traditional zsh primitives (e.g.,
# "typedef -Fr"), avoid promoting such bad behavior by aliasing human-readable
# names to such primitives. Defer defining further aliases and documentation for
# these specific aliases to the main Zeshy codebase.
#alias\
#    string_global_export='export'\
#    boolean_global_export=string_global_export\
#    character_global_export=string_global_export\
#    integer_global_export='export -i'\
#    float_global_export='export -F'\
#    list_global_export='export -a'\
#    list_set_global_export='export -Ua'\

# "export -A" fails with error; "export -a", however, succeeds. *massive shrug*
#alias map_global_export='typeset -Agx'
#FUXME: After doing so, I'm not necessarily convinced there 
#FUXME: Shift elsewhere, per lengthy discussion in "digest". Honestly, why don't
#we just rename this component to "config" and shift the autoload_zsh_modules()
#*INTO THE MAIN ZESHY CODEBASE*, *PREPENDED* (emphasis on prepended) to
#startup_zeshy(). We *NEVER* call any such module functions here at the topmost
#level -- and even if we did, we'd just replace such implicit autoload with an
#explicit load of such module. Faster, simpler. Bam! :)
# after defining aliases
# required by such files. For efficiency, defer defining all other aliases to
# Zeshy startup in the proper Zeshy codebase and hence compilation into the
# Zeshy digest file. Redefine aliases defined below with such other aliases,
# guaranteeing that:
#
# * Zeshy records all aliases defined below in global list ${ZESHY_ALIAS_NAMES},
#   to be subsequently undefined if recompiling Zeshy in the current shell or a
#   child of the current shell. (See "compile" for gruesome details.)
# * Zeshy retrieves documentation for all aliases defined below in the same
#   manner as such other aliases. (See "help" for miserable details.)#
    # This matches all basenames of immediate files of directories in the function
    # path. (Since this is also the set of all autoloadable function names,
    # autoloading such basenames autoloads all autoloadable functions.) Oh!
#       print 'enabling debugging'
#       alias is_zeshy_verbose_and='true &&'
    # * "/*", each immediate file and subdirectory of such directory.
    # * "N", ignoring non-extant files and subdirectories.
# ....................{ CONFIGURERS ~ main                 }....................
#   for autoloadable_function_name in ${^fpath}/*(N.:t); do
#FUXME: O.K.; because of this, it would seem prudent to split this component
#into two new components "config" and "digest": the former defining the above
#config-specific aliases, functions, and globals; the latter defining all
#remaining objects declared in this component. While I'm somewhat loathe to
#introduce yet another component into startup logic, the sheer inanity of this
#behavior suggests we could benefit from doing so. After all, we must admit
#that digest behavior is wholly separate from config file behavior.
#FUXME: If splitting as described, digest behavior could actually be readily
#merged into existing component "autoload". In such case, it could make sense
#to do the following, in which case no actual split need take case *WHICH IS
#ABSOLUTELY GREAT*:
#
#* Shift all digest behavior below to "autoload."
#* Shift all zsh module-specific behavior in "autoload" here.
#* Rename "autoload" to "digest" to better reflect its role.
#
#And that's it. *NO NEW TOPMOST COMPONENTS REQUIRED*, just a slight shuffling
#of existing functionality for improved understandability.
#FUXME: Yes. Make it so, I should think.

    #FUXME: Many of the functions this function calls redundantly test
    #"[[ -n "${ZESHY_DOT_DIR}" ]]" as well. Eliminate that.
#   [[ -n "${ZESHY_DOT_DIR}" ]] || return 0
    # Source Zeshy's user configuration files here, as such files define global
    # ${ZESHY_IS_DEBUG} tested by functions called immediately below.
#   setup_zeshy_configuration
#   which is_zeshy_verbose_and
#   is_zeshy_verbose_and print 'ok'

#FUXME: If splitting as described, rename the above function to source_zeshy_configuration(),
#which is really a much more sensible name in any case.
#FUXME: Eliminate.
#set_function_documentation setup_zeshy_digest_uptodate '
#void setup_zeshy_digest_uptodate(void)
#
#Assuming Zeshy''s user digest file to be up-to-date, implement placeholders for
#aliases and functions required only for compiling an outdated digest file.
#'
#function setup_zeshy_digest_uptodate() {
#    # Validate sanity.
#    (( # == 0 )) || die 'expected no arguments'
#
#    # Implement placeholders with zsh builtin ":" (i.e., noop).
#    alias document_alias=':'
#    alias document_function=':'
#    alias document_global=':'
#}

#FUXME: O.K.; start using is_zeshy_verbose_and<> everywhere. Yum!

#Parse the passed documentation, associating the global name prefixing such
#documentation with such documentation and globally exporting such global as the
#Zeshy-specific type prefixing such documentation. Expand this alias only before
#compiling Zeshy''s user digest file.
#FUXME: Use is_zeshy_verbose_and<> instead. This requires we shift such
    #code to the very bottom of this component, but it makes everything nice and
    #orthogonal. So, go-go-go!
    #FUXME: This isn't right. Such configuration defines ${ZESHY_IS_DEBUG},
    #used *ABOVE*. Clearly, config files should be sourced *BEFORE* testing the
    #digest file, yes?

#FUXME: For both efficiency and readability, define a new alias resembling:
#
#  alias inquisitively='[[ -n "${ZESHY_IS_DEBUG}" ]] &&'    # or perhaps...
#  alias investigatively='[[ -n "${ZESHY_IS_DEBUG}" ]] &&'
#
#I'll admit neither adjective to be the best, but "debuggedly" simply doesn't
#make sense. That said, we could also contemplate "if_zeshy_debugging" or
#"is_zeshy_verbose_and"... Yes, the latter seems quite sensible, in fact. So,
#where does the "efficiency" part come in? Pretty simple: we'd like to
#effectively "compile away" all such statements under release builds: namely, if
#${ZESHY_IS_DEBUG} is false *AFTER* sourcing user config files. In such
#case, we can simply re-alias as follows:
#
#  alias is_zeshy_verbose_and='true ||'
#
#Brilliant! This reduces such test to a (hopefully) maximally fast no-op while
#ensuring it evaluates to true and hence does not throw exceptions.
#FUXME: After defining such alias, fixup all current references to
#${ZESHY_IS_DEBUG} - particularly at the top level.
    # Replacing all prior instances of '[[ -n "${ZESHY_IS_DEBUG}" ]] &&' in
    # the Zeshy codebase with 'is_zeshy_verbose_and'
    #
    # If such configuration enables Zeshy debugging, expand such alias to the
    # empty string, thus unconditionally running the passed command.
#  alias investigatively='[[ -n "${ZESHY_IS_DEBUG}" ]] &&'
#
#I'll admit neither adjective to be the best, but "debuggedly" simply doesn't
#make sense. That said, we could also contemplate "if_zeshy_debugging" or
#"is_zeshy_verbose_and"... Yes, the latter seems quite sensible, in fact. So,
#where does the "efficiency" part come in? Pretty simple: we'd like to
#effectively "compile away" all such statements under release builds: namely, if
#${ZESHY_IS_DEBUG} is false *AFTER* sourcing user config files. In such
#case, we can simply re-alias as follows:
#
#  alias is_zeshy_verbose_and='true ||'

#       say 'digest outdated!'
#   print "ZESHY_USER_DIGEST_FILE_IS_OUTDATED: ${ZESHY_USER_DIGEST_FILE_IS_OUTDATED}"
# non-zero only if such file was outdated at shell startup.
    #FUXME: Not quite right. We need to set
    #ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MODIFICATION_TIME to the current
    #time. Now how do we do that, again...?
#* The main user-specific Zeshy configuration file. This file contains theme
#  settings, which when edited require recompiling theme autoloads.
#* The main system-wide command directories (e.g., "/bin", "/usr/bin").
#  Installing or uninstalling commands requires recompiling command autoloads.

#           if [[ "${function_name}" == *'[or]'* ]]; then
#FUXME: Shift is_zeshy_digest_outdated() here and cache the result into a global
#variable, as subsequent components will also need reference such result. Shift
#document_function() here as well. If Zeshy's digest file is outdated, define
#document_function() and document_global() as below (i.e., nest such function
#and alias definitions in a code or function block run only if outdated);
#otherwise, define both document_function() and document_global() to be aliases
#expanding to ":". Genius, no? This should ensure we incur no measurable
#overhead when sourcing configuration files and *NOT* recompiling such digest.

#Processes assigned to class 3 are idle-only processes scheduled when no other
#process performs I/O. Class 3 processes are likely to suffer scheduling
#starvation and hence appropriate only for background daemons.
#FUXME: Document all such globals.
#document_global '
#list ZESHY_IONICE_CLASS_HIGH
#
#"ionice"-specific highest and lowest priority pairs consisting of class and
#ioniceness for I/O scheduling of processes. Processes assigned to class 3
#signify "idle-only" processes to be scheduled only when no other process
#performs I/O. Since such processes are likely to suffer scheduling starvation,
#omit class 3 from consideration.
#; assigning class 2 to the default lowest priority class improves
#process responsiveness.
#'

#       '/bin' '/sbin' '/usr/bin' '/usr/sbin' "${ZESHY_USER_CONFIG_DIR}"/{,*}) {
    #FUXME: We may need to explicitly unset ${documentation__dg} *ONCE* after
    #sourcing all configuration files. We'll know whether we need to do so based on
    #whether or not the current environment has become polluted with such variable
    #after entering a new Zeshy shell.

#FUXME: Should probably be pushed into "main". Ideally, this could allow us to
#obsolete the lower-level set_*_documentation() family of functions in favor of
#the higher-level document_*() family of functions. It will increase the size of
#"main", but probably not by quite as much as thought -- after all, we'd also be
#removing a sizable block of existing functionality: set_*_documentation().
#Naturally, this requires moving document_*() and all conditional logic defining
#such functions from here to "main".
#FUXME: Since we'd like to declare such functionality as "early" as possible, we
#should probably declare "set -e" at the top of "main" and then inject such code
#immediately after "setopt" calls (i.e., before defining die(), say(), and
#friends). This implies we should undo "set -e" immediately prior to defining
#die(). (I recall we do something similar; just double-check us up.)
#FUXME: Actually, the current method isn't terribly inappropriate. Steady as she
#goes, folks!

        # Nonetheless, reuse the same glob expression for simplicity.
        # Hence, this glob expression matches more strictly than the function
        # glob expression above. Dismantled, this is:

#FUXME: Hopefully superfluous, after implementing document_global() properly.
#Excise after excising from all config files.
    # If Zeshy's user digest file is up-to-date, define placeholders for
    # runnables required only for compiling an outdated digest file.

    # * Loading Zeshy's user directory and
#   [[ -n "${ZESHY_DOT_DIR}" &&\
#FUXME: This looks *EXTREMELY* heavyweight. I'm concerned about expanding such
#alias as much as we inevitably will be. Given that, I'm currently inclined to
#reconsider aliasing document_global=':' when the digest file is not outdated.
#This requires we retain variable declarations, which is probably a good idea.
#   [[ -n "${(k)ZESHY_GLOBAL_TYPE_TO_DECLARATOR[(r)${match[1]}]-}" ]] ||
    #FUXME: Insufficient. document_global() needs to *AT LEAST* declare such
    #global based on the passed help string.
    #FUXME: In reflection, declaring such global is basically the entirety of
    #document_global(). We'd might as well just define the whole thing as is.
#   alias document_global=':'

    # Parse variable helpstring here. Since the first line is something like:
    #
    #     string ZESHY_ZSTRANGE
    #
    #     I''m a strange global. (But here I am.)
    #
    # ...this implementation can parse that line and produce the corresponding
    # "export ZESHY_ZSTRANGE" line. No problem, yes? Most efficient
    # implementation uses a dictionary lookup on the first shell word of such
    # helpstring. Name the dictionary, say, ZESHY_GLOBAL_TYPE_TO_DECLARATOR.
    # See initial definition above.

#: e.g.,
  # Declare ${THIS_IS_A_MAP} to be a global map.
# >>> ${(z)ZESHY_GLOBAL_TYPE_TO_DECLARATOR[map]} THIS_IS_A_MAP
#FUXME: Excise after converting all current configuration file global
#declarations to the aliases below.
#FUXME: Hmm; actually, we'll have to replicate the current document_function()
#function into a new document_global() function defined here. And since we're
#defining that function here, we'd might as well move document_function() from
#"compile" here as well for sanity. Shouldn't be terribly difficult. The tedious
#aspect will be in converting existing configuration files to call such
#function. Well... no time like the present, yes?
#FUXME: Ah; hmm. I note that we *COULD* define:
#alias document_global='
#{
#    # Parse variable helpstring here. Since the first line is something like:
#    #
#    #     string ZESHY_ZSTRANGE
#    #
#    #     I'm a strange global. (But here I am.)
#    #
#    # ...this implementation can parse that line and produce the corresponding
#    # "export ZESHY_ZSTRANGE" line. No problem, yes? Most efficient
#    # implementation uses a dictionary lookup on the first shell word of such
#    # helpstring. Name the dictionary, say, ZESHY_GLOBAL_TYPE_TO_DECLARATOR.
#    # See initial definition above.
#} <<<'
#I am mildly concerned about the efficiency of sourcing configuration files with
#numerous such alias expansions. If efficiency becomes a problem, just
#implement a separate document_global() function. That then leaves us with code
#resembling:
#
#document_global '
#string ZESHY_ZSTRANGE
#
#I'm a strange global. (But here I am.)
#'
#string_global_export ZESHY_ZSTRANGE='lululululuuuuuu"
#
#The above alternative leaves us with:
#
#document_global '
#string ZESHY_ZSTRANGE
#
#I'm a strange global. (But here I am.)
#'
#ZESHY_ZSTRANGE='lululululuuuuuu"
#
#FUXME: O.K.; so, in either case, we have a document_global() runnable. The
#latter case is more concise and hence preferable, but somewhat less efficient
#due to parsing overhead. Let's see how much it costs us. Simple experiment:
#
#* Temporarily force is_zeshy_digest_outdated() to return_false.
#* Copy all of the existing config files to a new dir under "old/".
#* Migrate existing config files to call document_global().
#* Time startup under both! Hopefully, the overhead isn't hideously noticeable.
#FUXME: The following aliases *SHOULD* already exist under "always/00-setup".
#Ensure this to be the case; then, excise such aliases here.

#       set_global_documentation "${match[2]}" "${documentation}"
# print_function_documentation() to subsequently print such documentation.
#       then set_function_documentation "${match[1]}" "${documentation}"
# ....................{ EXPORTS                            }....................
# Zeshy configuration files declare only global exports. While such files can
# declare locals and non-exported globals with traditional zsh primitives (e.g.,
# "typedef -Fr"), avoid promoting such bad behavior by aliasing human-readable
# names to such primitives. Delay defining all remaining Zeshy aliases to the
# main Zeshy codebase.

#is_zeshy_digest_outdated() returning true. Yes:
#this is somewhat hackier than we prefer, but the alternatives are uglier.
#   local -a path_plus_zeshy
#   path_plus_zeshy=( "${path[@]}" "${ZESHY_USER_CONFIG_DIR}/zeshy" )
#   local path_plus_zeshy_glob="${(j~|~)${(q@)path_plus_zeshy}}"
#   zeshy_dependency_mtimes+="$(zstat +mtime "${path_plus_zeshy_glob}")"

    #FUXME: Definitely not right. We absolutely want to do this *AFTER*
    #"always/shell/profile" establishes the global list "path"; then, replace
    #the awkwardly hard-coded paths below with the following:
    #
    #    for dependency_pathname ("${path[@]}" "${ZESHY_USER_CONFIG_DIR}"/{,*}) {
    #
    #Concise; awesome; and exactly what's needed. We'll probably just want to
    #extricate the setting of the ${PATH} currently performed by
    #"always/shell/profile" to somewhere directly under "src/" -- perhaps this
    #component? There's really no reason to perform such logic *ONLY* under a
    #login shell; ideally, the ${PATH} should always be "fixed up" on Zeshy
    #startup. After all, either the user or a script could destroy the ${PATH}
    #after login, in which case we really wouldn't want to trust its current
    #setting. So, fix it up to guarantee sane behavior.
    #FUXME: We can substantially optimize this, I believe. Cease appending
    #modification times to list ${dependency_mtimes}; instead, perform a single
    #call to $(zstat +mtime ...) with a single argument selecting the oldest
    #such path that exists:
    #
    # zstat +mtime (if_shell_interactive|posix)(e:'[[ -e $REPLY ]]':om[1])
    #
    #That works at the shell. Given that, how about a generalization:
    #
    # zstat +mtime (~dependency_pathname_glob)(e:'[[ -e $REPLY ]]':om[1])

#
    # Dismantled, this is:
    #
    # * "${ZESHY_USER_CONFIG_DIR}"/{,*}, expanding to the current user's Zeshy
    #   configuration dirname and all filenames under such dirname, thus
    #   reporting Zeshy to be outdated on adding, deleting, or editing a Zeshy
    #   configuration file.
#   local dependency_pathname_glob
#   : ${dependency_pathname_glob::=\'${^path}\'}
#   dependency_pathname_glob="${path}|${ZESHY_USER_CONFIG_DIR}/zeshy"
#   ="${path}|${ZESHY_USER_CONFIG_DIR}/zeshy"

    #FUXME: Mostly right. Note that for safe generality, however, reserved glob
    #characters in pathnames should be prefixed by "\" to prevent usage as glob
    #characters. Fine for now, but of some importance later.
#   local -a path_quoted
#   path_quoted=( \'${^path}\' "${ZESHY_USER_CONFIG_DIR}/zeshy" )
#   local path_quoted_glob="${(j:|:)path_quoted}"

    #FUXME: Rename "ZESHY_IS_DEBUG" to "ZESHY_IS_IN_DEVELOPMENT". :)
    # * "${ZESHY_USER_CONFIG_DIR}"/{,*}, expanding to the current user's Zeshy
    #   configuration dirname and all filenames under such dirname, thus
    #   reporting Zeshy to be outdated on adding, deleting, or editing a Zeshy
    #   configuration file.
    # If either or configuration directory do not exist or
    # the latter exists but is empty, mark such file "outdated."
    # Ensure the current user's Zeshy configuration directory and all non-extant
    # parents of such directory exist.
#   command mkdir -p -- "${ZESHY_USER_CONFIG_DIR}"

    # specifically including:
    #
    # * All plain files in such directory.
    # * If the current shell is interactive, all plain files in subdirectory
    #   "if_shell_interactive" of such directory.
    #
    # If the current shell is interactive and such directory contains a
    # subdirectory "if_shell_interactive" containing at least one Zeshy script,
    # source such scripts as above.
#   config_filenames=( "${ZESHY_USER_CONFIG_DIR}/if_shell_interactive/"*(-.) )

# Booleans are false if set to the empty string and otherwise true.
#
# For simplicity, disable or enable booleans by commenting or uncommenting the
# lines on which they appear (e.g., prefixing such lines with "#" or deleting
# such prefix).

    # subsequent logic
    # sources the default versions of such files.

#FUXME: All of the magic constants defined in "global" should be declared
#frozen, perhaps suggesting new "string_global_constant",
#"boolean_global_constant", and so on types in "alias".

#FUXME: I'm not terribly fond of enabling booleans by setting them to 1. Avoid
#such magic by defining the following magic in "global":
#
#string_global_constant ZESHY_BOOLEAN_TRUE=1 ZESHY_BOOLEAN_FALSE=''
#
#Then use below: e.g.,
#ZESHY_IS_DEBUG=${ZESHY_BOOLEAN_TRUE}

# void string_global_export(string variable_name)
#
# Globally declare a string exported to the calling shell.
#alias string_global_export='export'

# void boolean_global_export(string variable_name)
#
# Globally declare a boolean exported to the calling shell.
#alias boolean_global_export='export'

# void integer_global_export(string variable_name)
#
# Globally declare an integer exported to the calling shell.
#alias integer_global_export='export -i'

# void float_global_export(string variable_name)
#
# Globally declare a float exported to the calling shell.
#alias float_global_export='export -F'

# void list_global_export(list variable_name)
#
# Globally declare a list exported to the calling shell.
#alias list_global_export='export -a'

# void map_global_export(map variable_name)
#
# Globally declare a map exported to the calling shell.
#alias map_global_export='typeset -Agx'   # "export -A" oddly fails with error;
                                          # "export -a" succeeds, however (!?!)
        # Source such file.
#       say "sourcing \"${target_filename}\"..."
#       source -- "${target_filename}"
    #FUXME: Right. We can drastically reduce the size of the "config" component,
    #now that we've made the load order much more sensible. Doing so permits us
    #to shift that function here, which seems sensible. The fewer components the
    #better, I should think.
#   source -- "${ZESHY_HOME}/config"

#, a hard
    # requirement due to *THIS* function defining the global list of all Zeshy
    # functions. (Fugly, fugly, fugly. But there seem little sane alternatives.)
    # While order should *NOT* matter here, can we ever really know?
#, and source such files.
#   ZESHY_GLOBAL_NAMES_NEW=( ${${(f)"$(typeset +g +)"}##* } )
#FUXME: Add support for sourcing all files directly under an overlay *IF* such
#overlay is not the main overlay. An important user convenience, particularly for
#smaller overlays not requiring a tree structure.
    # Make startup_zeshy() and friends.
#   append_precompile_zeshy_command precompile_zeshy_functions_startup

    # Make startup_zeshy_aliases() and startup_zeshy_globals() *AFTER DEFINING
    # ALL OTHER ZESHY-SPECIFIC FUNCTIONS*. This is a hard requirement, as this
    # function necessarily defines the list of such functions. (Fugly, fugly,
    # fugly. But there seem little sane alternatives, in this case.)
#   append_precompile_zeshy_command\
#       precompile_zeshy_functions_startup_aliases_and_globals
# [[ && -o interactive ]] &&
# List of commands to be run immediately before compiling Zeshy's digest file.
#export -Ua ZESHY_HOOKS_RUN_ON_ZESHY_PRECOMPILE
#FUXME: Rename to append_precompile_zeshy_command(). Much more natural (...the
#most important "precompile_zeshy" part comes first) and in keeping with nomenclature
#elsewhere.
    # If such overlay is *NOT* an overlay root (i.e., is neither the topmost
    # system-wide or user-specific overlays), append all scripts in such
    # overlay's directory.
#   [[ "${overlay_dir}" != ("${ZESHY_HOME}"|"${ZESHY_USER_OVERLAY_DIR}") ]] &&
#   for filename ("${overlay_dir}"/${~ZESHY_SCRIPT_NAME_GLOB}) {
#       print "autoload filename: ${filename}"
#   }
#FUXME: *UGH*. The ${ZESHY_UNIT_*} globals are no longer recorded as Zeshy
#globals. Hmm; I'm beginning to think we need, by default, to delete *ALL*
#globals matching ${ZESHY_*} *NOT* previously declared by "main", "config", or
#"autoload". Question is: how can we do this without incurring substantial
#complexity and/or fragility costs? You know, I think I'm happy to pay a slight
#efficiency cost here... but wait. You know, this is all symptomatic of a
#larger problem. If globals aren't being persisted correctly, it stands to
#reason neither are aliases or functions. Something subtly terrible is
#happening somewhere -- and we really need to fix it before releasing even an
#alpha version. To begin debugging, run "which startup_zeshy_globals"
#immediately after logging in (i.e., in a Zeshy login shell). What's the
#result? I half-guarantee it's substantially messed up. If that's *NOT* the
#case, then something may be going wrong during shell instantation and
#inheritance. Mmmhmmm.
# * On editing the "ZESHY_THEME" global in the "~/.zeshy/config/main"
#   configuration file from the default "vanilla" to, say, "cookiedough", Zeshy
#   supplants the default theme symbols it exports with those from the
#   "cookiedough" theme.
#       overlay_theme_dir="${overlay_dir}/if_theme/${ZESHY_THEME:-vanilla}"
    # Append the subdirectory of this overlay's theme directory matching the
    # user's currently configured theme to the overlay stack, if found.
#   [[ -d "${overlay_theme_dir}" ]] &&
#       ZESHY_OVERLAY_DIRNAME_STACK+="${overlay_theme_dir}"

        # If Zeshy's user configuration directory does not already contain
        # such file, copy such file from such overlay to such directory.
#       [[ ! -f "${target_filename}" ]] && {
#to Zeshy's user-specific configuration directory
# Since upgrading occurs after digest
    #compilation but "~/.zeshy/config/zeshy" would already exist,
    #${ZESHY_USER_THEME} would not be found here, provoking a zsh error (e.g.,
    #"no such variable"). Simplest way to fix this:
    #
    #* Behave defensively. Never assume a global setting to exist (e.g., always
    #  append "-" to parameter expansions). This probably needs to happen
    #  anyway, for safety and robustness. Make it so!
#FUXME: It'd be nice to harmonize config dirs "/usr/share/zeshy/src/if_config"
#and "~/

#Prepare all user configuration files in the passed overlay directory. Namely:
#
#* Recursively copy all such files not found in Zeshy''s user-specific
#  configuration directory to such directory.
#* Source such files.
    #FUXME: Rather than print each overlay, it would be *MUCH* more concise and
    #hence reasonable to only print the set of all sourced overlays after the
    #fact. To do so, simply iterate local list ${ZESHY_OVERLAY_DIRNAME_STACK} after
    #sourcing all such overlays. We never remove overlays from such stack, so
    #just iterate such stack after sourcing, ignoring the first two elements on
    #such stack (i.e., "/usr/share/zeshy/src" and "~/.zeshy/src"). For all other
    #elements:
    #
    #* Determine whether such overlay is a suboverlay of
    #  "/usr/share/zeshy/src" or "~/.zeshy/src".
    #* In either case, strip the prefixing 
    # "/usr/share/zeshy/src" or "~/.zeshy/src".
    #
    #FUXME: Nonsense. *WAY* too complex. O.K.; only spit this out if we're
    #debugging. There. DONE.
    #FUXME: Shift into a new function print_shell_variables().

    # Validate sanity.
    # Run each such command.
#Perform pre-compilation functionality subsequently defined in the main
#Zeshy overlay.

#document_function '
#void compile_zeshy_digest_to_precompile_zeshy(void)
#
#Perform last-minute functionality prior to compiling Zeshy''s digest file.
#In particular, make the final functions to be compiled into such file.
#'
#function compile_zeshy_digest_to_precompile_zeshy() {
#    # Validate sanity.
#    (( # == 0 )) || die 'expected no arguments'
#}

    # Perform post-compilation functionality subsequently defined in the main
    # Zeshy overlay.
#   append_precompile_zeshy_command precompile_zeshy_functions

    # Perform last-minute functionality prior to compiling Zeshy's digest file.
    # In particular, make the final functions to be compiled into such file.

#Prepare the current shell environment for digest compilation.
#Perform initialization prior to compiling Zeshy''s digest file.
#Dynamically synthesize functions to be compiled into the Zeshy digest file.
    # Synthesize the final set of Zeshy-specific functions.
#   precompile_zeshy_functions

#FUXME: Define document_function() here to strip the function name from the
#passed documentation, ignoring all prefixing whitespace. See "zeshy/help/help"
#for existing globs to assist doing so.
#FUXME: Actually run such commands -- somewhere near the tail of this file, yes?

    # If such documentation is prefixed by optional whitespace followed by
    # non-optional function prototype consisting of non-empty return type, non-
    # empty whitespace, non-empty function name, and left parens "(", match the
    # Get the function name prefixing such documentation.
    # Glob matching any number of non-newline characters followed by a newline,
    # thus matching the rest of a line.
    # If such documentation begins with optional whitespace followed by a
    # mandatory function prototype, match the function name from such
    # prototype.
#   line_glob="[^${newline}]#${newline}"
    # Newline character, abbreviated for readability.
#   local newline=$'\n'
#   [^$'\n']#$'\n'

# ....................{ GLOBALS                            }....................
    # * Source such file.
    # * Copy such file to Zeshy's user configuration directory, if not already
    #   containing such file.
    # If the current shell is interactive and loading the Zeshy user directory,

    #FUXME: Need to explicitly persist such maps to the current digest file.
    # Maps from Zeshy-specific aliases, functions, and globals to the absolute
    # paths of the Zeshy components defining such objects. While this Zeshy
    # component requires no such maps, others -- especially, the Zeshy help
    # component, do. Hence, this component sets such maps on behalf of other
    # components.
#   export -A\
#       ZESHY_ALIAS_NAME_TO_FILENAME\
#       ZESHY_ALIAS_SUFFIX_NAME_TO_FILENAME\
#       ZESHY_FUNCTION_NAME_TO_FILENAME\
#       ZESHY_GLOBAL_NAME_TO_FILENAME

#       compile_zeshy_digest_source "${script_filename}"
    #FUXME: Hmm; the last iteration of the above for loop sets such lists
    #already. 'tis a minor optimization at best, but... *shrug*

# void compile_zeshy_digest_source(string script_filename)
#
# Source the passed script as contributing to the current compilation of Zeshy's
# digest file. In particular, record all aliases, functions, and globals newly
# defined by such script.
#function compile_zeshy_digest_source() {
#   ZESHY_ALIAS_NAMES_NEW=( ${(f)"$(alias +)"} )
#   ZESHY_ALIAS_SUFFIX_NAMES_NEW=( ${(f)"$(alias +s)"} )
#   ZESHY_GLOBAL_NAMES_NEW=( ${(f)"$(typeset +gx)"} )

    # Source such script.
#   say "sourcing \"${script_filename}\"..."
#   source "${script_filename}"
#   say "sourced \"${autoload_function_filename}\"."

#   ZESHY_ALIAS_NAMES_NEW=( ${(f)"$(alias +)"} )
#   ZESHY_ALIAS_SUFFIX_NAMES_NEW=( ${(f)"$(alias +s)"} )
#   ZESHY_GLOBAL_NAMES_NEW=( ${(f)"$(typeset +gx)"} )

    # Obtain all aliases, functions, and globals newly defined by such script.
#   ZESHY_SCRIPT_ALIAS_NAMES=(
#       "${ZESHY_ALIAS_NAMES_NEW[@]:|ZESHY_ALIAS_NAMES_OLD}" )
#   ZESHY_SCRIPT_SUFFIX_ALIAS_NAMES=(
#       "${ZESHY_ALIAS_SUFFIX_NAMES_NEW[@]:|ZESHY_ALIAS_SUFFIX_NAMES_OLD}" )
#   ZESHY_SCRIPT_NAME_GLOBAL_NAMES=(
#       "${ZESHY_GLOBAL_NAMES_NEW[@]:|ZESHY_GLOBAL_NAMES_OLD}" )

    # Filter canonical zsh globals from the list of Zeshy-specific globals.
#   ZESHY_SCRIPT_NAME_GLOBAL_NAMES=( "${ZESHY_GLOBAL_NAMES[@]:#${~ZSH_GLOBAL_NAMES_GLOB}}" )

#   ZESHY_FUNCTION_NAME_TO_FILENAME[
#}

        # Source such script.
#       say "sourcing \"${script_filename}\"..."
#       source "${script_filename}"
#       say "sourced \"${autoload_function_filename}\"."

#       ZESHY_FUNCTION_NAME_TO_FILENAME[
        # Load the functions this file defines for subsequent compilation.
    # For each function declared in each file in the passed directory and
    # subdirectories of that directory, make a symbolical link in the digest
    # directory with that function name to that file.
#FUXME: Add support for storing defined globals and aliases in a single
#startup_zeshy_globals() function. Naturally, do so prior to calling
#precompile_zeshy_functions_startup().

#   {
#       print -rl -- "================[old function names]================" "${ZESHY_FUNCTION_NAMES_OLD[@]}"
#       print -rl -- "================[new function names]================" "${ZESHY_FUNCTION_NAMES_NEW[@]}"
#       print -rl -- "================[dif function names]================" "${ZESHY_FUNCTION_NAMES_NEW[@]:|ZESHY_FUNCTION_NAMES_OLD}"
#   } | less
    # The alias() builtin lists only regular and global names with option "+"
    # and only suffix alias names with option "+s". Split the output of both on
    # newlines to get all regular, global, and suffix aliases.

    # Delete all Zeshy-specific globals defined by and imported from the parent
    # shell, locally preserving global ${ZESHY_HOME} for subsequent use. Failure to
    # delete such globals results in a subtle issue when compiling the Zeshy digest
    # file, which persists such globals to startup_zeshy_globals() by differencing
    # the lists of globals defined before and after such compilation. Failing to
    # delete such globals ensures the two lists to be effectively identical, thus
    # preventing persistence of Zeshy globals into the Zeshy digest file.
    #
    # See undefine_variable_matching() for details on variable deletion.
    #local zeshy_home="${ZESHY_HOME-}"

    #FUXME: Hmm; should use unexported globals by default, I think.
    #Unfortunately, getting a list of unexported globals appears to be somewhat
    #more difficult. The following should work, assuming globals without
    #whitespace (which I believe may be prohibited by POSIX, yes?):

    # Zeshy declares globals to be globally exported (e.g., "typeset -gx") rather
    # than merely as globals or exports (i.e., "typeset -g" or "typeset -x"). For
    # disambiguity, list only the former.
#   ZESHY_GLOBAL_NAMES_OLD=( ${(f)"$(typeset +x)"} )
# to the current user and then compiles only such 
# selects which such aliases, functions, and globals 
# recompiles all aliases, functions, and globals defined only *AFTER*
# sourcing befor
#
# determines which currently defined zsh aliases, functions, and globals to The
# difference of 
# Zeshy decides
#
# If recompiling the Zeshy digest file and hence sourcing Zeshy scripts
# defining globals, undefine such globals prior to initializing Zeshy. Why?
# The reason may be subtle, but the logic flows like butter. Zeshy may and
# typically does declare globals to be read-only. Understandably, zsh fails on
# attempting to redefine such globals. The subsequent call to startup_zeshy()
# and hence startup_zeshy_globals() does just that, requiring such globals be
# undefined prior to such calls. Oh, 'tis all a tad silly and worm-bitten, but
# so goes life in the tranche of code trenches.
    #FUXME: Unsure this much matters, now.
    # Recompilation optimizations require Zeshy to *NOT* have been autoloaded at
    # this point... Throw an exception if Zeshy has been. While this should
    # never be the case, one can't be too careful in a bitwise world.
#   typeset -f get_zeshy_version &>/dev/null and
#       die "get_zeshy_version() and hence Zeshy already autoloaded"

    # Undefine all globals defined by sourcing Zeshy. Why? The reason is subtle;
    # the logic flows like butter. Zeshy may (and usually does) declare some
    # such globals to be read-only. Understandably, zsh prints errors on
    # attempting to redefine such globals. However, Zeshy's subsequent calling
    # of startup_zeshy() and hence startup_zeshy_globals() attempts to do just
    # that! Undefining such globals here permits there subsequent redefinition.
    # ('tis all a tad silly, but so goes life in the tranche of code trenches.)
#   undefine_global "${ZESHY_GLOBAL_NAMES[@]}"
#   typeset -p ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY
#   [[ -n "${ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY+x}" ]] and print 'hmmmmm'
    #FUXME: Fairly certain we don't want to export. No point, really. "main"
    #just blows away all imported Zeshy globals, anyway. Just revert to '+g' in
    #"alias", yes?

#   $(join_list_on_newline ZESHY_ALIAS_NAMES)
#   $(join_list_on_newline ZESHY_GLOBAL_NAMES)
    # Convert global lists of commands to be run on startup into newline-
    # delimited strings to be interpolated into the functions created below.
#   string startup_zeshy_aliases startup_zeshy_globals
#   startup_zeshy_aliases="$(join_list_on_newline ZESHY_ALIAS_NAMES)"
#   startup_zeshy_globals="$(join_list_on_newline ZESHY_GLOBAL_NAMES)"

    # Make such functions.
#   eval "function startup_zeshy_aliases() {
#   ${startup_zeshy_aliases}
#}"
#   eval "function startup_zeshy_globals() {
#   ${startup_zeshy_globals}
#}"

    # List of all currently declared aliases, functions, and exported variables
    # declared after sourcing and compiling the Zeshy codebase.
    # Synthesize additional functions after sourcing all Zeshy scripts
    # applicable to the current user (above) but before compiling the Zeshy
    # digest file (below). Such functions have dynamic definitions dependent on
    # global variables set while sourcing such scripts.
# (i.e., subsequent to
    # recursively sourcing Zeshy and hence declaring Zeshy functions)
#   is -d "${ZESHY_HOME}" si or
#       die "Zeshy home \"${ZESHY_HOME}\" not found"

#       "${^ZESHY_AUTOLOAD_DIRNAMES[@]}"/**/*~*.swp(.)
    #FUXME: Add new get_list_difference() and get_list_intersection() functions
    #to "type/function", leveraging die_unless_list() and return_list(). (Yep!)
    #Hmm; wait. We're probably better off with difference_lists_into() and
    #intersect_lists_into() functions accepting a third arg: the target list.

    # Append:
    #
    # * All subdirectories in this overlay's command directory matching commands
    #   in the user's current $PATH to the overlay stack.
    # * All files in this overlay's command directory matching such commands to
    #   the list of autoloadable files.
#   is -d "${overlay_command_dir}" si and {
        # List of all paths in this overlay's command directory corresponding to a
        # currently installed executable file in the $PATH. Dismantled, this is:
        #
        # * "${ZESHY_AUTOLOAD_COMMAND_DIR}/"*, listing each file in Zeshy's
        #   command directory.
        # * "(e{[[ ... ]]})", excluding files failing the following test:
        #   * "$REPLY", the current file.
        #   * ":t", the basename of such file.
        #   * ":c", the absolute path to a command in the $PATH with such name.
        #   * "== /*", true only when ":c" succeeds in finding such a command.
        # * "or true", ignoring failure (if ":c" fails finding such a command).
#       list overlay_command_paths; overlay_command_paths=(
#           "${overlay_command_dir}/"*(e{'[[ $REPLY:t:c == /* ]]'})
#       ) or true

#       # Append all files in this directory to the list of autoloadable files.
#       ZESHY_AUTOLOAD_FILENAMES+=( "${^overlay_command_paths[@]}"(.) )

#       # Append all directories in this directory to the overlay stack.
#       ZESHY_OVERLAY_DIRNAME_STACK+=( "${^overlay_command_paths[@]}"(/) )
#   }

#FUXME: Sourcing configuration files *REALLY* needs to happen prior to
#compilation, for obvious reasons. O.K.; so, that's taken care of. But we need
#to also ensure that if we *DON'T* perform compilation we still source such files.
#Do:
#    source "${ZESHY_USER_CONFIG_DIR}/"*

    # If "lsb_release" is installed, run it to obtain the distro name of the
    # current operating system. Most modern distros provide such executable
    # for exactly this purpose. While crude alternatives to "lsb_release" do
    # exist (e.g., globbing for filenames matching /etc/*release), it hardly
    # seems worth the buggy effort so early in the bootstrap process.
    # Dismantled, this is:
    #
    # * "${:-lsb_release}", expanding to the string "lsb_release".
    # * "${...:c}", expanding to the absolute path of "lsb_release" if installed
    #   in the current $PATH or only "lsb_release" otherwise.
    # * "-x", returning true if such path is executable and hence installed.
    #   Unless the current directory contains an executable "lsb_release", this
    #   returns true only if ":c" expanded to an absolute path.
#   if is -x "${${:-lsb_release}:c}" si; then
        # Lowercase the distro name for dirname comparison.
#       string distro_name autoload_distro_dir
#       distro_name="${(L)$(lsb_release -si)}"
#       autoload_distro_dir="${ZESHY_AUTOLOAD_DISTRO_DIR}/${distro_name}"
#       print "autoload_distro_dir: ${autoload_distro_dir}"

        # If Zeshy provides distro-specific components, append distro-
        # specific dirnames and filenames to the corresponding lists.
#       if is -d "${autoload_distro_dir}" si; then
#           ZESHY_AUTOLOAD_DIRNAMES+="${autoload_distro_dir}/always"
#           ZESHY_AUTOLOAD_FILENAMES+=(
#               "${autoload_distro_dir}/if_pathable/"*(e{'[[ $REPLY:t:c == /* ]]'})
#           ) or true
#       fi
#   fi
    # List of directories recursively containing zsh scripts containing
    # autoloadable functions to be compiled into Zeshy's digest file.
#   ZESHY_AUTOLOAD_DIRNAMES+="${ZESHY_AUTOLOAD_CORE_DIR}"

#   string overlay_dir="${1}"
#   is -d "${overlay_dir}" si or
#       die "\"${overlay_dir}\" not found or not a directory"
#   string source_filename="${1}" target_filename basename
#   is -f "${source_filename}" si or
#       die "\"${source_filename}\" not found or not a file"
#   basename="$(basename "${source_filename}")"
#   target_filename="${ZESHY_USER_CONFIG_DIR}/${basename}"

    # If not found, make the user-specific Zeshy configuration (and hence dot)
    # directory and file.
#   is -d "${ZESHY_USER_CONFIG_DIR}" si or mkdir -p "${ZESHY_USER_CONFIG_DIR}"
#   is -f "${target_filename}" si or {
#       say "fabricating \"${target_filename}\"..."
#       cp "${source_filename}" "${ZESHY_USER_CONFIG_DIR}/"
#   }

    #FUXME: We need to do this in "src/import", instead. Probably just:
    #source "${ZESHY_USER_CONFIG_DIR}/"*
    # Import such file, hopefully defining all globals declared above.
#   source "${target_filename}"
    # List of directories recursively containing zsh scripts containing
    # autoloadable functions to be compiled into Zeshy's digest file.
#   list ZESHY_OVERLAYS
#   ZESHY_OVERLAYS=( "${ZESHY_AUTOLOAD_CORE_DIR}" )

    # Recursively compile the Zeshy codebase specific to current system and user
    # state starting from (in order):
#compile_zeshy_theme() {
#}

    # List of Zeshy overlays (i.e., system- and user-specific directories
    # obeying the same structure as Zeshy's top-level "./src" directory). All
    # files and directories in a Zeshy overlay are ignored except those with the
    # following Zeshy-specific names:
    #
    # * "always", a directory recursively containing only:
    #   * Subdirectories with arbitrary names and nesting, purely for
    #     organizational purposes. (Optional.)
    #   * Zeshy scripts, to be unconditionally compiled into Zeshy's digest
    #     file. Scripts may reside directly in the top-level "always" directory
    #     or under optional subdirectories. In either case, Zeshy automatically
    #     finds and compiles all zsh functions in all such files.
    #
    # recursively containing zsh scripts containing
    # autoloadable functions to be compiled into Zeshy's digest file.

    #FUXME: O.K.; technically, this works -- but not here, as we have yet to
    #autoload Zeshy. This is a fairly complex operation. (Can we reduce it to
    #more efficient zsh builtins and ideally simply glob matching?)
    # Determine whether or not this process is running is a cronjob. This is
    # adapted from this itworld.com article, "Am I being run by cron?":
    #        http://www.itworld.com/Comp/3380/nls_unixcron041209/index.html
    #
    # Do this prior to saying imports, as the say() function requires this.
#    string cron_pids="$(pgrep -x cron)"
#    integer grandparent_pid="$(ps -eo ppid,pid= | grep " ${PPID}$" | awk '{print $1}')"
#    ZESHY_IS_CRONJOB="$(one_if match_multiline "^${cron_pids}$" "${grandparent_pid}")"
#   echo "cron: ${ZESHY_IS_CRONJOB}; cron_pids: ${cron_pids}; gpid: ${grandparent_pid}"

# All monitoring and modification is silent, efficient, and entirely automatic.
# to accomodate
# such changes. Such are silent, efficient, and entirely automatic.
# efficiently monitors such state for changes,      # * "${distro_command:c}", expanding to the absolute path of
    #   "lsb_release" if installed or only "lsb_release" otherwise.
#   string distro_command='lsb_release'
#   if is -x "${distro_command:c}" si; then
#FUXME: This is concise enough now to be merged back into "module", which should
#incidentally be renamed "load" (...I suppose).

    #FUXME: Test for pathological cases: namely, if there *IS* a Zeshy function
    #currently declared that shouldn't be (e.g., get_zeshy_version()). In such
    #case, I'm unsure what the proper response is. We currently th
    #FUXME: See "gwydden/output" for "TODO" comments on substantially
    #improving the theme support.

# ....................{ AUTOLOADS                          }....................
#FUXME: Keep the old method about, for a bit.
    # List set of autoloadable function names defined in such listed files.
#   list_set autoload_function_names
#   say "recursively sourcing \"${ZESHY_HOME}\"..."

    # Load "mapfile", a core zsh module mapping file contents to map values.
    # It's both brilliant and efficient, an unhappily rare combination. It's
    # also remarkably dangerous, since accidentally unsetting keys from this
    # map deletes the corresponding files. Hence, we immediately unload this
    # module after use.
#   zmodload zsh/mapfile

    #FUXME: Terrible! Utterly. When enabled, this sporadically fails with an
    #inscrutible error resembling:
    #    "(anon):82: bad math expression: operand expected at `/usr/share...'"
    #File a bug report if this is still the case under recent zsh versions.
    # Forcibly prevent harmful ${mapfile} and hence filesystem changes.
#       typeset -r mapfile
#       print ${mapfile[/tmp/config]}
#       print -rl -- ${(f)mapfile[/usr/share/zeshy/src/autoload/if_pathable/7z]}

    # For each function declared in each file in the passed directory and
    # subdirectories of that directory, make a symbolical link in the digest
    # directory with that function name to that file. Dismantled, this is:
    #
    # * "${^ZESHY_AUTOLOAD_DIRNAMES[@]}", expanding to each directory in the list.
    # * "/**/*",  recursively expanding to each file of this directory.
    # * "~*.swp", excluding temporary files.
    # * "(.L+0)", including only non-empty plain files. "mapfile" currently
    #   fails with error on attempting to expand an empty plain file,
    #   arguably a bug. Nonetheless, respect its wishes.
#   for autoload_function_filename (
#       "${^ZESHY_AUTOLOAD_DIRNAMES[@]}"/**/*~*.swp(.L+0)
#       "${ZESHY_AUTOLOAD_FILENAMES[@]}"
#   ) {
        # Load the functions this file defines for subsequent compilation.
#           say "sourcing \"${autoload_function_filename}\"..."
#       source "${autoload_function_filename}"

        # Append to the list of autoloadable functions all:
        #
        # * Explicitly defined functions of form "${function_name}() {".
        # * Implicitly defined interactive aliases of form
        #   "alias_cli ${alias_name}=${alias_expansion}".
        #
        # Dismantled, this is:
        #
        # * "${(f)mapfile[...]}", expanding to each line of this file.
        # * "${(M)", ":#", and "}", excluding lines not matching the
        #   following extended glob expression:
        #   * "\(\) \{", followed by "() {", signifying a function.
        #   * "[[:alnum:]_-]##", greedily matching a substring of one or
        #     more alphanumeric, underscore, and hyphen characters.
        # * "${" and "%%\(*}", excluding the "() {" suffixing such lines.
        # * "=?*", greedily matching "=" followed by one or more characters.
        #
        # Note: *DO NOT QUOTE THIS EXPRESSION*. Doing so silently expands
        # this expression to the empty string, though we have no idea why!
        # Also, do not quote the expansion of ${autoload_function_file} in
        # this expression. Doing so causes "mapfile" to interpret such
        # quotes as prefixing and suffixing such filename, thus raising an
        # exception on not finding such "munged" filename.
#       autoload_function_names+=(
#           ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|alias_cli [[:alnum:]_-]##=?)*}#alias_cli }%%[(=]*}
#               ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|alias_cli [[:alnum:]_-]##=?)*}#alias_cli }%%[(=]*}
#       )
#           say "sourced \"${autoload_function_filename}\"."
#   }

    # Unload "mapfile", for safety.
#   zmodload -u zsh/mapfile

    #FUXME: Not quite right. If the user disables
    #${ZESHY_IS_WRAPPING_CORE_RUNNABLES}, then some interactive aliases will not
    #actually be defined. zcompile() *FAILs* when fed non-extant function names.
    #To rectify this, we really want to make the prior loop sourcing each file
    #and matching "autoload_function_names" much, much smarter. First, stop
    #grepping file contents. If you consider it, all you really need to do is:
    #
    #* Before sourcing such file, stuff the set of all function names into a list.
    #* After! sourcing such file, diff! the set of all function names against
    #  such list. A new subtract_list_from_list() function would be of help,
    #  here. The resulting list is the set of all function names such file
    #  defined. This method may or may not be slower, depending on zsh. What's
    #  clear, however, is that it's *MUCH* more resilient and *MUCH* less hacky.
    #
    #Ah-ha! zsh 5.0 bundles a "${left_list:|right_list}" operator subtracting
    #the two lists. This implies a hard dependency.
#   is "$(whence -w -- "${1}")" == *': function' si
#   list ZESHY_FUNCTION_NAMES_OLD; ZESHY_FUNCTION_NAMES_OLD=( $(typeset -f +) )

    # Recompile all such loaded function definitions into the digest file.
#       print "autoload function names: ${autoload_function_names[@]}"
#       say "compiling \"${ZESHY_USER_DIGEST_FILE}\"..."
#   zcompile -c "${ZESHY_USER_DIGEST_FILE}" "${autoload_function_names[@]}"

# ....................{ WASTELANDS                         }....................
        #FUXME: This should be a "list_set" rather than "list", for a slight
        #efficiency (and clarity (and stability!)) improvement.
#
        # For clarity, temporarily set the script name to Zeshy.
#       string ZESHY_SCRIPT_NAME='zeshy'

#       zcompile "${ZESHY_USER_DIGEST_FILE}" "${ZESHY_USER_DIGEST_DIR}"/**/*(@)
#               ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|alias_cli [[:alnum:]_-]##=?)*}#alias_cli }%%( \(|\=)*}
            #FUXME: I believe these two mappings can be condensed into one.
#               ${(f)mapfile[/usr/share/zeshy/src/autoload/if_pathable/7z]}
#               ${(f)mapfile[${autoload_function_filename}]}
#               ${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|alias_cli [[:alnum:]_-]##=?)*}
#               ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|alias_cli [[:alnum:]_-]##=?)*}#alias_cli }%%( \(|=)*}
#               ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#alias_cli [[:alnum:]_-]##=?*}#alias_cli }%%\=*}
#               ${${(M)${(f)mapfile[${autoload_function_filename}]}:#[[:alnum:]_-]##\(\) \{}%%\(*}
#               ${${${(M)${(f)mapfile[/usr/share/zeshy/src/autoload/if_pathable/7z]}:#alias_cli [[:alnum:]_-]##=?*}#alias_cli }%%\=*}
#           print "alias_clies:"
#           print -rl -- ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#alias_cli [[:alnum:]_-]##=*}#alias_cli }%%\=*}

# --------------------( TODO                               )--------------------
# * Ultimately, Zeshy should auto-compile the recursive entirety of all Zeshy
#   function definitions into a single so-called "digest" file at, say,
#   "~/.zeshy/digest.zwc". Such a file is autoloadable by:
#       
#       # ...implicitly autoloading such digest.
#       fpath=( "~/.zeshy/digest.zwc" "${fpath[@]}" )
#
#       # ...explicitly autoloading such digest.
#       autoload -Uw "~/.zeshy/digest.zwc"
#
#   I'm unsure if the former supercedes the latter. (Probably not, no.) Both
#   required, perhaps.
#
#   What's nice about this is that such a digest file appears to come prepended
#   with a list of all functions defined by such digest, thus rendering
#   autoloading of digest files terrifically fast. Auto-generating such a digest
#   on any change to any Zeshy file or directory is, unfortunately, not quite so
#   easy. We'll need to write something resembling:
#
#       if is "$(get_path_mtime "~/.zeshy/digest.zwc") equals SOMETHING si; then
#           zcompile "~/.zeshy/digest.zwc" "${ZESHY_HOME}/src/"**/*(.)
#       fi
#
#   However, it's unclear just how aggregating multiple files into one handles
#   initialization code. Clearly, it either doesn't or does but simply lumps all
#   initialization together. Either case is bad. We'll need to rewrite Zeshy to:
#
#   * Perform all non-costly initialization up-front in Zeshy .main or core.
#   * Perform all costly initialization in the functions requiring such
#     initialization as the first line of such functions. You know that grind...
# * Ugh. Current symlink technique doesn't quite work. It's quite close, though.
#   A working system either:
#   * Harvests the set of all function names using the current technique *AND*
#     manually recursively sources all Zeshy files (easy) *AND* uses the "-c"
#     flag to zcompile to compile all such function names into the digest
#     (easy). This isn't quite perfect, but it seems pretty darn close.
#   * Alternatively, create new temporary files in "~/.zeshy/digest/" defining
#     each such function separately by matching out the definition of such
#     functions from the existing files. This is somewhat more work, and
#     demonstrably of no greater benefit than the prior method. I reck'n it'd
#     work, but I'd rather try to pick the prior low-hanging fruit, first.


    #     zrecompile -p\
    #         -R ~/.zshrc --\
    #         -M ~/.zcompdump --\
    #         ~/zsh/comp.zwc ~/zsh/Completion/*/_*
    #
    #This does everything for us. Swag, no? Memory map everything, of course.
    #Oh, and the latter line is the one that applies to us. To quote: "re-create
    #the file ~/zsh/comp.zwc if any of the files matching the given pattern is
    #newer than it." We'll need to dynamically construct the arguments to be
    #passed for the command-specific directories. Shouldn't be hard:
    #
    #     list zrecompile_args
    #     zrecompile_args=( "${generic_dir}.zwc" "${generic_dir}"/**/*(.) )
    #     for command_dir in "src/auto/command"/*(/); do
    #         zrecompile_args+=( "${command_dir}.zwc" "${command_dir}"/**/*(.) )
    #     done
    #     print "za: ${zrecompile_args[@]}"

    # Automatically recompile all compiled files in function path "${FPATH}" whose
    # corresponding uncompiled files have since changed.
    #autoload -U zrecompile
#   zrecompile -p

        # Make the digest directory, if needed.
#       say "composing \"${ZESHY_USER_DIGEST_DIR}\"..."
#       mkdir -p "${ZESHY_USER_DIGEST_DIR}"

        # Remove all existing symbolic links in the digest directory, if needed.
#       list digest_symlinks; digest_symlinks=( "${ZESHY_USER_DIGEST_DIR}/"*(@) )
#       is -n "${digest_symlinks}" si and rm "${digest_symlinks[@]}"


#           print "autoload_function_file=${autoload_function_file}"
#           for autoload_function_name\
#               ( ${${(M)${(f)mapfile[${autoload_function_file}]}:#[[:alnum:]_-]##\(\) \{}%%\(*} ) {
#               ln -s\
#                   "${autoload_function_file}"\
#                   "${ZESHY_USER_DIGEST_DIR}/${autoload_function_name}"
#           }

#       is_shell_terminal and print 'Yum!'
#       zcompile -c "${ZESHY_USER_DIGEST_FILE}" is_shell_terminal

#   zstat +mtime "${1}"
    # Dismantled, this is:
    #
    # * "${pathname}"/**/*, all files and subdirectories of this directory.
    # * "om", such files and subdirectories in ascending order by mtime.
    # * "[1]", the first and hence newest such file or subdirectory.
#   zstat +mtime "${pathname}"/**/*(om[1])

#   touch -m --date=@"${mtime}" "${pathname}"

# void _populate_zeshy_digest_dir_with(string dirname)
#
# Populate Zeshy's digest directory with one symbolic link for each autoloadable
# function in each file of the passed directory, recursively.
#_populate_zeshy_digest_dir_with() {
#    die_unless_one_arg 'expected exactly one dirname'
#
#    # For each function declared in each file in the passed directory and
#    # subdirectories of that directory, make a symbolical link in the digest
#    # directory with that function name to that file. Dismantled, this is:
#    #
#    # * "/**/*", recursively expanding to each file and subdirectory of the
#    #   passed directory.
#    # * "~*.(swp)", excluding temporary files.
#    # * "(.)", including only plain files.
#    for autoload_function_file\
#        ( "${ZESHY_AUTOLOAD_ALWAYS_DIR}"/**/*~*.(swp)(.) ) {
#        # Dismantled, this is:
#        #
#        # * "${(f)mapfile["${autoload_function_file}"]}", iteratively
#        #   expanding to each line of this file.
#        # * "${(M)", ":#", and "}", excluding lines not matching the
#        #   following extended glob expression:
#        #   * "[[:alnum:]_-]##", greedily matching a substring of one or
#        #     more alphanumeric, underscore, and hyphen characters.
#        #   * "\(\) \{", followed by "() {", signifying a function.
#        # * "${" and "%%\(*}", excluding the "() {" suffixing such lines.
#        for autoload_function_name\
#            ( "${${(M)${(f)mapfile["${autoload_function_file}"]}:#[[:alnum:]_-]##\(\) \{}%%\(*}" ) {
#            ln -s\
#                "${autoload_function_file}"\
#                "${ZESHY_USER_DIGEST_DIR}/${autoload_function_name}"
#        }
#    }
#}

#       for autoload_command_filename\
#           ( "${ZESHY_COMMAND_DIR}/"*(e{'[[ $REPLY:t:c == /* ]]'}) ) {
#           ZESHY_AUTOLOAD_FILENAMES+=( "${autoload_command_filename}" )
#       }

        #FUXME: Replace with an "rm -rf" once confident this works.
#           mv "${ZESHY_USER_DIGEST_DIR}" "${ZESHY_DOT_DIR}/tmp/$(date +'%N')"

#_zeshy_autoload_digest_old() {
    #FUXME: This only applies to developer systems. In production, Zeshy
    #requires only one initial compilation, thus eliminating the cost of such
    #recompilation. Ah; I wonder. Wouldn't a "zrecompile -p" immediately after
    #declaring the "fpath" do this, assuming we'd first compiled all necessary
    #digests? If so, that would suggest we'd only need a simple test for
    #
    #    if not is_file "${ZESHY_USER_DIGEST_FILE}"; then
    #       # Compile everything anew here! Don't bother checking mtimes.
    #    fi
    #
    #Then, a zrecompile should handle the rest, yes? That would be considerably
    #more efficient, given zsh's C-backed implementation. Ah; O.K., it gets even
    #better. We can entirely reduce this if-conditional to a zrecompile() call
    #resembling the given example:
    #
    #     zrecompile -p\
    #         -R ~/.zshrc --\
    #         -M ~/.zcompdump --\
    #         ~/zsh/comp.zwc ~/zsh/Completion/*/_*
    #
    #This does everything for us. Swag, no? Memory map everything, of course.
    #Oh, and the latter line is the one that applies to us. To quote: "re-create
    #the file ~/zsh/comp.zwc if any of the files matching the given pattern is
    #newer than it." We'll need to dynamically construct the arguments to be
    #passed for the command-specific directories. Shouldn't be hard:
    #
    #     list zrecompile_args
    #     zrecompile_args=( "${generic_dir}.zwc" "${generic_dir}"/**/*(.) )
    #     for command_dir in "src/auto/command"/*(/); do
    #         zrecompile_args+=( "${command_dir}.zwc" "${command_dir}"/**/*(.) )
    #     done
    #     print "za: ${zrecompile_args[@]}"
#    say "detecting \"${ZESHY_USER_DIGEST_FILE}\"..."
#    integer zeshy_mtime=$(get_path_mtime_recursive "${ZESHY_SRC_HOME}")
#    if not is_file "${ZESHY_USER_DIGEST_FILE}" or
#        (( zeshy_mtime != $(get_path_mtime "${ZESHY_USER_DIGEST_FILE}") )); then
#        say "compiling \"${ZESHY_USER_DIGEST_FILE}\"..."
#        # ...the "-." matches all files and symbolic links to files.
#        zcompile "${ZESHY_USER_DIGEST_FILE}" "${ZESHY_SRC_HOME}"/**/*~*.(swp|zwc)(-.)

#        # Set the mtime of the compiled script to that of the uncompiled
#        # script to ensure the above conditional fails on future imports.
#        set_path_mtime "${ZESHY_USER_DIGEST_FILE}" "${zeshy_mtime}"
#    fi

    # Declare all functions provided by the digest file to be autoloadable.
#    autoload -w "${ZESHY_USER_DIGEST_FILE}"

    # Prefix "${FPATH}" with the absolute path to the digest file, ensuring zsh
    # searches such file for the definition of such functions first. Oddly, zsh
    # has no means of directly associating the two.
#    fpath=( "${ZESHY_USER_DIGEST_FILE}" "${fpath[@]}" )
#}
