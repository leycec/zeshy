#!/usr/bin/env zsh

declare_parcel_as_script_with_stdin <<'-/-'
Configure CLI aliases. See alias_cli() for further details.

== See Also ==

* print_aliases_cli(), listing all current interactive aliases including
  abbreviations and substitutions.
* alias_cli_abbreviation(), for further details on interactive abbreviations.
* alias_cli_substitution(), for further details on interactive substitutions.
-/-

# ....................{ ABBREVIATIONS                      }....................
declare_global_with_stdin <<'/---'
map ZESHY_ALIAS_CLI_ABBREVIATIONS

List of aliases to be expanded only when run directly from the command line,
abbreviating but _never_ replacing existing *runnables* (i.e., external commands
or `zsh` aliases, builtins, or functions) and hence referred to as *CLI
abbreviation aliases*: e.g.,

.${ZESHY_ALIAS_CLI_ABBREVIATIONS}
==========================================
[source]
------------------------------------------
# This is a normal zsh alias, always expanding "lr" to "ls -lR".
>>> alias lr="ls -lR"

# This is a CLI abbreviation alias, only expanding "lr" to "ls -lR" if:
#
# * Run directly from the command line.
# * "lr" is not already an existing runnable. If "lr" is an existing
#   runnable, `zeshy` iteratively tries the following alias names until
#   either finding a name not already taken by an existing runnable or
#   exhausting all available choices, in which case an exception is thrown:
#   "lsr", "lsre", "lsrec", "lsrecu", "lsrecur", "lsrecurs", "lsrecurse".
>>> alias_cli_abbreviation {l}s{r}ecurse="ls -lR"
------------------------------------------
==========================================

== Comparison to CLI Substitution Aliases ==

By contrast, the CLI substitution aliases listed by
${ZESHY_ALIAS_CLI_SUBSTITUTIONS} _always_ replace existing runnables. Call
print_aliases_cli() to list all currently defined CLI aliases -- abbreviations,
substitutions, or otherwise.

CLI abbreviation aliases are ideal for abbreviating the typically longer human-
readable function names called by shell scripts to the typically shorter human-
typeable alias names expanded at the command line (e.g., abbreviating
list_path_recursively_verbosely_with_options() to simply `lr`).

== Comparison to Normal zsh Aliases ==

For typical uses (e.g., abbreviating frequently typed commands at the command
line), most users will probably find CLI aliases to be safer than and hence
preferable to normal `zsh` aliases. The latter never change, even when the
underlying runnables such aliases expand to are renamed, removed, or otherwise
rendered unavailable. CLI aliases, however, dynamically adapt on each `zeshy`
digest recompilation to reflect current system and user state -- including:

* Whether such alias is expanded directly from the command line. If such alias
  is expanded from any other context (e.g., a non-interactive shell script) and
  such alias is:
** An abbreviation, an exception will be thrown.
** A substitution, the runnable being substituted will be silently run instead.
* Whether such alias abbreviates or substitutes an existing runnable. If:
** Such runnable exists and such alias is an abbreviation, an exception will be
   thrown on the next recompilation of `zeshy`\'s user digest (since
   abbreviations never replace existing runnables).
** Such runnable does _not_ exist and such alias is a substitution, an exception
   will be thrown on the next recompilation of `zeshy`\'s user digest (since
   substitutions always replace existing runnables).

== CLI Alias Names ==

The actual name `zeshy` assigns each CLI alias dynamically depends on current
system and user state, including:

* Which directories are in the current user's ${PATH}.
* Which commands are currently installed to such directories.
* Which `zsh` aliases and functions are currently defined.

=== Embedded CLI Abbreviation Alias Names ===

CLI abbreviation and substitution aliases both extend normal `zsh` aliases by
permitting `{`- and `}`-delimited substrings to be embedded within alias names.
Such substrings denote the preferred CLI abbreviation name for such alias. If
such abbreviation name has not already been taken by an existing runnable on the
current system, `zeshy` abbreviates such alias to such name; else, `zeshy`
incrementally lengthens such name until finding the shortest abbreviation name
not already taken by an existing runnable on the current system. (Specifically,
`zeshy` iteratively shifts the leftmost `}` in such name to the right one
character and tries again until finding a name not already an existing runnable
_or_ shifting the leftmost `}` past the `=`, in which case an error is printed.)

Embedding abbreviation names thus improves portability and safety. In general,
_all_ CLI abbreviation and substitution alias names should contain at least one
`{`- and `}`-delimited substring: e.g.,

.Interactive Abbreviation Search Algorithm
==========================================
[source]
------------------------------------------
# The specified key-value pair below induces the following search:
#
# * First, try "md". If "md" is not already an existing runnable name, this is
#   equivalent to "alias_cli md=make_dir_if_not_found_with_options".
# * Else, try "mkd". If "mkd" is not already an existing runnable name, this is
#   equivalent to "alias_cli mkd=make_dir_if_not_found_with_options".
# * Else, try "mkdi". If "mkdi" is not already an existing runnable name, this
#   is equivalent to "alias mkdi=make_dir_if_not_found_with_options".
# * Else, repeat until eventually trying "mkdirparents". Assuming that also is
#   an existing runnable name (however unlikely that may be), print an error.
#
# In any case, `zeshy` continues to the next key-value pair.
>>> ZESHY_ALIAS_CLI_ABBREVIATIONS=(
...            ...
...     {m}k{d}irparents "make_dir_if_not_found_with_options"
...            ...
... )
------------------------------------------
==========================================
/---
ZESHY_ALIAS_CLI_ABBREVIATIONS=(
    # Core.
    {c}h{m}od{r}ecursive  'set_path_permissions_recursively_with_options'
    {c}h{o}wn{r}ecursive  'set_path_user_and_group_recursively_with_options'
    {c}p{r}ecursive       'copy_path_recursively_with_options'
    {lns}ymbolic          'make_link_symbolic_with_options'
    {l}s{l}ong            'list_path_verbosely_with_options'
    {l}s{l}ong{r}ecursive 'list_path_recursively_verbosely_with_options'
    {l}s{r}ecursive       'list_path_recursively_with_options'
    {r}m{r}ecursive       'remove_path_recursively_with_options'

    # Calendar.
    {cal}endar{q}uarter 'print_calendar_quarter'
    {cal}endar{y}ear    'print_calendar_year'

    # Compressed archives.
    {e}xtract{a}rchive 'extract_archive'
    {l}ist{a}rchive    'list_archive'
    {m}ake{a}rchive    'make_archive'

    #FIXME: Actually, this doesn't quite work. We'll need to wire such aliases
    #with the same completions as such builtins. Investigate.
    # Directory stack. (Use "zsh" primitives rather than zeshy functions, for
    # the moment; try hitting <Tab> after typing either to see why.)
    {c}hange{b}ackward 'rotate_dir_stack_backward'
    {c}hange{f}orward  'rotate_dir_stack_foreward'
#   {c}hange{b}ackward 'cd -'
#   {c}hange{f}orward  'cd +'

    # File counters.
    {wcl}ine{r}ecursive 'get_file_text_line_count_recursively'

    # File grepping.
    {g}rep{i}nsensitive 'grep_path_caselessly_with_options'
    {g}rep{r}ecursive   'grep_path_recursively_with_options'
    {g}rep{r}ecursive{i}nsensitive 'grep_path_recursively_caselessly_with_options'

    # Kernel modules.
    {mod}ule{p}rint  'print_kernel_module'
    {mod}ule{l}oad   'load_kernel_module'
    {mod}ule{u}nload 'unload_kernel_module'

    # Libraries.
    {l}s{b}inary{e}xecutable 'print_binary_executable'

    # Shell lifecycle.
    {e}xit{z}sh      'exit_zsh'
    {re}start{z}eshy 'restart_zeshy'
    {re}startz{s}h   'restart_zsh'

    # zeshy internals.
    {h}elp 'print_zeshy_help'

    #FIXME: Expand to proper zeshy functions.
    {d}ate 'date'
    {k}ill{a}ll    'killall'
    {k}ill{a}ll{9} 'killall -9'

    #FIXME: Works great... except that it throws a TRAPZERR-induced exception on
    #*EVERY* suspension back to the command-line. Dig into this a bit further.
    #(Clearly, this should probably be simply ignored.)
    {f}g 'fg'
)

# ....................{ SUBSTITUTIONS                      }....................
# See the section above for further details on "="-delimited alias syntax.

declare_global_with_stdin <<'/---'
map ZESHY_ALIAS_CLI_SUBSTITUTIONS

List of aliases to be expanded only when run directly from the command line,
_always_ replacing existing *runnables* (i.e., external commands or `zsh`
aliases, builtins, or functions) and hence referred to as *CLI substitution
aliases*. Such aliases are ideal for wrapping conventional runnables with more
powerful functions (e.g., replacing `ls` with list_path_with_options()).

By contrast, the CLI abbreviation aliases listed by
${ZESHY_ALIAS_CLI_ABBREVIATIONS} _never_ replace existing runnables. See such
list for further details on usage, syntax, and motivation.
/---
ZESHY_ALIAS_CLI_SUBSTITUTIONS=(
    #FIXME: Clearly, any function called below *MUST* be suffixed by
    #_with_options() and implemented accordingly. We're about halfway there, I'd
    #say. Not a pleasant chore, but it really must be done for `zeshy` to be
    #widely applicable. Start with the heavy hitters: "grep", "cat", and so on.
    #"mount" will probably be an absolute nightmare, so save for last! :)

    # Unabbreviated substitutions.
    cd  'set_dir_with_options'
    du  'print_path_size_sorted_with_options'
    rm  'remove_file_with_options'

    # Abbreviated substitutions.
    {ca}t     'print_file_text'
    {c}h{m}od 'set_path_permissions_with_options'
    {c}h{o}wn 'set_path_user_and_group_with_options'
    {c}p      'copy_path_with_options'
    {di}rs    'print_dir_stack'
    {fd}isk   'check_disk'
    {fr}ee    'print_memory_use'
    {g}rep    'grep_path_with_options'
    {l}s      'list_path_with_options'
    {l}s{m}od 'print_kernel_modules'
    {m}k{d}ir 'make_dir_if_not_found_with_options'
    {mo}unt   'mount_nicely'
    {m}v      'move_path_with_options'
    {r}m{d}ir 'remove_dir_empty_with_options'
    {umo}unt  'unmount_point'

    #FIXME: Expand to a proper zeshy function.
    df 'df --human-readable --sync'
)

declare_global_with_stdin <<'/---'
map ZESHY_ALIAS_CLI_SUBSTITUTIONS_IF_RUNNABLE

List of aliases to be expanded only when run directly from the command line,
ignoring aliases whose name (sans `{` and `}` delimiters) is _not_ the name of
an existing *runnable* (i.e., external command or `zsh` alias, builtin, or
function). See ${ZESHY_ALIAS_CLI_ABBREVIATIONS} for further details.
/---
ZESHY_ALIAS_CLI_SUBSTITUTIONS_IF_RUNNABLE=(
    #FIXME: This should be an abbreviation, obviously. Consequently, we'll need
    #an ${ZESHY_ALIAS_CLI_ABBREVIATIONS_IF_PATHABLE} -- or we would if I still
    #considered this a fine idea. Clearly, it's not. This is the only such alias
    #declared here or anywhere! Just shift this into a new configuration file
    #"if_pathable/vim/if_config/pathable/vim" and remove this global. Done.
    #FIXME: Incidentally, all "if_config/if_pathable/" subdirectories should be
    #renamed to "if_config/pathable/". They're *NOT* conditional.
    {v}im       'vim'                          # ViM editor.
    {v}im{d}iff 'vimdiff'                      # ViM merger.
)

declare_global_with_stdin <<'/---'
list ZESHY_CLI_SUBSTITUTION_NAMES_IF_RUNNABLE_RUN_DISOWNED

List of *runnables* (i.e., external commands or `zsh` aliases, builtins, or
functions) to be *disowned* (i.e., _not_ terminated on termination of their
parent shell) when run from directly from the command line, ignoring nonextant
runnables. Since CLI commands should be terminated on termination of their
parent shell, consider listing only GUI and headless daemon commands here. See
See ${ZESHY_ALIAS_CLI_ABBREVIATIONS} for further details: e.g.,

.${ZESHY_CLI_SUBSTITUTION_NAMES_IF_RUNNABLE_RUN_DISOWNED}
==========================================
[source]
------------------------------------------
# The specified list element below induces a search as described under
# ${ZESHY_ALIAS_CLI_ABBREVIATIONS}. Assuming "calibre" is installed in the
# current user's ${PATH} and "cali" is *NOT* an existing runnable, this is
# equivalent to:
#
#     alias_cli_substitution calibre="run_command_disowned calibre"
#     alias_cli_abbreviation cali="run_command_disowned calibre"
#
# If "calibre" is *NOT* installed, the element is ignored. If "cali" is an
# existing runnable, `zeshy` iteratively attempts to abbreviate such runnable
# to "calib" and "calibr" in that order.
#
# In any case, `zeshy` continues to the next list element.
>>> ZESHY_CLI_SUBSTITUTION_NAMES_IF_RUNNABLE_RUN_DISOWNED=(
...        ...
...     {cali}bre
...        ...
... )
------------------------------------------
==========================================
/---
ZESHY_CLI_SUBSTITUTION_NAMES_IF_RUNNABLE_RUN_DISOWNED=(
    {abi}word                            # AbiWord processor.
    {acr}oread                           # Adobe Acrobat.
    {ama}rok                             # Amarok music player.
    {aud}acity                           # Audacity audio editor.
    {ca}li{b}re                          # Calibre eBook manager.
    {ch}rom{e}                           # Google Chrome browser.
    {ch}romium                           # Google Chromium browser.
    {dvds}tyler                          # DVDStyler DVD creator.
    dia                                  # GNOME Dia.
    {ecl}ipse                            # Eclipse IDE.
    {ema}cs                              # GNU Emacs IDE.
    {f}ire{f}ox                          # Mozilla Firefox browser.
    {f}ile{li}ght                        # KDE Filelight.
    {fo}nt{fo}rge                        # FontForge.
    {g}ee{q}ie                           # Geeqie image viewer.
    {gl}x{g}ears                         # GLXGears OpenGL tester.
    {gim}p                               # GNU Image Manipulation Program.
    {gv}im                               # Graphical ViM IDE.
    {ink}scape                           # Inkscape vector graphics editor.
    kile                                 # KDE Integrated LaTEX Environment.
    {kon}tact                            # KDE Kontact e-mail reader.
    {kto}rrent                           # KDE KTorrent.
    {l}ibre{o}ffice                      # LibreOffice suite.
    {li}nks                              # Links browser.
    lyx                                  # LyX editor.
    {mp}layer2                           # Media Player.
    {n}et{b}eans                         # NetBeans IDE.
    {ok}ular                             # KDE Okular document reader.
    {oo}ffice                            # Apache OpenOffice suite.
    {pdfs}am                             # PDF Split and Merge utility.
    {pi}d{g}en                           # Pidgin Chat Client.
    {pu}tty                              # PuTTY SSH client.
    {scr}ibus                            # Scribus document creator.
    {thu}nderbird                        # Mozilla Thunderbird e-mail reader.
    {t}or{b}rowser                       # Tor Browser.
    {ump}layer                           # Universal Media Player.
    vlc                                  # VLC media player.
)
