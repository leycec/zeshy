#!/usr/bin/env zsh
# ====================[ alias                              ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Configure interactive aliases.
#
# --------------------( SEE ALSO                           )--------------------
# list_interactive_aliases
#   List all current interactive aliases (e.g., abbreviations, substitutions).
#
# help interactive_abbreviation
#   Further details on Zeshy-specific interactive abbreviations.
#
# help interactive_substitution
#   Further details on Zeshy-specific interactive substitutions.

# ....................{ ABBREVIATIONS                      }....................
declare_global_with_stdin <<'-\-'
map ZESHY_INTERACTIVE_ABBREVIATIONS

List of aliases to be expanded only when run from an interactive Zeshy shell,
abbreviating but _not_ replacing existing runnables (i.e., external commands or
zsh aliases, builtins, or functions). Interactive abbreviations are helpful for
abbreviating long human-readable function names typically only called by shell
scripts with shorter human-typeable alias names typically only called by shell
users (e.g., shortening list_path_recursively_verbosely_with_options() to `lr`).
List current interactive abbreviations with list_interactive_abbreviations().

By contrast, the interactive substitutions listed by
${ZESHY_INTERACTIVE_SUBSTITUTIONS} _always_ replace existing runnables.
Interactive abbreviations and substitutions both extend normal zsh aliases by
parsing `{`- and `}`-delimited substrings in the alias name as user-defined
hints helping Zeshy to find the shortest desired alias name not already taken by
an existing runnable on the current system: e.g.,

[source]
------------------------------------------
# This is a normal zsh alias, always expanding "lr" to "ls -lR".
>>> alias lr="ls -lR"

# This is an interactive alias, only expanding "lr" to "ls -lR" if:
#
# * The current shell is interactive. (If the current shell is non-
#   interactive, Zeshy throws an exception on expanding such alias.)
# * "lr" is not already an existing runnable. (If "lr" is an existing
#   runnable, Zeshy iteratively tries the following alias names until
#   either finding a name not already taken by an existing runnable or
#   exhausting all available choices, in which case Zeshy prints an error:
#   "lsr", "lsre", "lsrec", "lsrecu", "lsrecur", "lsrecurs", "lsrecurse").
>>> interactive_abbreviation {l}s{r}ecurse="ls -lR"
------------------------------------------

For typical uses (e.g., abbreviating frequently typed commands at the command
line), some users will find interactive abbreviations and substitutions to be
safer than and hence preferable to normal `zsh` aliases. While normal `zsh`
aliases never change, interactive abbreviations and substitutions conditionally
change to reflect current user and system state: namely, whether the current
shell is interactive and whether the shortest desired alias name is already the
name of an existing runnable as defined by the current user's ${PATH} and shell
environment.

As the above example suggests, the actual name Zeshy assigns to interactive
abbreviations and substitutions heuristically depends on the current state.
Concatenating all `{`- and `}`-delimited substrings in the substring left of the
`=` in such an alias denotes a preferred alias name. If not an existing runnable
name, Zeshy promptly assigns this alias this alias name; otherwise, Zeshy
iteratively shifts the leftmost `}` in such name to the right one character and
tries again until finding a name not already an existing runnable or shifting
the leftmost `}` past the `=`. In the latter case, since no available alias name
exists for such alias; Zeshy prints an error and continues: e.g.,

[source]
------------------------------------------
# This is a normal zsh alias, always expanding "lr" to "ls -lR".
>>> alias lr="ls -lR"

# First, try "md". If "md" is not already an existing runnable name, this
# reduces to "alias md=make_dir_if_not_found_interactively".
#
# Next, try "mkd". If "mkd" is not already an existing runnable name, this
# reduces to "alias mkd=make_dir_if_not_found_interactively".
#
# Next, try "mkdi". If "mkdi" is not already an existing runnable name, this
# reduces to "alias mkdi=make_dir_if_not_found_interactively".
#
# Repeat until trying "mkdirparents". If already an existing runnable name,
# print a warning and continue to the next abbreviation, "{r}m{d}irempty".
>>> ZESHY_INTERACTIVE_ABBREVIATIONS=(
...                 ...
...   {m}k{d}irparents="make_dir_if_not_found_interactively"
...   {r}m{d}irempty="remove_dir_empty_if_found_interactively"
...                 ...
... )
------------------------------------------
-\-
ZESHY_INTERACTIVE_ABBREVIATIONS=(
    # Core.
    {c}h{m}od{r}ecursive  'set_path_permissions_recursively_with_options'
    {c}h{o}wn{r}ecursive  'set_path_user_and_group_recursively_with_options'
    {c}p{r}ecursive       'copy_path_recursively_with_options'
    {lns}ymbolic          'make_link_symbolic_with_options'
    {l}s{l}ong            'list_path_verbosely_with_options'
    {l}s{l}ong{r}ecursive 'list_path_recursively_verbosely_with_options'
    {l}s{r}ecursive       'list_path_recursively_with_options'
    {r}m{r}ecursive       'remove_path_recursively_with_options'

    # Calendar.
    {cal}endar{q}uarter 'print_calendar_quarter'
    {cal}endar{y}ear    'print_calendar_year'

    # Compressed archives.
    {e}xtract{a}rchive 'extract_archive'
    {l}ist{a}rchive    'list_archive'
    {m}ake{a}rchive    'make_archive'

    # Directory stack. (Use "zsh" primitives rather than Zeshy functions, for
    # the moment; try hitting <Tab> after typing either to see why.)
    {c}hange{b}ackward 'cd -'
    {c}hange{f}orward  'cd +'

    # File counters.
    {wcl}ine{r}ecursive 'get_file_text_line_count_recursively'

    # File grepping.
    {g}rep{i}nsensitive 'grep_path_caselessly_with_options'
    {g}rep{r}ecursive   'grep_path_recursively_with_options'
    {g}rep{r}ecursive{i}nsensitive 'grep_path_recursively_caselessly_with_options'

    # Kernel modules.
    {mod}ule{p}rint  'print_kernel_module'
    {mod}ule{l}oad   'load_kernel_module'
    {mod}ule{u}nload 'unload_kernel_module'

    # Libraries.
    {l}s{b}inary{e}xecutable 'print_binary_executable'

    # Shell lifecycle.
    {e}xit{z}sh      'exit_zsh'
    {re}start{z}eshy 'restart_zeshy'
    {re}startz{s}h   'restart_zsh'

    # Zeshy internals.
    {h}elp 'print_zeshy_help'

    #FIXME: Expand to proper Zeshy functions.
    {d}ate 'date'
    {k}ill{a}ll    'killall'
    {k}ill{a}ll{9} 'killall -9'

    #FIXME: Works great... except that it throws a TRAPZERR-induced exception on
    #*EVERY* suspension back to the command-line. Dig into this a bit further.
    {f}g 'fg'
)

# ....................{ SUBSTITUTIONS                      }....................
# See the section above for further details on "="-delimited alias syntax.

declare_global_with_stdin <<'-\-'
map ZESHY_INTERACTIVE_SUBSTITUTIONS

List of aliases to be expanded only when run from an interactive Zeshy shell,
_always_ replacing existing runnables (i.e., external commands or zsh aliases,
builtins, or functions). Interactive substitutions are useful for wrapping
conventional runnables with convenience wrapper functions (e.g., replacing
`ls` with list_path_with_options()). List current interactive substitutions with
list_interactive_substitutions().

By contrast, the interactive abbreviations listed by
${ZESHY_INTERACTIVE_ABBREVIATIONS} _never_ replace existing runnables. See such
list for further details on usage, syntax, and motivation.
-\-
ZESHY_INTERACTIVE_SUBSTITUTIONS=(
    #FIXME: Clearly, any function called below *MUST* be prefixed by
    #_with_options() and implemented accordingly. We're about halfway there, I'd
    #say. Not a pleasant chore, but it really must be done for Zeshy to be
    #widely applicable. Start with the heavy hitters: "grep", "cat", and so on.
    #"mount" will probably be an absolute nightmare, so save for last! :)

    # Unabbreviated substitutions.
    cd  'set_dir_with_options'
    du  'print_path_size_sorted_with_options'
    rm  'remove_file_with_options'

    # Abbreviated substitutions.
    {ca}t     'print_file_text'
    {c}h{m}od 'set_path_permissions_with_options'
    {c}h{o}wn 'set_path_user_and_group_with_options'
    {c}p      'copy_path_with_options'
    {di}rs    'print_dir_stack'
    {fd}isk   'check_disk'
    {fr}ee    'print_memory_use'
    {g}rep    'grep_path_with_options'
    {l}s      'list_path_with_options'
    {l}s{m}od 'print_kernel_modules'
    {m}k{d}ir 'make_dir_if_not_found_with_options'
    {mo}unt   'mount_nicely'
    {m}v      'move_path_with_options'
    {r}m{d}ir 'remove_dir_empty_with_options'
    {umo}unt  'unmount_point'

    #FIXME: Expand to proper Zeshy functions.
    df 'df --human-readable --sync'
)

declare_global_with_stdin <<'-\-'
map ZESHY_INTERACTIVE_SUBSTITUTIONS_IF_PATHABLE

List of aliases to be expanded when run from an interactive shell and that
alias name (excluding embedded `{` and `}` characters) is the name of an
existing runnable. See ${ZESHY_INTERACTIVE_ABBREVIATIONS} for further details.
-\-
ZESHY_INTERACTIVE_SUBSTITUTIONS_IF_PATHABLE=(
    #FIXME: This should be an abbreviation, obviously. Consequently, we'll need
    #an ${ZESHY_INTERACTIVE_ABBREVIATIONS_IF_PATHABLE} -- or we would if I still
    #considered this a fine idea. Clearly, it's not. This is the only such alias
    #declared here or anywhere! Just shift this into a new configuration file
    #"if_pathable/vim/if_config/if_interactive/vim" and remove this global. Done.
    {v}im 'vim'                          # ViM editor.
)

declare_global_with_stdin <<'-\-'
list ZESHY_INTERACTIVE_SUBSTITUTIONS_IF_PATHABLE_RUN_DISOWNED

List of external commands to be disowned (i.e., not closed on shell closure)
when run from an interactive shell and that command is in the current user's
${PATH}. If present, `{`- and `}`-delimited substrings define the alias name.

For example, the single line `{cali}bre` listed below produces aliases `cali`
and `calibre` running Calibre disowned when the current shell is interactive
and the current ${PATH} contains `calibre` (i.e., when Calibre is installed).
Zeshy effectively converts this single line to a block of code resembling:

[source]
------------------------------------------
>>> is_shell_interactive and is_pathable calibre and {
...     alias calibre="run_command_disowned calibre"
...     alias cali="run_command_disowned calibre"
... }
------------------------------------------

Since closing a shell should implicitly close all commands started under such
shell excluding GUI and headless daemon commands, consider only listing the
latter commands here.
-\-
ZESHY_INTERACTIVE_SUBSTITUTIONS_IF_PATHABLE_RUN_DISOWNED=(
    {abi}word                            # AbiWord processor.
    {acr}oread                           # Adobe Acrobat.
    {ama}rok                             # Amarok music player.
    {aud}acity                           # Audacity audio editor.
    {cali}bre                            # Calibre eBook manager.
    {ch}rom{e}                           # Google Chrome browser.
    {ch}romium                           # Google Chromium browser.
    {dvds}tyler                          # DVDStyler DVD creator.
    dia                                  # GNOME Dia.
    {ecl}ipse                            # Eclipse IDE.
    {ema}cs                              # GNU Emacs IDE.
    {f}ire{f}ox                          # Mozilla Firefox browser.
    {f}ile{li}ght                        # KDE Filelight.
    {fo}nt{fo}rge                        # FontForge.
    {g}ee{q}ie                           # Geeqie image viewer.
    {glxg}ears                           # GLXGears OpenGL tester.
    {gim}p                               # GNU Image Manipulation Program.
    {gv}im                               # Graphical ViM IDE.
    {ink}scape                           # Inkscape vector graphics editor.
    kile                                 # KDE Integrated LaTEX Environment.
    {kon}tact                            # KDE Kontact e-mail reader.
    {kto}rrent                           # KDE KTorrent.
    {l}ibre{o}ffice                      # LibreOffice suite.
    {li}nks                              # Links browser.
    lyx                                  # LyX editor.
    {mp}layer2                           # Media Player.
    {n}et{b}eans                         # NetBeans IDE.
    {ok}ular                             # KDE Okular document reader.
    {oo}ffice                            # Apache OpenOffice suite.
    {pdfs}am                             # PDF Split and Merge utility.
    {pidg}en                             # Pidgin Chat Client.
    {pu}tty                              # PuTTY SSH client.
    {scr}ibus                            # Scribus document creator.
    {t}hunder{bi}rd                      # Mozilla Thunderbird e-mail reader.
    {t}or{b}rowser                       # Tor Browser.
    {ump}layer                           # Universal Media Player.
    vlc                                  # VLC media player.
)
