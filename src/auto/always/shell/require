#!/usr/bin/env zsh
# ====================[ require                            ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Require, implementing script import functionality.

# ....................{ IMPORTS                            }....................
# void requires(char *script_name1, ..., char *script_nameN)
# 
# Import all passed scripts.
requires() {
    die_unless_at_least_one_argument 'expected at least one script name'
    for script_name in "${@}"; do require "${script_name}"; done
}

# void require(char *pathname, char *arguments)
# 
# Conditionally import the passed file or directory, if not previously imported
# by this function or externally modified since such import. We pass the passed
# arguments to all files imported in this manner.
# 
# If the passed path is relative, we look for such path first under the current
# working directory and then Zeshy's root directory (e.g., "/usr/share/zeshy/").
# We then resolve the exact Zeshy script(s) to be imported as follows:
#
# * If the passed path is an existing file, import such file.
# * If the passed path is an existing directory:
#   * Containing a file named "${ZESHY_MAIN_SCRIPT_BASENAME}", import such file.
#   * Otherwise, import all files such directory contains.
# * Otherwise, die.
#
# This function mimics the import() built-in of most high-level languages. To
# avoid conflict with ImageMagick's "import" command, we prefer "require".
#
# --------------------( VARIABLES                          )--------------------
# This function defines local variables, which imported scripts may safely
# access for informative path metadata: namely,
#
# * "zeshy_script_name", having the relative path to the imported script under
#   "${ZESHY_HOME}/src".
# * "zeshy_script_path", having the absolute path to the imported script.
# * "zeshy_script_mtime", having the modification time of the imported script.
#
# --------------------( EXAMPLES                           )--------------------
#     # Implicitly imports the Zeshy script "zeshy/os/.main".
#     >>> require zeshy/os
require() {
    die_unless_at_least_one_argument\
        'expected one pathname and optional script options'
#   utter "requireing ${1}..."

    # Passed script name. Shift it off the argument stack, to allow us to pass
    # this script the set of all remaining arguments on sourcing it below.
    string zeshy_script_name="${1}"; shift

    # Absolute path to this script.
    string zeshy_script_path 
    
    # If the passed script name is either an absolute path or existing relative
    # path, try to import it as is.
    if is "${zeshy_script_name[1]}" == '/' or -e "${zeshy_script_name}" si
    then zeshy_script_path="${zeshy_script_name}"
    #FIXME: Actually, first try the current working directory.
    # Otherwise, try to import a Zeshy component having that script name.
    else zeshy_script_path="${ZESHY_HOME}/src/${zeshy_script_name}"
    fi
    
    # Delegate to helper functions depending on path type.
    if is_dir "${zeshy_script_path}"
    then require_dir  "${zeshy_script_path}" "${@}"
    else require_file "${zeshy_script_path}" "${@}"
    fi
}

# void require_dir(char *dirname, char *arguments)
# 
# Conditionally import the passed directory. See require() for details.
require_dir() {
    die_unless_at_least_one_argument\
        'expected one dirname and optional import options'
    string zeshy_script_dir="${1}"; shift
    is_dir "${zeshy_script_dir}" or
        die "\"${zeshy_script_dir}\" not a directory or not found"
    string zeshy_main_script="${zeshy_script_dir}/${ZESHY_MAIN_SCRIPT_BASENAME}"

    # If this directory contains a main script, import only such script;
    # otherwise, import all children of such directory.
    if is_file "${zeshy_main_script}"
    then require_file         "${zeshy_main_script}" "${@}"
    else require_dir_children "${zeshy_script_dir}" "${@}"
    fi
}

# void require_dir_children(char *dirname, char *arguments)
# 
# Conditionally import all files and directories under the passed directory.
require_dir_children() {
    die_unless_at_least_one_argument\
        'expected one dirname and optional import options'
    string zeshy_script_dir="${1}"; shift
    is_dir "${zeshy_script_dir}" or
        die "\"${zeshy_script_dir}\" not a directory or not found"

    # Dismantled, this imports all files in this directory subject to:
    #
    # * "(^D@)", excluding dotfiles and symbolic links.
    # * "~*.(swp|zwc)", excluding files with filetype "swp" or "zwc".
    for zeshy_script_dir_child in "${zeshy_script_dir}"/*(^D@)~*.(swp|zwc); do
        require "${zeshy_script_dir_child}" "${@}"
    done
}

#global_string ZESHY_CACHE_COMPILATION_DIR="${ZESHY_CACHE_DIR}/compilation"
#FIXME: Add support for zcompile(). Pass "-M" if the passed file matches
# */zeshy/src/* and "-R" otherwise.
# void require_file(char *filename, char *arguments)
# 
# Conditionally import the passed file. See require() for details.
require_file() {
    die_unless_at_least_one_argument\
        'expected one filename and optional import options'
    string zeshy_script_path="${1}"; shift
    die_unless_file "${zeshy_script_path}"
   
    # Canonicalize the path so as to ensure the dictionary lookup below
    # successfully compares it against a previously canonicalized path.
    zeshy_script_path="$(canonicalize_path "${zeshy_script_path}")"

    #FIXME: Hmm; this should be an integer, but Zsh is currently hassling me. *sigh*
    # Modification time of this script.
    string zeshy_script_mtime
    zeshy_script_mtime=$(get_path_mtime "${zeshy_script_path}")
    
    global_map ZESHY_REQUIRED_PATH_TO_MTIME

    # If this script has not yet been imported or has been but has changed since
    # being imported, (re)import this script.
    if is -z\
        "${ZESHY_REQUIRED_PATH_TO_MTIME[(I)"${zeshy_script_path}"]}" or
        "${ZESHY_REQUIRED_PATH_TO_MTIME["${zeshy_script_path}"]}" -ne\
        "${zeshy_script_mtime}" si; then
        # If the script corresponds to a command-specific script under
        # "zeshy/command" excluding the top-level ".main" script, ensure this
        # command is actually installed.
        if is "${zeshy_script_path}" == */zeshy/command/* si; then
            string command_name="${zeshy_script_path#*/zeshy/command/}"
            is "${command_name}" == "${ZESHY_MAIN_SCRIPT_BASENAME}" si or
                die_unless_installed "${command_name}"
        fi

        # Record this script as being imported prior to doing so, thus
        # preventing infinitely recursive reimportation should this or another
        # script imported by this script attempt to import this script again.
        ZESHY_REQUIRED_PATH_TO_MTIME["${zeshy_script_path}"]="${zeshy_script_mtime}"

        #FIXME: Technically, this works. Sadly, Zsh exposes no explicit
        #mechanism for sourcing zcompiled scripts. (Odd, we know.) Rather, one
        #can only use such scripts with the fpath-enabled autoload mechanism.
        # Absolute path to the file caching the compilation of this script.
#       string zeshy_script_compiled_path="${ZESHY_CACHE_COMPILATION_DIR}${zeshy_script_path}.zwc"

        # If this script has not yet been compiled or has been but has changed since
        # being compiled, (re)compile this script.
#       if is not -f "${zeshy_script_compiled_path}" or\
#           ${zeshy_script_mtime} -ne\
#           $(get_path_mtime "${zeshy_script_compiled_path}") si; then
#           # zcompile() refuses to create directory structure, so do so for it.
#           make_directory_if_not_found "$(dirname "${zeshy_script_compiled_path}")"

#           utter "compiling \"${zeshy_script_path}\" to \"${zeshy_script_compiled_path}\"..."
#           utter "compiling \"${zeshy_script_path}\"..."
#           zcompile "${zeshy_script_compiled_path}" "${zeshy_script_path}"

            # Set the mtime of the compiled script to that of the uncompiled
            # script to ensure the above conditional fails on future imports.
#           set_path_mtime "${zeshy_script_compiled_path}" ${zeshy_script_mtime}
#       fi
#       source "${zeshy_script_compiled_path}" "${@}"

        # Do so.
        utter "requiring \"${zeshy_script_path}\"..."
        source "${zeshy_script_path}" "${@}"
    fi
}

# void zeshy_initialize_imports(void)
#
# Initialize the imports dictionary, used by the require() function. This is a
# global dictionary mapping from imported script name to the mtime (i.e.,
# modification time) of the script at the time of importation. The require()
# function adds script names to this dictionary on importing those scripts so
# as to record having done so. This record keeping allows that function to
# avoid importing already imported scripts.
#
# Zeshy Shell requires we separate this initialization into a distinct function,
# for hitherto inexplicable reasons. (There be subtle dragons aboot.)
zeshy_initialize_imports() {
    die_unless_no_arguments
    
    # Explicitly empty the dictionary. This is irrelevant on the first call to
    # this function, but definitely matters on subsequent calls!
    global_map ZESHY_REQUIRED_PATH_TO_MTIME; ZESHY_REQUIRED_PATH_TO_MTIME=( )
}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
