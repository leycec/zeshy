#!/usr/bin/env zsh
# ====================[ file                               ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy File, extending the file- and path-handling Zeshy Core already
# implements with supplementary functionality.
#
# --------------------( TODO                               )--------------------
# * It'd be nice to incorporate "zmv", for those who want and/or expect it.
#   "zmv" is a built-in shell function applying extended glob patterns to
#   the usual "mv" command, thus allowing batch renaming of file- and path-names.
#   (Use option "-n" before permanently applying any such pattern, so as to
#   prete[n]d- apply the pattern as initial "trial run;" or, use option "-i" to
#   force "zmv" to [i]nteractively ask your permission to perform each rename.)
#   For example: zmv -n '(*).txt' '$1.xtx'  # renames files ending in 'txt' to
#   end in 'xtx'. Naturally, "zmv" is an autoloadable function: e.g.,
#   autoload -U zmv

# ....................{ ALIASES                            }....................
interactive_alias lns="make_symbolic_link"
interactive_alias mvt="move_to_temporary_dir"

# Filesystem checking (fsck). Note we do not implicitly pass the "-a" or "-p"
# options to fsck, as fsck ignores some filesystem errors (e.g., superblock
# mount time in the future) when those options are passed.
string ZESHY_FSCK_OPTIONS="-C -M -T"
interactive_alias fsck="fsck ${ZESHY_FSCK_OPTIONS}"
interactive_alias fsck.ext2="fsck.ext2 ${ZESHY_FSCK_OPTIONS}"
interactive_alias fsck.ext3="fsck.ext3 ${ZESHY_FSCK_OPTIONS}"
interactive_alias fsck.vfat="fsck.vfat ${ZESHY_FSCK_OPTIONS}"

# ....................{ EXCEPTIONS                         }....................
# void die_if_file(char *filename, char *error_message = 'is a file')
#
# Raise an exception if the passed file exists.
die_if_file() {
    die_unless_one_or_two_arguments\
        'expected filename and optional error message'
    string filename="${1}"
    is_file "${filename}" and die "${2:-\"${filename}\" is an existing file}"
}

# void die_unless_found(char *pathname, char *error_message = 'not found')
#
# Raise an exception unless the passed path exists.
die_unless_found() {
    die_unless_one_or_two_arguments\
        'expected pathname and optional error message'
    string pathname="${1}"
    is_found "${pathname}" or die "${2:-\"${pathname}\" not found}"
}

# void die_unless_file(char *filename, char *error_message = 'not a file')
#
# Raise an exception unless the passed file exists.
die_unless_file() {
    die_unless_one_or_two_arguments\
        'expected filename and optional error message'
    string filename="${1}"
    is_file "${filename}" or die "${2:-\"${filename}\" not found or not a file}"
}

# void die_unless_dir(char *dirname, char *error_message = 'not a directory')
#
# Raise an exception unless the passed directory exists.
die_unless_dir() {
    die_unless_one_or_two_arguments\
        'expected dirname and optional error message'
    string dirname="${1}"
    is_dir "${dirname}" or
        die "${2:-\"${dirname}\" not found or not a directory}"
}

# void die_unless_installed(
#   char *command_name, char *error_message = 'not found in $PATH')
#
# Raise an exception unless the passed command exists.
die_unless_installed() {
    die_unless_one_or_two_arguments 'expected exactly one command name'
    string dirname="${1}"
    is_installed "${dirname}" or die "${2:-\"${dirname}\" not found in \$PATH}"
}

# void die_unless_device_file(char *filename, char *error_message = '')
#
# Raise an exception unless the passed device file exists.
die_unless_device_file() {
    die_unless_one_or_two_arguments\
        'expected filename and optional error message'
    string filename="${1}"
    is_device_file "${filename}" or
        die "${2:-\"${filename}\" not found or not a device file}"
}

# ....................{ TESTS                              }....................
# bool is_found(char *pathname)
# 
# Return true if the passed path exists.
is_found() {
    die_unless_one_argument 'expected exactly one pathname'
    is -e "${1}" si
}

# bool is_file(char *pathname)
# 
# Return true if the passed path is an existing file.
is_file() {
    die_unless_one_argument 'expected exactly one pathname'
    is -f "${1}" si
}

# bool is_dir(char *pathname)
# 
# Return true if the passed path is an existing directory.
is_dir() {
    die_unless_one_argument 'expected exactly one pathname'
    is -d "${1}" si
}

# bool is_device_file(char *pathname)
# 
# Return success if the passed path is an existing device file (i.e., either
# block- or character-special). Otherwise, failure.
is_device_file() {
   die_unless_one_argument 'expected exactly one pathname'
   is -b "${1}" or -c "${1}" si
}

# bool is_installed(char *command_name)
#
# Return true if the command with the passed name is currently installed.
is_installed() {
    # Do not call the quietly() function, as that calls the run() function which
    # calls *THIS* function which induces an infinitely recursive loop. Agathoth 
    # and Memnon!
    which_command "${@}" 1>/dev/null 2>&1
}

# bool is_symbolic_link(char *pathname)
# 
# Return true if the passed path is an existing symbolic link.
is_symbolic_link() {
    die_unless_one_argument 'expected exactly one pathname'
    is -L "${1}" si
}

# ....................{ TESTS ~ pathnames                  }....................
# bool is_pathname_absolute(char *pathname)
#
# Return true if the passed path is absolute (i.e., begins with an "/"),
# regardless of whether it actually exists.
is_pathname_absolute() {
    die_unless_one_argument 'expected exactly one pathname'
    is "${1[1]}" == '/' si
}

# ....................{ TESTS ~ content                    }....................
# bool is_file_binary(char *pathname)
#
# Return success if the passed pathname corresponds to a binary file (i.e., not
# a text file). (If the passed pathname corresponds to a directory instead, this
# function always returns failure.)
is_file_binary() {
    die_unless_one_argument 'expected exactly one pathname'
    is_file "${1}" and is "$(file --mime-encoding "${1}")" == *': binary' si
}

# bool is_file_text(char *pathname)
#
# Return success if the passed pathname corresponds to a text file (i.e., not a
# binary file). (If the passed pathname corresponds to a directory instead, this
# function always returns failure.)
is_file_text() {
    die_unless_one_argument 'expected exactly one pathname'
    is_file "${1}" and not is_binary_file "${1}"
}

#FIXME: Should be renamed to, say, "get_find_command_text_file_filter()", and
#consequently moved -- ideally, into a new "zeshy/file/find".
# bool is_text_file_find_compatible(void)
#
# Return a string which, when passed as argument to a "find" process, filters
# the currently visited filename if the corresponding file is binary. "find"
# itself provides no built-in means of performing such filtering, unfortunately.
is_text_file_find_compatible() {
    print "\-exec sh -c 'file --mime-encoding {} | grep --invert-match --quiet \": binary$\"' \\\;"
}

# ....................{ GETTERS                            }....................
# char *get_basename(char *pathname)
#
# Get the basename of the passed path (i.e., sans parent directory name).
get_basename() {
    die_unless_one_argument 'expected exactly one pathname'
    print "${1:t}"
}

# char *get_dirname(char *pathname)
#
# Get the dirname of the passed path (i.e., sans basename).
get_dirname() {
    die_unless_one_argument 'expected exactly one pathname'
    print "${1:h}"
}

# char *get_filename_sans_filetype(char *filename)
#
# Get the filename of the passed filename sans filetype. If this filename has
# no filetype, this is the filename itself. By design, this only excludes the
# rightmost filetype: e.g.,
#
#     >>> get_basename_sans_filetype '/endymion/hastur.tar.gz'
#     /endymion/hastur.tar
get_filename_sans_filetype() {
    die_unless_one_argument 'expected exactly one filename'
    print "${1%.*}"
}

# char *get_filetype(char *filename)
#
# Get the filetype of the passed filename. If this filename has no filetype,
# this is the empty string. Note the only matches the rightmost filetype: e.g.,
#
#     >>> get_filetype 'hastur.tar.gz'
#     gz
get_filetype() {
    die_unless_one_argument 'expected exactly one filename'
    string filename="${1}"
    string filetype="${filename##*.}"

    # If this filename has no filetype, then the prior parameter expansion
    # matched the filename itself, in which case we test for and ignore this. 
    is "${filetype}" == "${filename}" si or print "${filetype}"
}

# ....................{ GETTERS ~ mtime                    }....................
# int get_path_mtime(char *pathname)
#
# Get the mtime (i.e., modification time) of the passed path in Unix time,
# reflecting the most recent time of path creation or change of path content
# (i.e., file content for files and the list of files and subdirectories for
# directories), filename, or permissions. For directories, mtime does *NOT*
# reflect change of file or subdirectory content or permissions.
get_path_mtime() {
    die_unless_one_argument 'expected exactly one pathname'
    zstat +mtime "${1}"
}

# int get_path_mtime_recursive(char *pathname)
#
# Get the recursive mtime (i.e., modification time) of the passed path in Unix
# time. For files, this is the same time as returned by the non-recursive
# get_path_mtime() function. For directories, this reflects the most recent time
# of recursive path creation or change of path content, filename, or
# permissions. This function is considerably more costly than get_path_mtime().
get_path_mtime_recursive() {
    die_unless_one_argument 'expected exactly one pathname'
    string pathname="${1}"

    if is_file "${pathname}"; then
        get_path_mtime "${pathname}"
    elif is_dir "${pathname}"; then
        # Dismantled, this is:
        #
        # * "${pathname}"/**/*, all files and subdirectories of this directory.
        # * "om", such files and subdirectories in ascending order by mtime.
        # * "[1]", the first and hence newest such file or subdirectory.
        get_path_mtime "${pathname}"/**/*(om[1])
#           "$(find "${pathname}" -type f -printf '%A@\t%p\n' | sort -r -k1 | head -n1 | cut -f2)"
    else
        die "\"${pathname}\" not a file or directory or not found"
    fi
}

# ....................{ SETTERS                            }....................
# void set_path_mtime(char *pathname, int mtime)
#
# Set the mtime (i.e., modification time) of the passed path in Unix time.
set_path_mtime() {
    die_unless_two_arguments 'expected exactly one pathname and one mtime'
    string pathname="${1}"
    integer mtime="${2}"
    die_unless_found "${pathname}"
    touch -m --date=@"${mtime}" "${pathname}"
}

# ....................{ FINDERS                            }....................
# char *canonicalize_pathname(char *pathname)
#
# Get the canonicalized form of the passed absolute path. Canonicalization
# reduces this path to standard form, such that two canonical paths are equal
# if and only if they represent the same file. Note that this is not
# necessarily the case with non-canonical paths (e.g., "/tmp" and
# "/tmp/../tmp/./" are not equal but represent the same directory).
# Specifically, canonicalization:
#
# * Expands every pseudo-directory component (e.g., "./", "../") iteratively,
#   until the resulting path contains no pseudo-directory components.
# * Expands every symlink in every component of the passed path recursively,
#   until the resulting path contains no symlinks.
canonicalize_pathname() {
    die_unless_one_argument 'expected exactly one pathname'
    readlink --canonicalize-existing "${1}"
}

# char *which_command(char *command_name)
#
# Return the absolute path to the command with the passed name if such command
# exists in the $PATH and an error message otherwise: e.g.,
#
#     >>> which_command zsh
#     /bin/zsh
which_command() {
    die_unless_one_argument 'expected exactly one command name'
    string command_name="${1}"
    string command_pathname="${command_name:c}"

    # If no such command exists, print an error message and return with failure.
    if not is_pathname_absolute "${command_pathname}"; then
        curse "\"${command_name}\" not found"
        return_failure
    fi

    # Otherwise, print the absolute path of this command.
    print "${command_pathname}"
}

# char *which_script(char *script_name)
#
# Get the absolute path to the script with the passed name. If
# there exist multiple such scripts, return the first such script. This function
# generalizes which_autoload() by searching for (in order):
#
# * Any file in the current working directory with such name.
# * Any file in the ${PATH} with such name (i.e., a command).
# * Any file in the ${FPATH} with such name (i.e., an autoload).
which_script() {
    die_unless_at_least_one_argument 'expected exactly one script name'
    list script_paths; script_paths=( "${PWD}" "${path[@]}" "${fpath[@]}" )
    which_autoload "${1}" 'script_paths'
}

# char *which_autoload(
#   char *autoload_name, char **autoload_paths_list_name = 'fpath')
#
# Get the absolute path to the autoloadable script with the passed name. If
# there exist multiple such scripts, return the first such script: e.g.,
#
#     >>> which_autoload zsh-mime-handler
#     /usr/share/zsh/4.3.11/functions/MIME/zsh-mime-handler
which_autoload() {
    die_unless_at_least_one_argument 'expected exactly one autoload name'
    string autoload_name="${1}"
    string autoload_paths_list_name="${2:-fpath}"
    
    # Dismantled, this is:
    #
    # * "autoload_paths_list_name", the name of the list listing all
    #   directories to be searched for the passed autoload.
    # * "(P)", expanding to such list.
    # * "^", iteratively expanding to each such directory.
    # * "/${autoload_name}", concatenating the passed autoload to each such
    #   directory, producing a possible absolute path to such autoload.
    # * "(N)", removing non-extant paths.
    # * "(..)", listing all extant paths.
    list autoload_paths
    autoload_paths=( ${^${(P)autoload_paths_list_name}}/"${autoload_name}"(N) )

    # If no command has the passed name, print an error message and return
    # failure. To permit the caller to recover, do not raise a fatal error.
    if is_empty "${autoload_paths}"; then
        curse "\"${autoload_name}\" not found"
        return_failure
    fi

    # Otherwise, print the first absolute path to this autoload.
    print "${autoload_paths[1]}"
}

# char *which_files(char *filename1, *filename2, ...)
#
# Get the absolute path to the first filename in the list of passed filenames
# which exists: e.g.,
#
#     >>> which_files '/the_ancient.one' '/the_king_in.yellow' '/tmp'
#     /tmp
which_files() {
    die_unless_at_least_one_argument 'expected exactly one filename'

    # Scalarize the list of passed filenames for use in an error message.
    string filenames="'${^@}'"
    
    # Iteratively look for each filename in the passed list.
    string filename
    while is_at_least_one_argument; do
        filename="${1}"; shift

        # If this filename exists, return it.
        if is_file "${filename}"; then
            print  "${filename}"
            return_success
        fi
    done
    
    # Otherwise, no such filename exists. Fail.
    curse "\"${filenames}\" not found"
    return_failure
}

# char *which_commands(char *command_name1, *command_name2, ...)
#
# Get the absolute path to the first command in the list of passed commands
# which exists: e.g.,
#
#     >>> which_commands Council_of_Nicea Constantinople zsh
#     /bin/zsh
# 
# This function is intended to automate selection of commands, in descending
# order of preference. (In the above example, the hypothetical
# "Council_of_Nicea" command would be selected before all following commands on
# systems having the command.)
which_commands() {
    die_unless_at_least_one_argument 'expected exactly one command name'
    
    # Scalarize the list of passed filenames for use in an error message.
    string command_names="'${^@}'"

     # Iteratively look for each command in the passed list.
    string command_path
    while is_at_least_one_argument; do
        # If this command exists, return its absolute path.
        if command_path="$(stderr_to_stdout which_command "${1}")"; then
            print "${command_path}"
            return_success
        fi

        # Otherwise, shift this command off the passed list and try again.
        shift
    done
    
    # Otherwise, no such command exists. Fail.
    curse "\"${command_names}\" not found"
    return_failure
}

# ....................{ FINDERS ~ temporary                }....................
# char *which_temporary_dir(void)
#
# Get the absolute path to the temporary directory. This is, in descending order
# of preference:
#
# * "${HOME}/tmp", if the current user's home directory has such a subdirectory. 
# * "/tmp", otherwise.
which_temporary_home() {
    die_unless_no_arguments 'expected no arguments'
    
    string user_temporary_dir="${HOME}/tmp" root_temporary_dir="/tmp"
    if   is_dir "${user_temporary_dir}"
    then print  "${user_temporary_dir}"
    elif is_dir "${root_temporary_dir}"
    then print  "${root_temporary_dir}"
    else die "no temporary directory found"
    fi
}

# char *which_temporary_dir(char *prefix)
#
# Get the absolute path to a temporary path having the passed prefix: e.g.,
#
#     >>> which_temporary_dir git_patches
#     /tmp/git_patches~2012-04-18_22-58-34_609198275
#
# While subtle race conditions may arise with concurrent processing, this path
# is generally unique. This should probably not be depended upon for mission
# critical Zsh scripts, however. (.......of course, if you're coding mission
# critical Zsh scripts, you've probably already gone too far.)
which_temporary_dir() {
    die_unless_one_argument 'expected exactly one dirname prefix'
    
    string which_temporary_dir
    while true; do
        which_temporary_dir="$(which_temporary_home)/${1}.path~$(date +'%F_%H-%M-%S_%N')"
        if not is_dir "${which_temporary_dir}"; then
            print  "${which_temporary_dir}"
            break
        fi
    done
}

# char *which_temporary_file(char *prefix)
#
# Get the absolute path to a temporary file having the passed prefix: e.g.,
#
#   # Prints "/tmp/git_patch_file~2012-12-01_18-37-41", for example.
#   which_temporary_file git_patch_file
#
# Subtle race conditions may arise, as above.
which_temporary_file() {
    die_unless_one_argument 'expected exactly one filename prefix'
    
    string which_temporary_file
    while true; do
        which_temporary_file="$(which_temporary_home)/${1}.file~$(date +'%F_%H-%M-%S')"
        if not is_file "${which_temporary_file}"; then
            print "${which_temporary_file}"
            break
        fi
    done
}

# ....................{ WRITERS                            }....................
# void make_directory_if_not_found(char *dirname1, char *dirname2, ...)
#
# Examine each of the passed absolute paths and, for each non-existant path,
# make that path and all non-existant parent paths of that path.
make_directory_if_not_found() {
    die_unless_one_argument 'expected exactly one dirname'

    # While there are more paths to consider, shift the current path to be
    # considered to a local variable "new_path" and make it when not found.
    string new_path
    while is_arguments; do
        new_path="${1}"; shift

        if is_file "${new_path}"; then
            die "\"${new_path}\" already a file"
        elif not is_dir "${new_path}"; then
#           utter "making \"${new_path}\"..."
            mkdir --parents "${new_path}"
        fi
    done
}

# void make_parent_directory_if_not_found(char *pathname)
#
# Make the parent directory of the passed path, if not found.
make_parent_directory_if_not_found() {
    die_unless_one_argument 'expected exactly one pathname'
    make_directory_if_not_found "$(dirname "${1}")"
}

# void make_symbolic_link(char *source_pathname, *target_filename)
#
# Symbolically link the former passed path to the latter passed file. If such
# file already exists and is a symbolic link, replace such file without error;
# otherwise, raise an error if such file already exists.
make_symbolic_link() {
    die_unless_two_arguments\
        'expected exactly one source pathname and one target filename'
    string source_pathname="${1}" target_filename="${2}"
    die_unless_exists "${source_pathname}"

    if is_symbolic_link "${target_filename}"; then
        ln -sf "${source_pathname}" "${target_filename}"
    else
        die_if_exists "${target_filename}"
        ln -s  "${source_pathname}" "${target_filename}"
    fi
}

# void move_to_temporary_dir(char *pathname1, char *pathname2, ...)
#
# Move the passed set of files and/or directories to the "/tmp" directory. For
# Additionally, this suffixing all files and
# paths that already exist in "/tmp/" with the current time. 
move_to_temporary_dir() {
    die_unless_arguments
    string target_path source_path source_basename

    # Quote the list of all passed paths with "(q)" to avoid improperly
    # splitting individual paths on whitespace.
    for source_path in "${(q)@}"; do
        source_basename="$(get_basename "${source_path}")"
        target_path="/tmp/${source_basename}"
        is_path "${target_path}" and
            target_path="$(which_temporary_home)/$source_basename~$(date +'%F_%H-%M-%S')"
        
        try mv "${source_path}" "${target_path}"
    done
}

# void remove_paths(char *pathname1, char *pathname2, ...)
#
# Permanently remove the passed paths.
remove_paths() {
    die_unless_at_least_one_argument 'expected at least one pathname'
    rm -- "${@}"
}

#FIXME: Obsolete.
# char *which_command(char *command_name)
#
# If found, get the absolute path to the command with the passed name;
# otherwise, return false. All but the first whitespace-delimited word of this
# string is ignored: e.g.,
#
#     >>> which_command zsh
#     /bin/zsh
#     >>> which_command "zsh -x -o shwordsplit scr"
#     /bin/zsh
#which_command() {
#    die_unless_one_argument 'expected exactly one command name'
#    string command_name="${1[(w)1]}"
#    string command_path="${command_name:c}"
#
#    # If no such command exists, print an error message and return with failure.
#    if is "${command_path:c}" != /* si; then
#        curse "\"${command_name}\" not found"
#        return_failure
#    fi
#
#    # Otherwise, print the absolute path of this command.
#    print "${command_path}"
#}

#   if not command_path="$(whence -p "${command_name}")"; then
#
# ....................{ FILENAMES ~ lists                 }....................
# char **get_filenames(char *dirname = '')
#
# Return a stringified list of all files in the passed directory or, if no such
# directory was passed, the current working directory. Callers should
# destringify the return value by calling the expand_list() function.
#get_filenames() {
#    die_unless_at_most_one_argument 'expected at most one optional dirname'
#    string dirname="${1:-${PWD}}"
#    die_unless_dir "${dirname}"
#    list filenames; filenames=( "${dirname}"/*(N) )
#    return_list filenames
#}

#      file --mime-encoding "${pathname}" | grep --quiet ': binary$'
#      file --mime-encoding "${pathname}" | grep --quiet --invert-match ': binary$'

#       die "neither \"${user_temporary_dir}\" or \"${root_temporary_dir}\""\
#           "found; no temporary directory found"
#alias -g get_filenames="( *(N) )"

#lias get_next_argument_as='string __tmp__="${1}"; shift; print "${__tmp__}"'
#lias get_next_argument_as='string __tmp__="${1}"; shift; print "${__tmp__}"'
#       filename="$(get_next_argument)"
#       get_next_argument_as filename

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
