#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Casually inspect the current system (e.g., operating system, window manager).
# @{digest} depends on this parcel to determine whether or not the previously
# compiled digest file applies to the current system.

#FIXME: Note that, since neither Mir or Wayland currently appear to provide
#command-line interfaces to query for the current window manager,
#${ZESHY_WINDOW_MANAGER_NAME} should simply be set to either "Mir" or
#"Wayland" under such display servers. Indeed, under Wayland, the display
#server *IS* the window manager. What we refer to as "window managers" under
#X11 will be *MUCH* more tightly bound to Wayland itself. Indeed, under Weston
#(the reference implementation of Weston), window managers appear to be loaded
#as dynamically shared libraries on Weston startup and hence referred to as
#"shell plugins". Specifically:
#
#"Weston has shell plugins. A shell plugin is basically a window manager,
# implementing all the window management policy and protocol. It is a plugin,
# because it has to be part of the server.  The desktop-shell plugin is a window
# manager for desktops. There is also a tablet-shell plugin, but it would need
# more love. The desktop-shell plugin is accompanied with the desktop-shell
# client, which in a separate process is resposible for GUI elements, like
# backgrounds and panels. The Wayland protocol extension specific to
# desktop-shell is wl_shell.  The name is misleading nowadays, since it is not
# really part of the core protocol. Any client will use wl_shell for window
# management related requests."
#
#This is all a bit annoying, as it implies that under non-Weston Wayland
#implementations, window managers will probably be implemented in a completely
#non-orthogonal, different manner, and there exists no uniform API -- accessible
#at the CLI or not -- for querying the name of "the thing currently managing
#windows." Silly. But there it is. Of course, it'll be a year or two before
#Wayland is even robust enough for general-purpose use. In the meantime, we just
#set ${ZESHY_WINDOW_MANAGER_NAME} to simple strings without attempting querying.
#
#There already exist a few such shell plugins: i3way (inspired by tiling window
#manager i3), Orbital, and so on. The interesting thing is that zeshy probably
#doesn't *NEED* to care about shell plugins. Weston should theoretically
#eventually provide a uniform C API and hence command-line interface for
#performing generic operations universally applicable to *EVERY* shell plugin
#(e.g., setting the background image).
#
#Right. Then, under Weston, the interesting thing to see will be how the KDE
#and GNOME desktop environments are implemented -- perhaps as one or more
#plugins? Though, that seems a bit ridiculous, given the heavy and fiercely
#independent nature of both. In any case, at the moment, *WHO CARES.* :{}

# ....................{ GLOBALS                            }....................
typeset -g\
    ZESHY_SYSTEM_ID\
    ZESHY_LINUX_DISTRO_NAME\
    ZESHY_DISPLAY_SERVER_NAME\
    ZESHY_DESKTOP_ENVIRONMENT_NAME\
    ZESHY_WINDOW_MANAGER_NAME

# ....................{ SETTERS                            }....................
# Detecting system-specific metadata in a reliable manner is notoriously hard,
# let alone in an efficient *AND* reliable manner. Since zeshy calls the
# following functionality on every startup, such functionality should be
# optimized. In practice, this means that *MOST* inspection of the current
# system should reduce to scalar comparisons on existing string globals --
# either guaranteed to exist by zsh itself (e.g., ${OSTYPE}) or whose existence
# strongly implies the existence of related functionality (e.g., ${DISPLAY}
# strongly implying that a display server supporting the X11 protocol is
# currently running).
#
# As inspiration for such functionality, contemplate the following sources (in
# descending order of subjective reliability and utility as of this writing):
#
# * HardInfo, a C system profiler.
# * screenFetch, a Bash system profiler.
# * inxi, a Bash system profiler.

#FIXME: Insufficient, although certainly close enough for now. In particular,
#the current distribution should be appended to ${OSTYPE} to also handle
#migration of zeshy between different distributions of the same OS.
#FIXME: Interestingly, GNOME 3.12 provides a GNOME-specific Wayland compositor
#and hence alternative to Weston, the reference implementation for such
#compositors. Detect such compositor below and set appropriate variables. It
#seems likely KDE will follow suite, requiring we also detect the Wayland
#compositor KDE 5 (?) inevitably provides as well.
#FIXME: Interesting. Due to fewer available developers, KDE will be implementing
#a so-called "Wayland session compositor" running on top of a genuine Wayland
#compositor rather than a full Wayland compositor, suggesting KDE Wayland users
#will need to run KDE either as a Weston or Mutter (GNOME Wayland) shell plugin.
#(Har har!) In any case, detection presumably becomes that much more cumbersome.

# void ::set_system_globals(void)
function ::set_system_globals() {
    # Validate sanity.
    (( # == 0 )) || die 'Expected no arguments.'

    # Define all of the globals declared above.
    ::set_system_globals_os
    ::set_system_globals_gui

    # Define the global uniquely identifying the current system to (in order):
    #
    # * The lowercase name of the current operating system guaranteed to contain
    #   no whitespace. See @{*-core/*-test/*-os} for further details.
    # * The lowercase name of the current CPU architecture guaranteed to contain
    #   no whitespace. See @{*-core/*-test/*-architecture} for further details.
    # * The current Linux-specific distribution if any or "none" otherwise.
    # * The current display server if any or "none" otherwise.
    # * The current desktop environment if any or "none" otherwise.
    # * The current window manager if any or "none" otherwise.
    #
    # While prior logic should guarantee all such names to be both set *AND*
    # nonempty, overzealous caution never hurt no one.
    ZESHY_SYSTEM_ID="${OSTYPE}.${MACHTYPE}.${ZESHY_LINUX_DISTRO_NAME:-none}.${ZESHY_DISPLAY_SERVER_NAME:-none}.${ZESHY_DESKTOP_ENVIRONMENT_NAME:-none}.${ZESHY_WINDOW_MANAGER_NAME:-none}"

    # Convert all spaces in such identifier to underscores.
    ZESHY_SYSTEM_ID="${ZESHY_SYSTEM_ID// /_}"

    # Inform debuggers of such identifier.
    :output_line_if_debugging 'Identified current system as "'${ZESHY_SYSTEM_ID}'".'
}

# ....................{ SETTERS ~ os                       }....................
# void ::set_system_globals_os(void)
function ::set_system_globals_os() {
    # Validate sanity.
    (( # == 0 )) || die 'Expected no arguments.'

    # If the current OS is *NOT* GNU/Linux, return immediately. Only GNU/Linux
    # offers what are referred to as Linux distributions, at present.
    [[ "${OSTYPE}" == 'linux-gnu' ]] || return 0

    #FIXME: Shift most of the contents of @{*-core/*-test/*-distro} here. This
    #will probably be somewhat non-trivial, as we'll need to safely implement
    #file text grepping via "mapfile".

    #FIXME: Arguably inefficient. Consider instead testing if "/etc/lsb-release"
    #is an existing file and, if so, parsing such file for the unquoted value of
    #key "DISTRIB_ID": e.g., the string "Gentoo" from the line resembling:
    #
    #    DISTRIB_ID="Gentoo"
    #
    #This has two clear benefits over the current method:
    #
    #1. Fewer dependencies. If "lsb_release" is not pathable *BUT*
    #   "/etc/lsb-release" is an existing file, we can still reliably harvest
    #   the distro name from such file without "lsb_release".
    #2. Efficiency. Avoiding additional subshells, particularly on *EVERY* zeshy
    #   startup, is crucial.

    # Load zsh module "mapfile", providing efficient access to file contents.
    # See :load_module_mapfile_start() for further details.
    zmodload zsh/mapfile

    {
        # If "/etc/lsb-release" exists, parse the unquoted value of standard key
        # "DISTRIB_ID" from such file (e.g., string Gentoo from the file line
        # 'DISTRIB_ID="Gentoo"'). Note that the following also suffices:
        #
        #     # If "lsb_release" is pathable, capture such command's output.
        #     if (( ${+commands[lsb_release]} )) {
        #         ZESHY_LINUX_DISTRO_NAME="$(lsb_release --short --id)"
        #     }
        #
        # While more succinct, such approach requires:
        #
        # * Both file "/etc/lsb-release" and command "lsb_release", whereas the
        #   current approach requires only the former.
        # * An inefficient command substitution and hence subshell, whereas the
        #   current approach operates entirely within the current shell.
        #
        # Dismantled, this is:
        #
        # * "(?m)", matching such PCRE in a multiline-aware manner (i.e., such
        #   that "^" and "$" match both newlines and the string start and end).
        # * "(?|...)", capturing all following groups into ${match[1]}. (By
        #   default, the second such group would be captured into ${match[2]}.)
        if [[ -f '/etc/lsb-release' && "${mapfile[/etc/lsb-release]}" =~\
            '(?m)^DISTRIB_ID=(?|"([^"]++)"|(.++))$' ]] {
            ZESHY_LINUX_DISTRO_NAME="${match[1]}"
        } elif [[ -f '/etc/lsb-release' && "${mapfile[/etc/lsb-release]}" =~\
            '(?m)^DISTRIB_ID=(?|"([^"]++)"|(.++))$' ]] {
        }
    # Unload the previously loaded zsh module "mapfile", even in the event of
    # uncaught exceptions or unhandled errors. See :load_module_mapfile_stop()
    # for further details.
    } always {
        zmodload -ui zsh/mapfile
    }
}

# ....................{ SETTERS ~ gui                      }....................
# void ::set_system_globals_gui(void)
function ::set_system_globals_gui() {
    # Validate sanity.
    (( # == 0 )) || die 'Expected no arguments.'

    # If the current display server is Wayland, set such globals statically. See
    # :is_display_server_wayland() for further details.
    if (( ${+WAYLAND_DISPLAY} )) {
        # If such server supports the X11 protocol, XWayland must be running.
        # See :is_display_server_x() for further details.
        if (( ${+DISPLAY} )) {
            ZESHY_DISPLAY_SERVER_NAME='XWayland'
        # Else, only Wayland itself is running.
        } else {
            ZESHY_DISPLAY_SERVER_NAME='Wayland'
        }
    # Else if the current display server is Mir, set such globals statically.
    # See :is_display_server_mir() for further details.
    } elif (( ${+MIR_SOCKET} )) {
        # Mir provides its own desktop environment as a Mir plugin. Curiously,
        # such environment retains the predictable Ubuntu name "Unity" despite
        # having little to nothing in common under the hood with prior GNOME-
        # and Compiz-based Ubuntu desktop environments of the same name. True
        # to its word, "Unity" has responsibly unified open-source efforts.
        # (Said with finger down throat.)
        ZESHY_DESKTOP_ENVIRONMENT_NAME='Unity'

        # If such server supports the X11 protocol, XMir must be running.
        if (( ${+DISPLAY} )) {
            ZESHY_DISPLAY_SERVER_NAME='XMir'
        # Else, only Mir itself is running.
        } else {
            ZESHY_DISPLAY_SERVER_NAME='Mir'
        }
    # Else if the current OS is Apple iOS, set such globals statically. See
    # @{*-core/*-test/*-os} for further details.
    } elif [[ "${OSTYPE}" == 'darwin'* ]] {
        # If the current display server (Quartz Compositor) supports the X11
        # protocol, XQuartz must be running.
        if (( ${+DISPLAY} )) {
            ZESHY_DISPLAY_SERVER_NAME='XQuartz'
        # Else, only Quartz Compositor is running.
        } else {
            ZESHY_DISPLAY_SERVER_NAME='Quartz'
        }
    # Else if the current OS is Microsoft Windows, set such globals statically.
    } elif [[ "${OSTYPE}" == ('cygwin'|'mingw')* ]] {
        # If the current display server supports the X11 protocol, either XMing
        # or Cygwin X is probably running. For brevity, assume the former.
        if (( ${+DISPLAY} )) {
            ZESHY_DISPLAY_SERVER_NAME='XMing'
        # Else, only Windows itself is running.
        } else {
            ZESHY_DISPLAY_SERVER_NAME='Windows'
        }
    # Else if the current display server supports the X11 protocol, set such
    # globals dynamically by querying the appropriate X11 property of the root
    # window (i.e., the desktop). This is fairly computationally complex, but
    # there's little we can do about that.
    } elif (( ${+DISPLAY} )) {
        ::set_system_globals_gui_x
    # Else, there either exists no display server or the current OS is running
    # an OS-specific and hence non-X11-compatible display server. For
    # simplicity, ignore the latter case. In the former case, the current shell
    # is running under a virtual console. While virtual consoles are *NOT*
    # display servers, pretend they are. (Again, for simplicity.)
    } else {
        ZESHY_DISPLAY_SERVER_NAME='console'
    }

    # If no desktop environment and/or window manager was identified, default
    # such names to the name of the current display server if any. This does
    # *NOT* signify an error but the common case for display servers serving as
    # their sole window managers (e.g., Mir, Quartz, Wayland). See
    # set_string_if_empty_to_string() for further details.
    : "${ZESHY_DESKTOP_ENVIRONMENT_NAME:=${ZESHY_DISPLAY_SERVER_NAME}}"
    : "${ZESHY_WINDOW_MANAGER_NAME:=${ZESHY_DESKTOP_ENVIRONMENT_NAME}}"
}

# void ::set_system_globals_gui_x(void)
function ::set_system_globals_gui_x() {
    # Validate sanity.
    (( # == 0 )) || die 'Expected no arguments.'

    # Set the current display server to merely X.
    ZESHY_DISPLAY_SERVER_NAME='X'

    # Identify the current window manager.
    #
    # If "wmctrl" is installed, prefer such command. Whereas "xprop" requires at
    # least two command substitutions and string mungings to reliably do so,
    # "wmctrl" only requires one of each. See is_pathable() for further details.
    if (( ${+commands[wmctrl]} )) {
        # Get a human-readable synopsis of the current window manager: e.g.,
        #
        #     Name: FVWM
        #     Class: N/A
        #     PID: N/A
        #     Window manager's "showing the desktop" mode: N/A
        ZESHY_WINDOW_MANAGER_NAME="$(command wmctrl -m)"

        # Extract the substring between "Name: " and the first newline.
        # Dismantled, this is:
        #
        # * "(f)", expanding to the first line of such synopsis.
        # * "[7,-1]", stripping such prefix from such line.
        ZESHY_WINDOW_MANAGER_NAME="${ZESHY_WINDOW_MANAGER_NAME[(f)1][7,-1]}"
    # Else if "xprop" is installed, fallback to such command.
    } elif (( ${+commands[xprop]} )) {
        # Get the window ID of the child window of the root window whose window
        # properties reflect the current window manager rather than such window.
        # Default "xprop" output is cumbersome to parse: e.g.,
        #
        #     _NET_SUPPORTING_WM_CHECK(WINDOW): window id # 0x80001a
        #
        # Hence, pass options streamlining such output: e.g.,
        #
        #     _NET_SUPPORTING_WM_CHECK 0x80001a
        integer window_id_wm; window_id_wm="$(command xprop -root -notype\
            -f _NET_SUPPORTING_WM_CHECK 32x ' $0' _NET_SUPPORTING_WM_CHECK)"

        # Strip the prefixing property name from such ID.
        window_id_wm="${window_id_wm##* }"

        # Get the name of the current window manager from such window. Again,
        # default "xprop" output is cumbersome to parse: e.g.,
        #
        #     _NET_WM_NAME(UTF8_STRING) = "FVWM"
        #
        # Hence, pass options streamlining such output: e.g.,
        #
        #     _NET_WM_NAME "FVWM"
        ZESHY_WINDOW_MANAGER_NAME="$(command xprop -id "${window_id_wm}" -notype\
            -f _NET_WM_NAME 8u ' $0' _NET_WM_NAME)"

        # Munge such name. Specifically:
        #
        # * Strip the prefixing property name and '"' from such name.
        # * Strip the suffixing '"' from such name.
        ZESHY_WINDOW_MANAGER_NAME="${${ZESHY_WINDOW_MANAGER_NAME##*\"}[1,-2]}"
    }

    # Identify the current desktop environment *AFTER* such window manager, as
    # the latter can be used to efficiently deduce the former in some cases.
    #
    # If canonical KDE-specific environment variable ${KDE_SESSION_VERSION}
    # exists, this is a KDE desktop of major version equal to such value.
    if (( ${+KDE_SESSION_VERSION} )) {
        ZESHY_DESKTOP_ENVIRONMENT_NAME="KDE${KDE_SESSION_VERSION}"
    # Else if canonical KDE-specific environment variable ${KDE_FULL_SESSION}
    # exists, this is a KDE desktop. Recall that:
    #
    # * KDE 3.5.5 introduced ${KDE_FULL_SESSION}.
    # * KDE 4 introduced ${KDE_SESSION_VERSION}.
    # * ${KDE_SESSION_VERSION} does *NOT* exist.
    #
    # Hence, we deduce this to necessarily be a KDE3 desktop.
    } elif (( ${+KDE_FULL_SESSION} )) {
        ZESHY_DESKTOP_ENVIRONMENT_NAME='KDE3'
    # Else if such window manager was identified, attempt to match the desktop
    # environment corresponding to such manager.
    } elif [[ -n "${ZESHY_WINDOW_MANAGER_NAME}" ]] {
        # If such window manager name is (in descending order of likelihood)...
        case "${ZESHY_WINDOW_MANAGER_NAME}" {
        # ..."Muffin", this is a Cinammon desktop (i.e., GNOME 3 fork).
        'Muffin') ZESHY_DESKTOP_ENVIRONMENT_NAME='Cinammon';;
        # ..."Mutter", this is a GNOME 3 desktop.
        'Mutter') ZESHY_DESKTOP_ENVIRONMENT_NAME='GNOME3';;
        # ..."Marco", this is a MATE desktop (i.e., GNOME 2 fork).
        'Marco') ZESHY_DESKTOP_ENVIRONMENT_NAME='MATE';;
        # ..."Metacity", this is a GNOME 2 desktop.
        'Metacity') ZESHY_DESKTOP_ENVIRONMENT_NAME='GNOME2';;
        # ...prefixed by "Xfwm" (e.g., "Xfwm4", "Xfwm5), this is an XFCE desktop
        # of major version equal to such name's suffix.
        'Xfwm'*) ZESHY_DESKTOP_ENVIRONMENT_NAME="XFCE${ZESHY_WINDOW_MANAGER_NAME[5,-1]}";;
        }
    }

    # If such desktop environment remains unidentified, the search goes on.
    if [[ -z "${ZESHY_DESKTOP_ENVIRONMENT_NAME}" ]] {
        # If proposed environment variable ${XDG_CURRENT_DESKTOP} exists,
        # default to the value of such variable verbatim. As the answer
        # beginning "On Ubuntu 12.04 I tested environment..." at
        # http://askubuntu.com/questions/72549/how-to-determine-which-window-manager-is-running
        # demonstrates, *ALL* desktop environments setting such variable appear
        # to reliably format such variable's value exactly as we require (e.g.,
        # "GNOME", "LXDE", "Unity").
        if (( ${+XDG_CURRENT_DESKTOP} )) {
            ZESHY_DESKTOP_ENVIRONMENT_NAME="${XDG_CURRENT_DESKTOP}"
        # If GNOME-specific environment variable ${GNOME_DESKTOP_SESSION_ID}
        # exists, this is a GNOME desktop. Note that later versions of GNOME 2
        # and all versions of GNOME 3 deprecate but continue to reliably set
        # such variable to "this-is-deprecated". Amusingly, the existence of
        # such variable serves as the most efficient means of detecting GNOME.
        #
        # Test such variable *AFTER* testing for ${XDG_CURRENT_DESKTOP}, which
        # most if not all modern GNOME forks and variants set to their specific
        # name (e.g., "Unity") and is hence preferable to "GNOME" itself.
        #
        # Sadly, differentiating between GNOME versions requires capturing
        # "gnome-about --gnome-version" output. Since the prior conditional also
        # fails to do so *AND* since zeshy subsequently does so during digest
        # compilation, this is hardly the end of the world.
        } elif (( ${+GNOME_DESKTOP_SESSION_ID} )) {
            ZESHY_DESKTOP_ENVIRONMENT_NAME='GNOME'
        # Else if proposed environment variable ${DESKTOP_SESSION} exists,
        # default to the value of such variable verbatim. As function
        # detect_desktop_environment() in HardInfo suggests (and as the answer
        # beginning "I've tested the best tools I've found with..." at the prior
        # URL confirms), desktop environments setting such variable and *NOT*
        # also setting ${XDG_CURRENT_DESKTOP} appear to reliably format such
        # variable's value. Since this remains the least reliable of available
        # variables, however, test such variable last.
        } elif (( ${+DESKTOP_SESSION} )) {
            ZESHY_DESKTOP_ENVIRONMENT_NAME="${DESKTOP_SESSION}"
        # Else if such window manager was identified, default such desktop
        # environment to such window manager. This is sensible under
        # minimalist window managers leveraging no known desktop environment
        # (e.g., tiling window managers). Note the similar expression below.
        # See set_string_if_empty_to_string() for further details.
        } else {
            : "${ZESHY_DESKTOP_ENVIRONMENT_NAME:=${ZESHY_WINDOW_MANAGER_NAME}}"
        }
    }
}

# ....................{ MAIN                               }....................
::set_system_globals

# --------------------( WASTELANDS                         )--------------------
        # If "lsb_release" is pathable, capture such command's output.
        # if (( ${+commands[lsb_release]} )) {
        #     ZESHY_LINUX_DISTRO_NAME="$(lsb_release --short --id)"
        # }

    # If the current *nix distribution provides the "lsb_release" command, run
    # such command to obtain the name of such distribution. While alternatives
    # to "lsb_release" do exist (e.g., globbing for filenames matching
    # /etc/*release), it hardly seems worth the effort so early in the bootstrap
    # process. Dismantled, this is:
    #
    # * "${:-lsb_release}", expanding to the string "lsb_release".
    # * "${...:c}", expanding to the absolute path of "lsb_release" if installed
    #   in the current $PATH or only "lsb_release" otherwise.
    # * "-x", returning true if such path is executable and hence installed.
    #   Unless the current directory contains an executable "lsb_release", this
    #   returns true only if ":c" expanded to an absolute path.
    # if [[ -x "${${:-lsb_release}:c}" ]] {

# The strictly lowercase name of the current operating system, which zsh
    #   guarantees to contain no whitespace. See @{*-core/*-test/*-os} for
    #   further details.

#FUXME: The current digest file needs to depend on both zeshy-specific state
#(e.g., whether or not we're compiling a debug build) and system-specific state
#(e.g., the current OS and windowing manager in use). At the moment, it only
#depends on the former. The reason we such file needs to depend on both is that
#users should be able to seemlessly move their entire "~/.zeshy" directory
#between not only different machines running the same OS but between different
#machines running different OSes. To effect the latter, we'll need to
#specifically create an intermediary subdirectory directly under
#"~/.zeshy/cache/digest" named after all relevant system state: e.g.,
#
#    ~/.zeshy/
#        cache/
#            digest/
#                current -> linux.gentoo.x11/
#                linux.gentoo.mir/
#                    debug.zwc
#                    release.zwc
#                linux.gentoo.wayland/
#                    debug.zwc
#                    release.zwc
#                linux.gentoo.x11/
#                    debug.zwc
#                    release.zwc
#                darwin/
#                    debug.zwc
#                    release.zwc
#                windows/
#                    debug.zwc
#                    release.zwc
#
#Note the symbolic link "current", linking to configuration tree
#"linux.gentoo.x11/" in the above example. Such directory is both for user
#convenience and zeshy use. Indeed, setting such symlink in a reliable manner
#simplifies our autoloading of the digest file corresponding to the current
#system state. (That is, assuming we set such symlink reliably, *NO* existing
#code in this parcel needs to change to accommodate this improvement.)
#
#In any case, the symbolic link is quite negligible. For safety, the critical
#thing is that we implement support for such subdirectories. That's it. Yummy!
#FUXME: Note, however, this implies that we'll need to shift OS and windowing
#manager detection logic here (...or possibly in a new top-level parcel sourced
#by this parcel called, say, @{test}). Unavoidable, really. Since we only need
#the subset of such logic producing a single flat string describing all relevant
#system state (e.g., "linux.gentoo.x11"), such logic *HOPEFULLY* won't be
#grossly cumbersome.
#
#Note, however, that such logic *WILL* be reused by @{compile} when deciding
#which suboverlays of an "if_os" overlay to register. This suggests we probably
#will need more than simply logic producing such string... but, without actually
#delving into it, it's presumptuous to say with certainty.
#FUXME: O.K.; after reasonably deep contemplation, here's the low-level plan for
#implementing the above:
#
#* Create new top-level parcel @{inspect}, dynamically inspecting the current
#  system and setting persistent string globals describing the results of such
#  inspection. Given the variety of all possible operating systems, display
#  servers, window managers, and so forth to be inspected, such parcel is
#  expected to eventually grow to considerable size and hence be inappropriate
#  for inclusion in this parcel.
#* @{inspect} should declare and define at least the following string globals:
#  * ${ZESHY_WINDOW_MANAGER_NAME}, the raw low-level name of the current window
#    manager.  Basically, this is the capitalized string reported by "xprop"
#    (with the delimiting double quotes necessarily stripped, of course). Since
#    window managers are necessarily tied to particular display servers, the
#    window manager name implies a unique display server (e.g., if
#    "${ZESHY_WINDOW_MANAGER_NAME} == FVWM", then the display server is X).
#    Hence, we needn't formalize the names of either the current display server
#    *OR* deskop environment. (Which is nice, as the latter in particular can be
#    fairly expensive.)
#  * ${ZESHY_SYSTEM_ID}, set as
#    ZESHY_SYSTEM_ID="${OSTYPE}.${ZESHY_WINDOW_MANAGER_NAME}" (e.g.,
#    "linux-gnu.FVWM"). This is *THE* critical string, used as the basename of
#    the subdirectory under both "~/.zeshy/cache/digest" and "~/.zeshy/config"
#    to write and read from.  Naturally, such basename should contain no
#    whitespace, punctuation aside from "_", "-", and ".", or UTF8 characters.
#  And that's it, for now.
#* This implies we should rename:
#  * ${ZESHY_USER_DIGEST_ROOT_DIRNAME} to ${ZESHY_USER_DIGEST_ROOT_DIRNAME}.
#  * ${ZESHY_USER_CONFIG_ROOT_DIRNAME} to ${ZESHY_USER_CONFIG_ROOT_DIRNAME}.
#  Then set:
#  * ZESHY_USER_DIGEST_ROOT_DIRNAME="${ZESHY_USER_DIGEST_ROOT_DIRNAME}/${ZESHY_SYSTEM_ID}".
#  * ZESHY_USER_CONFIG_ROOT_DIRNAME="${ZESHY_USER_CONFIG_ROOT_DIRNAME}/${ZESHY_SYSTEM_ID}".
#* Shift the window manager detection code currently embodied in
#  :set_string_to_window_manager() to @{inspect}. Thereafter,
#  :set_string_to_window_manager() should be dynamically defined to always
#  statically return ${ZESHY_WINDOW_MANAGER_NAME}.
#* Do *NOT* shift the OS detection code currently embodied in
#  @{*-core/*-test/*-os} here. Instead, simply use the low-level raw string
#  ${OSTYPE} as is without modification in @{inspect}.
#* Have this parcel unconditionally source @{inspect}.
#FUXME: [NOTE: None of the above applies, actually. See the next FUXME comment.]
#
#Great. So, that inspects the system and establishes the requisite globals. What
#then? Well, then we have to actually compare the previously cached version of
#${ZESHY_SYSTEM_ID} to the current version, implying we need to cache such
#global. When? Where? Simple: existing function ::precompile_zeshy_cache() in
#@{compile} *ALREADY* writes list global ${ZESHY_USER_DIGEST_DEPENDENCY_PATHNAMES} to
#zsh script "${ZESHY_USER_DIGEST_DEPENDENCIES_FILENAME}". In fact, that's the *ONLY*
#global that's currently written there. But it certainly needn't be. Modify such
#function to *ALSO* write ${ZESHY_SYSTEM_ID} to such file. (Dead simple, given
#that such function does so by calling write_file_with_variable().)
#
#:is_zeshy_digest_outdated() then sources such file and hence defines all such
#globals. Arguably, ::precompile_zeshy_cache() should save at least
#${ZESHY_SYSTEM_ID} under a different name to permit comparison with the
#current value of ${ZESHY_SYSTEM_ID} established by @{inspect} -- say, as
#${ZESHY_SYSTEM_ID_OLD}. (Since such global is a string, it's both trivial and
#efficient to locally copy such string to a temporary new global
#${ZESHY_SYSTEM_ID_OLD} defined and then subsequently unset within
#::precompile_zeshy_cache().) Great! So, *AFTER* sourcing
#"${ZESHY_USER_DIGEST_DEPENDENCIES_FILENAME}" but *BEFORE* examining any path
#mtimes, :is_zeshy_digest_outdated() performs the following comparison:
#
#  [[ "${ZESHY_SYSTEM_ID}" == "${ZESHY_SYSTEM_ID_OLD}" ]] || return 0
#FUXME: Oh, wait. We don't even *NEED* to perform such comparison, since it's
#implicit in the fact that ${ZESHY_USER_DIGEST_ROOT_DIRNAME} and hence
#${ZESHY_USER_DIGEST_FILENAME} now depends on ${ZESHY_SYSTEM_ID}. This, in turn,
#means we don't even need to perform any of the above writing of
#${ZESHY_SYSTEM_ID} into ${ZESHY_USER_DIGEST_DEPENDENCIES_FILENAME}. Dead simple!
#FUXME: Ah! Note that @{digest} will actually need to set:
#
#* ZESHY_USER_DIGEST_ROOT_DIRNAME="${ZESHY_USER_DIGEST_ROOT_DIRNAME}/${HOST}.${ZESHY_SYSTEM_ID}".
#* ZESHY_USER_CONFIG_ROOT_DIRNAME="${ZESHY_USER_CONFIG_ROOT_DIRNAME}/${ZESHY_SYSTEM_ID}".
#
#We prepend the hostname of the current system to the current digest but *NOT*
#configuration root directory, ensuring that migrating zeshy to a different
#machine triggers recompilation regardless of whether the current digest file is
#newer than everything on such machine.

    #FUXME: BSD installs no such command, so this clearly fails to suffice.
    #We'll probably want to just import the entire get_distro_name() command.
    #Or perhaps not. Is the logic simple, under BSD?
    #FUXME: Oh! Right. Now that we've *SIGNIFICANTLY* refactored the codebase,
    #we are veritably guaranteed of having get_distro_name() defined by
    #@{20-main} prior to needing such function for deciding what to compile in
    #@{30-if_distro}. Hence, excise all reference to ${ZESHY_DISTRO_NAME},
    #including the code block below, and simply call get_distro_name() where we
    #previously expanded ${ZESHY_DISTRO_NAME} below.

    # * Initialize the string uniquely identifying such system to the strictly
    # lowercase name of the current operating system, which zsh guarantees to
    # contain no whitespace. See @{*-core/*-test/*-os} for further details.

                #FUXME: It'd be great if we could efficiently differentiate
                #between GNOME 2 and 3. Unfortunately, it's unclear that we can.
                #While we could of course capture "gnome-about --gnome-version"
                #output, doing so would hardly be efficient. Contemplate.

        # Else if proposed canonical environment variable ${XDG_CURRENT_DESKTOP}
        # exists, default to the value of such variable verbatim. See
        # set_string_if_empty_to_string() for further details.
        # } elif [[ -n "${XDG_CURRENT_DESKTOP}" ]] {
        #     : "${ZESHY_WINDOW_MANAGER_NAME:=${XDG_CURRENT_DESKTOP}}"
    # [[ -n "${ZESHY_DESKTOP_ENVIRONMENT_NAME}" ]] ||
    #     ZESHY_DESKTOP_ENVIRONMENT_NAME="${ZESHY_DISPLAY_SERVER_NAME}"
    # }
    # [[ -n "${ZESHY_WINDOW_MANAGER_NAME}" ]] ||
    #     ZESHY_WINDOW_MANAGER_NAME="${ZESHY_DISPLAY_SERVER_NAME}"
    # local display_server_name
    #     # The Wayland display server also serves as its sole window manager.
    #     ZESHY_WINDOW_MANAGER_NAME="${ZESHY_DISPLAY_SERVER_NAME}"
    #     # The Mir display server also serves as its sole window manager.
    #     ZESHY_WINDOW_MANAGER_NAME="${ZESHY_DISPLAY_SERVER_NAME}"

            # * Convert all spaces in such name to underscores. (Though rare, window
            #   manager names can technically contain spaces.)
            # ZESHY_WINDOW_MANAGER_NAME="${${ZESHY_WINDOW_MANAGER_NAME##*\"}[1,-2]// /_}"

    # * The current window manager if any or "none" otherwise, converting all
    #   spaces in such name to underscores. (Though rare, window manager names
    #   can technically contain spaces.)
    # ZESHY_SYSTEM_ID="${OSTYPE}.${ZESHY_DISPLAY_SERVER_NAME:-none}.${ZESHY_WINDOW_MANAGER_NAME:-none// /_}"
