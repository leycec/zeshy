#!/usr/bin/env zsh
# ====================[ autoload                           ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Autoload Zeshy functions and Zsh module functions and variables.
#
# --------------------( SEE ALSO                           )--------------------
# https://jgao.googlecode.com/svn/trunk/.shell/zsh_module
#     Comprehensive Zsh module autoload definitions inspiring those below.

#FIXME: This could be a nice opportunity to truncate "main" a bit. I'd
#specifically like to see get_script_name() shifted into "shell/shell" and
#say() and cry() shifted into "shell/output".

# ....................{ TESTERS                            }....................
# boolean is_zeshy_digest_outdated(void)
#
# Return true if Zeshy's digest is outdated and hence requires recompilation, as
# when such file does not exist or does but is older than the newest of:
#
# * The main user-specific Zeshy configuration file. This file contains theme
#   settings, which when edited require recompiling theme autoloads.
# * The main system-wide command directories (e.g., "/bin", "/usr/bin").
#   Installing or uninstalling commands requires recompiling command autoloads.
function is_zeshy_digest_outdated() {
    # Validate sanity.
    (( # == 0 )) || die 'expected no arguments'

    # If either Zeshy's digest file or configuration directory do not exist or
    # the latter exists but is empty, mark such file "outdated."
    [[ -f "${ZESHY_DOT_DIGEST_FILE}" && -d "${ZESHY_DOT_CONFIG_DIR}" ]] && {
        local -a zeshy_user_config_dir_if_nonempty
        zeshy_user_config_dir_if_nonempty=( "${ZESHY_DOT_CONFIG_DIR}"(/F) )
        (( #zeshy_user_config_dir_if_nonempty ))
    } || return 0

    # List of modification times of paths on which Zeshy's digest depends,
    # initialized to contain .
    local -a dependency_mtimes

    #FIXME: Definitely not right. We absolutely want to do this *AFTER*
    #"always/shell/profile" establishes the global list "path"; then, replace
    #the awkwardly hard-coded paths below with the following:
    #
    #    for dependency_pathname ("${path[@]}" "${ZESHY_DOT_CONFIG_DIR}"/{,*}) {
    #
    #Concise; awesome; and exactly what's needed. We'll probably just want to
    #extricate the setting of the ${PATH} currently performed by
    #"always/shell/profile" to somewhere directly under "src/" -- perhaps this
    #component? There's really no reason to perform such logic *ONLY* under a
    #login shell; ideally, the ${PATH} should always be "fixed up" on Zeshy
    #startup. After all, either the user or a script could destroy the ${PATH}
    #after login, in which case we really wouldn't want to trust its current
    #setting. So, fix it up to guarantee sane behavior.

    # Dismantled, this is:
    #
    # * "${ZESHY_DOT_CONFIG_DIR}"/{,*}, expanding to the current user's Zeshy
    #   configuration dirname and all filenames under such dirname, thus
    #   reporting Zeshy to be outdated on adding, deleting, or editing a Zeshy
    #   configuration file.
    for dependency_pathname (
        '/bin' '/sbin' '/usr/bin' '/usr/sbin' "${ZESHY_DOT_CONFIG_DIR}"/{,*}) {
#       say "adding mtime for dependency \"${dependency_pathname}\"..."
        [[ -e "${dependency_pathname}" ]] &&
            dependency_mtimes+="$(zstat +mtime "${dependency_pathname}")"
    }

    #FIXME: Rename "ZESHY_IS_DEBUGGING" to "ZESHY_IS_IN_DEVELOPMENT". :)
    # If the current user is a Zeshy developer, obtain the last modification
    # time of the Zeshy codebase by sorting the set of all last modification
    # times of all files and directories in this codebase and selecting the
    # largest such time. This is at best an O(n*lg(n)) operation, and hence
    # confined to developers. Dismantled, this is:
    #
    # * "${...}"/**/*, all files and directories of this codebase.
    # * "om", sorting such files and directories by descending mtime.
    # * "[1]", the first and hence newest such file or directory.
    [[ -n "${ZESHY_IS_DEBUGGING-}" ]] && {
#       say "adding mtime for Zeshy codebase \"${ZESHY_HOME}\"..."
        dependency_mtimes+="$(zstat +mtime "${ZESHY_HOME}"/**/*(om[1]))"
    }

    # The newest modification time of all dependencies of Zeshy's digest.
    # Technically, sorting such list is technically O(n lg(n)). Assuming a
    # sufficiently small ${PATH}, sorting is nearly O(n). Dismantled, this is:
    #
    # * "(nO@)", numerically sorting such list in descending order.
    # * "[1]", the first and hence newest such time.
    ZESHY_NEWEST_DEPENDENCY_MTIME="${${(nO@)dependency_mtimes}[1]}"

    # The modification time of Zeshy's digest.
    integer zeshy_digest_mtime
    zeshy_digest_mtime="$(zstat +mtime "${ZESHY_DOT_DIGEST_FILE}")"

    # If Zeshy's digest is older than its newest dependency, signify such digest
    # to be outdated by returning true.
#   say "mtimes: ${dependency_mtimes[@]}"
#   say "newest: ${ZESHY_NEWEST_DEPENDENCY_MTIME}"
#   say "digest: ${zeshy_digest_mtime}"
#   say "digest file: \"${ZESHY_DOT_DIGEST_FILE}\""
    (( zeshy_digest_mtime < ZESHY_NEWEST_DEPENDENCY_MTIME ))
}

# ....................{ AUTOLOADERS                        }....................
# void autoload_zeshy(void)
#
# Autoload Zeshy functions and functions and variables defined by Zsh modules.
function autoload_zeshy() {
    (( # == 0 )) || die 'expected no arguments'
    autoload_zeshy_zsh_modules
    autoload_zeshy_functions
}

# void autoload_zeshy_zsh_modules(void)
#
# Autoload functions and variables defined by stock Zsh modules, thus deferring
# loading such modules until calling such functions or expanding such variables.
function autoload_zeshy_zsh_modules() {
    # Validate sanity.
    (( # == 0 )) || die 'expected no arguments'

    # Define autoloads for all autoloadable functions in ${fpath}, obsoleting
    # manual autoloading of such functions (e.g., "zsh-mime-setup" versus
    # "autoload -U zsh-mime-setup; zsh-mime-setup"). Dismantled, this is:
    #
    # * "fpath", the list of all directories with autoloadable files.
    # * "^", iteratively expanding to each such directory.
    # * "/*", each immediate file and subdirectory of such directory.
    # * "N", ignoring non-extant files and subdirectories.
    # * ".", including only plain files (e.g., excluding directories).
    # * ":t", the tail (i.e., basename) of such file.
    #
    # This matches all basenames of immediate files of directories in the function
    # path. (Since this is also the set of all autoloadable function names,
    # autoloading such basenames autoloads all autoloadable functions.) Oh!
#   for autoloadable_function_name in ${^fpath}/*(N.:t); do
    for function_name in ${^fpath}/*(.:t); do
        #   print "autoloading \"${autoload_function_name}\"..."
        # For safety, autoload this function under option "-U" to suppress alias
        # expansion. This prevents expansion of Zeshy- and user-specific aliases
        # under core Zsh functions implemented with no such aliases in mind.
        autoload -U -- "${function_name}"
    done

    # Define autoloads for all autoloadable functions defined by Zsh modules not
    # autoloaded above. Unlike above, this requires manually mapping such
    # functions to such modules -- an unctuous proposition. Avoid mapping:
    #
    # * Modules previously loaded by the main Zeshy script.
    # * "mapfile", whose overly permissive style poses a profound risk of
    #   permanent, silent file deletion or modification. For safety, this module
    #   must be manually loaded and unloaded.
    # * "prof", which when loaded begins aggressively profiling Zsh functions.
    #   While useful, autoloading the zprof() function this module defines will
    #   begin profiling *ONLY* at the first call of such function, whereas such
    #   function is intended to be called after having already loaded this
    #   module and performed the profiled code. By intentional design, this
    #   module must be manually loaded and unloaded.
    #
    # Dismantled, this is:
    #
    # * "-a", autoloading the following builtins ("b"), functions ("f"), or
    #   parameters ("p") from the immediately following module.
    # * "i", ignoring rather than failing when such builtins, functions, or
    #   parameters have already been loaded within such module.
    zmodload -abi zsh/cap cap getcap setcap
    zmodload -abi zsh/clone clone
    zmodload -abi zsh/compctl compctl compcall
    zmodload -abi zsh/computil comparguments compdescribe compfiles compgroups\
        compquote comptags comptry compvalues
    zmodload -afi zsh/deltochar delete-to-char zap-to-char
    zmodload -afi zsh/mathfunc abs int float acos acosh asin asinh atan atanh\
        cbrt ceil cos cosh erf erfc exp expm1 fabs floor gamma j0 j1 lgamma log\
        log10 log1p logb sin sinh sqrt tan tanh y0 y1 ilogb signgam copysign\
        fmod hypot nextafter jn yn ldexp scalb rand48
    zmodload -abi zsh/pcre pcre_compile pcre_study pcre_match
    zmodload -abi zsh/sched sched
    zmodload -abi zsh/net/socket zsocket
    zmodload -abi zsh/net/tcp ztcp
    zmodload -abi zsh/system syserror sysread syswrite
    zmodload -api zsh/system errnos
    zmodload -abi zsh/termcap echotc
    zmodload -api zsh/termcap termcap
    zmodload -abi zsh/zftp zftp
    zmodload -api zsh/zleparameter keymaps widgets
    zmodload -abi zsh/zpty zpty
    zmodload -abi zsh/zselect zselect
}

# void autoload_zeshy_functions(void)
#
# Render all Zeshy functions applicable to the current user autoloadable after
# recompiling such functions into the Zeshy digest file for such user.
function autoload_zeshy_functions() {
    # Validate sanity.
    (( # == 0 )) || die 'expected no arguments'

    # If ignoring the Zeshy user directory, manually source all applicable Zeshy
    # scripts and hence functions without autoloading Zeshy.
    [[ -n "${ZESHY_DOT_DIR}" ]] || {
        source_zeshy_scripts_without_dot_dir
        return 0
    }

    # The modification time of the newest path on which Zeshy's digest depends.
    # is_zeshy_digest_outdated() subsequently sets this if returning true. Yes:
    # this is somewhat hackier than we prefer, but the alternatives are uglier.
    integer ZESHY_NEWEST_DEPENDENCY_MTIME

    # If such digest is outdated, compile all Zeshy functions applicable to the
    # current user into such digest and render such functions autoloadable.
#   say "detecting \"${ZESHY_DOT_DIGEST_FILE}\"..."
    if is_zeshy_digest_outdated
    then autoload_zeshy_functions_after_compiling_digest
    # Otherwise, attempt to autoload the previously compiled digest for the
    # current user. If such autoload fails, (re)compile such digest and try
    # again.
    else
#       say "autoloading \"${ZESHY_DOT_DIGEST_FILE}\"..."
        autoload -w -- "${ZESHY_DOT_DIGEST_FILE}" ||
            autoload_zeshy_functions_after_compiling_digest
    fi

    # Prefix the function path with the absolute path to the digest file to
    # ensure Zsh searches such file for the definition of such functions first.
    # Oddly, Zsh has no means of directly associating the two.
    fpath=( "${ZESHY_DOT_DIGEST_FILE}" "${fpath[@]}" )
}

# void autoload_zeshy_functions_after_compiling_digest(integer digest_mtime)
#
# Render all Zeshy functions applicable to the current user autoloadable after
# recompiling such functions into the Zeshy digest file for such user, setting
# the modification time of such file to the passed integer.
function autoload_zeshy_functions_after_compiling_digest() {
    # Validate sanity.
    (( # == 0 )) || die 'expected no arguments'

    # Source all applicable Zeshy scripts and hence functions.
    source_zeshy_script compile

    # Set the modification time of such digest to that of the newest
    # modification time to avoid recompilation on the next Zeshy run.
    touch -m --date=@${ZESHY_NEWEST_DEPENDENCY_MTIME} --\
        "${ZESHY_DOT_DIGEST_FILE}"

    # Declare all functions defined by such digest to be autoloadable.
#   say "autoloading \"${ZESHY_DOT_DIGEST_FILE}\"..."
    autoload -w -- "${ZESHY_DOT_DIGEST_FILE}" ||
        die "\"${ZESHY_DOT_DIGEST_FILE}\" cannot be compiled"
}

# ....................{ SOURCERS                           }....................
# void source_zeshy_scripts_without_dot_dir(void)
#
# Source all Zeshy scripts and hence functions applicable to the current user
# without reading to or writing from such user's Zeshy directory.
function source_zeshy_scripts_without_dot_dir() {
    # Validate sanity.
    (( # == 0 )) || die 'expected no arguments'

    # Source such scripts.
    source_zeshy_script compile

    # Delete Zsh-specific globals possibly referencing such directory.
    unset -- HISTFILE
}

# ....................{ MAIN                               }....................
autoload_zeshy

# --------------------( WASTELANDS                         )--------------------
#   zmodload -abi zsh/datetime strftime
    #   never profile in the intended manner.
    #   such profiling is both wasteful where not immediately
    #   utilized and not cost-free and could in the
    #   amortization of all such costs become prohibitively expensive.
#   zmodload -abi zsh/zprof zprof
    # If ignoring Zeshy's user directory, pretend the digest file under such
    # directory to be outdated. This induces Zeshy to source all appropriate
    # scripts manually, below.
#   [[ -n "${ZESHY_DOT_DIR}" ]] || return 0

    # Validate passed arguments.
#   (( # == 1 )) || die 'expected one integer'
#   string digest_mtime="${1}"
#   [[ "${digest_mtime}" == <-> ]] ||
#       die "\"${digest_mtime}\" not a nonnegative integer"

    # Otherwise, source all user configuration files. Since the above condition
    # implicitly sources such files already, do so when not recompiling here.
#   else
        # If the current user's Zeshy configuration dir exists but is empty,
        # throw an exception. Despite having previously tested for this, do so
        # again in the unlikely event of a race condition in which such user
        # deleted such files in between the prior and current tests. If such an
        # event occurs and we fail to throw an exception here, calling "source"
        # below with no arguments results in an undecipherable error resembling
        # "source: not enough arguments".
#       list user_config_filenames
#       user_config_filenames=( "${ZESHY_DOT_CONFIG_DIR}/"* )
#       (( #user_config_filenames )) or
#           die "configuration dir \"${ZESHY_DOT_CONFIG_DIR}\" empty"

        # Otherwise, source the current user's Zeshy configuration files.
#       source -- "${user_config_filenames[@]}"
#   fi

#   if [[ -d "${ZESHY_DOT_CONFIG_DIR}" ]]; then
#   source -- "${user_config_filenames[@]}"
#       list zeshy_user_config_dir_if_nonempty
#       zeshy_user_config_dir_if_nonempty=( "${ZESHY_DOT_CONFIG_DIR}"(/F) )
#       (( #zeshy_user_config_dir_if_nonempty )) or
#           die "zeshy configuration dir \"${ZESHY_DOT_CONFIG_DIR}\" empty"

        #FIXME: O.K.; the dir could exist but have no files, in which case
        #source() spits out an error. Test this and die ourselves, since this
        #should never happen here! Test this here to avoid race conditions, in
        #case such files have been deleted since the similar test above.
#       source "${ZESHY_DOT_CONFIG_DIR}/"*
    #FIXME: Is ${ZESHY_DOT_CONFIG_DIR} guaranteed to exist at this point? If
    #not, returning true if such directory does not exist also seems sane.

    # ~~~~~~~~~~~~~~~~< ZSH                                >~~~~~~~~~~~~~~~~~~~~
    # ~~~~~~~~~~~~~~~~< ZESHY                              >~~~~~~~~~~~~~~~~~~~~
# Source (i.e., load) Zsh modules and autoload Zeshy functions.
#       is -d '/bin'     si and digest_dependent_mtimes+=$(zstat +mtime '/bin')
#       is -d '/usr/bin' si and digest_dependent_mtimes+=$(zstat +mtime '/usr/bin')

#   is -f "${ZESHY_DOT_CONFIG_FILE}" si and
#       digest_dependent_mtimes+=$(zstat +mtime "${ZESHY_DOT_CONFIG_FILE}")
#        is -f "${ZESHY_DOT_DIGEST_FILE}" si and
#        (( newest_mtime == $(zstat +mtime "${ZESHY_DOT_DIGEST_FILE}") )); then
#to synchronize function definitions
    # with current system and user state
        # Find the maximum of this and the prior modification time.
#       (( zeshy_dev_mtime > zeshy_mtime )) and zeshy_mtime="${zeshy_dev_mtime}"

    #FIXME: Hmmmm; O.K.; I have a dramatic improvement here, but I'm simply too
    #lazy to implement it. Not hard; just lazy. Under the current approach, we
    #technically should also be considering the mtimes of "/etc/zsh/zshrc" and
    #"~/.zshrc", as both files may define a $PATH different from the last time
    #Zeshy was invoked. But, if you think about it, this run_quickly regresses into
    #insanity, because *ANY* profile script (e.g., "/etc/profile.env") could
    #conceivably set or augment $PATH (and probably does). So, we instead need
    #to simply test the following two things:
    #
    #* If no cache file exists or such a file exists but with insufficient or
    #  erroneous content, forego the tests below and *JUST* recompile.
    #* The current (if undefined, default to empty string) against the cached
    #  value of $ZESHY_THEME.
    #* The current (if undefined, default to empty string) against the cached
    #  value of $PATH. This requires a cache file containing sourceable values,
    #  which we declare to be local prior to sourcing: say,
    #
    #       last_ZESHY_THEME="..."
    #       last_PATH="..."
    #
    #Simple. The catch is: when do we create this file? I'm beginning to
    #suspect that our definition of $PATH for interactive shells in
    #"always/shell/profile" may obstruct things a bit, here. Oh; no. That
    #doesn't work. It must be late. Clearly, that fails to account for... well,
    #pretty much everything. Back to le drawing board.

    # If the digest file does not exist or does but is older than Zeshy's last
    # modification time, recompile this file to synchronize compiled function
    # definitions with newer Zeshy changes.
#   integer\
#         zeshy_mtime=$(zstat +mtime "${ZESHY_DOT_CONFIG_DIR}")\
#         zeshy_mtime=$(zstat +mtime "${ZESHY_DOT_CONFIG_FILE}")\
#           bin_mtime=$(zstat +mtime '/bin')\
#       usr_bin_mtime=$(zstat +mtime '/usr/bin')
#   ((     bin_mtime > zeshy_mtime )) and zeshy_mtime="${bin_mtime}"
#   (( usr_bin_mtime > zeshy_mtime )) and zeshy_mtime="${usr_bin_mtime}"
