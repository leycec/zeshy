#!/usr/bin/env zsh
# ====================[ core                               ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Core, implementing core functionality not readily definable in another
# Zeshy component.

# ....................{ EXCEPTIONS                         }....................
# void die(char *error_message = '')
#
# Print the passed error message and a stack trace to standard error, then exit
# the current shell with an error exit status.
die() {
    # If the exit status of the prior command signified an error, exit with that
    # status; otherwise, exit with the normal error status (i.e., 1).
    integer exit_status=${?}
    (( ${exit_status} == ${ZESHY_SUCCESS_CODE} )) and
       exit_status=${ZESHY_FAILURE_CODE}
    
    # Print the passed error message and a complete stack trace.
    curse "${@}"
    print_stack_trace

    # Die with the prior return code.
    die_with ${exit_status}
}

# void die_unless_set(char *variable_name, char *error_message = 'not set')
#
# Raise an exception unless the passed variable is set in the current scope.
die_unless_set() {
    die_unless_one_or_two_arguments\
        'expected one variable name and optional error message'
    string variable_name="${1}"
    is_set "${variable_name}" or die "${2:-\"${variable_name}\" not set}"
}

# void die_unless_unset(char *variable_name, char *error_message = 'already set')
#
# Raise an exception unless the passed variable is unset in the current scope.
die_unless_unset() {
    die_unless_one_or_two_arguments\
        'expected one variable name and optional error message'
    string variable_name="${1}"
    is_unset "${variable_name}" or die "${2:-\"${variable_name}\" already set}"
}

# ....................{ TESTS                              }....................
# bool is_set_nonempty(char *variable_name)
#
# Return true if the variable with the passed name is set and non-empty.
is_set_nonempty() {
    die_unless_one_argument 'expected exactly one variable name'
    is -n "${(P)1-}" si    # See below.
}

# bool is_set(char *variable_name)
#
# Return true if the variable with the passed name is set (i.e., declared).
is_set() {
    die_unless_one_argument 'expected exactly one variable name'

    # Dismantled, this is:
    # 
    # * "1", the passed name.
    # * "(P)", the variable the passed name refers to.
    # * "+x", the value to expand this variable to if set. Since any non-empty
    #   value will do, arbitrarily use "x".
    # * "-n", true only if this variable is "x" and hence set.
    is -n "${(P)1+x}" si
}

# bool is_unset(char *string)
#
# Return true if the  variable with the passed name is unset (i.e., undeclared).
is_unset() {
    die_unless_one_argument 'expected exactly one variable name'
    is -z "${(P)1+x}" si  # negate the condition is_set() tests for
}

#FIXME: Rename is_nonzero(), in keeping with Zsh nomenclature.
# bool is_nonempty(char *string)
#
# Return true if the passed string is non-empty (i.e., not "").
is_nonempty() {
    die_unless_one_argument 'expected exactly one string'
    is -n "${1}" si
}

#FIXME: Rename is_zero(), in keeping with Zsh nomenclature.
# bool is_empty(char *string)
#
# Return true if the passed string is empty (i.e., "").
is_empty() {
    die_unless_one_argument 'expected exactly one string'
    is -z "${1}" si
}

# ....................{ GETTERS                            }....................
# float get_zsh_version(void)
#
# Get the current version of Zsh as a comparable floating point number.
get_zsh_version() {
    die_unless_no_arguments
    print "${ZSH_VERSION}"
} 

# float get_zeshy_version(void)
#
# Get the current version of Zeshy as a comparable floating point number.
get_zeshy_version() {
    die_unless_no_arguments
    print 0.1
}

# ....................{ GETTERS                            }....................
# void freeze_variable(char *variable_name)
#
# Freeze the variable with the passed name, rendering such variable read-only
# (i.e., "const", "final").
freeze_variable() {
    die_unless_one_argument 'expected exactly one variable name'
    string variable_name="${1}"
    die_unless_set "${variable_name}"
    typeset -r     "${variable_name}"
}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
