#!/usr/bin/env zsh
# ====================[ command                            ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Command, handling executable commands in the current user's ${PATH}.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_installed(
#   char *command_name, char *error_message = 'not found in $PATH')
#
# Throw an exception unless the passed command exists.
die_unless_installed() {
    die_unless_one_or_two_args\
        'expected one command name and optional error message'
    string command_name="${1}"
    is_installed "${command_name}" or
        die "${2:-\"${command_name}\" not found in \$PATH}"
}

# ....................{ TESTS                              }....................
# bool is_installed(char *command_name)
#
# Return true if the command with the passed name is currently installed.
is_installed() {
    die_unless_one_arg 'expected one command name'

    # Dismantled, this is:
    #
    # * "${1:c}", expanding to the absolute path of the passed command if such
    #   command exists or only the passed command itself otherwise.
    # * "is_executable", returning true if such path is executable.
    is_executable "${1:c}"
}

# ....................{ GETTERS                            }....................
# char *get_command_path(char *command_name)
#
# Get the absolute path to the command with the passed name if found in the
# current user's $PATH and raise an exception otherwise.
get_command_path() {
    die_unless_one_arg 'expected one command name'
    get_command_path_if_found "${1}" or die "\"${1}\" not found in \$PATH"
}

# char *get_command_path_if_found(char *command_name)
#
# Get the absolute path of the command with the passed name if found in the
# current user's $PATH and return failure otherwise.
get_command_path_if_found() {
    die_unless_one_arg 'expected one command name'

    # Absolute path of the command with the passed name. Dismantled, this is:
    #
    # * "1", expanding to the passed command name.
    # * ":t", excluding all but the basename of such name. This prevents this
    #   function from returning true when passed absolute paths not
    #   corresponding to commands in the $PATH (e.g.,
    #   "get_command_path_if_found /tmp").
    # * ":c", expanding to the absolute path of such command.
    string command_pathname="${1:t:c}"

    if is_absolute_path "${command_pathname}"
    then print "${command_pathname}"
    else return_false
    fi
}

# char *get_script_path(char *script_name)
#
# Get the absolute path to the script with the passed name. If
# there exist multiple such scripts, return the first such script. This function
# generalizes get_autoload_path() by searching for (in order):
#
# * Any file with such name, if absolute.
# * Any file in the current working directory with such name.
# * Any file in the ${PATH} with such name (i.e., a command).
# * Any file in the ${FPATH} with such name (i.e., an autoload).
get_script_path() {
    die_unless_one_arg 'expected one script name'
    string script_name="${1}"

    if is_absolute_path      "${script_name}"; then
        die_unless_text_file "${script_name}"
        sputter        "${script_name}"
    else
        list script_paths; script_paths=( "${PWD}" "${path[@]}" "${fpath[@]}" )
        get_autoload_path "${script_name}" script_paths
    fi
}

# char *get_autoload_path(
#   char *autoload_name, char **autoload_paths_list_name = 'fpath')
#
# Get the absolute path to the autoloadable script with the passed name. If
# there exist multiple such scripts, return the first such script: e.g.,
#
#     >>> get_autoload_path zsh-mime-handler
#     /usr/share/zsh/4.3.11/functions/MIME/zsh-mime-handler
get_autoload_path() {
    die_unless_one_or_two_args\
        'expected one autoload name and optional list name'
    string autoload_name="${1}" autoload_paths_list_name="${2:-fpath}"
    
    # Dismantled, this is:
    #
    # * "autoload_paths_list_name", the name of the list listing all
    #   directories to be searched for the passed autoload.
    # * "(@P)", expanding to such list.
    # * "^", iteratively expanding to each such directory.
    # * "/${autoload_name}", concatenating the passed autoload to each such
    #   directory, producing a possible absolute path to such autoload.
    # * "(N)", ignoring non-extant such absolute paths.
    list autoload_paths; autoload_paths=(
        ${^${(@P)autoload_paths_list_name}}"/${autoload_name}"(N)
    )
#   autoload_paths=( ${^fpath}/"${autoload_name}"(N) )

    # If no command has the passed name, print an error message and return
    # failure. To permit the caller to recover, do not raise a fatal error.
#   utter "got \"${autoload_paths[@]}\""
    die_unless_list_nonempty autoload_paths "\"${autoload_name}\" not found"

    # Otherwise, print the first absolute path to this autoload.
    sputter "${autoload_paths[1]}"
}

# ....................{ GETTERS ~ first                    }....................
# char *get_first_command_path(char *command_name1, *command_name2, ...)
#
# Get the absolute path of the first command in the passed list of command names
# found in the ${PATH} and raise an exception otherwise.
get_first_command_path() {
    get_first_command_path_if_found "${@}" or
        die "$(join_list_to_legible_truncated_string 'and' "\"${^@}\"") not found in \$PATH"
}

# char *get_first_command_path_if_found(char *command_name1, *command_name2, ...)
#
# Get the absolute path of the first command in the passed list of command names
# found in the ${PATH} and return false otherwise.
get_first_command_path_if_found() {
    die_unless_at_least_one_arg 'expected at least one command name'

    # Unfortunately, glob qualifiers accept only extant pathnames; hence, the
    # following call always fails (unless the current working directory contains
    # at least one of the passed commands as a path, in which case it
    # erroneously succeeds):
    #
    #   get_first_path_matching_glob_qualifiers\
    #       'found in $PATH' 'found in $PATH'\
    #       'e{whence -cp $REPLY}' "${@}"
    #
    # We adopt a concise alternative leveraging trickery. Dismantled, this is:
    #
    # * "${^@", expanding to each passed command name.
    # * ":t", excluding all but the basenames of such names.
    # * ":c", expanding to, for commands...
    #   * ...in the current user's $PATH, the absolute path of such commands.
    #   * ...otherwise, noop (i.e., the command name itself).
    # * ":#[^/]*", excluding all non-absolute paths and hence command names
    #   not in the current user's $PATH.
    # 
    # See get_command_path() for further details.
    list command_pathnames; command_pathnames=( ${${^@:t:c}:#[^/]*} )
    is_list_nonempty command_pathnames and
        print "${command_pathnames[1]}"
}

#FIXME: Obsolete.
# ....................{ GETTERS ~ user                     }....................
# char *get_editor_path(void)
#
# Get the (not necessarily absolute) path of the current user's editor command
# if set or a sane currently installed editor command, otherwise.
#get_pager_path() {
#    die_unless_no_args
#    print "${EDITOR}"
#}

# char *get_pager_path(void)
#
# Get the (not necessarily absolute) path of the current user's pager command.
#get_pager_path() {
#    die_unless_no_args
#    print "${PAGER:-less}"
#}

#   if is_list_nonempty command_pathnames
#   then print "${command_pathnames[1]}"
#   else return_false
#   fi

#e{whence -cp $REPLY}
#    get_first_path_matching_glob_qualifiers\
#        'found in $PATH' 'found in $PATH'\
#        '(.)' "${^@}:t:c"
#       'e(REPLY=${REPLY:c})' "${@}"
#       'e{REPLY=$REPLY:t:c; [[ $REPLY == /* ]]}' "${@}"
#       "e{REPLY=\$(get_command_path_if_found \"\$REPLY\")}" "${@}"
#       "e{'is_installed \$REPLY'}" "${@}"
    # * "or true", preventing failure if at least one pathname is excluded.
#   list pathnames; pathnames=( ${^@}(${glob_qualifiers}) ) or true
#   eval "pathnames=( \${^@}(${glob_qualifiers}) ) or true"

    # If the list of passed pathnames contains at least one writable pathname,
    # print the first such match; otherwise, raise an exception.
#   if is_list_nonempty pathnames
#   then print "${pathnames[1]}"
#   else return_false
#   fi

#FIXME: *****WAIT*****. We can substantially improve every other function by
#rewriting to the implementation of which_dir_writable(). Also, which_files()
#should clearly simply defer to which_files_if_found() rather than
#reimplementing the whole shebang.

# * Compress which_commands() into which_command() and which_files() into
#   which_file(). (Simplify life, yes? No justifiable reason not to, really.)

# char *which_commands(char *command_name1, *command_name2, ...)
#
# Get the absolute path of the first command in the passed list of command names
# found in the ${PATH} or raise an exception if no such command is found: e.g.,
#
#     >>> which_commands Council_of_Nicea Constantinople zsh
#     /bin/zsh
# 
# This function is intended to automate selection of commands, in descending
# order of preference. (In the above example, the hypothetical
# "Council_of_Nicea" command would be selected before all following commands on
# systems having the command.)
#which_commands() {
#    die_unless_at_least_one_arg 'expected one command name'
#    
#    # Iteratively look for each command in the passed list.
#    string command_path
#    for command_name ("${@}") {
#        if command_path="$(unify_output which_command "${command_name}")"; then
#            print "${command_path}"
#            return_true
#        fi
#    }
#    
#    # Otherwise, no such command exists. Die? Die! Die.
#    string command_names=$(join_join_list_to_string_prefixing_last_with ', ' 'or ' "\"${^@}\"")
#    die "neither ${command_names} found in \$PATH"
#}

#     >>> which_files '/the_ancient.one' '/the_king_in.yellow' '/tmp'
#     /tmp#   die_unless_at_least_one_arg 'expected at least one dirname'

    # List of writable dirnames filtered from the list of passed pathnames.
    # Dismantled, this is:
    #
    # * "${^@}", iteratively expanding to each passed pathname.
    # * "(e{'...'}), excluding pathnames not matching the embedded test.
    # * "or true", preventing failure if at least one pathname is excluded.
#   list dirnames
#        dirnames=( ${^@}(e{'[[ -d $REPLY && -w $REPLY ]]'}) ) or true

    # If the list of passed pathnames contains at least one writable dirname,
    # print the first such match; otherwise, raise an exception.
#   if is_list_nonempty dirnames
#   then print "${dirnames[1]}"
#   else die "neither $(join_join_list_to_string_prefixing_last_with ', ' 'or ' "\"${^@}\"") found"
#   fi

    # Dismantled, this is:
    #
    # * "autoload_paths_list_name", the name of the list listing all
    #   directories to be searched for the passed autoload.
    # * "(P)", expanding to such list.
    # * "^", iteratively expanding to each such directory.
    # * "/${autoload_name}", concatenating the passed autoload to each such
    #   directory, producing a possible absolute path to such autoload.
    # * "(N)", removing non-extant paths.
    # * "(..)", listing all extant paths.
#   list autoload_paths
#   autoload_paths=( ${^${(P)autoload_paths_list_name}}/"${autoload_name}" )

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
