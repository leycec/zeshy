#!/usr/bin/env zsh
# ====================[ dirname                            ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Dirname.
#
# --------------------( SEE ALSO                           )--------------------
# * http://git.grml.org/f/grml-etc-core/etc/zsh/zshrc
#   Inspiring Zeshy's chpwd() hook implementation (i.e., persistent dirs).

# ....................{ ALIASES                            }....................
interactive_alias c='cd'
interactive_alias dirs='print_directory_stack'
interactive_alias mkdir='make_directory_if_not_found'
interactive_alias mvt='move_to_temporary_dir'

# ....................{ EXCEPTIONS                         }....................
# void die_unless_dir(char *dirname, char *error_message = 'not a directory')
#
# Raise an exception unless the passed directory exists.
die_unless_dir() {
    die_unless_one_or_two_arguments\
        'expected one dirname and optional error message'
    string dirname="${1}"
    is_dir "${dirname}" or
        die "${2:-\"${dirname}\" not found or not a directory}"
}

# ....................{ TESTS                              }....................
# bool is_dir(char *pathname)
# 
# Return true if the passed path is an existing directory.
is_dir() {
    die_unless_one_argument 'expected exactly one pathname'
    is -d "${1}" si
}

# ....................{ GETTERS                            }....................
# char *get_current_working_dirname(void)
# 
# Get the absolute canonical path of the current working directory.
get_current_working_dirname() {
    die_unless_no_arguments
    print "${PWD}"
}

# ....................{ SETTERS                            }....................
# void set_current_working_dirname(char *dirname = '')
# 
# Set the current working directory to the passed dirname, implicitly invoking
# the chpwd() hook and hence pushing that dirname if valid onto the persistent
# directory stack. If:
#
# * Called non-interactively and:
#   * The passed dirname is empty, raise an exception. 
#   * Otherwise, set the current working dirname to the passed dirname without
#     calling the chpwd() hook or hooks in the ${chpwd_functions} list (i.e.,
#     "quietly"). This prevents unintended pollution of the current user's
#     directory stack with script-specific dirnames.
# * Called interactively and:
#   * The passed dirname is empty and:
#     * The directory stack is non-empty, pop the top dirname off that stack
#       and set the current working dirname to that directory.
#     * Otherwise, set the current working dirname to the current user's home.
#   * Otherwise, set the current working dirname to the passed dirname.
# 
# For brevity, alias "cd" to this function.
set_current_working_dirname cd() {
    if is_interactive and is_list_nonempty 'funcstack'; then 
        if is_arguments
        then builtin cd "${@}"
        elif is_list_nonempty 'dirstack'
        then popd
        else builtin cd "${HOME}"
        fi
    else
        die_unless_one_argument 'expected exactly one dirname'
        builtin cd -q "${1}"
    fi
}

# ....................{ HOOKS                              }....................
# void chwpd(void)
#
# Respond to the current working dirname being set by pushing that dirname if
# valid onto the directory stack.
chpwd() {
    # If the top directory on the stack is not already the current working
    # directory, push this directory onto the stack.
    is "${dirstack[-1]}" == "${PWD}" si or dirstack+=( "${PWD}" )
}

# ....................{ PRINTERS                           }....................
# char *print_directory_stack(void)
#
# Print the contents of the directory stack in human-readable format.
print_directory_stack() {
    die_unless_no_arguments
    dirs -lpv
}

# ....................{ WRITERS                            }....................
# void make_directory_if_not_found(char *dirname1, char *dirname2, ...)
#
# Examine each of the passed absolute paths and, for each non-existant path,
# make that path and all non-existant parent paths of that path.
make_directory_if_not_found() {
    die_unless_arguments 'expected at least one dirname'
    mkdir -p "${@}"
}

#FIXME: Obsolete, once we complete a working remove_path() function.
# void move_to_temporary_dir(char *pathname1, char *pathname2, ...)
#
# Move the passed set of files and/or directories to the "/tmp" directory. For
# Additionally, this suffixing all files and
# paths that already exist in "/tmp/" with the current time. 
move_to_temporary_dir() {
    die_unless_arguments
    string target_path source_basename

    # Quote the list of all passed paths with "(q)" to avoid improperly
    # splitting individual paths on whitespace.
    for source_path ("${(q)@}") {
        source_basename="$(get_basename "${source_path}")"
        target_path="/tmp/${source_basename}"
        is_path "${target_path}" and
            target_path="$(which_temporary_home)/$source_basename~$(date +'%F_%H-%M-%S')"
        mv "${source_path}" "${target_path}"
    }
}

#FIXME: Obsolete.
#           if is "${1}" == (-|+)* si
#           then builtin cd "${@}"
#           else pushd "${@}"
#           fi

#FIXME: Uhm; why doesn't "mkdir --parents" suffice?

    # While there are more paths to consider, shift the current path to be
    # considered to a local variable "new_path" and make it when not found.
#   string new_path
#   while is_arguments; do
#       new_path="${1}"; shift

#       if is_file "${new_path}"; then
#           die "\"${new_path}\" already a file"
#       elif not is_dir "${new_path}"; then
#           utter "making \"${new_path}\"..."
#           mkdir --parents "${new_path}"
#       fi
#   done

# void make_parent_directory_if_not_found(char *pathname)
#
# Make the parent directory of the passed path, if not found.
#make_parent_directory_if_not_found() {
#    die_unless_one_argument 'expected exactly one pathname'
#    make_directory_if_not_found "$(dirname "${1}")"
#}

#cd() {
#  if [ -z "$1" ]
#  then popd
#  else pushd "$@"
#  fi
#}

# Get the absolute canonical path (i.e., containing no symbolic links) of the
# current working directory.

#   readlink --canonicalize-existing "${1}"
# char *which_command(char *command_name)
#
# If found, get the absolute path to the command with the passed name;
# otherwise, return false. All but the first whitespace-delimited word of this
# string is ignored: e.g.,
#
#     >>> which_command zsh
#     /bin/zsh
#     >>> which_command "zsh -x -o shwordsplit scr"
#     /bin/zsh
#which_command() {
#    die_unless_one_argument 'expected exactly one command name'
#    string command_name="${1[(w)1]}"
#    string command_path="${command_name:c}"
#
#    # If no such command exists, print an error message and return with failure.
#    if is "${command_path:c}" != /* si; then
#        curse "\"${command_name}\" not found"
#        return_failure
#    fi
#
#    # Otherwise, print the absolute path of this command.
#    print "${command_path}"
#}

#   if not command_path="$(whence -p "${command_name}")"; then
#
# ....................{ FILENAMES ~ lists                 }....................
# char **get_filenames(char *dirname = '')
#
# Return a stringified list of all files in the passed directory or, if no such
# directory was passed, the current working directory. Callers should
# destringify the return value by calling the expand_list() function.
#get_filenames() {
#    die_unless_at_most_one_argument 'expected at most one optional dirname'
#    string dirname="${1:-${PWD}}"
#    die_unless_dir "${dirname}"
#    list filenames; filenames=( "${dirname}"/*(N) )
#    return_list filenames
#}

#      file --mime-encoding "${pathname}" | grep --quiet ': binary$'
#      file --mime-encoding "${pathname}" | grep --quiet --invert-match ': binary$'

#       die "neither \"${user_temporary_dir}\" or \"${root_temporary_dir}\""\
#           "found; no temporary directory found"
#alias -g get_filenames="( *(N) )"

#lias get_next_argument_as='string __tmp__="${1}"; shift; print "${__tmp__}"'
#lias get_next_argument_as='string __tmp__="${1}"; shift; print "${__tmp__}"'
#       filename="$(get_next_argument)"
#       get_next_argument_as filename

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
