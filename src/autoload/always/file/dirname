#!/usr/bin/env zsh
# ====================[ dirname                            ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Dirname.

# ....................{ ALIASES                            }....................
interactive_alias mvt="move_to_temporary_dir"

# ....................{ EXCEPTIONS                         }....................
# void die_unless_dir(char *dirname, char *error_message = 'not a directory')
#
# Raise an exception unless the passed directory exists.
die_unless_dir() {
    die_unless_one_or_two_arguments\
        'expected one dirname and optional error message'
    string dirname="${1}"
    is_dir "${dirname}" or
        die "${2:-\"${dirname}\" not found or not a directory}"
}

# ....................{ TESTS                              }....................
# bool is_dir(char *pathname)
# 
# Return true if the passed path is an existing directory.
is_dir() {
    die_unless_one_argument 'expected exactly one pathname'
    is -d "${1}" si
}

# ....................{ WRITERS                            }....................
# void make_directory_if_not_found(char *dirname1, char *dirname2, ...)
#
# Examine each of the passed absolute paths and, for each non-existant path,
# make that path and all non-existant parent paths of that path.
make_directory_if_not_found() {
    die_unless_one_argument 'expected exactly one dirname'

    # While there are more paths to consider, shift the current path to be
    # considered to a local variable "new_path" and make it when not found.
    string new_path
    while is_arguments; do
        new_path="${1}"; shift

        if is_file "${new_path}"; then
            die "\"${new_path}\" already a file"
        elif not is_dir "${new_path}"; then
#           utter "making \"${new_path}\"..."
            mkdir --parents "${new_path}"
        fi
    done
}

# void make_parent_directory_if_not_found(char *pathname)
#
# Make the parent directory of the passed path, if not found.
make_parent_directory_if_not_found() {
    die_unless_one_argument 'expected exactly one pathname'
    make_directory_if_not_found "$(dirname "${1}")"
}

# void move_to_temporary_dir(char *pathname1, char *pathname2, ...)
#
# Move the passed set of files and/or directories to the "/tmp" directory. For
# Additionally, this suffixing all files and
# paths that already exist in "/tmp/" with the current time. 
move_to_temporary_dir() {
    die_unless_arguments
    string target_path source_path source_basename

    # Quote the list of all passed paths with "(q)" to avoid improperly
    # splitting individual paths on whitespace.
    for source_path in "${(q)@}"; do
        source_basename="$(get_basename "${source_path}")"
        target_path="/tmp/${source_basename}"
        is_path "${target_path}" and
            target_path="$(which_temporary_home)/$source_basename~$(date +'%F_%H-%M-%S')"
        
        try mv "${source_path}" "${target_path}"
    done
}

#FIXME: Obsolete.
#   readlink --canonicalize-existing "${1}"
# char *which_command(char *command_name)
#
# If found, get the absolute path to the command with the passed name;
# otherwise, return false. All but the first whitespace-delimited word of this
# string is ignored: e.g.,
#
#     >>> which_command zsh
#     /bin/zsh
#     >>> which_command "zsh -x -o shwordsplit scr"
#     /bin/zsh
#which_command() {
#    die_unless_one_argument 'expected exactly one command name'
#    string command_name="${1[(w)1]}"
#    string command_path="${command_name:c}"
#
#    # If no such command exists, print an error message and return with failure.
#    if is "${command_path:c}" != /* si; then
#        curse "\"${command_name}\" not found"
#        return_failure
#    fi
#
#    # Otherwise, print the absolute path of this command.
#    print "${command_path}"
#}

#   if not command_path="$(whence -p "${command_name}")"; then
#
# ....................{ FILENAMES ~ lists                 }....................
# char **get_filenames(char *dirname = '')
#
# Return a stringified list of all files in the passed directory or, if no such
# directory was passed, the current working directory. Callers should
# destringify the return value by calling the expand_list() function.
#get_filenames() {
#    die_unless_at_most_one_argument 'expected at most one optional dirname'
#    string dirname="${1:-${PWD}}"
#    die_unless_dir "${dirname}"
#    list filenames; filenames=( "${dirname}"/*(N) )
#    return_list filenames
#}

#      file --mime-encoding "${pathname}" | grep --quiet ': binary$'
#      file --mime-encoding "${pathname}" | grep --quiet --invert-match ': binary$'

#       die "neither \"${user_temporary_dir}\" or \"${root_temporary_dir}\""\
#           "found; no temporary directory found"
#alias -g get_filenames="( *(N) )"

#lias get_next_argument_as='string __tmp__="${1}"; shift; print "${__tmp__}"'
#lias get_next_argument_as='string __tmp__="${1}"; shift; print "${__tmp__}"'
#       filename="$(get_next_argument)"
#       get_next_argument_as filename

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
