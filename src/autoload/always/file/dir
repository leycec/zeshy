#!/usr/bin/env zsh
# ====================[ dir                                ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Dir.
#
# --------------------( SEE ALSO                           )--------------------
# * http://git.grml.org/f/grml-etc-core/etc/zsh/zshrc
#   Inspiring Zeshy's chpwd() hook implementation (i.e., persistent dirs).
#
# --------------------( TODO                               )--------------------
# * It'd be helpful to auto-truncate the directory stack if it gets too tall --
#   say, higher than ${ZESHY_DIRSTACK_MAX_SIZE} (defaulting to 16). Entries
#   should probably be truncated off the bottom, I r'ckon.
# * This looks quite nice, a "vi"-key aware path switcher:
#   http://www.reddit.com/r/linux/comments/yxfwz/introducing_cdd_a_simply_directory_navigation

# ....................{ ALIASES                            }....................
#FIXME: It'd be quite nice to improve interactive_alias() to accept multiple
#alias names for the same alias. Note this also requires "src/digest" to parse
#such names, as well. *shrug*
interactive_alias cd='set_current_dir'
interactive_alias cb='rotate_dir_stack_backward'
interactive_alias cf='rotate_dir_stack_forward'
interactive_alias di='print_dir_stack'
interactive_alias dirs='print_dir_stack'
interactive_alias mk='make_dir_safely'
interactive_alias mkdir='make_dir_safely'
interactive_alias mvt='move_to_temporary_dir'

# ....................{ EXCEPTIONS                         }....................
# void die_unless_dir(char *dirname, char *error_message = 'not a directory')
#
# Raise an exception unless the passed directory exists.
die_unless_dir() {
    die_unless_one_or_two_args\
        'expected one dirname and optional error message'
    string dirname="${1}"
    is_dir "${dirname}" or
        die "${2:-\"${dirname}\" not found or not a directory}"
}

# void die_unless_writable_dir(
#	char *dirname, char *error_message = 'not a writable directory')
#
# Raise an exception unless the passed directory exists and is writable by the
# current user.
die_unless_writable_dir() {
    die_unless_one_or_two_args\
        'expected one dirname and optional error message'
    string dirname="${1}"
    is_writable_dir "${dirname}" or
        die "${2:-\"${dirname}\" not found or not a writable directory}"
}

# ....................{ TESTS                              }....................
# bool is_dir(char *pathname)
# 
# Return true if the passed path is an existing directory.
is_dir() {
    die_unless_one_arg 'expected one pathname'
    is -d "${1}" si
}

# bool is_writable_dir(char *pathname)
# 
# Return true if the passed path is an existing directory and writable by the
# current user.
is_writable_dir() {
    die_unless_one_arg 'expected one pathname'
    is -d "${1}" and -w "${1}" si
}

# ....................{ GETTERS                            }....................
# char *get_current_dir(void)
# 
# Get the absolute path of the current working directory.
get_current_dir() {
    die_unless_no_args
    sputter "${PWD}"
}

# ....................{ GETTERS ~ first                    }....................
# char *get_first_dir(char *dirname1, *dirname2, ...)
#
# Get the absolute path of the first directory in the passed list of dirnames
# that exists after resolving symbolic links or raise an exception if no such
# directory exists.
get_first_dir() {
    get_first_path_matching_glob_qualifiers\
        'a directory' 'directories' '-/' "${@}"
}

# char *get_first_writable_dir(char *dirname1, *dirname2, ...)
#
# Get the absolute path of the first directory in the passed list of dirnames
# that exists and is writable by the current user after resolving symbolic links
# or raise an exception if no such directory exists.
get_first_writable_dir() {
    get_first_path_matching_glob_qualifiers\
        'a writable directory' 'writable directories'\
        '-e{[[ -d $REPLY && -w $REPLY ]]}' "${@}"
}

# ....................{ SETTERS ~ current dir              }....................
# void set_current_dir(char *dirname = '')
# 
# Set the current working directory to the passed dirname, implicitly invoking
# the chpwd() hook and hence pushing that dirname if valid onto the persistent
# directory stack. Specifically, if:
#
# * Called non-interactively and...
#   * No dirname was passed, raise an exception. 
#   * Otherwise, set the current working dirname to the passed dirname.
# * Called interactively and...
#   * No dirname was passed and...
#     * The directory stack is non-empty, pop the top dirname off that stack
#       and set the current working dirname to that directory.
#     * Otherwise, set the current working dirname to the current user's home.
#   * Otherwise, set the current working dirname to the passed dirname.
set_current_dir() {
    if is_interactive; then 
        # If passed at least one argument, switch to such directory.
        if is_args
        then builtin cd -- "${@}"
        # If the directory stack is non-empty, switch to the prior directory.
        elif is_list_nonempty dirstack
        then restore_current_dir
        # Otherwise, switch to the home directory.
        else builtin cd -- "${HOME}"
        fi
    else
        die_unless_one_arg 'expected one dirname'
        builtin cd -- "${1}"
    fi
}

# void store_current_dir(char *dirname)
# 
# Set the current working directory to the passed dirname, implicitly invoking
# the chpwd() hook and hence pushing that dirname if valid onto the persistent
# directory stack. This function is the less intelligent step-child of
# set_current_dir() and hence appropriate for non-interactive scripts.
store_current_dir() {
    die_unless_one_arg 'expected one dirname'
    builtin pushd -- "${1}"
}

# void restore_current_dir()
# 
# Restore the current working directory to the immediately prior directory on
# the directory stack.
restore_current_dir() {
    die_if_args
    die_unless_list_nonempty dirstack 'directory stack empty'

    # Pop off and "cd" to the top directory off the directory stack, implicitly
    # calling set_current_dir(). (If, in fact, this function was called already
    # by set_current_dir() due to the latter having been called with no
    # arguments, the second call to set_current_dir() is called with one
    # argument, thus delimiting recursion.)
    popd
#   interactively print_dir_stack
}

# ....................{ SETTERS ~ dir stack                }....................
# void clear_dir_stack(void)
# 
# Clear the directory stack.
clear_dir_stack() {
    die_if_args
    dirs -c
}

# void rotate_dir_stack_backward(int dir_count = 1)
# 
# Set the current directory to that of the passed offset from the top of the
# directory stack (defaulting to 1 and hence the prior directory).
rotate_dir_stack_backward() {
    die_if_args
    die_unless_list_nonempty dirstack 'directory stack empty'
    pushd -q +${1:-1}
    interactively print_dir_stack
}

# void rotate_dir_stack_forward(int dir_count = 1)
# 
# Set the current directory to that of the passed offset from the bottom of the
# directory stack (defaulting to 1 and hence the last directory). Assuming some
# prior call to rotate_current_dir_backward(), calling this function with the
# same count effectively undoes the former.
rotate_dir_stack_forward() {
    die_if_args
    die_unless_list_nonempty dirstack 'directory stack empty'
    integer dir_count="${1:-1}"
    pushd -q -$((dir_count - 1))
    interactively print_dir_stack
}

#FIXME: Auto-compress the stack when it gets too large. Also, we really don't
#want *ANY* duplicates on the stack; we currently only prohibit duplicates on
#the top of the stack.

# ....................{ HOOKS                              }....................
# void chwpd(void)
#
# Respond to the current directory being set by pushing that directory onto the
# directory stack if not already. Unlike the "auto_pushd" option activated only
# on pushd() calls, Zsh activates this hook on every call setting the current
# directory excluding popd() (e.g., cd(), pushd()).
chpwd() {
    # If the top directory on the stack is not already the current working
    # directory, push this directory onto the stack.
#   utter "pwd: ${PWD}\ndirstack[1]: ${dirstack[1]}\ndirstack[-1]: ${dirstack[-1]}"
    { is_list_empty dirstack or is "${dirstack[1]}" != "${PWD}" si } and
        #FIXME: Add a new prepend_list() function to "type/list".
        dirstack=( "${PWD}" "${dirstack[@]}" )
#   {
#       is_list_nonempty dirstack and utter "pwd: ${PWD}\ndirstack[1]: ${dirstack[1]}\ndirstack[-1]: ${dirstack[-1]}"
#   }
}

# ....................{ PRINTERS                           }....................
# char *print_dir_stack(void)
#
# Print the contents of the directory stack in human-readable format.
print_dir_stack() {
    # Print a prefixing header.
    die_if_args
#   interactively utter 'printing the current directory stack...'
    sputter '   index     dir'
    utter_banner

    # Capture standard output from "dirs". Oddly, this output does not coincide
    # with the actual contents of the ${dirstack} list: specifically, "dirs"
    # prepends output with the current directory regardless of whether the
    # first directory in the directory stack is already this directory. To
    # amend this:
    #
    # * If the directory stack is empty, print nothing.
    # * Otherwise, print all lines following the first.
    is_list_nonempty dirstack or return_true
    string dirs_output; dirs_output="$(dirs -p)"
    number_lines_highlighting "$(get_lines "${dirs_output}" 2 -1)" 1
}

# ....................{ WRITERS                            }....................
# void make_dir(char *dirname1, char *dirname2, ...)
#
# Make all passed directories (but *NOT* parent directories of such directories)
# if no such directories exist and otherwise raise an exception.
make_dir() {
    die_unless_args 'expected at least one dirname'
    mkdir -- "${@}"
}

# void make_dir_safely(char *dirname1, char *dirname2, ...)
#
# Make all passed directories and parent directories of such directories if no
# such directory exists.
make_dir_safely() {
    die_unless_args 'expected at least one dirname'
    mkdir -p -- "${@}"
}

# ....................{ WASTELANDS                         }....................
#       dirstack+=( "${PWD}" )
#   if is_list_empty dirstack
#   then dirstack+=( "${PWD}" )
#   else is "${dirstack[-1]}" == "${PWD}" si or dirstack+=( "${PWD}" )
#   fi
#   (( ${#dirstack} )) or die 'directory stack empty'
#   die_unless_list_nonempty dirstack 'directory stack empty'
  
# For brevity, alias "cd" to this function.

#FIXME: Doesn't work, sadly. Investigate. (I suspect "src/digest" parses such
#whitespace incorrectly.)
#set_current_dir cd() {
#   without
#     calling the chpwd() hook or hooks in the ${chpwd_functions} list (i.e.,
#     "quietly"). This prevents unintended pollution of the current user's
#     directory stack with script-specific dirnames.

# ....................{ PUSHERS                            }....................
# void change_

#FIXME: The "autopushd" option already enables this.
# ....................{ HOOKS                              }....................
# void chwpd(void)
#
# Respond to the current working dirname being set by pushing that dirname if
# valid onto the directory stack.
#chpwd() {
#    # If the top directory on the stack is not already the current working
#    # directory, push this directory onto the stack.
#    is "${dirstack[-1]}" == "${PWD}" si or dirstack+=( "${PWD}" )
#}

#           if is "${1}" == (-|+)* si
#           then builtin cd "${@}"
#           else pushd "${@}"
#           fi

#FIXME: Uhm; why doesn't "mkdir --parents" suffice?

    # While there are more paths to consider, shift the current path to be
    # considered to a local variable "new_path" and make it when not found.
#   string new_path
#   while is_args; do
#       new_path="${1}"; shift

#       if is_file "${new_path}"; then
#           die "\"${new_path}\" already a file"
#       elif not is_dir "${new_path}"; then
#           utter "making \"${new_path}\"..."
#           mkdir --parents "${new_path}"
#       fi
#   done

# void make_parent_directory_if_not_found(char *pathname)
#
# Make the parent directory of the passed path, if not found.
#make_parent_directory_if_not_found() {
#    die_unless_one_arg 'expected one pathname'
#    make_dir_safely "$(dirname "${1}")"
#}

#cd() {
#  if [ -z "$1" ]
#  then popd
#  else pushd "$@"
#  fi
#}

# Get the absolute canonical path (i.e., containing no symbolic links) of the
# current working directory.

#   readlink --canonicalize-existing "${1}"
# char *which_command(char *command_name)
#
# If found, get the absolute path to the command with the passed name;
# otherwise, return false. All but the first whitespace-delimited word of this
# string is ignored: e.g.,
#
#     >>> which_command zsh
#     /bin/zsh
#     >>> which_command "zsh -x -o shwordsplit scr"
#     /bin/zsh
#which_command() {
#    die_unless_one_arg 'expected one command name'
#    string command_name="${1[(w)1]}"
#    string command_path="${command_name:c}"
#
#    # If no such command exists, print an error message and return with failure.
#    if is "${command_path:c}" != /* si; then
#        curse "\"${command_name}\" not found"
#        return_false
#    fi
#
#    # Otherwise, print the absolute path of this command.
#    print "${command_path}"
#}

#   if not command_path="$(whence -p "${command_name}")"; then
#
# ....................{ FILENAMES ~ lists                 }....................
# char **get_filenames(char *dirname = '')
#
# Return a stringified list of all files in the passed directory or, if no such
# directory was passed, the current working directory. Callers should
# destringify the return value by calling the expand_list() function.
#get_filenames() {
#    die_unless_at_most_one_arg 'expected at most one optional dirname'
#    string dirname="${1:-${PWD}}"
#    die_unless_dir "${dirname}"
#    list filenames; filenames=( "${dirname}"/*(N) )
#    return_list filenames
#}

#      file --mime-encoding "${pathname}" | grep --quiet ': binary$'
#      file --mime-encoding "${pathname}" | grep --quiet --invert-match ': binary$'

#       die "neither \"${user_temporary_dir}\" or \"${root_temporary_dir}\""\
#           "found; no temporary directory found"
#alias -g get_filenames="( *(N) )"

#lias get_next_arg_as='string __tmp__="${1}"; shift; print "${__tmp__}"'
#lias get_next_arg_as='string __tmp__="${1}"; shift; print "${__tmp__}"'
#       filename="$(get_next_arg)"
#       get_next_arg_as filename

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
