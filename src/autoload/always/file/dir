#!/usr/bin/env zsh
# ====================[ dir                                ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Dir.
#
# --------------------( SEE ALSO                           )--------------------
# * http://git.grml.org/f/grml-etc-core/etc/zsh/zshrc
#   Inspiring Zeshy's chpwd() hook implementation (i.e., persistent dirs).

# ....................{ ALIASES                            }....................
#FIXME: It'd be quite nice to improve interactive_alias() to accept multiple
#alias names for the same alias. Note this also requires "src/digest" to parse
#such names, as well. *shrug*
interactive_alias cd='set_current_working_dirname'
interactive_alias dirs='print_dir_stack'
interactive_alias mk='make_dir_if_not_found'
interactive_alias mkdir='make_dir_if_not_found'
interactive_alias mvt='move_to_temporary_dir'

# ....................{ EXCEPTIONS                         }....................
# void die_unless_dir(char *dirname, char *error_message = 'not a directory')
#
# Raise an exception unless the passed directory exists.
die_unless_dir() {
    die_unless_one_or_two_arguments\
        'expected one dirname and optional error message'
    string dirname="${1}"
    is_dir "${dirname}" or
        die "${2:-\"${dirname}\" not found or not a directory}"
}

# ....................{ TESTS                              }....................
# bool is_dir(char *pathname)
# 
# Return true if the passed path is an existing directory.
is_dir() {
    die_unless_one_argument 'expected exactly one pathname'
    is -d "${1}" si
}

# ....................{ GETTERS                            }....................
# char *get_current_working_dirname(void)
# 
# Get the absolute canonical path of the current working directory.
get_current_working_dirname() {
    die_unless_no_arguments
    print "${PWD}"
}

# char *get_first_writable_dir(char *dirname1, *dirname2, ...)
#
# Get the absolute path of the first directory in the passed list of dirnames
# that exists and is writable by the current user or raise an exception if no
# such directory exists.
get_first_writable_dir() {
    get_first_path_matching_glob_qualifiers\
        'a writable directory' 'writable directories'\
        'e{[[ -d $REPLY && -w $REPLY ]]}' "${@}"
}

# ....................{ SETTERS                            }....................
# void set_current_working_dirname(char *dirname = '')
# 
# Set the current working directory to the passed dirname, implicitly invoking
# the chpwd() hook and hence pushing that dirname if valid onto the persistent
# directory stack. If:
#
# * Called non-interactively and:
#   * The passed dirname is empty, raise an exception. 
#   * Otherwise, set the current working dirname to the passed dirname without
#     calling the chpwd() hook or hooks in the ${chpwd_functions} list (i.e.,
#     "quietly"). This prevents unintended pollution of the current user's
#     directory stack with script-specific dirnames.
# * Called interactively and:
#   * The passed dirname is empty and:
#     * The directory stack is non-empty, pop the top dirname off that stack
#       and set the current working dirname to that directory.
#     * Otherwise, set the current working dirname to the current user's home.
#   * Otherwise, set the current working dirname to the passed dirname.
# 
# For brevity, alias "cd" to this function.

#FIXME: Doesn't work, sadly. Investigate. (I suspect "src/digest" parses such
#whitespace incorrectly.)
#set_current_working_dirname cd() {
set_current_working_dirname() {
    if is_interactive_directly; then 
        if is_arguments
        then builtin cd "${@}"
        elif is_list_nonempty dirstack
        then popd
        else builtin cd "${HOME}"
        fi
    else
        die_unless_one_argument 'expected exactly one dirname'
        builtin cd -q "${1}"
    fi
}

# ....................{ PRINTERS                           }....................
# char *print_dir_stack(void)
#
# Print the contents of the directory stack in human-readable format.
print_dir_stack() {
    die_unless_no_arguments
    dirs -lpv
}

# ....................{ WRITERS                            }....................
# void make_dir(char *dirname1, char *dirname2, ...)
#
# Make all passed directories (but *NOT* parent directories of such directories)
# if no such directories exist and otherwise raise an exception.
make_dir() {
    die_unless_arguments 'expected at least one dirname'
    mkdir -- "${@}"
}

# void make_dir_if_not_found(char *dirname1, char *dirname2, ...)
#
# Make all passed directories and parent directories of such directories if no
# such directory exists.
make_dir_if_not_found() {
    die_unless_arguments 'expected at least one dirname'
    mkdir -p -- "${@}"
}

#FIXME: Obsolete.
#FIXME: The "autopushd" option already enables this.
# ....................{ HOOKS                              }....................
# void chwpd(void)
#
# Respond to the current working dirname being set by pushing that dirname if
# valid onto the directory stack.
#chpwd() {
#    # If the top directory on the stack is not already the current working
#    # directory, push this directory onto the stack.
#    is "${dirstack[-1]}" == "${PWD}" si or dirstack+=( "${PWD}" )
#}

#           if is "${1}" == (-|+)* si
#           then builtin cd "${@}"
#           else pushd "${@}"
#           fi

#FIXME: Uhm; why doesn't "mkdir --parents" suffice?

    # While there are more paths to consider, shift the current path to be
    # considered to a local variable "new_path" and make it when not found.
#   string new_path
#   while is_arguments; do
#       new_path="${1}"; shift

#       if is_file "${new_path}"; then
#           die "\"${new_path}\" already a file"
#       elif not is_dir "${new_path}"; then
#           utter "making \"${new_path}\"..."
#           mkdir --parents "${new_path}"
#       fi
#   done

# void make_parent_directory_if_not_found(char *pathname)
#
# Make the parent directory of the passed path, if not found.
#make_parent_directory_if_not_found() {
#    die_unless_one_argument 'expected exactly one pathname'
#    make_dir_if_not_found "$(dirname "${1}")"
#}

#cd() {
#  if [ -z "$1" ]
#  then popd
#  else pushd "$@"
#  fi
#}

# Get the absolute canonical path (i.e., containing no symbolic links) of the
# current working directory.

#   readlink --canonicalize-existing "${1}"
# char *which_command(char *command_name)
#
# If found, get the absolute path to the command with the passed name;
# otherwise, return false. All but the first whitespace-delimited word of this
# string is ignored: e.g.,
#
#     >>> which_command zsh
#     /bin/zsh
#     >>> which_command "zsh -x -o shwordsplit scr"
#     /bin/zsh
#which_command() {
#    die_unless_one_argument 'expected exactly one command name'
#    string command_name="${1[(w)1]}"
#    string command_path="${command_name:c}"
#
#    # If no such command exists, print an error message and return with failure.
#    if is "${command_path:c}" != /* si; then
#        curse "\"${command_name}\" not found"
#        return_failure
#    fi
#
#    # Otherwise, print the absolute path of this command.
#    print "${command_path}"
#}

#   if not command_path="$(whence -p "${command_name}")"; then
#
# ....................{ FILENAMES ~ lists                 }....................
# char **get_filenames(char *dirname = '')
#
# Return a stringified list of all files in the passed directory or, if no such
# directory was passed, the current working directory. Callers should
# destringify the return value by calling the expand_list() function.
#get_filenames() {
#    die_unless_at_most_one_argument 'expected at most one optional dirname'
#    string dirname="${1:-${PWD}}"
#    die_unless_dir "${dirname}"
#    list filenames; filenames=( "${dirname}"/*(N) )
#    return_list filenames
#}

#      file --mime-encoding "${pathname}" | grep --quiet ': binary$'
#      file --mime-encoding "${pathname}" | grep --quiet --invert-match ': binary$'

#       die "neither \"${user_temporary_dir}\" or \"${root_temporary_dir}\""\
#           "found; no temporary directory found"
#alias -g get_filenames="( *(N) )"

#lias get_next_argument_as='string __tmp__="${1}"; shift; print "${__tmp__}"'
#lias get_next_argument_as='string __tmp__="${1}"; shift; print "${__tmp__}"'
#       filename="$(get_next_argument)"
#       get_next_argument_as filename

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
