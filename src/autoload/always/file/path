#!/usr/bin/env zsh
# ====================[ path                               ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Path.
#
# --------------------( TODO                               )--------------------
# * It'd be nice to render remove_filename() an uber-powerful meta-remove command used in
#   place of "rmdir", "rm -rf *", etc. The essential ideas are:
#   * Add a config file option ${ZESHY_IS_RECYCLING}, disabled by default but, when
#     enabled, auto-moving all removed files to a new path
#     "${ZESHY_RECYCLE_BIN)/$(date +'%N')/', the former defaulting to
#     "${HOME}/tmp/zeshy.recycled". This effectively guarantees no
#     collision (still test such collision, and simply repeat until non-colliding).
#     I'll probably enable this locally, I imagine. Obviously, such auto-moving
#     such test for sufficient free disk space on the mounted disk to be moved to
#     prior to doing so and fail with error if insufficient disk space remains.
#     *ALSO*, note that no recycling must be done on paths in the recycler: an "rm"
#     within the recycler is always perma-death.
#   * Add implicit support for "rmdir". Basically, if the passed path is an empty
#     directory, use "rmdir"; otherwise, either "rm -ri ${DIRNAME}" or
#     "rm -rI ${DIRNAME}", depending on how many files or subdirectories exist
#     in such directory.
# * It'd be nice to incorporate "zmv", for those who want and/or expect it.
#   "zmv" is a built-in shell function applying extended glob patterns to
#   the usual "mv" command, thus allowing batch renaming of file- and path-names.
#   (Use option "-n" before permanently applying any such pattern, so as to
#   prete[n]d- apply the pattern as initial "trial run;" or, use option "-i" to
#   force "zmv" to [i]nteractively ask your permission to perform each rename.)
#   For example: zmv -n '(*).txt' '$1.xtx'  # renames files ending in 'txt' to
#   end in 'xtx'. Naturally, "zmv" is an autoloadable function: e.g.,
#   autoload -U zmv

# ....................{ ALIASES                            }....................
interactive_alias c='copy_path'
interactive_alias cp='copy_path'
#interactive_alias c='cp --interactive --verbose'

#FIXME: These could use copy_path() and copy_path_recursively() functions with
#corresponding globals ${ZESHY_CP_OPTIONS} and so forth.
interactive_alias cr='cp --archive --recursive --verbose --update'

interactive_alias m='mv -iv'
interactive_alias mv='mv -iv'
interactive_alias rm='remove_path'
#interactive_alias rm='rm -iv'
interactive_alias umask='umask -S'

# ....................{ EXCEPTIONS                         }....................
# void die_unless_found(char *pathname, char *error_message = 'not found')
#
# Throw an exception unless the passed path exists.
die_unless_found() {
    die_unless_one_or_two_args\
        'expected one pathname and optional error message'
    string pathname="${1}"
    is_found "${pathname}" or die "${2:-\"${pathname}\" not found}"
}

# ....................{ TESTS                              }....................
# bool is_found(char *pathname)
# 
# Return true if the passed path exists.
is_found() {
    die_unless_one_arg 'expected one pathname'
    is -e "${1}" si
}

# bool is_executable(char *pathname)
# 
# Return true if the passed path exists and is executable by the current user.
is_executable() {
    die_unless_one_arg 'expected one pathname'
    is -x "${1}" si
}

# bool is_readable(char *pathname)
# 
# Return true if the passed path exists and is readable by the current user.
is_readable() {
    die_unless_one_arg 'expected one pathname'
    is -r "${1}" si
}

# bool is_writable(char *pathname)
# 
# Return true if the passed path exists and is writable by the current user.
is_writable() {
    die_unless_one_arg 'expected one pathname'
    is -w "${1}" si
}

# bool is_absolute_path(char *pathname)
#
# Return true if the passed path is absolute (i.e., begins with an "/"),
# regardless of whether it actually exists.
is_absolute_path() {
    die_unless_one_arg 'expected one pathname'
    is "${1[1]}" == '/' si
}

# ....................{ GETTERS                            }....................
# char *canonicalize_path(char *pathname)
#
# Get the canonicalized form of the passed absolute path. Canonicalization
# reduces this path to standard form, such that two canonical paths are equal
# if and only if they represent the same file. Note that this is not
# necessarily the case with non-canonical paths (e.g., "/tmp" and
# "/tmp/../tmp/./" are not equal but represent the same directory).
# Specifically, canonicalization:
#
# * Expands every pseudo-directory component (e.g., "./", "../") iteratively,
#   until the resulting path contains no pseudo-directory components.
# * Expands every symlink in every component of the passed path recursively,
#   until the resulting path contains no symlinks.
canonicalize_path() {
    die_unless_one_arg 'expected one pathname'
    string pathname="${1}" 
    die_unless_found "${pathname}"
    return_string "${pathname}"(:A)
#   string canonical_pathname=( "${pathname}"(:A) )
#   is_nonempty "${canonical_pathname}" or die "\"${pathname}\" "
}

# char *get_basename(char *pathname)
#
# Get the basename of the passed path (i.e., sans parent directory name).
get_basename() {
    die_unless_one_arg 'expected one pathname'
    return_string "${1:t}"
}

# char *get_dirname(char *pathname)
#
# Get the dirname of the passed path (i.e., sans basename).
get_dirname() {
    die_unless_one_arg 'expected one pathname'
    return_string "${1:h}"
}

# char *get_filename_sans_filetype(char *filename)
#
# Get the filename of the passed filename sans filetype. If this filename has
# no filetype, this is the filename itself. By design, this only excludes the
# rightmost filetype: e.g.,
#
#     >>> get_basename_sans_filetype '/endymion/hastur.tar.gz'
#     /endymion/hastur.tar
get_filename_sans_filetype() {
    die_unless_one_arg 'expected one filename'
    return_string "${1%.*}"
}

# ....................{ GETTERS ~ filetypes                }....................
# char *get_filetype(char *filename)
#
# Get the filetype of the passed filename or throw an exception if that filename
# has no filetype. For filenames suffixed by two-part "tar" designators, the
# filetype is "tar." followed by the rightmost period-delimited suffix; else,
# filetype is the merely the rightmost period-delimited suffix: e.g.,
#
#     >>> get_filetype 'hastur.tar.gz'
#     tar.gz
#     >>> get_filetype 'pasteur.ar.gz'
#     gz
get_filetype() {
    die_unless_one_arg 'expected one filename'
    string filename="${1}" filetype
    filetype="$(get_filetype_if_matched "${filename}")"
    die_unless_nonempty "${filetype}" "\"${filename}\" has no filetype"
}

# char *get_filetype_if_matched(char *filename)
#
# Get the filetype of the passed filename or the empty string if that filename
# has no filetype. See get_filetype() for further details.
get_filetype_if_matched() {
    # Localize passed arguments.
    die_unless_one_arg 'expected one filename'
    string filename="${1}" filetype

    # Match the passed filename's filetype, discarding leading ".".
    is "${filename}" =~ '\.(tar\.)?[^.]+$' si and
        return_string "$(remove_prefix "${MATCH}" '.')"
}

# ....................{ GETTERS ~ glob qualifiers          }....................
# char *get_first_path_matching_glob_qualifiers(
#   char *match_type_singular, char *match_type_plural,
#   char *glob_qualifiers, char *pathname1, *pathname2, ...)
#
# Get the first pathname in the passed list to successfully match all passed
# glob qualifiers (e.g., 'w/', matching all owner-writable directories) or
# raise an exception if no such directory exists. See section "Glob Qualifiers"
# of "man zshexpn", for glob qualifier reference.
get_first_path_matching_glob_qualifiers() {
    string match_type_singular="${1}" match_type_plural="${2}" first_pathname
    shift_two_args

    if first_pathname="$(get_first_path_matching_glob_qualifiers_if_found "${@}")"
    then print "${first_pathname}"
    else
        # Shift the glob qualifier off the argument list, leaving only the list
        # of passed pathnames. While hardly necessary, this simplifies logic.
        shift_one_arg

        if is_at_least_two_args
        then die "$(list_to_human_readable_string 'and' "\"${^@}\"") not found or not ${match_type_plural}"
        else die "\"${1}\" not found or not ${match_type_singular}"
        fi
    fi
}

# char *get_first_path_matching_glob_qualifiers_if_found(
#   char *glob_qualifiers, char *pathname1, *pathname2, ...)
#
# Get the first pathname in the passed list to successfully match all passed
# glob qualifiers (e.g., 'r.', matching all owner-readable plain files) or
# return false if no such directory exists. See section "Glob Qualifiers" of
# "man zshexpn", for glob qualifier reference.
get_first_path_matching_glob_qualifiers_if_found() {
    die_unless_at_least_two_args\
        'expected at least one glob qualifiers string and one pathname'

    # Glob qualifiers to be matched.
    string glob_qualifiers="${1}"
    shift_one_arg

    # List of pathnames filtered from the list of passed pathnames. Dismantled,
    # this is:
    #
    # * "${^@}", iteratively expanding to each passed pathname.
    # * "(${glob_qualifiers}), excluding pathnames not matching the passed glob
    #   qualifiers.
    # * "[1]", excluding all but the first such match. (Yes, this is somewhat
    #   silly. While *WE* know this glob expression is guaranteed to match at
    #   most one pathname, Zsh doesn't. For safety, GLOB_ASSIGN is not globally
    #   enabled. While this function could locally enable such option, that
    #   hardly seems sensible.)
    list pathnames; pathnames=( ${^@}(${glob_qualifiers}[1]) ) or true

    # If the list of passed pathnames contains at least one writable pathname,
    # print the first such match; otherwise, raise an exception.
    is_list_nonempty pathnames and print "${pathnames[1]}"
#   string first_match="$(print ${^@}(${glob_qualifiers}[1]))"
#   if is_nonempty "${first_match}"
#   then print     "${first_match}"
#   else return_failure
#   fi
}

# ....................{ GETTERS ~ mtime                    }....................
# int get_modification_time(char *pathname)
#
# Get the mtime (i.e., modification time) of the passed path in Unix time,
# reflecting the most recent time of path creation or change of path content
# (i.e., file content for files and the list of files and subdirectories for
# directories), filename, or permissions. For directories, mtime does *NOT*
# reflect change of file or subdirectory content or permissions.
get_modification_time() {
    die_unless_one_arg 'expected one pathname'
    zstat +mtime "${1}"
}

# int get_modification_time_recursive(char *pathname)
#
# Get the recursive mtime (i.e., modification time) of the passed path in Unix
# time. For files, this is the same time as returned by the non-recursive
# get_modification_time() function. For directories, this reflects the most recent time
# of recursive path creation or change of path content, filename, or
# permissions. This function is considerably more costly than get_modification_time().
get_modification_time_recursive() {
    die_unless_one_arg 'expected one pathname'
    string pathname="${1}"

    if is_file "${pathname}"
    then get_modification_time "${pathname}"
    elif is_dir "${pathname}"
    # Dismantled, this is:
    #
    # * "${pathname}"/**/*, all files and subdirectories of this directory.
    # * "om", such files and subdirectories in ascending order by mtime.
    # * "[1]", the first and hence newest such file or subdirectory.
    then get_modification_time "${pathname}"/**/*(om[1])
    else die "\"${pathname}\" not found or not a file or directory"
    fi
}

# ....................{ SETTERS ~ mtime                    }....................
# void set_modification_time(char *pathname, int modification_time)
#
# Set the mtime (i.e., modification time) of the passed path in Unix time.
set_modification_time() {
    die_unless_two_args 'expected one pathname and one modification time'
    string pathname="${1}"
    integer modification_time="${2}"
    die_unless_found "${pathname}"
    touch -m --date=@"${modification_time}" -- "${pathname}"
}

# ....................{ WRITERS ~ copiers                  }....................
# void copy_path(
#   char *source_pathname, char *target_pathname1, char *target_pathname2, ...)
#
# Copy the passed source path to the passed target paths. If interactive and the
# current user has not reconfigured ${ZESHY_CP_OPTIONS_IF_INTERACTIVE[@]},
# confirm such copy for each already extant target path. If the passed source
# path is a symbolic link, print errors for target paths that are now broken
# symbolic links (as is commonly the case when copying symbolic links shallow).
copy_path() {
    # Copy.
    die_unless_at_least_two_args\
        'expected one source pathname and one or more target pathnames'
    run_with_options 'command cp' 'ZESHY_CP_OPTIONS' "${@}"

    # Test for broken symbolic link copies.
    if is_symbolic_link "${1}"; then
        for filename ("${@[2,-1]}") {
            if is_broken_symbolic_link "${filename}"; then
                string filename_target="$(get_symbolic_link_target "${filename}")"
                curse "symbolic link \"${filename}\" target \"${filename_target}\" not found"
            fi
        }
    fi
}

# void copy_path_physically(
#   char *source_pathname, char *target_pathname1, char *target_pathname2, ...)
#
# Copy the passed source path to the passed target paths. If the former is a
# symbolic link, deeply copy the physical path to which that symbolic link
# transitively links and not the shallow symbolic link itself.
copy_path_physically() {
    die_unless_at_least_two_args\
        'expected one source pathname and one or more target pathnames'
    list ZESHY_CP_OPTIONS; ZESHY_CP_OPTIONS=( "${ZESHY_CP_OPTIONS[@]}" -L )
    run_with_options 'command cp' 'ZESHY_CP_OPTIONS' "${@}"
}

# ....................{ WRITERS ~ removers                 }....................
# void remove_path(char *pathname1, char *pathname2, ...)
#
# Permanently remove the passed files, throwing an exception if any such file
# does not exist. If interactive, the current user has not reconfigured
# ${ZESHY_RM_OPTIONS_IF_INTERACTIVE[@]}, and...
#
# * Only one, two, or three files were passed, confirm each such removal.
# * Four or more files were passed, confirm only the first such removal.
remove_path() {
    die_unless_args 'expected one or more pathnames'

    list rm; rm=( command rm "${ZESHY_RM_OPTIONS[@]}" )
    if is_interactive; then
        rm+=( "${ZESHY_RM_OPTIONS_IF_INTERACTIVE[@]}" )

        # If the caller passed no more than three files to be deleted, require
        # manual confirmation for each such deletion.
        if is_at_most_three_args
        then "${rm[@]}" -- "${@}"
        # If the caller passed at least four files to be deleted *AND* requests
        # interactive confirmation with option "-i", require only one initial
        # confirmation implicitly covering all deletions with option "-I".
        # Otherwise, delete all passed files without confirmation.
        else "${rm[@]//-i/-I}" -- "${@}"
        fi
    else "${rm[@]}" "${ZESHY_RM_OPTIONS_IF_NON_INTERACTIVE[@]}" -- "${@}"
    fi
}

# void remove_path_if_found(char *pathname1, char *pathname2, ...)
#
# Permanently remove all passed files that exist, ignoring those that do not.
# See remove_path() for further discussion.
remove_path_if_found() {
    die_unless_args 'expected one or more pathnames'

    # Filter non-extant paths from the passed paths. Dismantled, this is:
    #
    # * "${^@}", iteratively expanding to each passed path.
    # * "(e:...:), excluding paths failing the embedded test:
    #   * '[[ -e "${REPLY}" ]]', succeeding only for extant paths.
    set_args ${^@}(e:'[[ -e "${REPLY}" ]]':)

    # Remove all extant paths.
    remove_path "${@}"
}

#FIXME: Obsolete.
#   string filetype="$(remove_prefix_matching '*.')"
#   string filetype="${filename##*.}"

    # If the passed filename has no filetype, remove_prefix_matching() failed to
    # match and hence returned the filename itself. If this is the case, return the empty string instead.
#   if is "${filetype}" == "${filename}" si or print "${filetype}"

    # Target filetype, supporting two-part "tar" designators. The regular expression
    # matches a prefixing ".", discarded via "#." below for brevity.
#   is "${filename}" =~ '\.(tar\.)?([^.]+)$' si or
#       die "\"${filename}\" has no identifying filetype"
#   filetype="$(remove_prefix "${MATCH}" '.')"

# char *get_filetype(char *filename)
#
# Get the filetype of the passed filename. If this filename has no filetype,
# this is the empty string. Note the only matches the rightmost filetype: e.g.,
#
#     >>> get_filetype 'hastur.tar.gz'
#     gz
#get_filetype() {
#    die_unless_one_arg 'expected one filename'
#    string filename="${1}"
#    string filetype="${filename##*.}"
#
#    # If this filename has no filetype, then the prior parameter expansion
#    # matched the filename itself, in which case we test for and ignore this. 
#    is "${filetype}" == "${filename}" si or print "${filetype}"
#
#    # Target filetype, supporting two-part "tar" designators. The regular expression
#    # matches a prefixing ".", discarded via "#." below for brevity.
#    is "${filename}" =~ '\.(tar\.)?([^.]+)$' si or
#        die "\"${filename}\" has no identifying filetype"
#    filetype="$(remove_prefix "${MATCH}" '.')"
#}

    # The difficulty of removing specific indices from ${@} prompts us to copy ${@}
    # into a local list and operate on that, instead.
#   list extant_paths; extant_paths=( "${@}" )
#   extant_paths

#   list cp; cp=( command cp "${ZESHY_CP_OPTIONS[@]}" )
#   if is_interactive
#   then "${cp[@]}" "${ZESHY_CP_OPTIONS_IF_INTERACTIVE[@]}"     -- "${@}"
#   else "${cp[@]}" "${ZESHY_CP_OPTIONS_IF_NON_INTERACTIVE[@]}" -- "${@}"
#   fi
#   list cp; cp=( command cp "${ZESHY_CP_OPTIONS[@]}" )
#   if is_interactive
#   then "${cp[@]}" "${ZESHY_CP_OPTIONS_IF_INTERACTIVE[@]}"     -L -- "${@}"
#   else "${cp[@]}" "${ZESHY_CP_OPTIONS_IF_NON_INTERACTIVE[@]}" -L -- "${@}"
#   fi

#FIXME: When copying and moving symbolic links, we should verify afterwards that
#the target symbolic link is still valid. If it isn't, we should curse to stderr
#but probably not die. We'll want a new function for this; courtesy the mailing
#list, here's how we test for broken symbolic links. Cool:
#
#  # ...where "mylinktest" is the filename of the link to test. Replace with
#  # a parameter expansion, of course.
#  broken=( mylinktest(N-@) )
#
#  if (( ${#broken} ))
#  then print mylinktest is a broken symbolic link
#  else print mylinktest is not a symbolic link or is not broken
#  fi
#
#See http://www.zsh.org/mla/users/2005/msg00394.html for helpful explanation.

        #FIXME: Pretty sure there's a better way to do this by substituting "-i" 
        #for "-I" in "rm" with parameter expansion flags. Investigate.
#       elif is_list_element rm '-i'
#       then "${rm[@]}" -I -- "${@}"
#       else "${rm[@]}"    -- "${@}"

        #FIXME: Not right. We should only replace an existing option "-i" with
        #"-I" rather than indiscriminantly appending "-I". 
#   char *cp_option1, char *cp_option2, ...,

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
