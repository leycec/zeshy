#!/usr/bin/env zsh
# ====================[ file                               ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy File, implementing non-directory file handling. While directories are
# technically files, we hereafter write "file" to imply non-directories.

# ....................{ ALIASES                            }....................
interactive_alias lns='make_symbolic_link'

# ....................{ EXCEPTIONS                         }....................
# void die_if_file(char *pathname, char *error_message = 'is a file')
#
# Raise an exception if the passed file exists.
die_if_file() {
    die_unless_one_or_two_arguments\
        'expected one pathname and optional error message'
    string pathname="${1}"
    is_file "${pathname}" and die "${2:-\"${pathname}\" is an existing file}"
}

# void die_unless_file(char *pathname, char *error_message = 'not a file')
#
# Raise an exception unless the passed file exists.
die_unless_file() {
    die_unless_one_or_two_arguments\
        'expected one pathname and optional error message'
    string pathname="${1}"
    is_file "${pathname}" or die "${2:-\"${pathname}\" not found or not a file}"
}

# void die_unless_files(char *pathname1, char *pathname2, ...)
#
# Raise an exception unless all of the passed files exist.
die_unless_files() {
    die_unless_arguments 'expected at least one pathname'
    is_files "${@}" or
        die "${2:-\"${pathname}\" not all found or not all files}"
}

# void die_unless_installed(
#   char *command_name, char *error_message = 'not found in $PATH')
#
# Raise an exception unless the passed command exists.
die_unless_installed() {
    die_unless_one_or_two_arguments\
        'expected one command name and optional error message'
    string command_name="${1}"
    is_installed "${command_name}" or
        die "${2:-\"${command_name}\" not found in \$PATH}"
}

# ....................{ TESTS                              }....................
# bool is_file(char *pathname)
# 
# Return true if the passed path is an existing non-directory file.
is_file() {
    die_unless_one_argument 'expected exactly one pathname'
    is -e "${1}" and not -d "${1}" si
}

# bool is_files(char *pathname1, char *pathname2, ...)
# 
# Return true if all passed paths are existing files.
is_files() {
    die_unless_arguments 'expected at least one pathname'

    # List of filenames filtered from the passed list of pathnames. Dismantled,
    # this is:
    #
    # * "${^@}", iteratively expanding to each passed pathname.
    # * "(.)", excluding non-filenames.
    list filenames; filenames=( ${^@}(.) ) 

    # Return true only if the list of passed pathnames contains only filenames.
    (( "${#filenames}" == "${#@}" ))
}

# bool is_installed(char *command_name)
#
# Return true if the command with the passed name is currently installed.
is_installed() {
    is_absolute_path "${1:c}"
}

# bool is_regular_file(char *pathname)
# 
# Return true if the passed path is an existing regular file (i.e., a file not a
# device, directory, named pipe, socket, or symbolic link).
is_regular_file() {
    die_unless_one_argument 'expected exactly one pathname'
    is -f "${1}" si
}

# bool is_symbolic_link(char *pathname)
# 
# Return true if the passed path is an existing symbolic link.
is_symbolic_link() {
    die_unless_one_argument 'expected exactly one pathname'
    is -L "${1}" si
}

# ....................{ GETTERS                            }....................
# char *get_first_file(char *filename1, *filename2, ...)
#
# Get the absolute path of the first file in the passed list of filenames that
# exists or raise an exception if no such file exists.
get_first_file() {
    get_first_path_matching_glob_qualifiers 'a file' 'files' '.' "${@}"
}

# char *get_first_file_if_found(char *filename1, *filename2, ...)
#
# Get the absolute path of the first file in the passed list of filenames that
# exists or return false (but do not raise an exception) if no such file exists.
get_first_file_if_found() {
    get_first_path_matching_glob_qualifiers_if_found\
        'a file' 'files' '.' "${@}"
}

# ....................{ WRITERS                            }....................
# void make_file(char *filename1, char *filename2, ...)
#
# Make all passed files if no such files exist and otherwise raise an exception.
make_file() {
    die_unless_arguments 'expected at least one filename'

    # While Zeshy enables "noclobber" by default, the current user or context
    # may have re-enabled "clobber". For safety, force "noclobber" locally.
    localize_zsh_options noclobber

    # For each passed file, attempt to make such file without truncating such
    # file if already extant. Since the simplest means of effecting this is to
    # attempt to redirect zero-length output to such file under "noclobber",
    # perform such redirection as the intentional side effect of a noop.
    for filename ("${@}") { 
        noop > "${1}"
    }
}

# void make_file_if_not_found(char *filename1, char *filename2, ...)
#
# Make passed files if no such files exist.
make_file_if_not_found() {
    die_unless_arguments 'expected at least one filename'
    touch -- "${@}"
}

# void make_symbolic_link(char *source_pathname, *target_filename)
#
# Symbolically link the former passed path to the latter passed file. If such
# file already exists and is a symbolic link, replace such file without error;
# otherwise, raise an error if such file already exists.
make_symbolic_link() {
    die_unless_two_arguments\
        'expected exactly one source pathname and one target filename'
    string source_pathname="${1}" target_filename="${2}"
    die_unless_file "${source_pathname}"

    if is_symbolic_link "${target_filename}"; then
        ln -sf "${source_pathname}" "${target_filename}"
    else
        die_if_file "${target_filename}"
        ln -s  "${source_pathname}" "${target_filename}"
    fi
}

#FIXME: Obsolete.
#   setopt local_options 
#   die_unless_files "${@}" 
#   touch -c -- "${@}"

    # List of filenames filtered from the passed list of pathnames. Dismantled,
    # this is:
    #
    # * "${^@}", iteratively expanding to each passed pathname.
    # * "(.)", excluding non-filenames.
#   list filenames; filenames=( ${^@}(.) ) 

    # If filenames were filtered from the list of passed pathnames, die.
#   (( "${#filenames}" == "${#@}" )) or
#       die "${2:-\"${filename}\" not all found or not all files}"

#   quietly ls -- "${@}" or die ''
#           "$(find "${pathname}" -type f -printf '%A@\t%p\n' | sort -r -k1 | head -n1 | cut -f2)"
#
#   readlink --canonicalize-existing "${1}"
# char *which_command(char *command_name)
#
# If found, get the absolute path to the command with the passed name;
# otherwise, return false. All but the first whitespace-delimited word of this
# string is ignored: e.g.,
#
#     >>> which_command zsh
#     /bin/zsh
#     >>> which_command "zsh -x -o shwordsplit scr"
#     /bin/zsh
#which_command() {
#    die_unless_one_argument 'expected exactly one command name'
#    string command_name="${1[(w)1]}"
#    string command_path="${command_name:c}"
#
#    # If no such command exists, print an error message and return with failure.
#    if is "${command_path:c}" != /* si; then
#        curse "\"${command_name}\" not found"
#        return_failure
#    fi
#
#    # Otherwise, print the absolute path of this command.
#    print "${command_path}"
#}

#   if not command_path="$(whence -p "${command_name}")"; then
#
# ....................{ FILENAMES ~ lists                 }....................
# char **get_filenames(char *dirname = '')
#
# Return a stringified list of all files in the passed directory or, if no such
# directory was passed, the current working directory. Callers should
# destringify the return value by calling the expand_list() function.
#get_filenames() {
#    die_unless_at_most_one_argument 'expected at most one optional dirname'
#    string dirname="${1:-${PWD}}"
#    die_unless_dir "${dirname}"
#    list filenames; filenames=( "${dirname}"/*(N) )
#    return_list filenames
#}

#      file --mime-encoding "${pathname}" | grep --quiet ': binary$'
#      file --mime-encoding "${pathname}" | grep --quiet --invert-match ': binary$'

#       die "neither \"${user_temporary_dir}\" or \"${root_temporary_dir}\""\
#           "found; no temporary directory found"
#alias -g get_filenames="( *(N) )"

#lias get_next_argument_as='string __tmp__="${1}"; shift; print "${__tmp__}"'
#lias get_next_argument_as='string __tmp__="${1}"; shift; print "${__tmp__}"'
#       filename="$(get_next_argument)"
#       get_next_argument_as filename

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
