#!/usr/bin/env zsh
# ====================[ temporary                          ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Temporary, implementing temporary file and directory handling.

#FIXME: It'd be helpful to manually create "${HOME}/tmp", if needed.
# ....................{ GETTERS                            }....................
# char *get_temporary_home(void)
#
# Get the absolute path of this user's topmost temporary directory (in order):
#
# * "${HOME}/tmp", if this directory exists.
# * "/tmp", otherwise.
get_temporary_home() {
    die_unless_no_arguments 'expected no arguments'
    get_first_writable_dir "${HOME}/tmp" '/tmp'
}

# ....................{ MAKERS                             }....................
# char *make_temporary_dir_prefixed_with(char *prefix = '')
#
# Make a new temporary directory with basename prefixed by the passed prefix
# (defaulting to the empty string) and return its absolute path: e.g.,
#
#     >>> make_temporary_dir_prefixed_with ursus_maritimus
#     /tmp/ursus_maritimus~2012-04-18_22-58-34_609198275
make_temporary_dir_prefixed_with() {
    make_temporary_path_prefixed_with 'make_dir' "${@}"
}

# char *make_temporary_file_prefixed_with(char *prefix = '')
#
# Make a new temporary file with basename prefixed by the passed prefix
# (defaulting to the empty string) and return its absolute path: e.g.,
#
#     >>> make_temporary_file_prefixed_with ursus_nanulak
#     /tmp/ursus_nanulak~2012-04-18_22-58-34_609198275
make_temporary_file_prefixed_with() {
    make_temporary_path_prefixed_with 'make_file' "${@}"
}

# char *make_temporary_path_prefixed_with(
#   char *make_command_name, char *prefix = '')
#
# Make a new temporary path with basename prefixed by the passed prefix
# (defaulting to the empty string) by calling the passed command and return its
# absolute pathname. This helper function avoids common race conditions by
# guaranteeing only this and no prior call created this path, with caveats:
#
# * This function *CANNOT* guarantee the returned path exists on returning. It
#   guarantees only that the returned path once existed prior to returning. In
#   theory, another concurrent process could delete (or move) this path after
#   this function creates this path but before returning. Short of patching Zsh
#   itself with mutual exclusion primitives, this is not likely to be fixable.
make_temporary_path_prefixed_with() {
    die_unless_one_or_two_arguments\
        'expected one make command name and optional dirname prefix'
    string make_command_name="${1}" temporary_home="$(get_temporary_home)"\
           temporary_dirname_prefix temporary_dirname
    die_unless_runnable "${make_command_name}"

    # If the caller passed a prefix, suffix such prefix with a delimiter
    # separating that prefix from a uniquifying current date and time string.
    is_set_nonempty '2' and temporary_dirname_prefix="${2}~"
    
    while (true) {
        # If the desired temporary path does not exist...
        temporary_dirname="${temporary_home}/${temporary_dirname_prefix}$(date +'%F_%H-%M-%S_%N')"
        if not is_found "${temporary_dirname}"; then
            # ...and is successfully created, return its absolute path.
            if quietly "${make_command_name}" "${temporary_dirname}"; then
                print "${temporary_dirname}"
                return
            # ...and is *NOT* successfully created and the temporary home
            # directory is not writable, raise an exception. This is probably
            # incredibly rare, but could theoretically occur if the current user
            # loses write permissions to the temporary home directory after the
            # prior call to get_temporary_home(). In such a case, failing to
            # explicitly test this case induces an infinite loop. Which is bad.
            elif not is_writable "${temporary_home}"; then
                die "\"${temporary_home}\" not writable"
            # ...otherwise, another concurrent process (probably calling this
            # function) successfully created this directory after the call to
            # is_found() but before the call to make_directory(). Try again!
            fi
        # ...otherwise, the desired temporary path already exists (probably
        # by some prior call to this function). Try again!
        fi
    }
}

# ....................{ MOVERS                             }....................
#FIXME: Obsolete, once we complete a working remove_path() function. Also, the
#current implementation is riddled with probably dangerous race conditions.
# void move_to_temporary_dir(char *pathname1, char *pathname2, ...)
#
# Move the passed set of files and/or directories to the "/tmp" directory. For
# Additionally, this suffixing all files and
# paths that already exist in "/tmp/" with the current time. 
move_to_temporary_dir() {
    die_unless_arguments
    string target_path source_basename

    # Quote the list of all passed paths with "(q)" to avoid improperly
    # splitting individual paths on whitespace.
    for source_path ("${(q)@}") {
        source_basename="$(get_basename "${source_path}")"
        target_path="/tmp/${source_basename}"
        is_path "${target_path}" and
            target_path="$(get_temporary_home)/$source_basename~$(date +'%F_%H-%M-%S')"
        mv "${source_path}" "${target_path}"
    }
}


#FIXME: Obsolete.
#FIXME: Revise to call which_dir_writable(). *THIS IS EXCEPTIONALLY IMPORTANT*.
#Failure to check writability results in subtle failure, below.
#   string user_temporary_home="${HOME}/tmp" root_temporary_home="/tmp"
#   if   is_dir "${user_temporary_home}"
#   then print  "${user_temporary_home}"
#   elif is_dir "${root_temporary_home}"
#   then print  "${root_temporary_home}"
#   else die 'no temporary directory found'
#   fi

# char *get_temporary_filename_prefixed_with(char *prefix)
#
# Get the absolute path to a temporary file having the passed prefix: e.g.,
#
#     >>> get_temporary_filename_prefixed_with git_patch_file
#     /tmp/git_patch_file~2012-12-01_18-37-41_837170937
#
# Subtle race conditions may arise, as above.
#get_temporary_filename_prefixed_with() {
#    die_unless_one_argument 'expected exactly one filename prefix'
#    string temporary_filename_prefix="${1}" which_temporary_file
#
#    while (true) {
#        which_temporary_file="$(get_temporary_home)/${temporary_filename_prefix}.file~$(date +'%F_%H-%M-%S_%N')"
#        if not is_file "${which_temporary_file}"; then
#            print "${which_temporary_file}"
#            break
#        fi
#    }
#}

# char *get_temporary_pathname_prefixed_with(char *prefix)
#
# Get the absolute path of a temporary path having the passed prefix: e.g.,
#
#     >>> get_temporary_pathname_prefixed_with git_patches
#     /tmp/git_patches~2012-04-18_22-58-34_609198275
#
# While subtle race conditions may arise with concurrent processing, this path
# is generally unique. This should probably not be depended upon for mission
# critical Zsh scripts, however. (.......of course, if you're coding mission
# critical Zsh scripts, you've probably already gone too far.)
#get_temporary_pathname_prefixed_with() {
#    die_unless_one_argument 'expected exactly one dirname prefix'
#    
#    string which_temporary_dir
#    while (true) {
#        which_temporary_dir="$(get_temporary_home)/${1}.path~$(date +'%F_%H-%M-%S_%N')"
#        if not is_dir "${which_temporary_dir}"; then
#            print "${which_temporary_dir}"
#            break
#        fi
#    }
#}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
