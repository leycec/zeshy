#!/usr/bin/env zsh
# ====================[ text                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy File Content Text, handling non-binary file contents.

# ....................{ ALIASES                            }....................
is_zeshy_wrapping_core_commands and
interactive_alias cat='print_text_file'
interactive_alias wclr="get_text_file_line_length_recursively"

# ....................{ ALIASES                            }....................
# char *print_text_file(char *filename1, char *filename2, ...)
#
# Print the contents of the passed text files piped to the current pager if such
# output exceeds the terminal height or as is (i.e., without paging) otherwise.
print_text_file() {
    if is_piped_input; then
        die_if_args
        pass_piped_input_to run_paged command cat
    else
        die_unless_args 'expected at least one filename'

        # When passed one file, "cat" output unambiguously corresponds to such
        # file. In such a case, "cat" suffices.
        if is_one_arg
        then run_paged command cat -- "${@}"
        # When passed multiple files, "cat" fails to prepend the output from
        # each with the corresponding filename. Correct this, scallywag "cat"!
        else
            {
                # Print the first passed file.
                utter_first_section "${1}"
                command cat -- "${1}"
                shift_one_arg

                # Print all other passed files.
                for filename ("${@}") {
                    utter_next_section "${filename}"
                    command cat -- "${filename}"
                }
            } | run_paged
        fi
    fi
}

# ....................{ EXCEPTIONS                         }....................
# void die_unless_text_file(char *filename, char *error_message = '')
#
# Raise an exception unless the passed file exists and is a text file.
die_unless_text_file() {
    die_unless_one_or_two_args\
        'expected pathname and optional error message'
    string filename="${1}"
    is_text_file "${filename}" or
        die "${2:-\"${filename}\" not found or not a text file}"
}

# ....................{ TESTS                              }....................
# bool is_text_file(char *pathname)
#
# Return true if the passed pathname corresponds to a text file (i.e., not a
# binary file). (If the passed pathname corresponds to a directory instead, this
# function always returns failure.)
is_text_file() {
    die_unless_one_arg 'expected one pathname'
    is_file "${1}" and not is_binary_file "${1}"
}

# bool is_text_file_contains(char *filename, char *text)
#
# Return true if the passed text file contains the passed text.
is_text_file_contains() {
    # Localize.
    die_unless_one_arg 'expected one filename'
    string filename="${1}" text="${2}"
    die_unless_text_file "${filename}"

    # Match.
    string text_file_contents; text_file_contents="$(get_text_file_contents)"
    is "${text_file_contents}" == *"${text}"* si
}

# bool is_text_file_pcre_line_match(
#   char *filename, char *pcre, char *pcre_arg1, char *pcre_arg2, ...)
#
# Return true if the passed text file contains a line matching the passed PCRE
# under option "-m" for multiline matching and the additional passed options.
# This function implements a pure-Zsh analogue to "grep --perl-regexp".
is_text_file_pcre_line_match() {
    # Localize.
    die_unless_two_or_three_args\
        'expected one filename, one regex, and optional regex options'
    string filename="${1}" pcre="${2}"
    die_unless_text_file "${filename}"
    shift_one_arg

    # Match.
    string text_file_contents; text_file_contents="$(get_text_file_contents)"
    is_pcre_line_match "${text_file_contents}" "${@}"
}

# ....................{ GETTERS                            }....................
# char *get_text_file_contents(char *filename)
#
# Get the contents of the passed text file.
get_text_file_contents() {
    die_unless_one_arg 'expected one filename'
    string filename="${1}"
    die_unless_text_file "${filename}"
    run_with_mapfile "sputter \${mapfile[${filename}]}"
}

# ....................{ GETTERS ~ lines                    }....................
#FIXME: Silly. Completely replace with a new get_text_file_lines() function
#returning the passed range. See "shell/shell" for further comments. Oh, and
#this should be calling get_text_file_contents().

# char *get_text_file_first_line(char *filename)
#
# Get the first line of the passed text file.
get_text_file_first_line() {
    # Localize and validate passed arguments.
    die_unless_one_arg 'expected one filename'
    string filename="${1}"
    die_unless_text_file "${filename}"

    # Grep. See run_with_mapfile() for mapfile discussion.
    load_zsh_module zsh/mapfile
    list lines; lines=( ${(f)mapfile[${filename}]} )
    sputter ${lines[1]}
    unload_zsh_module zsh/mapfile
#   eval "list lines; lines=( oeu oeu); print -l -- \${lines[@]}"
#   run_with_mapfile "list lines;
#       lines=( \${(f)mapfile[${filename}]} );
#       sputter \${lines[1]}"
}

# int get_text_file_line_length_recursively(char *path)
#
# Get the total number of lines corresponding to the file(s) in the passed path,
# as follows:
#
# * If no path is passed, default to the current directory.
# * If this path is a directory, recursively sum the number of lines for files
#   in this path ignoring binary files.
# * If this path is a file:
#   * And this file is a PDF, use "pdftotext" to sum the number of text lines in
#     the rendered PDF.
#   * Otherwise, sum the number of lines in this file.
get_text_files_total_line_length_recursively() {
    # Localize passed parameters.
    die_unless_at_most_one_arg 'expected optional pathname'
    string find_path="${1:-$(get_current_dir)}"

    #FIXME: Replace dependency on "find" and "wc" with pure Zsh.
    if is_dir "${find_path}"; then
        utter "summing line length for all text files in \"${find_path}\"..."

        # Recursively find all files *NOT*:
        #
        # * Non-files (e.g., directories, device files).
        # * Dotfiles and dot directories (e.g., ".cvs/", ".git/", ".svn/").
        # * Binary files. We borrow this expression from is_text_file().
        find "${find_path}"\
            -type d -iname '*test*' -prune -o\
            -type f \( ! -regex '.*/\..*' \)\
            $(is_text_file_find_compatible)\
            -exec wc -l {} \; |\
            awk '{ total += \$1 } END { print total }' |\
            convert_integer_to_comma_separated_string
    elif is_file "${find_path}"; then
        utter "getting line length for \"${find_path}\"..."

        if is "$(get_filetype "${find_path}")" == pdf si; then
            pdftotext "${find_path}" - | wc -l | comma_separate_integer
        else
            die_unless_file_file "${find_path}"
            wc -l "${find_path}" | comma_separate_integer
        fi
    else
        die "\"${find_path}\" neither a file or directory"
    fi
}

# --------------------( WASTELANDS                         )--------------------
    #FIXME: This probably isn't behaving as intended. It *SHOULD* be printing
    #file contents to stderr while concatenating together file contents. In
    #practice, it probably just exhumes an error. Hurk!
#   string output
#   for filename ("${@}") {
#       output+="$(< "${filename}" 1>&1 1>&2)"
#   }
    # Test under the "mapfile" module for efficiency.
#   load_mapfile
#   is ${mapfile[${filename}]} == *"${text}"* si
#   unload_mapfile
#   run_with_mapfile "is \${mapfile[${filename}]} == *""${text}""* si"

#FIXME: It'd be nice to abstract out the load_zsh_module/freeze_variable/unload_zsh_module
#cruft into a helper function -- say, with_mapfile(): e.g.,
#
#    with_mapfile 'print ${${(f)mapfile[${filename}]}[1]}'

    # Load Zsh module "mapfile".
#   load_zsh_module zsh/mapfile

    # Forcibly prevent harmful ${mapfile} and hence filesystem changes.
#   freeze_variable mapfile

    # Print the first line of the file with the passed filename.
#   print ${${(f)mapfile[${filename}]}[1]}

    # Unload "mapfile", for safety.
#   unload_zsh_module zsh/mapfile
#FIXME: Should be renamed to, say, "get_find_command_text_file_filter()", and
#consequently moved -- ideally, into a new "zeshy/file/find".
# bool is_text_file_find_compatible(void)
#
# Return a string which, when passed as argument to a "find" process, filters
# the currently visited filename if the corresponding file is binary. "find"
# itself provides no built-in means of performing such filtering, unfortunately.
#is_text_file_find_compatible() {
#    print "\-exec sh -c 'file --mime-encoding {} | grep --invert-match --quiet \": binary$\"' \\\;"
#}
