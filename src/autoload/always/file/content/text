#!/usr/bin/env zsh
# ====================[ text                               ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Text File.

# ....................{ ALIASES                            }....................
interactive_alias wclr="get_text_file_line_length_recursively"

# ....................{ EXCEPTIONS                         }....................
# void die_unless_text_file(char *filename, char *error_message = '')
#
# Raise an exception unless the passed file exists and is a text file.
die_unless_text_file() {
    die_unless_one_or_two_args\
        'expected filename and optional error message'
    string filename="${1}"
    is_text_file "${filename}" or
        die "${2:-\"${filename}\" not found or not a text file}"
}

# ....................{ TESTS                              }....................
# bool is_text_file(char *pathname)
#
# Return true if the passed pathname corresponds to a text file (i.e., not a
# binary file). (If the passed pathname corresponds to a directory instead, this
# function always returns failure.)
is_text_file() {
    die_unless_one_arg 'expected one pathname'
    is_file "${1}" and not is_binary_file "${1}"
}

# bool is_text_file_contains(char *filename, char *text)
#
# Return true if the passed text file contains the passed text.
is_text_file_contains() {
    # Localize.
    die_unless_one_arg 'expected one filename'
    string filename="${1}" text="${2}"
    die_unless_text_file "${filename}"

    # Match.
    string text_file_contents; text_file_contents="$(get_text_file_contents)"
    is "${text_file_contents}" == *"${text}"* si
}

# bool is_text_file_line_matching_pcre(
#   char *filename, char *pcre, char *pcre_arg1, char *pcre_arg2, ...)
#
# Return true if the passed text file contains a line matching the passed PCRE
# under option "-m" for multiline matching and the additional passed options.
# This function implements a pure-Zsh analogue to "grep --perl-regexp".
is_text_file_line_matching_pcre() {
    # Localize.
    die_unless_two_or_three_args\
        'expected one filename, one regex, and optional regex options'
    string filename="${1}" pcre="${2}" 
    die_unless_text_file "${filename}"
    shift_one_arg

    # Match.
    string text_file_contents; text_file_contents="$(get_text_file_contents)"
    is_line_matching_pcre "${text_file_contents}" "${@}"
}

# ....................{ GETTERS                            }....................
# char *get_text_file_contents(char *filename)
#
# Get the contents of the passed text file.
get_text_file_contents() {
    die_unless_one_arg 'expected one filename'
    string filename="${1}"
    die_unless_text_file "${filename}"
    run_with_mapfile "sputter \${mapfile[${filename}]}"
}

# ....................{ GETTERS ~ lines                    }....................
#FIXME: Silly. Completely replace with a new get_text_file_lines() function
#returning the passed range. See "shell/shell" for further comments. Oh, and
#this should be calling get_text_file_contents().

# char *get_text_file_first_line(char *filename)
#
# Get the first line of the passed text file.
get_text_file_first_line() {
    # Localize and validate passed arguments.
    die_unless_one_arg 'expected one filename'
    string filename="${1}"
    die_unless_text_file "${filename}"

    # Grep. See run_with_mapfile() for mapfile discussion.
    load_zsh_module zsh/mapfile
    list lines; lines=( ${(f)mapfile[${filename}]} )
    sputter ${lines[1]}
    unload_zsh_module zsh/mapfile
#   eval "list lines; lines=( oeu oeu); print -l -- \${lines[@]}"
#   run_with_mapfile "list lines;
#       lines=( \${(f)mapfile[${filename}]} );
#       sputter \${lines[1]}"
}

# int get_text_file_line_length_recursively(char *path)
#
# Get the total number of lines corresponding to the file(s) in the passed path,
# as follows:
#
# * If no path is passed, default to the current directory.
# * If this path is a directory, recursively sum the number of lines for files
#   in this path ignoring binary files.
# * If this path is a file:
#   * And this file is a PDF, use "pdftotext" to sum the number of text lines in
#     the rendered PDF.
#   * Otherwise, sum the number of lines in this file.
get_text_files_total_line_length_recursively() {
    # Localize passed parameters.
    die_unless_at_most_one_arg 'expected optional pathname'
    string find_path="${1:-$(get_current_dir)}"

    #FIXME: Replace dependency on "find" and "wc" with pure Zsh.
    if is_dir "${find_path}"; then
        utter "summing line length for all text files in \"${find_path}\"..."
        
        # Recursively find all files *NOT*:
        # 
        # * Non-files (e.g., directories, device files).
        # * Dotfiles and dot directories (e.g., ".cvs/", ".git/", ".svn/").
        # * Binary files. We borrow this expression from is_text_file().
        find "${find_path}"\
            -type d -iname '*test*' -prune -o\
            -type f \( ! -regex '.*/\..*' \)\
            $(is_text_file_find_compatible)\
            -exec wc -l {} \; |\
            awk '{ total += \$1 } END { print total }' |\
            convert_integer_to_comma_separated_string
    elif is_file "${find_path}"; then
        utter "getting line length for \"${find_path}\"..."
        
        if is "$(get_filetype "${find_path}")" == pdf si; then
            pdftotext "${find_path}" - | wc -l | comma_separate_integer
        else
            die_unless_file_file "${find_path}"
            wc -l "${find_path}" | comma_separate_integer
        fi
    else
        die "\"${find_path}\" neither a file or directory"
    fi
}

# ....................{ WASTELANDS                         }....................
    # Test under the "mapfile" module for efficiency.
#   load_mapfile
#   is ${mapfile[${filename}]} == *"${text}"* si
#   unload_mapfile
#   run_with_mapfile "is \${mapfile[${filename}]} == *""${text}""* si"

#FIXME: It'd be nice to abstract out the load_zsh_module/freeze_variable/unload_zsh_module
#cruft into a helper function -- say, with_mapfile(): e.g.,
#
#    with_mapfile 'print ${${(f)mapfile[${filename}]}[1]}'

    # Load Zsh module "mapfile".
#   load_zsh_module zsh/mapfile

    # Forcibly prevent harmful ${mapfile} and hence filesystem changes.
#   freeze_variable mapfile

    # Print the first line of the file with the passed filename.
#   print ${${(f)mapfile[${filename}]}[1]}

    # Unload "mapfile", for safety.
#   unload_zsh_module zsh/mapfile
#FIXME: Should be renamed to, say, "get_find_command_text_file_filter()", and
#consequently moved -- ideally, into a new "zeshy/file/find".
# bool is_text_file_find_compatible(void)
#
# Return a string which, when passed as argument to a "find" process, filters
# the currently visited filename if the corresponding file is binary. "find"
# itself provides no built-in means of performing such filtering, unfortunately.
#is_text_file_find_compatible() {
#    print "\-exec sh -c 'file --mime-encoding {} | grep --invert-match --quiet \": binary$\"' \\\;"
#}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
