#!/usr/bin/env zsh
# ====================[ content                            ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# ZeshyFile Content.

# ....................{ ALIASES                            }....................
interactive_alias wclr="get_text_file_line_length_recursively"

# ....................{ EXCEPTIONS                         }....................
# void die_unless_file_text(char *filename, char *error_message = '')
#
# Raise an exception unless the passed file exists and is a text file.
die_unless_file_text() {
    die_unless_one_or_two_args\
        'expected filename and optional error message'
    string filename="${1}"
    is_file_text "${filename}" or
        die "${2:-\"${filename}\" not found or not a text file}"
}

# void die_unless_file_binary(char *filename, char *error_message = '')
#
# Raise an exception unless the passed file exists and is a non-text file.
die_unless_file_binary() {
    die_unless_one_or_two_args\
        'expected filename and optional error message'
    string filename="${1}"
    is_file_binary "${filename}" or
        die "${2:-\"${filename}\" not found or not a binary file}"
}

# ....................{ TESTS                              }....................
# bool is_file_text(char *pathname)
#
# Return true if the passed pathname corresponds to a text file (i.e., not a
# binary file). (If the passed pathname corresponds to a directory instead, this
# function always returns failure.)
is_file_text() {
    die_unless_one_arg 'expected exactly one pathname'
    is_file "${1}" and not is_binary_file "${1}"
}

# bool is_file_binary(char *pathname)
#
# Return true if the passed pathname corresponds to a binary file (i.e., not
# a text file). (If the passed pathname corresponds to a directory instead, this
# function always returns failure.)
is_file_binary() {
    die_unless_one_arg 'expected exactly one pathname'
    is_file "${1}" and is "$(file --mime-encoding "${1}")" == *': binary' si
}

#FIXME: Should be renamed to, say, "get_find_command_text_file_filter()", and
#consequently moved -- ideally, into a new "zeshy/file/find".
# bool is_text_file_find_compatible(void)
#
# Return a string which, when passed as argument to a "find" process, filters
# the currently visited filename if the corresponding file is binary. "find"
# itself provides no built-in means of performing such filtering, unfortunately.
is_text_file_find_compatible() {
    print "\-exec sh -c 'file --mime-encoding {} | grep --invert-match --quiet \": binary$\"' \\\;"
}

# ....................{ TESTS ~ lines                      }....................
# bool is_file_contains(char *filename, char *text)
#
# Return true if the file with the passed filename contains the passed text.
is_file_contains() {
    die_unless_one_arg 'expected exactly one filename'
    string filename="${1}" text="${2}"
    die_unless_file "${filename}"

    #FIXME: Replace with a Zsh one-liner -- ideally, mapfile driven.
    grep -q "${text}" "${filename}"
}

# ....................{ RUNNERS                            }....................
with_mapfile() {
    # Load Zsh module "mapfile".
    load_module zsh/mapfile

    #FIXME: Causes subtle errors, at the moment. Zsh bugs, yes?
    # Forcibly prevent harmful ${mapfile} and hence filesystem changes.
#   freeze_variable mapfile

    # Run the passed command.
    run "${(q)@}"

    # Unload "mapfile", for safety.
    unload_module zsh/mapfile
}

# ....................{ GETTERS                            }....................
#FIXME: It'd be nice to abstract out the load_module/freeze_variable/unload_module
#cruft into a helper function -- say, with_mapfile(): e.g.,
#
#    with_mapfile 'print ${${(f)mapfile[${filename}]}[1]}'

# char *get_file_first_line(char *filename)
#
# Get the first line of the file with the passed filename.
get_file_first_line() {
    # Localize and validate arguments.
    die_unless_one_arg 'expected exactly one filename'
    string filename="${1}"
    die_unless_file "${filename}"
    with_mapfile 'print ${${(f)mapfile[${filename}]}[1]}'

    # Load Zsh module "mapfile".
#   load_module zsh/mapfile

    # Forcibly prevent harmful ${mapfile} and hence filesystem changes.
#   freeze_variable mapfile

    # Print the first line of the file with the passed filename.
#   print ${${(f)mapfile[${filename}]}[1]}

    # Unload "mapfile", for safety.
#   unload_module zsh/mapfile
}

# int get_text_file_line_length_recursively(char *path)
#
# Get the total number of lines corresponding to the file(s) in the passed path,
# as follows:
#
# * If no path is passed, default to the current directory.
# * If this path is a directory, recursively sum the number of lines for files
#   in this path ignoring binary files.
# * If this path is a file:
#   * And this file is a PDF, use "pdftotext" to sum the number of text lines in
#     the rendered PDF.
#   * Otherwise, sum the number of lines in this file.
get_text_files_total_line_length_recursively() {
    # Parse parameters.
    die_unless_at_most_one_arg 'expected at most one pathname'
    string find_path="${1:-${PWD}}"

    #FIXME: Replace dependency on "find" and "wc" with pure Zsh.
    if is_dir "${find_path}"; then
        utter "summing line length for all text files in \"${find_path}\"..."
        
        # Recursively find all files *NOT*:
        # 
        # * Non-files (e.g., directories, device files).
        # * Dotfiles and dot directories (e.g., ".cvs/", ".git/", ".svn/").
        # * Binary files. We borrow this expression from is_file_text().
        find "${find_path}"\
            -type d -iname '*test*' -prune -o\
            -type f \( ! -regex '.*/\..*' \)\
            $(is_text_file_find_compatible)\
            -exec wc -l {} \; |\
            awk '{ total += \$1 } END { print total }' |\
            integer_to_comma_separated_string
    elif is_file "${find_path}"; then
        utter "getting line length for \"${find_path}\"..."
        
        if is "$(get_filetype "${find_path}")" == pdf si; then
            pdftotext "${find_path}" - | wc -l | comma_separate_integer
        else
            die_unless_file_file "${find_path}"
            wc -l "${find_path}" | comma_separate_integer
        fi
    else
        die "\"${find_path}\" neither a directory or file"
    fi
}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
