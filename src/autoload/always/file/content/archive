#!/usr/bin/env zsh
# ====================[ archive                            ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Archive, implementing file compression and decompression.

# ....................{ ALIASES                            }....................
interactive_alias ea='extract_archive'
interactive_alias la='list_archive'
interactive_alias ma='make_archive'

# ....................{ LISTERS                            }....................
#FIXME: Implement me. ;-)
# void list_archive(char *filename1, char *filename2, ...)
#
# Verbosely list the contents of the passed archives.
list_archive() {
    die_unless_args 'expected at least one filename'
    string filetype

    for filename ("${@}") {
        #FIXME: If no filetype, use "file" to attempt to magically ascertain its
        #MIME type and hence filetype. This also goes for the "*)" below. This
        #requires calling get_filetype_if_matched() instead, here.
        filetype="$(get_filetype "${filename}")"
       
        # Extract.
        interactively utter "listing \"${filename}\"..."
        case "${filetype}" in
            7z)
                7za l -- "${filename}";;
            #FIXME: I'm unsure there *IS* a list function for plain "bzip2"
            #archives, mostly as they're structureless in the filesystem sense.
            #This is probably the best we can do. At least it verifies the
            #integrity of the passed archive.
            bz|bz2)
                bunzip2 -tv "${filename}";;
#           cpio)
#               cpio -idmv < "${file_name}";;
#           gz)
#               gunzip -c "${filename}" >\
#                   "$(remove_suffix "${filename}" '.gz')";;
#           lzma)
#               unlzma "${filename}";;
#           rar)
#               unrar x "${filename}";;
            tar)
                tar -tvf  -- "${filename}";;
            tar.bz2|tbz|tbz2)
                tar -tvjf -- "${filename}";;
            tar.gz|tgz)
                tar -tvzf -- "${filename}";;
            tar.lzma|tar.xz|tlz|txz)
                tar -tvJf -- "${filename}";;
#           xz)
#               unxz "${filename}";;
#           zip|jar|cbz)
#               unzip "${filename}";;
#           Z)
#               uncompress -v "${filename}";;
            *)  string error_message="\"${filename}\" not a recognized archive"
                if is_interactive and is_at_least_two_args
                then curse "${error_message}"
                else die   "${error_message}"
                fi;;
        esac
    }
}

# ....................{ WRITERS                            }....................
# void extract_archive(char *filename1, char *filename2, ...)
#
# Decompress the passed compressed files into the current working directory.
# For such files with unrecognized filetype, if this function is:
#
# * Called non-interactively, throw an exception.
# * Called interactively with two or more arguments, print a warning but do
#   *NOT* throw an exception. This better coincides with user expectations.
#   When called with one argument, users expect fatal errors if not an archive.
#   When called with more than one argument, however, users prefer warnings on
#   non-archive arguments while continuing with subsequent arguments: e.g.,
#
#       # Extract all archives in the current directory, printing warnings but
#       # otherwise ignoring all other files.
#       >>> extract_archive *
extract_archive() {
    die_unless_args 'expected at least one filename'
    string filetype

    for filename ("${@}") {
        #FIXME: If no filetype, use "file" to attempt to magically ascertain its
        #MIME type and hence filetype. This also goes for the "*)" below. This
        #requires calling get_filetype_if_matched() instead, here.
        filetype="$(get_filetype "${filename}")"
       
        # Extract.
        interactively utter "extracting \"${filename}\"..."
        case "${filetype}" in
            7z)
                7za x -- "${filename}";;
            # Dismantled, this is:
            #
            # * "-k", preventing deletion of input files. (WUT!?!?!?!?!?!?!?!?!?!?!)
            # * "-v", printing verbosely.
            bz|bz2)
                bunzip2 -kv -- "${filename}";;
            cpio)
                cpio -idmv < "${file_name}";;
            gz)
                gunzip -c -- "${filename}" >\
                    "$(remove_suffix "${filename}" '.gz')";;
            lzma)
                unlzma -- "${filename}";;
            # Call "unrar" with option "x" rather than "e". The former preserves
            # subdirectory structure; the latter does not. 
            rar)
                unrar x -- "${filename}";;
            tar)
                tar -xvf  -- "${filename}";;
            tar.bz2|tbz|tbz2)
                tar -xvjf -- "${filename}";;
            tar.gz|tgz)
                tar -xvzf -- "${filename}";;
            tar.lzma|tar.xz|tlz|txz)
                tar -xvJf -- "${filename}";;
            xz)
                unxz -- "${filename}";;
            zip|jar|cbz)
                unzip -- "${filename}";;
            Z)
                uncompress -v -- "${filename}";;
            *)  string error_message="\"${filename}\" not a recognized archive"
                if is_interactive and is_at_least_two_args
                then curse "${error_message}"
                else die   "${error_message}"
                fi;;
        esac
    }
}

# ....................{ WRITERS ~ makers                   }....................
#FIXME: Improve documentation on defaults. Also, add a make_encrypted_archive()
#function, leveraging "if_installed/7z".
# void make_achive(
#   char *source_pathname1, char *source_pathname2,
#   char *target_filename)
#
# Compress the passed source paths to the passed target archive file. 
make_archive() {
    # If passed no arguments, default the source path to the current directory.
    is_no_args and set_args "$(get_current_dir)"
    
    # If passed one argument, default the target file to the canonicalized
    # basename of the passed source path (thus tripping trailing "/" from such
    # basename, if passed) suffixed with ".bz2".
    is_one_arg and append_args\
        "$(get_basename "$(canonicalize_path "${1}")").bz2"
 
    # Localize passed arguments.
    string target_filename="${@[-1]}" target_filetype
    pop_one_arg
    list source_pathnames; source_pathnames=( "${@}" )
    target_filetype="$(get_filetype "${target_filename}")"

    # Remove the target archive file, if already extant.
    remove_path_if_found "${target_filename}"

    #FIXME: Leverage run_with_options(), as above. Also, implement currently
    #unimplemented types.
    # Compress.
    interactively utter "archiving \"${target_filename}\"..."
    case "${filetype}" in
        # Dismantled, this is:
        #
        # * "-t7z", with 7zip compression. (Probably the default; doesn't hurt.)
        # * "-mx=9", with Ultra (i.e., maximum) compression.
        # * "-mpass=15", with the maximum number of (compression?) passes for
        #   additional compression.
        # * "-mfb=257", with the maximum number of (compression?) fast bytes for
        #   additional compression.
        # * "-mt=${cpu_count}", with one thread per logical processor or core.
        #
        # See also: http://docs.bugaco.com/7zip/MANUAL/switches/method.htm
        7z)
            integer cpu_count=$(get_cpu_count)
            7z a -t7z\
                -mx=9 -mpass=15 -mfb=257 -mmt=${cpu_count} --\
                "${target_filename}" "${source_pathnames[@]}";;
        # Dismantled, this is:
        #
        # * "-c", compressing to standard output.
        # * "-k", preventing deletion of input files. (WUT!?!?!?!?!?!?!?!?!?!?!)
        # * "-p", printing a progress bar.
        # * "-v", printing verbosely.
        # * "-9", allocating the largest in-memory block size possible.
        bz|bz2)
            (( ${#source_pathnames} == 1 )) or die\
                "${#source_pathnames} source paths passed, but \"bzip2\" expects exactly one"
            die_unless_file "${source_pathname[1]}"
            bzip2 -ckpv9 -- "${source_pathname[1]}" > "${target_filename}";;
        #FIXME: See update_initramfs() for the (rather long) command. This
        #implies that, once getting this working here, we can defer that
        #function's implementation to calling this function (which seems rather
        #more sensible).
#       cpio)
#           cpio -idmv < "${file_name}";;
#       cpio.gz) cpio -idmv < "${file_name}";;
#       gz) gunzip -c "${filename}" > "$(remove_suffix "${filename}" '.gz')";;
#       lzma) unlzma "${filename}";;
#       # Call "unrar" with option "x" rather than "e". The former preserves
#       # subdirectory structure; the latter does not. 
#       rar) unrar x "${filename}";;
        tar)
            tar -cf  -- "${target_filename}" "${source_pathnames[@]}";;
        tar.bz2|tbz|tbz2)
            tar -cjf -- "${target_filename}" "${source_pathnames[@]}";;
        tar.gz|tgz)
            tar -czf -- "${target_filename}" "${source_pathnames[@]}";;
        tar.lzma|tar.xz|tlz|txz)
            tar -cJf -- "${target_filename}" "${source_pathnames[@]}";;
#       xz) unxz "${filename}";;
#       zip|jar|cbz) unzip "${filename}";;
#       Z) uncompress -v "${filename}";;
        *)  die "\"${filename}\" not a recognized archive";;
    esac

    #FIXME: Uncomment when list_archive() actually works.
    #interactively and list_archive "${target_filename}"
}

#FIXME: Actually, this function is demonstrably terrible. Just stop using it.

#FIXME: We *REALLY* want to accept option list names (e.g.,
#"ZESHY_BZIP2_OPTIONS") rather than the currently very hacky command-options-
#packed-into-a-single-string-and-then-unpacked-with-"(z)"-style we have here.
#What's nice about such options is that we could then dynamically construct
#functions based on which are currently installed whose implementations simply
#leverage such options. Wait. That doesn't *quite* work; many archivers require
#stdin or stdout oddities. But, still...

# void make_archive_helper(
#   char *archive_filetype,
#   char *archive_command, char *archive_command_options, 
#   char *archive_list_command, char *archive_list_command_options,
#   char *pathname = '.')
#
# Archive the passed path (defaulting to the current working directory) into a
# file of the passed filetype using the passed command. This is a helper
# intended to be called only by other Zeshy functions.
make_archive_helper() {
    (( # >= 7 )) or die\
        'expected one archive filetype, archive command and options, '\
        'archive list command and options, and source pathname'

    # Localize and validate passed arguments. Canonicalize the passed dirname to
    # an absolute pathname. (This strips trailing '/' from the passed dirname,
    # as required for constructing valid archive filenames from such dirnames.)
    string\
        filetype="${1}"\
        command_name="${2}"\
        command_pre_options="${3}"\
        command_post_options="${4}"\
        list_command_name="${5}"\
        list_command_pre_options="${6}"\
        list_command_post_options="${7}"\
        pathname="${8:-$(get_current_dir)}"
    die_unless_found "${pathname}"
    string filename="$(get_basename "$(canonicalize_path "${pathname}")").${filetype}"
    
    # Compress.
    interactively utter "archiving \"${filename}\"..."
#   print "${command} ${command_pre_options} \"${filename}\" \"${pathname}\" ${command_post_options}"
    ${command_name}\
        ${(z)command_pre_options} "${filename}" "${pathname}"\
        ${(z)command_post_options}

    # If interactive, list the contents of the compressed archive.
    if is_interactive; then
        utter_blank_line
        utter "listing \"${filename}\"..."
        ${list_command_name}\
            ${(z)list_command_pre_options} "${filename}"\
            ${(z)list_command_post_options}
    fi
}

#FIXME: Obsolete.
        #FIXME: "-v" options should only be passed if is_interactive. Better yet,
        #this really requires a run_with_options() approach. Quite a bit of busy
        #work involved in that one, however; so... pass for now. Hmm; I'm not
        #entirely convinced it would work. Consider "<" and ">"; while
        #run_with_options should implicitly support such redirection, only a
        #real-world test can reveal the truth of it.
        #
        #Hmm. Actually, I'm unconvinced we can reasonably use run_with_options()
        #here. The number of combinations is simply too large; we have 12
        #different filetypes and numerous operation to interact with such
        #filetypes: listing, creating, encrypting, decrypting, etc.

        # Get this filename's filetype, supporting optional two-part "tar"-
        # specific filenames (e.g., "yog.sothoth.tar.xz"'s filetype is "tar.xz"
        # rather than "sothoth.tar.xz" or merely "xz"). The regular expression
        # matches a prefixing ".", discarded via "#." below for brevity.
#       is "${filename}" =~ '\.(tar\.)?([^.]+)$' si or
#           die "\"${filename}\" has no identifying filetype"
#       filetype="$(remove_prefix "${MATCH}" '.')"

    # Set default arguments if passed insufficient arguments.

#       print "filename: ${filename}\nfiletype: ${filetype}"
#       filetype="${MATCH#.}"

#FIXME: Revise to coincide with archive_dir(). Improve documentation.
# Archive of arbitrary type and command.
#archive_file() {
#    if [[ -n "${1}" && -f "${1}" ]]; then
#        # Remove this path's trailing '/', if it has such a trailing '/'.
#        2=$(echo "${1}" | sed --regexp-extended 's/\.[^.]+$/.'${2}'/' -)
#        
#        utter "creating \"${2}\"..."
#        ${3} ${4} "${2}" "${1}"
#
#        echo ""
#        utter "listing \"${2}\"..."
#        ${5} ${6} "${2}"
#    elif is_empty    "${1}"; then die "no path passed"
#    elif not is_file "${1}"; then die "\"${1}\" not a file"
#    fi
#}

# * Called non-interactively, 
# * Called interactively with two or more arguments, print a
#   warning but do *NOT* throw an exception. This improves the
#   user interface by better coinciding with user expectations.
#   When called with only one argument, most users expect a
#   fatal error if such argument is not actually an archive.
#   When called with more than one argument, however, users
#   prefer warning for non-archive arguments and continuing with
#   subsequent arguments, thus supporting simple globs: e.g.,
#
#       # Extract all archives in the current directory.
#       >>> extract_archive *
#        #FIXME: There must be a pure-Zsh alternative. Find it, please.
        # Obtain this archive's filetype. This is considerably more complex than it
        # should be, as "sed" seems to be incapable of obeying the following
        # substitution:
        #
        #   ... | sed -r 's/^.+\.(tar\.)?/\1/') 
        #
        # Specifically, "sed" refuses to substitute "\1" with "tar." when the
        # latter is found. If we remove the "?", then it does perform the
        # substitution, but (of course) fails on filenames not having the "tar."
        # extension. This is the best we can do, therefore; and it actually works.
        #
        # Oddly, Zsh also seems incapable of obeying the following PCRE:
        #
        #   ... =~ \.(tar\.)?(.+)
        # 
        # Thus, "sed" hackiness it is.
#       filetype="$(print "${filename}" | sed -r 's/^.+\.(tar\.)/tar~/' | sed -r 's/^.+\.//' | sed -r 's/tar~/tar./')"       

#       # Canonicalize abbreviated filetypes.
#       case "${filetype}" in
#           cbz) filetype='zip';;
#           jar) filetype='zip';;
#           tbz) filetype='tar.bz2';;
#           tgz) filetype='tar.gz';;
#       esac

# Strip any trailing '/' from the
    # passed dirname to aid in constructing an archive filename.
# char *bzcat_page(char *bzcat_option1, char *bzcat_option2, ...)
#
# Print the passed bz2-compressed filename under the current pager.
#bzcat_page() {
#    page bzcat "${@}"
#}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
