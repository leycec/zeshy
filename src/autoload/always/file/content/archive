#!/usr/bin/env zsh
# ====================[ archive                            ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Archive, implementing file compression and decompression.

# ....................{ ALIASES                            }....................
interactive_alias x='extract_archive'
interactive_alias lx='list_archive'

# ....................{ LISTERS                            }....................
#FIXME: Implement me. ;-)
# void list_archive(char *filename1, char *filename2, ...)
#
# Verbosely list the contents of the passed archives.
list_archive() {
    die_unless_args 'expected at least one filename'
    die 'Currently unimplemented; fixup extract_archive, first!'
}

# ....................{ WRITERS                            }....................
# void extract_archive(char *filename1, char *filename2, ...)
#
# Decompress the passed compressed files into the current working directory.
# For such files with unrecognized filetype, if this function is:
#
# * Called non-interactively, throw an exception.
# * Called interactively with two or more arguments, print a warning but do
#   *NOT* throw an exception. This better coincides with user expectations.
#   When called with one argument, users expect fatal errors if not an archive.
#   When called with more than one argument, however, users prefer warnings on
#   non-archive arguments while continuing with subsequent arguments: e.g.,
#
#       # Extract all archives in the current directory, printing warnings but
#       # otherwise ignoring all other files.
#       >>> extract_archive *
extract_archive() {
    die_unless_args 'expected at least one filename'

    string filetype
    for filename ("${@}") {
        #FIXME: If no filetype, use "file" to attempt to magically ascertain its
        #MIME type and hence filetype. This also goes for the "*)" below.

        # Get this filename's filetype, supporting optional two-part "tar"-
        # specific filenames (e.g., "yog.sothoth.tar.xz"'s filetype is "tar.xz"
        # rather than "sothoth.tar.xz" or merely "xz"). The regular expression
        # matches a prefixing ".", discarded via "#." below for brevity.
        is "${filename}" =~ '\.(tar\.)?([^.]+)$' si or
            die "\"${filename}\" has no identifying filetype"
        filetype="$(remove_prefix "${MATCH}" '.')"

        #FIXME: "-v" options should only be passed if is_interactive. Better yet,
        #this really requires a run_with_options() approach. Quite a bit of busy
        #work involved in that one, however; so... pass for now. Hmm; I'm not
        #entirely convinced it would work. Consider "<" and ">"; while
        #run_with_options should implicitly support such redirection, only a
        #real-world test can reveal the truth of it.

        # Extract.
        interactively utter "extracting \"${filename}\"..."
        case "${filetype}" in
            7z) 7za x "${filename}";;
            bz|bz2) bunzip2 -kv "${filename}";;
            cpio) cpio -idmv < "${file_name}";;
            gz) gunzip -c "${filename}" > "$(remove_suffix "${filename}" '.gz')";;
            lzma) unlzma "${filename}";;
            # Call "unrar" with option "x" rather than "e". The former preserves
            # subdirectory structure; the latter does not. 
            rar) unrar x "${filename}";;
            tar) tar -xvf "${filename}";;
            tar.bz2|tbz) tar -xvjf "${filename}";;
            tar.gz|tgz) tar -xvzf "${filename}";;
            tar.lzma|tar.xz|tlz|txz) tar -xvJf "${filename}";;
            xz) unxz "${filename}";;
            zip|jar|cbz) unzip "${filename}";;
            Z) uncompress -v "${filename}";;
            *)  string error_message="\"${filename}\" not an archive"
                if is_interactive and is_at_least_two_args
                then curse "${error_message}"
                else die   "${error_message}"
                fi;;
        esac
    }
}

# ....................{ WRITERS ~ helpers                  }....................
#FIXME: We *REALLY* want to accept option list names (e.g.,
#"ZESHY_BZIP2_OPTIONS") rather than the currently very hacky command-options-
#packed-into-a-single-string-and-then-unpacked-with-"(z)"-style we have here.
#What's nice about such options is that we could then dynamically construct
#functions based on which are currently installed whose implementations simply
#leverage such options. Wait. That doesn't *quite* work; many archivers require
#stdin or stdout oddities. But, still...

# void archive_path(
#   char *archive_filetype,
#   char *archive_command, char *archive_command_options, 
#   char *archive_list_command, char *archive_list_command_options,
#   char *pathname = '.')
#
# Archive the passed path (defaulting to the current working directory) into a
# file of the passed filetype using the passed command. This is a helper
# intended to be called only by other Zeshy functions.
archive_path() {
    (( # >= 7 )) or die\
        'expected one archive filetype, archive command and options, '\
        'archive list command and options, and source pathname'

    # Localize and validate passed arguments. Canonicalize the passed dirname to
    # an absolute pathname. (This strips trailing '/' from the passed dirname,
    # as required for constructing valid archive filenames from such dirnames.)
    string\
        filetype="${1}"\
        command_name="${2}"\
        command_pre_options="${3}"\
        command_post_options="${4}"\
        list_command_name="${5}"\
        list_command_pre_options="${6}"\
        list_command_post_options="${7}"\
        pathname="${8:-${PWD}}"
    die_unless_found "${pathname}"
    string filename="$(get_basename "$(canonicalize_path "${pathname}")").${filetype}"
    
    # Compress.
    interactively utter "archiving \"${filename}\"..."
#   print "${command} ${command_pre_options} \"${filename}\" \"${pathname}\" ${command_post_options}"
    ${command_name}\
        ${(z)command_pre_options} "${filename}" "${pathname}"\
        ${(z)command_post_options}

    # If interactive, list the contents of the compressed archive.
    if is_interactive; then
        utter_blank_line
        utter "listing \"${filename}\"..."
        ${list_command_name}\
            ${(z)list_command_pre_options} "${filename}"\
            ${(z)list_command_post_options}
    fi
}

#FIXME: Obsolete.
#       print "filename: ${filename}\nfiletype: ${filetype}"
#       filetype="${MATCH#.}"

#FIXME: Revise to coincide with archive_dir(). Improve documentation.
# Archive of arbitrary type and command.
#archive_file() {
#    if [[ -n "${1}" && -f "${1}" ]]; then
#        # Remove this path's trailing '/', if it has such a trailing '/'.
#        2=$(echo "${1}" | sed --regexp-extended 's/\.[^.]+$/.'${2}'/' -)
#        
#        utter "creating \"${2}\"..."
#        ${3} ${4} "${2}" "${1}"
#
#        echo ""
#        utter "listing \"${2}\"..."
#        ${5} ${6} "${2}"
#    elif is_empty    "${1}"; then die "no path passed"
#    elif not is_file "${1}"; then die "\"${1}\" not a file"
#    fi
#}

# * Called non-interactively, 
# * Called interactively with two or more arguments, print a
#   warning but do *NOT* throw an exception. This improves the
#   user interface by better coinciding with user expectations.
#   When called with only one argument, most users expect a
#   fatal error if such argument is not actually an archive.
#   When called with more than one argument, however, users
#   prefer warning for non-archive arguments and continuing with
#   subsequent arguments, thus supporting simple globs: e.g.,
#
#       # Extract all archives in the current directory.
#       >>> extract_archive *
#        #FIXME: There must be a pure-Zsh alternative. Find it, please.
        # Obtain this archive's filetype. This is considerably more complex than it
        # should be, as "sed" seems to be incapable of obeying the following
        # substitution:
        #
        #   ... | sed -r 's/^.+\.(tar\.)?/\1/') 
        #
        # Specifically, "sed" refuses to substitute "\1" with "tar." when the
        # latter is found. If we remove the "?", then it does perform the
        # substitution, but (of course) fails on filenames not having the "tar."
        # extension. This is the best we can do, therefore; and it actually works.
        #
        # Oddly, Zsh also seems incapable of obeying the following PCRE:
        #
        #   ... =~ \.(tar\.)?(.+)
        # 
        # Thus, "sed" hackiness it is.
#       filetype="$(print "${filename}" | sed -r 's/^.+\.(tar\.)/tar~/' | sed -r 's/^.+\.//' | sed -r 's/tar~/tar./')"       

#       # Canonicalize abbreviated filetypes.
#       case "${filetype}" in
#           cbz) filetype='zip';;
#           jar) filetype='zip';;
#           tbz) filetype='tar.bz2';;
#           tgz) filetype='tar.gz';;
#       esac

# Strip any trailing '/' from the
    # passed dirname to aid in constructing an archive filename.
# char *bzcat_page(char *bzcat_option1, char *bzcat_option2, ...)
#
# Print the passed bz2-compressed filename under the current pager.
#bzcat_page() {
#    page bzcat "${@}"
#}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
