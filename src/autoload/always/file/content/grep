#!/usr/bin/env zsh
# ====================[ grep                               ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Grep, performing recursive pattern matching on file content.
#
# --------------------( TODO                               )--------------------
# * It'd be nice to emit a progress bar for long "grep" operations. Investigate.
#   Yes. It looks like this is halfway there:
#   find . -name "*.rb" | pv | xargs grep
#   Note that we should use "zargs" instead, that we'll need to explicitly pass
#   the total number of files to "pv" (...perhaps it has a mode or option for
#   this already), and that...uhm. Well, it'll be a bit of work, anyway! But
#   it's well doable.

# ....................{ ALIASES                            }....................
interactive_alias g='grep_path'
interactive_alias gi='grep_path_caselessly'
interactive_alias gr='grep_path_recursively'
interactive_alias gri='grep_path_recursively_caselessly'

#FIXME: Re-enable after improving grep_path() for safety. It would help if we
#first improve is_interactive() to note that commands in the middle of a
#pipeline (e.g., the "grep" in "cat /tmp/oeu | grep humu | sort -r") are
#non-interactive. Readily testable with "[[ -p /dev/stdout ]]", I expect.) Or
#does Zsh ensure that already? Probably not. Test. 
#
#Then, we need grep_path() to succeed on receiving piped input: e.g.,
#
#  find /bin /sbin /usr/bin /usr/sbin -type l | xargs ls -l | grep busybox
#
#The prior command currently fails. Prefixing "grep" with "command" succeeds,
#however. Hence, something is awry. Ah, yes -- it's fairly obvious: "grep"
#either requires file arguments or standard input and no arguments. But die_*()
#aliases set arguments, by default. So, we need to cease using die_*(), test the
#passed args manually, test if stdin is piped (is_piped_input), and if so
#propagate the pipe on to grep. Since this is becoming a common theme, perhaps:
#
#  alias propagate_piped_input='cat /dev/stdin |'  # --OR--
#  alias run_with_piped_input='cat /dev/stdin |'   # --OR--
#  alias pass_piped_input_to='cat /dev/stdin |'
#
#Yeah. The latter one rocks. Let's adopt that one.

#interactive_alias grep='grep_path'
 
# ....................{ GETTERS                            }....................
#FIXME: The current implementation pretty suck. Stop using "--pcre-regexp"
#and just use the "ZESHY_GREP_OPTIONS" default. Ah; right. We can pretty much
#cut the whole implementation and replace with a much simpler call to
#run_with_options(). Out with the verbosely old; in with the briefly new!

# int get_grep_match_count(...)
#
# Return the number of matches in the passed string. Among other uses, this
# function counts occurrences of characters and substrings in strings: e.g.,
#
#     >>> get_number_of_matches 
#     2
get_grep_match_count() {
    die_unless_at_least_two_args\
        'expected at least one grep expression and one string'
    string pattern="${1}" string="${2}" string_newlined

    #FIXME: This is *TERRIBLE*. No, really.
    # Escape """ and "~" characters in the passed string, in preparation for
    # replacement by "sed".
    string="${string//\"/\\\"}"
    string="${string//\~/\\~}"

    # This exceptionally clever (and frankly obscene) logic comes inspired by
    # StackOverflow user "user216915" via this question:
    #
    #     http://stackoverflow.com/questions/1781329/count-the-number-of-occurrences-of-a-string-using-sed
    #
    # Sadly, neither sed, awk, grep, or zsh itself have any coherent means of
    # matching individual occurences regardless of newline; rather, they only
    # match each such occurence as a newline-specific group. This hack uses this
    # newline obsession by replacing each match with that match suffixed by a
    # newline. This guarantees no more than one match occupies each line.
    #
    # Finally, feeding the result into "grep -c" counts the number of such lines
    # and hence the number of matches. (Yeth, this sucketh mightily.)
#   print "sed expression: s/${(q)pattern}/${(q)pattern}\n/g"
    string_newlined="$(print "${string}" | sed --patternp-extended "s~(${pattern})~\1\n~g")"
#   die_unless_ok "string \"${string}\" or regular expression \"${pattern}\" malformed"
#   print "string_newlined: ${string_newlined}"

    # If "sed" did nothing, then neither should we.
    if is "${string}" == "${string_newlined}" si
    then return_integer 0
    else return_integer "${string_newlined}" | grep --perl-patternp --count "${pattern}"
    fi
}

# ....................{ GREP                               }....................
# char *grep_path(char *pattern, char *pathname1, char *pathname2, ...)
#
# Match the contents of the passed pathnames (defaulting to all plain files in
# the current directory) against the passed grep expression: e.g.,
#
#     # Grep all text files in the current directory for the passed string.
#     >>> grep 'Matthew*Sobol'
grep_path() {
    # Mimic run_with_options(). Unfortunately, grep's eccentric runtime behavior
    # precludes our calling that function directly.
    die_unless_at_least_one_arg 'expected at least one grep pattern'
    list grep; grep=( command grep "${ZESHY_GREP_OPTIONS[@]}" )

    if is_interactive
    then grep+=( "${ZESHY_GREP_OPTIONS_IF_INTERACTIVE[@]}" )
    else grep+=( "${ZESHY_GREP_OPTIONS_IF_NON_INTERACTIVE[@]}" )
    fi

    #FIXME: Should really be all plaintext plain files. Unsure how to test
    #efficiently... grep the forums.
    # Default to all plain files in the current directory, if needed.
    is_one_arg and append_args "${^PWD}/"*(.)

    # Grep. Since "grep" fails to emit a helpful message on failure, do so.
    # Unfortunately, detecting failure is much more cumbersome than it
    # should be. Since "grep" fails if at least one of the passed files is
    # a broken symbolic link despite such breakage *NOT* signifying a
    # genuine "grep" failure, ignore such breakage by rerunning the same
    # "grep" command with additional options "-qs". Such options squelch
    # output and hence are only helpful in returning the proper exit code.
    # For efficiency, perform such testing prior to running the real "grep"
    # command printing proper output. If such testing succeeds, force "grep"
    # to return success. (Yes, this is all incredibly, indelibly non-
    # sensical. Thanks, GNU "grep". Bang-up job there.)
#       grep+=( "${@}" )
    if "${grep[@]}" -qs -- "${@}"
#       utter "running \"${grep[@]} -- ${@}\" paged..."
    then run_paged "${grep[@]}" -- "${@}" or true
    else die\
        "\"${1}\" not matched in $(join_list_to_legible_truncated_string 'and' "\"${^@[2,-1]}\"")"
    fi
}

# char *grep_path_caselessly(char *grep_arg1, char *grep_arg2, ...)
#
# Match the contents of the passed files against the passed "grep" pattern case-
# insensitively.
grep_path_caselessly() {
    # Append "-i" to ${ZESHY_GREP_OPTIONS} for the duration of this call.
    list zeshy_grep_options; zeshy_grep_options=( "${ZESHY_GREP_OPTIONS[@]}" -i )
    list ZESHY_GREP_OPTIONS; ZESHY_GREP_OPTIONS=( "${zeshy_grep_options[@]}" )
    grep_path "${@}"
}

# ....................{ GREP ~ recursive                   }....................
# char *grep_path_recursively(char *pattern, char *pathname = '.')
#
# Recursively match the contents of all files in the passed paths (defaulting to
# the current working directory) against the passed "grep" pattern.
grep_path_recursively() {
    # Append "-r" to ${ZESHY_GREP_OPTIONS} for the duration of this call.
    list zeshy_grep_options; zeshy_grep_options=( "${ZESHY_GREP_OPTIONS[@]}" -r )
    list ZESHY_GREP_OPTIONS; ZESHY_GREP_OPTIONS=( "${zeshy_grep_options[@]}" )
    is_one_arg and append_args "${PWD}"
    grep_path "${@}"
}

# char *grep_path_recursively_caselessly(char *pattern, char *pathname = '.')
#
# Recursively match the contents of all files in the passed paths (defaulting to
# the current working directory) against the passed "grep" pattern case-
# insensitively.
grep_path_recursively_caselessly() {
    # Append "-ri" to ${ZESHY_GREP_OPTIONS} for the duration of this call.
    list zeshy_grep_options; zeshy_grep_options=( "${ZESHY_GREP_OPTIONS[@]}" -ri )
    list ZESHY_GREP_OPTIONS; ZESHY_GREP_OPTIONS=( "${zeshy_grep_options[@]}" )
    is_one_arg and append_args "${PWD}"
    grep_path "${@}"
}

# ....................{ WASTELANDS                         }....................
#   is_one_arg and append_args "${^PWD}/"*
#   die_unless_at_least_one_arg 'expected at least one grep expression'
#   string grep_pattern="${1}"
#   shift_one_arg
#   grep -r "${grep_pattern}" "${@:-${PWD}}"

#       then utter "grepping ${grep[@]} -qs ${@}..."; run_paged "${grep[@]}" "${@}"
#       then "${grep[@]}"     "${@}"

    #FIXME: Truncate the list of files to seem reasonable length. We'll probably
    #need a new trivial "type/string/string" function for this.

    #FIXME: Terrible. See related "FIXME" comments elsewhere.
    # If the topmost function on the function stack is "grep"-specific,
    # the current user called this function directly from the command-line.

#       if (( ${#funcstack} == 1 )) or is "${funcstack[-2]}" == grep* si
#FIXME: Obsolete.
    # Call is_interactive() rather than is_interactive_directly(). The embedded
    # conditional below implicitly implements the latter, already.
#   if is_interactive; then

    # If running non-interactively, pass *NO* Zeshy-specific options to "grep".
    # Doing so breaks non-interactive shell scripts and functions expecting
    # default (and arguably broken) "grep" behavior.
#   else command grep "${@}"
#   fi

# Please note that "grep" fails with error if at least one of the passed files
# is a broken symbolic link, even if when passing symbolic brokens

#grep_caseless() {
#    die_unless_at_least_two_args\
#        'expected at least one grep pattern and filename'
#
##    # See interactive_alias().
#    disable_function grep
#    if is_interactive; then
#        if (( #funcstack == 1 ))
#        then grep --ignore-case "${ZESHY_GREP_OPTIONS_IF_INTERACTIVE[@]}" "${@}"
#        else grep --ignore-case "${ZESHY_GREP_OPTIONS[@]}" "${@}"
#        fi
#    # If running non-interactively, pass *NO* Zeshy-specific options to "grep".
#    # Doing so breaks non-interactive shell scripts and functions expecting
#    # default "grep" behavior (e.g., basic patterns).
#    else grep "${@}"
#    fi
#    enable_function grep
#}
#
## ....................{ RECURSIVE                          }....................
##FIXME: Reimplement to resemble the implementation of grep(), above.
## char *grep_recursively(char *pattern, char *path)
##
## Recursively match all file contents under the passed path against the passed
## POSIX-style regular expression. If no path is passed, this recursively matches
## under the current path. Thusly, the simplest usage of this shell script is:
##
##   # Find all text files whose contents match "Wisdom ~ \d\d ~ Outlays".
##   >>> grep-recursively 'Wisdom ~ \d\d ~ Outlays'
#grep_recursively() {
#    die_unless_at_least_one_arg 'expected at least a regular expression'
#    string grep_pattern="${1}"; shift
#
##   utter 'grepping...'
#    run_paged grep\
#        --recursive "${ZESHY_GREP_OPTIONS_IF_INTERACTIVE[@]}"\
#        "${grep_pattern}" "${@:-${PWD}}"
#}
#
## char *grep_caseless_recursively(char *pattern, char *path)
##
## Recursively match all file contents under the passed path against the passed
## POSIX-style regular expression, case-insensitively.
#grep_caseless_recursively() {
#    die_unless_at_least_one_arg 'expected at least a regular expression'
#    string grep_pattern="${1}"; shift
#
##   utter 'grepping case-insensitively...'
#    run_paged grep\
#        --recursive "${ZESHY_GREP_OPTIONS_IF_INTERACTIVE[@]}" --ignore-case\
#        "${grep_pattern}" "${@:-${PWD}}"
#}
#
#list ZESHY_GREP_OPTIONS_MORE
#interactive_alias gr="grep ${ZESHY_GREP_OPTIONS_IF_INTERACTIVE[@]}"
#interactive_alias gri="grep ${ZESHY_GREP_OPTIONS_IF_INTERACTIVE[@]}"

# This
#   includes the standard retinue of *NIX commands, like "awk", "grep", "sed", 
#   and so forth.
        #as a directory, ignoring non-text files, dotfiles, and \"test\" subdirectories..."
#FIXME: Bizarre. "grep --include" does absolutely nothing. O_o
#alias grg="grep_glob"
#alias grgi="grep_glob_insensitively"
#
## char *grep_glob(char *grep_pattern, char *glob_expression)
##
## Grep all files matching the passed glob expression (e.g., "*.txt") against the
## passed grep pattern (e.g., "^unity in faith$").
#grep_glob() {
#    [[ ${#} -eq 1 || ${#} -eq 2 ]] ||
#        die "expected at least one regular expression"
#
#    local grep_pattern="${1}"
#    local glob_pattern="${2:-*.txt}"
#
#    utter "grepping \"${glob_pattern}\"..."
#    grep --include "${glob_pattern}" ${=ZESHY_GREP_OPTIONS}\
#        "${grep_pattern}" | "${PAGER}"
#}
#
## char *grep_glob_insensitively(char *grep_pattern, char *glob_expression)
##
## Grep all files matching the passed glob expression (e.g., "*.txt") against the
## passed grep pattern (e.g., "^unity in faith$") insensitively.
#grep_glob_insensitively() {
#    [[ ${#} -eq 1 || ${#} -eq 2 ]] ||
#        die "expected at least one regular expression"
#
#    local grep_pattern="${1}"
#    local glob_pattern="${2:-*.txt}"
#
#    utter "grepping \"${glob_pattern}\" case-insensitively..."
#    grep --include="${glob_pattern}" ${=ZESHY_GREP_INSENSITIVELY_OPTIONS}\
#        "${grep_pattern}"
#}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
