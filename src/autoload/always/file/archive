#!/usr/bin/env zsh
# ====================[ archive                            ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Archive, implementing file compression and decompression.

# ....................{ ALIASES                            }....................
interactive_alias la='list_archive'
interactive_alias ea='extract_archive'

# ....................{ COMPRESSING                        }....................
# void archive_dir(char *archive_filetype,
#     char *archive_command, char *archive_command_options, 
#     char *archive_list_command, char *archive_list_command_options,
#     char *dirname = '.')
#
# Archive the passed directory (defaulting to the current working directory)
# into a file of the passed filetype by the passed command. This function is a
# helper intended to be called only by other Zeshy components (e.g., Zeshy zip).
archive_dir() {
    (( # >= 7 )) or die\
        'expected exactly one archive filetype, archive command and options, '\
        'archive list command and options, and source dirname'

    # Localize and validate passed arguments. Canonicalize the passed dirname to
    # an absolute pathname. (This strips trailing '/' from the passed dirname,
    # helpful for use in forming an archive filename.)
    string\
        archive_filetype="${1}"\
        archive_command="${2}"\
        archive_command_pre_options="${3}"\
        archive_command_post_options="${4}"\
        archive_list_command="${5}"\
        archive_list_command_pre_options="${6}"\
        archive_list_command_post_options="${7}"\
        dirname="${8:-${PWD}}"
    die_unless_dir "${dirname}"
    string archive_filename="$(get_basename "$(canonicalize_path "${dirname}")").${archive_filetype}"
    
    # Compress.
    utter "archiving \"${archive_filename}\"..."
    print "${archive_command} ${archive_command_pre_options} \"${archive_filename}\" \"${dirname}\" ${archive_command_post_options}"
    ${archive_command}\
        ${(z)archive_command_pre_options} "${archive_filename}" "${dirname}"\
        ${(z)archive_command_post_options}

    # For verification, list the contents of the compressed archive.
    print
    utter "listing \"${archive_filename}\"..."
    ${archive_list_command}\
        ${(z)archive_list_command_pre_options} "${archive_filename}"\
        ${(z)archive_list_command_post_options}
}

#FIXME: Revise to coincide with archive_dir(). Improve documentation.
# Creates an archive of arbitrary type and command.
archive_file() {
    if [[ -n "${1}" && -f "${1}" ]]; then
        # Remove this path's trailing '/', if it has such a trailing '/'.
        2=$(echo "${1}" | sed --regexp-extended 's/\.[^.]+$/.'${2}'/' -)
        
        utter "creating \"${2}\"..."
        ${3} ${4} "${2}" "${1}"

        echo ""
        utter "listing \"${2}\"..."
        ${5} ${6} "${2}"
    elif is_empty    "${1}"; then die "no path passed"
    elif not is_file "${1}"; then die "\"${1}\" not a file"
    fi
}

# ....................{ UNCOMPRESSING                      }....................
# void list_archive(char *filename1, char *filename2, ...)
#
# Uncompress one or more compressed files of arbitrary type.
list_archive() {
    die_unless_at_least_one_argument 'expected at least one filename'
    die 'Currently unimplemented; fixup extract_archive, first!'
}

# void extract_archive(char *filename1, char *filename2, ...)
#
# Uncompress one or more compressed files of arbitrary type.
#FIXME: Add ".lzo" and ".lzma" support.
extract_archive() {
    die_unless_at_least_one_argument 'expected at least one filename'

    string archive_filetype
    for archive_filename ("${@}") {
        # Obtain this archive's filetype. This is considerably more complex than it
        # should be, as "sed" seems to be incapable of obeying the following
        # substitution:
        #
        #   ... | sed -r 's/^.+\.(tar\.)?/\1/') 
        #
        # Specifically, "sed" refuses to substitute "\1" with "tar." when the
        # latter is found. If we remove the "?", then it does perform the
        # substitution, but (of course) fails on filenames not having the "tar."
        # extension. This is the best we can do, therefore; and it actually works.
        #
        # Oddly, Zsh also seems incapable of obeying the following PCRE:
        #
        #   ... =~ \.(tar\.)?(.+)
        # 
        # Thus, "sed" hackiness it is.
        archive_filetype="$(print "${archive_filename}" | sed -r 's/^.+\.(tar\.)/tar~/' | sed -r 's/^.+\.//' | sed -r 's/tar~/tar./')"

        # Alias alternative archive filetypes to their canonical filetype.
        case "${archive_filetype}" in
            cbz) archive_filetype='zip';;
            jar) archive_filetype='zip';;
            tbz) archive_filetype='tar.bz2';;
            tgz) archive_filetype='tar.gz';;
        esac

        # Extract.
        case "${archive_filetype}" in
            7z)
                utter "un7ziping \"${archive_filename}\"..."
                7z x "${archive_filename}";;
            bz|bz2)
                utter "unbzip2ing \"${archive_filename}\"..."
                bunzip2 --keep "${archive_filename}";;
            rar)
                utter "unraring \"${archive_filename}\"..."
                unrar x "${archive_filename}";;
            tar)
                utter "untaring \"${archive_filename}\"..."
                tar -xvf "${archive_filename}";;
            tar.bz2)
                utter "untaring \"${archive_filename}\"..."
                tar -xvjf "${archive_filename}";;
            tar.gz)
                utter "untaring \"${archive_filename}\"..."
                tar -xvzf "${archive_filename}";;
            tar.lzma|tar.xz)
                utter "untaring \"${archive_filename}\"..."
                tar -xvJf "${archive_filename}";;
            gz)
                utter "ungziping \"${archive_filename}\"..."
                gunzip "${archive_filename}" --to-stdout > "${archive_file%.gz}";;
            lzma|xz)
                utter "unxziping \"${archive_filename}\"..."
                unxz "${archive_filename}";;
            zip)
                utter "unziping \"${archive_filename}\"..."
                unzip "${archive_filename}";;
            *) die "\"${archive_filename}\" not a recognized archive";;
        esac
    }
}

#FIXME: Obsolete.
# Strip any trailing '/' from the
    # passed dirname to aid in constructing an archive filename.
# char *bzcat_page(char *bzcat_option1, char *bzcat_option2, ...)
#
# Print the passed bz2-compressed filename under the current pager.
#bzcat_page() {
#    page bzcat "${@}"
#}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
