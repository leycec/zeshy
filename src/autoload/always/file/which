#!/usr/bin/env zsh
# ====================[ which                              ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Which, implementing ${PATH}-based filename finding.

# ....................{ MULTIPLE                           }....................
# char *which_files(char *filename1, *filename2, ...)
#
# Get the absolute path to the first filename in the list of passed filenames
# which exists: e.g.,
#
#     >>> which_files '/the_ancient.one' '/the_king_in.yellow' '/tmp'
#     /tmp
which_files() {
    die_unless_at_least_one_argument 'expected exactly one filename'

    # Scalarize the list of passed filenames for use in an error message.
    string filenames="'${^@}'"
    
    # Iteratively look for each filename in the passed list.
    string filename
    while is_at_least_one_argument; do
        filename="${1}"; shift

        # If this filename exists, return it.
        if is_file "${filename}"; then
            print  "${filename}"
            return_success
        fi
    done
    
    # Otherwise, no such filename exists. Fail.
    curse "\"${filenames}\" not found"
    return_failure
}

# char *which_commands(char *command_name1, *command_name2, ...)
#
# Get the absolute path to the first command in the list of passed commands
# which exists: e.g.,
#
#     >>> which_commands Council_of_Nicea Constantinople zsh
#     /bin/zsh
# 
# This function is intended to automate selection of commands, in descending
# order of preference. (In the above example, the hypothetical
# "Council_of_Nicea" command would be selected before all following commands on
# systems having the command.)
which_commands() {
    die_unless_at_least_one_argument 'expected exactly one command name'
    
    # Scalarize the list of passed filenames for use in an error message.
    string command_names="'${^@}'"

     # Iteratively look for each command in the passed list.
    string command_path
    while is_at_least_one_argument; do
        # If this command exists, return its absolute path.
        if command_path="$(stderr_to_stdout which_command "${1}")"; then
            print "${command_path}"
            return_success
        fi

        # Otherwise, shift this command off the passed list and try again.
        shift
    done
    
    # Otherwise, no such command exists. Fail.
    curse "\"${command_names}\" not found"
    return_failure
}

# ....................{ SINGLE                             }....................
# char *which_command(char *command_name)
#
# Return the absolute path to the command with the passed name if such command
# exists in the $PATH and an error message otherwise: e.g.,
#
#     >>> which_command zsh
#     /bin/zsh
which_command() {
    die_unless_one_argument 'expected exactly one command name'
    string command_name="${1}"
    string command_pathname="${command_name:c}"

    # If no such command exists, print an error message and return with failure.
    if not is_pathname_absolute "${command_pathname}"; then
        curse "\"${command_name}\" not found"
        return_failure
    fi

    # Otherwise, print the absolute path of this command.
    print "${command_pathname}"
}

# char *which_script(char *script_name)
#
# Get the absolute path to the script with the passed name. If
# there exist multiple such scripts, return the first such script. This function
# generalizes which_autoload() by searching for (in order):
#
# * Any file in the current working directory with such name.
# * Any file in the ${PATH} with such name (i.e., a command).
# * Any file in the ${FPATH} with such name (i.e., an autoload).
which_script() {
    die_unless_at_least_one_argument 'expected exactly one script name'
    list script_paths; script_paths=( "${PWD}" "${path[@]}" "${fpath[@]}" )
    which_autoload "${1}" 'script_paths'
}

# char *which_autoload(
#   char *autoload_name, char **autoload_paths_list_name = 'fpath')
#
# Get the absolute path to the autoloadable script with the passed name. If
# there exist multiple such scripts, return the first such script: e.g.,
#
#     >>> which_autoload zsh-mime-handler
#     /usr/share/zsh/4.3.11/functions/MIME/zsh-mime-handler
which_autoload() {
    die_unless_at_least_one_argument 'expected exactly one autoload name'
    string autoload_name="${1}"
#   string autoload_paths_list_name="${2:-fpath}"
    
    # Dismantled, this is:
    #
    # * "autoload_paths_list_name", the name of the list listing all
    #   directories to be searched for the passed autoload.
    # * "(P)", expanding to such list.
    # * "^", iteratively expanding to each such directory.
    # * "/${autoload_name}", concatenating the passed autoload to each such
    #   directory, producing a possible absolute path to such autoload.
    # 
    # Since "null_glob" is globally enabled, Zsh removes non-extant paths.
    list autoload_paths
    autoload_paths=( ^fpath/"${autoload_name}"(N) )
#   autoload_paths=( ${^fpath}/"${autoload_name}"(N) )
#   autoload_paths=( ${^${(P)autoload_paths_list_name}}/"${autoload_name}"(N) )

    # If no command has the passed name, print an error message and return
    # failure. To permit the caller to recover, do not raise a fatal error.
    if is_empty "${autoload_paths}"; then
        curse "\"${autoload_name}\" not found"
        return_failure
    fi

    # Otherwise, print the first absolute path to this autoload.
    print "${autoload_paths[1]}"
}

# ....................{ TEMPORARY                          }....................
# char *which_temporary_home(void)
#
# Get the absolute path of this user's topmost temporary directory (in order):
#
# * "${HOME}/tmp", if this directory exists.
# * "/tmp", otherwise.
which_temporary_home() {
    die_unless_no_arguments 'expected no arguments'
    
    string user_temporary_home="${HOME}/tmp" root_temporary_home="/tmp"
    if   is_dir "${user_temporary_home}"
    then print  "${user_temporary_home}"
    elif is_dir "${root_temporary_home}"
    then print  "${root_temporary_home}"
    else die 'no temporary directory found'
    fi
}

# char *which_temporary_dir(char *prefix)
#
# Get the absolute path to a temporary path having the passed prefix: e.g.,
#
#     >>> which_temporary_dir git_patches
#     /tmp/git_patches~2012-04-18_22-58-34_609198275
#
# While subtle race conditions may arise with concurrent processing, this path
# is generally unique. This should probably not be depended upon for mission
# critical Zsh scripts, however. (.......of course, if you're coding mission
# critical Zsh scripts, you've probably already gone too far.)
which_temporary_dir() {
    die_unless_one_argument 'expected exactly one dirname prefix'
    
    string which_temporary_dir
    while true; do
        which_temporary_dir="$(which_temporary_home)/${1}.path~$(date +'%F_%H-%M-%S_%N')"
        if not is_dir "${which_temporary_dir}"; then
            print  "${which_temporary_dir}"
            break
        fi
    done
}

# char *which_temporary_file(char *prefix)
#
# Get the absolute path to a temporary file having the passed prefix: e.g.,
#
#   # Prints "/tmp/git_patch_file~2012-12-01_18-37-41", for example.
#   which_temporary_file git_patch_file
#
# Subtle race conditions may arise, as above.
which_temporary_file() {
    die_unless_one_argument 'expected exactly one filename prefix'
    
    string which_temporary_file
    while true; do
        which_temporary_file="$(which_temporary_home)/${1}.file~$(date +'%F_%H-%M-%S')"
        if not is_file "${which_temporary_file}"; then
            print "${which_temporary_file}"
            break
        fi
    done
}

#FIXME: Obsolete.
    # Dismantled, this is:
    #
    # * "autoload_paths_list_name", the name of the list listing all
    #   directories to be searched for the passed autoload.
    # * "(P)", expanding to such list.
    # * "^", iteratively expanding to each such directory.
    # * "/${autoload_name}", concatenating the passed autoload to each such
    #   directory, producing a possible absolute path to such autoload.
    # * "(N)", removing non-extant paths.
    # * "(..)", listing all extant paths.
#   list autoload_paths
#   autoload_paths=( ${^${(P)autoload_paths_list_name}}/"${autoload_name}" )

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
