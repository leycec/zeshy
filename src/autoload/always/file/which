#!/usr/bin/env zsh
# ====================[ which                              ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Which, implementing ${PATH}-based filename finding.
#
# --------------------( TODO                               )--------------------
# * Create a new "file/command", shifting functions from "process" there.
# * Dismantle this file, distributing its functions to the appropriate files.

# ....................{ SINGULAR                           }....................
# char *which_command(char *command_name)
#
# Return the absolute path to the command with the passed name if such command
# exists in the $PATH and an error message otherwise: e.g.,
#
#     >>> which_command zsh
#     /bin/zsh
which_command() {
    die_unless_one_argument 'expected exactly one command name'
    string command_name="${1}"
    string command_pathname="${command_name:c}"

    # If no such command exists, print an error message and return with failure.
    is_absolute_path "${command_pathname}" or
        die "command \"${command_name}\" not found"

    # Otherwise, print the absolute path of this command.
    print "${command_pathname}"
}

# char *which_script(char *script_name)
#
# Get the absolute path to the script with the passed name. If
# there exist multiple such scripts, return the first such script. This function
# generalizes which_autoload() by searching for (in order):
#
# * Any file in the current working directory with such name.
# * Any file in the ${PATH} with such name (i.e., a command).
# * Any file in the ${FPATH} with such name (i.e., an autoload).
which_script() {
    die_unless_at_least_one_argument 'expected exactly one script name'
    list script_paths; script_paths=( "${PWD}" "${path[@]}" "${fpath[@]}" )
    which_autoload "${1}" 'script_paths'
}

# char *which_autoload(
#   char *autoload_name, char **autoload_paths_list_name = 'fpath')
#
# Get the absolute path to the autoloadable script with the passed name. If
# there exist multiple such scripts, return the first such script: e.g.,
#
#     >>> which_autoload zsh-mime-handler
#     /usr/share/zsh/4.3.11/functions/MIME/zsh-mime-handler
which_autoload() {
    die_unless_at_least_one_argument 'expected exactly one autoload name'
    string autoload_name="${1}" autoload_paths_list_name="${2:-fpath}"
    
    # Dismantled, this is:
    #
    # * "autoload_paths_list_name", the name of the list listing all
    #   directories to be searched for the passed autoload.
    # * "(P)", expanding to such list.
    # * "^", iteratively expanding to each such directory.
    # * "/${autoload_name}", concatenating the passed autoload to each such
    #   directory, producing a possible absolute path to such autoload.
    # * "(N)", ignoring non-extant such absolute paths.
    list autoload_paths
    autoload_paths=( ${^${(P)autoload_paths_list_name}}/"${autoload_name}"(N) )
#   autoload_paths=( ${^fpath}/"${autoload_name}"(N) )

    # If no command has the passed name, print an error message and return
    # failure. To permit the caller to recover, do not raise a fatal error.
#   print "which_autoload: ${autoload_paths[@]}"
    die_unless_list_nonempty 'autoload_paths' "\"${autoload_name}\" not found"
#   is_nonempty "${autoload_paths}" or
#       die "\"${autoload_name}\" not found"

    # Otherwise, print the first absolute path to this autoload.
    print "${autoload_paths[1]}"
}

# ....................{ PLURAL ~ dirs                      }....................
# char *get_first_command(char *command_name1, *command_name2, ...)
#
# Get the absolute path of the first command in the passed list of command names
# found in the ${PATH} or raise an exception if no such command is found.
get_first_command() {
    get_first_pathname_matching_glob_qualifiers\
        "e{'is_installed \$REPLY'}" "${@}"
}

# char *get_first_writable_dir(char *dirname1, *dirname2, ...)
#
# Get the absolute path of the first directory in the passed list of dirnames
# that exists and is writable by the current user or raise an exception if no
# such directory exists.
get_first_writable_dir() {
    get_first_pathname_matching_glob_qualifiers\
        "e{'[[ -d \$REPLY && -w \$REPLY ]]'}" "${@}"
}

# char *get_first_file(char *filename1, *filename2, ...)
#
# Get the absolute path of the first file in the passed list of filenames that
# exists or raise an exception if no such file exists.
get_first_file() {
    get_first_pathname_matching_glob_qualifiers '.' "${@}"
}

# char *get_first_file_if_found(char *filename1, *filename2, ...)
#
# Get the absolute path of the first file in the passed list of filenames that
# exists or return false (but do not raise an exception) if no such file exists.
get_first_file_if_found() {
    get_first_pathname_matching_glob_qualifiers_if_found '.' "${@}"
}

# char *get_first_pathname_matching_glob_qualifiers(
#   char *glob_qualifiers, char *pathname1, *pathname2, ...)
#
# Get the first pathname in the passed list to successfully match all passed
# glob qualifiers (e.g., 'w/', matching all owner-writable directories) or
# raise an exception if no such directory exists. See section "Glob Qualifiers"
# of "man zshexpn", for glob qualifier reference.
get_first_pathname_matching_glob_qualifiers() {
    get_first_pathname_matching_glob_qualifiers_if_found "${@}" or
        die "neither $(join_list_to_string_prefixing_last_with ', ' 'or ' "\"${^@[2,-1]}\"") found"
}

# char *get_first_pathname_matching_glob_qualifiers_if_found(
#   char *glob_qualifiers, char *pathname1, *pathname2, ...)
#
# Get the first pathname in the passed list to successfully match all passed
# glob qualifiers (e.g., 'r.', matching all owner-readable plain files) or
# return false if no such directory exists. See section "Glob Qualifiers" of
# "man zshexpn", for glob qualifier reference.
get_first_pathname_matching_glob_qualifiers_if_found() {
    die_unless_at_least_one_argument 'expected at least one pathname'

    # Glob qualifiers to be matched.
    string glob_qualifiers="${1}"
    shift_one_argument

    # List of pathnames filtered from the list of passed pathnames. Dismantled,
    # this is:
    #
    # * "${^@}", iteratively expanding to each passed pathname.
    # * "(${glob_qualifiers}), excluding pathnames not matching the passed glob
    #   qualifiers.
    # * "or true", preventing failure if at least one pathname is excluded.
    list pathnames; pathnames=( ${^@}(${glob_qualifiers}) ) or true
#   eval "pathnames=( \${^@}(${glob_qualifiers}) ) or true"

    # If the list of passed pathnames contains at least one writable pathname,
    # print the first such match; otherwise, raise an exception.
    if is_list_nonempty pathnames
    then print "${pathnames[1]}"
    else return_failure
    fi
}

# ....................{ PLURAL ~ commands                  }....................
#FIXME: Obsolete.
#FIXME: *****WAIT*****. We can substantially improve every other function by
#rewriting to the implementation of which_dir_writable(). Also, which_files()
#should clearly simply defer to which_files_if_found() rather than
#reimplementing the whole shebang.

# * Compress which_commands() into which_command() and which_files() into
#   which_file(). (Simplify life, yes? No justifiable reason not to, really.)

# char *which_commands(char *command_name1, *command_name2, ...)
#
# Get the absolute path of the first command in the passed list of command names
# found in the ${PATH} or raise an exception if no such command is found: e.g.,
#
#     >>> which_commands Council_of_Nicea Constantinople zsh
#     /bin/zsh
# 
# This function is intended to automate selection of commands, in descending
# order of preference. (In the above example, the hypothetical
# "Council_of_Nicea" command would be selected before all following commands on
# systems having the command.)
#which_commands() {
#    die_unless_at_least_one_argument 'expected exactly one command name'
#    
#    # Iteratively look for each command in the passed list.
#    string command_path
#    for command_name ("${@}") {
#        if command_path="$(pipe_stderr_to_stdout which_command "${command_name}")"; then
#            print "${command_path}"
#            return_success
#        fi
#    }
#    
#    # Otherwise, no such command exists. Die? Die! Die.
#    string command_names=$(join_list_to_string_prefixing_last_with ', ' 'or ' "\"${^@}\"")
#    die "neither ${command_names} found in \$PATH"
#}

#     >>> which_files '/the_ancient.one' '/the_king_in.yellow' '/tmp'
#     /tmp#   die_unless_at_least_one_argument 'expected at least one dirname'

    # List of writable dirnames filtered from the list of passed pathnames.
    # Dismantled, this is:
    #
    # * "${^@}", iteratively expanding to each passed pathname.
    # * "(e{'...'}), excluding pathnames not matching the embedded test.
    # * "or true", preventing failure if at least one pathname is excluded.
#   list dirnames
#        dirnames=( ${^@}(e{'[[ -d $REPLY && -w $REPLY ]]'}) ) or true

    # If the list of passed pathnames contains at least one writable dirname,
    # print the first such match; otherwise, raise an exception.
#   if is_list_nonempty dirnames
#   then print "${dirnames[1]}"
#   else die "neither $(join_list_to_string_prefixing_last_with ', ' 'or ' "\"${^@}\"") found"
#   fi

    # Dismantled, this is:
    #
    # * "autoload_paths_list_name", the name of the list listing all
    #   directories to be searched for the passed autoload.
    # * "(P)", expanding to such list.
    # * "^", iteratively expanding to each such directory.
    # * "/${autoload_name}", concatenating the passed autoload to each such
    #   directory, producing a possible absolute path to such autoload.
    # * "(N)", removing non-extant paths.
    # * "(..)", listing all extant paths.
#   list autoload_paths
#   autoload_paths=( ${^${(P)autoload_paths_list_name}}/"${autoload_name}" )

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
