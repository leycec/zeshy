#!/usr/bin/env zsh
# ====================[ which                              ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Which, implementing ${PATH}-based filename finding.
#
# --------------------( TODO                               )--------------------
# * Compress which_commands() into which_command() and which_files() into
#   which_file(). (Simplify life, yes? No justifiable reason not to, really.)

# ....................{ SINGULAR                           }....................
# char *which_command(char *command_name)
#
# Return the absolute path to the command with the passed name if such command
# exists in the $PATH and an error message otherwise: e.g.,
#
#     >>> which_command zsh
#     /bin/zsh
which_command() {
    die_unless_one_argument 'expected exactly one command name'
    string command_name="${1}"
    string command_pathname="${command_name:c}"

    # If no such command exists, print an error message and return with failure.
    is_absolute_path "${command_pathname}" or
        die "command \"${command_name}\" not found"

    # Otherwise, print the absolute path of this command.
    print "${command_pathname}"
}

# char *which_script(char *script_name)
#
# Get the absolute path to the script with the passed name. If
# there exist multiple such scripts, return the first such script. This function
# generalizes which_autoload() by searching for (in order):
#
# * Any file in the current working directory with such name.
# * Any file in the ${PATH} with such name (i.e., a command).
# * Any file in the ${FPATH} with such name (i.e., an autoload).
which_script() {
    die_unless_at_least_one_argument 'expected exactly one script name'
    list script_paths; script_paths=( "${PWD}" "${path[@]}" "${fpath[@]}" )
    which_autoload "${1}" 'script_paths'
}

# char *which_autoload(
#   char *autoload_name, char **autoload_paths_list_name = 'fpath')
#
# Get the absolute path to the autoloadable script with the passed name. If
# there exist multiple such scripts, return the first such script: e.g.,
#
#     >>> which_autoload zsh-mime-handler
#     /usr/share/zsh/4.3.11/functions/MIME/zsh-mime-handler
which_autoload() {
    die_unless_at_least_one_argument 'expected exactly one autoload name'
    string autoload_name="${1}" autoload_paths_list_name="${2:-fpath}"
    
    # Dismantled, this is:
    #
    # * "autoload_paths_list_name", the name of the list listing all
    #   directories to be searched for the passed autoload.
    # * "(P)", expanding to such list.
    # * "^", iteratively expanding to each such directory.
    # * "/${autoload_name}", concatenating the passed autoload to each such
    #   directory, producing a possible absolute path to such autoload.
    # * "(N)", ignoring non-extant such absolute paths.
    list autoload_paths
    autoload_paths=( ${^${(P)autoload_paths_list_name}}/"${autoload_name}"(N) )
#   autoload_paths=( ${^fpath}/"${autoload_name}"(N) )

    # If no command has the passed name, print an error message and return
    # failure. To permit the caller to recover, do not raise a fatal error.
#   print "which_autoload: ${autoload_paths[@]}"
    die_unless_list_nonempty 'autoload_paths' "\"${autoload_name}\" not found"
#   is_nonempty "${autoload_paths}" or
#       die "\"${autoload_name}\" not found"

    # Otherwise, print the first absolute path to this autoload.
    print "${autoload_paths[1]}"
}

#FIXME: *****WAIT*****. We can substantially improve every other function by
#rewriting to the implementation of which_dir_writable(). Also, which_files()
#should clearly simply defer to which_files_if_found() rather than
#reimplementing the whole shebang.

# ....................{ PLURAL ~ dirs                      }....................
# char *which_dir_writable(char *dirname1, *dirname2, ...)
#
# Get the absolute path of the first directory in the passed list of dirnames
# that exists and is writable by the current user or raise an exception if no
# such directory exists.
which_dir_writable() {
    die_unless_at_least_one_argument 'expected at least one dirname'

    # List of writable dirnames filtered from the list of passed pathnames.
    # Dismantled, this is:
    #
    # * "${^@}", iteratively expanding to each passed pathname.
    # * "(e{'...'}), excluding pathnames not matching the embedded test.
    # * "or true", preventing failure if at least one pathname is excluded.
    list dirnames
         dirnames=( ${^@}(e{'[[ -d $REPLY && -w $REPLY ]]'}) ) or true

    # If the list of passed pathnames contains at least one writable dirname,
    # print the first such match; otherwise, raise an exception.
    if is_list_nonempty dirnames
    then print "${dirnames[1]}"
    else die "neither $(join_list_to_string_prefixing_last_with ', ' 'or ' "\"${^@}\"") found"
    fi
}

# ....................{ PLURAL ~ files                     }....................
# char *which_files(char *filename1, *filename2, ...)
#
# Get the absolute path of the first file in the passed list of filenames that
# exists or raise an exception if no file exists: e.g.,
#
#     >>> which_files '/the_ancient.one' '/the_king_in.yellow' '/tmp'
#     /tmp
which_files() {
    die_unless_at_least_one_argument 'expected at least one filename'

    # Iteratively look for each filename in the passed list.
    for filename ("${@}") {
        if is_file "${filename}"; then
            print  "${filename}"
            return_success
        fi
    }
    
    # Otherwise, no such filename exists. Die. Die! Die?
    string filenames=$(join_list_to_string_prefixing_last_with ', ' 'or ' "\"${^@}\"")
    die "neither ${filenames} found"
}

# char *which_files_if_found(char *filename1, *filename2, ...)
#
# Get the absolute path of the first file in the passed list of filenames that
# exists or return failure (but do not raise an exception) if no file exists.
which_files_if_found() {
    die_unless_at_least_one_argument 'expected at least one filename'

    # Iteratively look for each filename in the passed list.
    for filename ("${@}") {
        if is_file "${filename}"; then
            print  "${filename}"
            return_success
        fi
    }
    
    return_failure
}

# ....................{ PLURAL ~ commands                  }....................
# char *which_commands(char *command_name1, *command_name2, ...)
#
# Get the absolute path of the first command in the passed list of command names
# found in the ${PATH} or raise an exception if no such command is found: e.g.,
#
#     >>> which_commands Council_of_Nicea Constantinople zsh
#     /bin/zsh
# 
# This function is intended to automate selection of commands, in descending
# order of preference. (In the above example, the hypothetical
# "Council_of_Nicea" command would be selected before all following commands on
# systems having the command.)
which_commands() {
    die_unless_at_least_one_argument 'expected exactly one command name'
    
    # Iteratively look for each command in the passed list.
    string command_path
    for command_name ("${@}") {
        if command_path="$(pipe_stderr_to_stdout which_command "${command_name}")"; then
            print "${command_path}"
            return_success
        fi
    }
    
    # Otherwise, no such command exists. Die? Die! Die.
    string command_names=$(join_list_to_string_prefixing_last_with ', ' 'or ' "\"${^@}\"")
    die "neither ${command_names} found in \$PATH"
}

#FIXME: Obsolete.
    # Dismantled, this is:
    #
    # * "autoload_paths_list_name", the name of the list listing all
    #   directories to be searched for the passed autoload.
    # * "(P)", expanding to such list.
    # * "^", iteratively expanding to each such directory.
    # * "/${autoload_name}", concatenating the passed autoload to each such
    #   directory, producing a possible absolute path to such autoload.
    # * "(N)", removing non-extant paths.
    # * "(..)", listing all extant paths.
#   list autoload_paths
#   autoload_paths=( ${^${(P)autoload_paths_list_name}}/"${autoload_name}" )

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
