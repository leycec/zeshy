#!/usr/bin/env zsh
# ====================[ mount                              ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Mount, implementing filesystem mounting and unmounting functionality.

# ....................{ ALIASES                            }....................
interactive_alias mo='mount_safely'
interactive_alias umo='umount'

# ....................{ EXCEPTIONS                         }....................
# void die_unless_unmounted_disk(
#   char *pathname, char *error_message = 'currently mounted')
#
# Raise an exception unless the passed device file corresponds to an unmounted
# disk (i.e., neither the disk itself or any partition of such disk is mounted).
die_unless_unmounted_disk() {
    die_unless_one_or_two_args\
        'expected one pathname and optional error message'
    string pathname="${1}"
    is_disk_device "${pathname}" and not is_disk_mounted "${pathname}" or
        die "${2:-\"${pathname}\" not found or not a mounted disk}"
}

# ....................{ TESTS                              }....................
# bool is_disk_mounted(char *pathname)
# 
# Return true if the passed device file corresponds to a mounted disk (i.e.,
# either the disk itself or some partition of such disk is currently mounted).
is_disk_mounted() {
    die_unless_one_arg 'expected exactly one device filename'
    string device_filename="${1}"

    # Genius. Unless "blkid -o list" reports the passed disk under column "mount
    # point" as "(not mounted)", either the disk itself or some partition of
    # such disk is currently mounted. There appears to be other reasonable means
    # of testing such transitive dependencies, so this is quite essential.
    is '(not mounted)' !=\
      "$(blkid -o list | awk -v DEV="${device_filename}" '$1 == DEV { print $4, $5 }')" si
}

# bool is_device_mounted_to(char *device_filename, char *mount_dirname)
#
# Return true if the device with the passed filename is mounted to the directory
# with the passed dirname.
is_device_mounted_to() {
    die_unless_two_args\
        'expected exactly one device filename and mount dirname'
    string device_filename="${1}" mount_dirname="${2}"
    
    # If the passed pathname does not correspond to an existing directory, it
    # cannot correspond to a valid mount point.
    { is_disk_device "${device_filename}" and is_dir "${mount_dirname}" } or
        return_failure

    #FIXME: Also implement without "mountpoint", if feasible.
    die_unless_installed mountpoint
    is "$(mountpoint -x "${device_filename}" 2>&1)" ==\
       "$(mountpoint -d "${mount_dirname}"   2>&1)" si
}

# ....................{ TESTS ~ mount points               }....................
# bool is_mount_point(char *dirname)
#
# Return true if the directory with the passed dirname hosts a mount point.
is_mount_point() {
    die_unless_one_arg 'expected exactly one dirname'
    string mount_dirname="${1}"

    # If the passed pathname corresponds to no existing directory, fail.
    if not is_dir "${mount_dirname}"
    then return_failure
    # If the cross-platform portable "mountpoint" is installed, defer to such
    # command. This is more reliable than grepping file content.
    elif is_installed mountpoint; then
        mountpoint -q "${mount_dirname}" | return_exit_status
    # If the Linux-specific "/proc/mounts" exists, grep its content. This is
    # more reliable than matching "mount" output. (See "man mount".)
    elif is_file '/proc/mounts'; then
        awk -v DIR="${mount_dirname}"\
            'BEGIN {CODE=1} $2 == DIR {CODE=0} END {exit CODE}' '/proc/mounts' |
            return_exit_status
    # Otherwise, manually match "mount" output.
    else
        mount | awk -v DIR="${mount_dirname}"\
            'BEGIN {CODE=1} $3 == DIR {CODE=0} END {exit CODE}' |
            return_exit_status
    fi
}

# bool is_writable_mount_point(char *dirname)
#
# Return true if the directory with the passed dirname is hosting a writable
# mount point (i.e., was not mounted read-only).
is_writable_mount_point() {
    die_unless_one_arg 'expected exactly one dirname'
    string mount_dirname="${1}"
    
    # If the passed pathname corresponds to no existing directory writable by
    # the current user, fail.
    if not is_writable_dir "${mount_dirname}"
    then return_failure
    # Since "mountpoint" has no writability option, we manually match strings.
    # This is hardly ideal, but there you are. If the Linux-specific
    # "/proc/mounts" exists, grep its content.
    elif is_file '/proc/mounts'; then
#       utter 'testing...'
        awk -v DIR="${mount_dirname}" '
BEGIN { CODE = 1 }
$2 == DIR && $4 ~ /(^|,)rw($|,)/ { CODE = 0 }
END { exit CODE }' '/proc/mounts' | return_exit_status
#       utter 'failed...'
    # Otherwise, manually match "mount" output.
    else
        mount | awk -v DIR="${mount_dirname}" '
BEGIN { CODE = 1 }
$3 == DIR && $NF ~ /(,|\()rw(,|\))/ { CODE = 0 }
END { exit CODE }' | return_exit_status
    fi
}

# ....................{ GETTERS                            }....................
# char *get_mount_home(void)
#
# Get the absolute path of the canonical directory to which the current user has
# write permissions sufficient for mounting devices. Rather than returning a
# static path, this function iteratively tests the following directories for
# writability (in order):
# 
# * "/media".
# * "/mnt".
# * "${HOME}/media".
# * "${HOME}/mnt".
#
# If no such directory exists or is writable, raise an exception.
get_mount_home() {
    die_unless_no_args
    get_first_writable_dir '/media' '/mnt' "${HOME}/media" "${HOME}/mnt"
}

# ....................{ PRINTERS                           }....................
# char *print_mount_points(void)
#
# Print a detailed human-readable list of current mount points.
print_mount_points() {
    die_unless_no_args

    # Dismantled, this is:
    #
    # * "print '...'", prefixing output with a header line.
    # * "print '-'", prefixing output with a banner line. (This is a temporary
    #   placeholder to be entirely replaced with a true banner line, below).
    # * "LC_ALL=C ", guaranteeing output from "mount" in the default format.
    # * "mount | awk", formatting output from "mount" through an "awk" script
    #   cutting the extraneous second and fourth columns.
    # * "(...)", aggregating such output into a single output stream.
    # * "column -t", reformatting output into a whitespace-delimited table.
    # * "awk", substituting commas with spaces in the flags column. Since
    #   "column -t" tabulates with such spaces, we must defer such substitution
    #   until after tabulating. Dismantled, this is:
    #   * "-v banner="$(utter_banner)"", passing the desired banner line to awk
    #     as an option variable.
    #   * "-F'[ ]'", preserving whitespace by treating individual spaces rather
    #     than contiguous "runs" of spaces as column delimiters.
    #   * "NR == 1", matching the first and hence header line. 
    #   * "NR == 2", matching the second and hence banner line. 
    #   * "NR >= 3", matching all subsequent lines output from "mount". 
    #   * "$NF", the last and hence flags column. We can't simply write "$4", as
    #     treating individual spaces as delimiters creates "dummy" columns.
    #
    # This one-liner inspired by Peteris Krumin's magical bash one-liner at:
    # http://www.catonmat.net/blog/another-ten-one-liners-from-commandlinefu-explained
    (
        print 'device directory type flags'
        print '???'
        LC_ALL=C mount | awk '{$2=$4=""; print}'
    ) | column -t | awk -v BANNER="$(utter_banner)" -F'[ ]' '
NR == 1 { print }
NR == 2 { print BANNER }
NR >= 3 {
    gsub(/\(|\)/, "", $NF)
    gsub(/,/, " ", $NF)
    print
}'
}

# ....................{ MOUNTERS                           }....................
# void mount_boot_writably(void)
#
# Mount the "/boot" partition if such partition exists and is not already
# mounted writably and do nothing otherwise.
mount_boot_writably() {
    #FIXME: Replace with die_if_args() everywhere.
    die_unless_no_args

    # Return immediately if "/boot" is already a writable mount point.
    is_writable_mount_point '/boot' and return_success

    # If the filesystem table defines an uncommented "/boot" mapping...
    if awk '
BEGIN { CODE = 1}
!/^[[:blank:]]*#/ && $2 == "/boot" { CODE = 0 }
END { exit CODE }' '/etc/fstab'; then
        # ...and "/boot" is already mounted (and hence read-only, since the prior
        # test failed to return), remount "/boot" read-write; otherwise, simply
        # mount "/boot" read-write.
        if is_mount_point '/boot'
        then mount -o remount,rw '/boot'
        else mount -o         rw '/boot'
        fi
    # Otherwise, raise an exception unless "/boot/" is already writable.
    else
	    die_unless_writable_dir '/boot'
    fi
}

# void mount_safely(
#   char *device_filename, char *mount_dirname,
#   char *mount_option1, char *mount_option2, ...)
#
# Mount the device with the passed filename to the mount point with the passed
# dirname and options. This function safely (and sanely) interprets the passed
# arguments as follows:
#
# * If this is an interactive shell and no arguments were passed, print a human-
#   readable list of current mount points.
# * If the passed device does not exist, attempt to find a device with such
#   basename under these directories (in order):
#   * "/dev/disk/by-label'.
#   * "/dev'.
#   * ...otherwise, raise an exception.
# * If no mount point was passed, assume a mount point with the passed device
#   basename under the current user's mount home.
# * If the passed mount point does not exist, recursively make it.
# * If the passed mount point is already mounted to:
#   * ...the passed device, do nothing.
#   * ...otherwise, raise an exception.
# * If the passed device is:
#   * ...a device file, perform the expected mount.
#   * ...a file with filetype ".iso", mount this file as an ISO image.
#
# In other words, this function quasi-intelligently accepts darn near anything.
mount_safely() {
    #FIXME: Add a dash of commentary, here and below.
    if not is_args and is_interactive_directly; then
        print_mount_points
    else
        # Localize and validate passed arguments.
        die_unless_args\
            'expected one device filename and/or mount dirname and optional mount options'

        #FIXME: This and the following conditional are effectively distinct
        #functions, and could reasonably be separated as such..... Perhaps.
        #Ah. Yes. Then, our calling of "mount -o rw /boot" above should be
        #replaced by calls to, say, "mount_point -o rw /boot". Note we'd need
        #define such function to take the last argument as the mount_dirname,
        #but that's certainly no issue.
        if is_one_arg; then
            string mount_dirname="${1}"

            make_dir_safely         "${mount_dirname}" 
            die_unless_writable_dir "${mount_dirname}"
            interactively utter\
                "mounting to \"${mount_dirname}\" via \"/etc/fstab\"..."
            mount "${mount_dirname}"
        #FIXME: Yup. How 'bout naming this one mount_disk()? Sensible.
        else
            string device_filename="${1}" mount_dirname
            shift_one_arg

            if not is_found "${device_filename}"; then
                # If the passed
                is_absolute_path "${device_filename}" and
                    die "\"${device_filename}\" not found"

                #FIXME (new): O.K.; we need a new function testify(). (Clever, no?
                #Also consider falsify(), though that name doesn't accurately describe
                #its purpose.) Call it like this:
                #device_filename="$(testify get_first_device "/dev/disk/by-label/${device_filename}" "/dev/${device_filename}")" or die "device \"${device_filename}\" not found"
                #Simple. testify() calls the passed command via the typical run()
                #construct *BUT WRAPPED IN AN EXCEPTION HANDLER* implicitly squelching
                #any caught exception and simply converting it into a false return value.
                #That then causes the entire equality to evaluate to "false" and hence
                #implicitly throw an exception. Phew! Solved.
                #
                #FIXME: Hmm; this doesn't appear to behave as expected. If
                #get_first_device() raises an exception, I'd expect that to unwind
                #this function's stack frame as well. It doesn't. Instead, "device_filename"
                #just gets the output of get_first_device(), which in the case of a
                #raised exception is a stack trace. Of course, that isn't a file, so
                #the subsequent call to die_unless_disk_device() fails as well. This
                #strikes me as a bug, perhaps corrected by a subsequent Zsh update?
                device_filename="$(get_first_device "/dev/disk/by-label/${device_filename}" "/dev/mapper/${device_filename}" "/dev/vg/${device_filename}" "/dev/${device_filename}")"
            fi
            die_unless_disk_device "${device_filename}"

            if is_args; then
                mount_dirname="${1}"
                shift_one_arg
            else
                mount_dirname="$(get_mount_home)/$(get_basename "${device_filename}")"
            fi

            if is_mount_point "${mount_dirname}"; then
                # If the passed device is already mounted to the passed directory, noop.
                # By default, "mount" unhelpfully fails with error.
                is_device_mounted_to "${device_filename}" "${mount_dirname}" and
                    return

                #FIXME: Print what it's actually mounted to, for assistance.
                # Otherwise, raise an exception.
                die "\"${mount_dirname}\" already mounted"
            fi

            make_dir_safely         "${mount_dirname}" 
            die_unless_writable_dir "${mount_dirname}"
            interactively utter\
                "mounting \"${device_filename}\" to \"${mount_dirname}\"..."

            if is_device "${device_filename}"; then
                mount "${@}" "${device_filename}" "${mount_dirname}"
            elif is "${device_filename}" == *.iso si; then
                mount "${@}" -t iso9660 -o 'exec,loop'\
                    "${device_filename}" "${mount_dirname}"
            else
                die "\"${device_filename}\" neither a device or ISO file"
            fi
        fi
    fi
}

#FIXME: Obsolete.
#   else is_nonempty "$(mount | awk '$3 == "/boot" {print $3}')"

#NR == 1 {
#    sub(/-/, " ")
#    print
#}

#   if is_nonempty\
#       "$(awk '!/^[[:blank:]]*#/ && $2 == "/boot" {print $2}' /etc/fstab)"; then
#   if is '/boot' == "$(awk '!/^[[:blank:]]*#/ {print $2}' /etc/fstab)" si; then

#is_disk_device "${device_filename}" and 

# void mount_iso(char *filename)
#
# Mount the ISO image with the passed filename to a temporary directory under
# the current user's mount home.
#mount_iso() {
    # Localize and validate passed arguments.
#   die_unless_one_arg 'expected exactly one ISO filename'
#   string iso_filename="${1}"
#   is "${iso_filename}" == *.iso si or
#       die "\"${iso_filename}\" not an ISO"
#   die_unless_file "${iso_filename}"
#   string ZESHY_SCRIPT_NAME='mount_iso'

    # Find a suitable mount path.
#   integer iso_mount_path_suffix=0
#   string  iso_mount_path_prefix="${ZESHY_MOUNT_ISO_PATH}"\
#           iso_mount_path="${iso_mount_path_prefix}"
#   utter 'searching for available mount point...'
#   while (is_mount_point "${iso_mount_path}") {
#       (( iso_mount_path_suffix++ ))
#       iso_mount_path="${iso_mount_path_prefix}${iso_mount_path_suffix}"
#   }
    
    # Mount the passed ISO filename to the desired mount path.
    #
    # Note that this does not pass the ",user" option when mounting, as doing so
    # would implicitly enables unhelpful mount options (e.g., "noexec").
#   utter "mounting \"${iso_filename}\" to \"${iso_mount_path}\"..."
#   make_dir_safely "${iso_mount_path}" 
#   mount -t iso9660 -o 'exec,loop'\
#       "${iso_filename}" "${iso_mount_path}" or
#       die "\"${iso_filename}\" not mountable to \"${iso_mount_path}\""
#}
#       if is_one_arg and is "${1}" == *.iso si; then
#           mount_iso "${1}"

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#FIXME: This is *TERRIBLE*. Just use "mount -l" to list current mount points.
#Grepping this Linux-specific file is horrible.
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# * If only one argument was passed and:
#   * ...this is an existing file with filetype "ISO", mount this file as an ISO
#     image to the current user's mount home.
#   * ...otherwise, raise an exception.

# char *get_mount_points_filename(void)
#
# Get the name of the system file listing current mount points.
#get_mount_points_filename() {
#    die_unless_no_args
#    print '/proc/mounts'
#}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
