#!/usr/bin/env zsh
# ====================[ mount                              ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Mount, implementing filesystem mounting and unmounting functionality.

# ....................{ ALIASES                            }....................
interactive_alias mo='mount_safely'
interactive_alias umo='umount'

# ....................{ TESTS                              }....................
# bool is_mount_point(char *dirname)
#
# Return true if the directory with the passed dirname is hosting a mount point.
is_mount_point() {
    die_unless_one_argument 'expected exactly one dirname'
    string mount_dirname="${1}"
    
    # If the passed pathname does not correspond to an existing directory, it
    # cannot correspond to a valid mount point.
    is_dir "${mount_dirname}" or return_failure

    #FIXME: Also implement without "mountpoint", if feasible. Note such an
    #implementation requires we convert relative to absolute dirnames.
    die_unless_installed mountpoint
    mountpoint -q "${mount_dirname}"
}

# bool is_device_mounted_to(char *device_filename, char *mount_dirname)
#
# Return true if the device with the passed filename is mounted to the directory
# with the passed dirname.
is_device_mounted_to() {
    die_unless_two_arguments\
        'expected exactly one device filename and mount dirname'
    string device_filename="${1}" mount_dirname="${2}"
    
    # If the passed pathname does not correspond to an existing directory, it
    # cannot correspond to a valid mount point.
    { is_disk_device "${device_filename}" and is_dir "${mount_dirname}" } or
        return_failure

    #FIXME: Also implement without "mountpoint", if feasible.
    die_unless_installed mountpoint
    is "$(mountpoint -x "${device_filename}" 2>&1)" ==\
       "$(mountpoint -d "${mount_dirname}"   2>&1)" si
}

# ....................{ GETTERS                            }....................
# char *get_mount_home(void)
#
# Get the absolute path of the canonical directory to which the current user has
# write permissions sufficient for mounting devices. Rather than returning a
# static path, this function iteratively tests the following directories for
# writability (in order):
# 
# * "/media".
# * "/mnt".
# * "${HOME}/media".
# * "${HOME}/mnt".
#
# If no such directory exists or is writable, raise an exception.
get_mount_home() {
    die_unless_no_arguments
    get_first_writable_dir '/media' '/mnt' "${HOME}/media" "${HOME}/mnt"
}

# ....................{ PRINTERS                           }....................
# char *print_mount_points(void)
#
# Print a detailed human-readable list of current mount points.
print_mount_points() {
    die_unless_no_arguments

    # Dismantled, this is:
    #
    # * "print '...'", prefixing output with a header line.
    # * "print '-'", prefixing output with a banner line. (This is a temporary
    #   placeholder to be entirely replaced with a true banner line, below).
    # * "LC_ALL=C ", guaranteeing output from "mount" in the default format.
    # * "mount | awk", formatting output from "mount" through an "awk" script
    #   cutting the extraneous second and fourth columns.
    # * "(...)", aggregating such output into a single output stream.
    # * "column -t", reformatting output into a whitespace-delimited table.
    # * "awk", substituting commas with spaces in the flags column. Since
    #   "column -t" tabulates with such spaces, we must defer such substitution
    #   until after tabulating. Dismantled, this is:
    #   * "-v banner="$(utter_banner)"", passing the desired banner line to awk
    #     as an option variable.
    #   * "-F'[ ]'", preserving whitespace by treating individual spaces rather
    #     than contiguous "runs" of spaces as column delimiters.
    #   * "NR == 1", matching the first and hence header line. 
    #   * "NR == 2", matching the second and hence banner line. 
    #   * "NR >= 3", matching all subsequent lines output from "mount". 
    #   * "$NF", the last and hence flags column. We can't simply write "$4", as
    #     treating individual spaces as delimiters creates "dummy" columns.
    #
    # This one-liner inspired by Peteris Krumin's magical bash one-liner at:
    # http://www.catonmat.net/blog/another-ten-one-liners-from-commandlinefu-explained
    (
        print 'device mount-point type flags'
        print '-'
        LC_ALL=C mount | awk '{$2=$4=""; print}'
    ) | column -t | awk -v banner="$(utter_banner)" -F'[ ]' '
NR == 1 {
    sub(/-/, " ")
    print
}
NR == 2 {
    print banner
}
NR >= 3 {
    gsub(/\(|\)/, "", $NF)
    gsub(/,/, " ", $NF)
    print
}
'
}

# ....................{ WRITERS                            }....................
# void mount_safely(
#   char *device_filename, char *mount_dirname,
#   char *mount_option1, char *mount_option2, ...)
#
# Mount the device with the passed filename to the mount point with the passed
# dirname and options. This function safely (and sanely) interprets the passed
# arguments as follows:
#
# * If this is an interactive shell and no arguments were passed, print a human-
#   readable list of current mount points.
# * If the passed device does not exist, attempt to find a device with such
#   basename under these directories (in order):
#   * "/dev/disk/by-label'.
#   * "/dev'.
#   * ...otherwise, raise an exception.
# * If no mount point was passed, assume a mount point with the passed device
#   basename under the current user's mount home.
# * If the passed mount point does not exist, recursively make it.
# * If the passed mount point is already mounted to:
#   * ...the passed device, do nothing.
#   * ...otherwise, raise an exception.
# * If the passed device is:
#   * ...a device file, perform the expected mount.
#   * ...a file with filetype ".iso", mount this file as an ISO image.
#
# In other words, this function quasi-intelligently accepts darn near anything.
mount_safely() {
    if is_interactive and not is_arguments; then
        print_mount_points
    else
        # Localize and validate passed arguments.
        die_unless_arguments\
            'expected one device filename, optional mount dirname, and optional mount options'
        string device_filename="${1}" mount_dirname
        shift_one_argument

        if not is_found "${device_filename}"; then
            is_absolute_path "${device_filename}" and
                die "\"${device_filename}\" not found"
            #FIXME: Hmm; this doesn't appear to behave as expected. If
            #get_first_device() raises an exception, I'd expect that to unwind
            #this function's stack frame as well. It doesn't. Instead, "device_filename"
            #just gets the output of get_first_device(), which in the case of a
            #raised exception is a stack trace. Of course, that isn't a file, so
            #the subsequent call to die_unless_disk_device() fails as well. This
            #strikes me as a bug, perhaps corrected by a subsequent Zsh update?
            device_filename="$(get_first_device "/dev/disk/by-label/${device_filename}" "/dev/${device_filename}")"
        fi
        die_unless_disk_device "${device_filename}"

        if is_arguments; then
            mount_dirname="${1}"
            shift_one_argument
        else
            mount_dirname="$(get_mount_home)/$(get_basename "${device_filename}")"
        fi

        if is_mount_point "${mount_dirname}"; then
            # If the passed device is already mounted to the passed directory, noop.
            # By default, "mount" unhelpfully fails with error.
            is_device_mounted_to "${device_filename}" "${mount_dirname}" and
                return

            #FIXME: Print what it's actually mounted to, for assistance.
            # Otherwise, raise an exception.
            die "\"${mount_dirname}\" already mounted"
        fi

        make_dir_if_not_found "${mount_dirname}" 
        die_unless_dir        "${mount_dirname}"
        interactively utter\
            "mounting \"${device_filename}\" to \"${mount_dirname}\"..."

        if is_device "${device_filename}"; then
            mount "${@}" "${device_filename}" "${mount_dirname}"
        elif is "${device_filename}" == *.iso si; then
            mount "${@}" -t iso9660 -o 'exec,loop'\
                "${device_filename}" "${mount_dirname}"
        else
            die "\"${device_filename}\" neither a device or ISO file"
        fi
    fi
}

#FIXME: Obsolete.
# void mount_iso(char *filename)
#
# Mount the ISO image with the passed filename to a temporary directory under
# the current user's mount home.
#mount_iso() {
    # Localize and validate passed arguments.
#   die_unless_one_argument 'expected exactly one ISO filename'
#   string iso_filename="${1}"
#   is "${iso_filename}" == *.iso si or
#       die "\"${iso_filename}\" not an ISO"
#   die_unless_file "${iso_filename}"
#   string ZESHY_SCRIPT_NAME='mount_iso'

    # Find a suitable mount path.
#   integer iso_mount_path_suffix=0
#   string  iso_mount_path_prefix="${ZESHY_MOUNT_ISO_PATH}"\
#           iso_mount_path="${iso_mount_path_prefix}"
#   utter 'searching for available mount point...'
#   while (is_mount_point "${iso_mount_path}") {
#       (( iso_mount_path_suffix++ ))
#       iso_mount_path="${iso_mount_path_prefix}${iso_mount_path_suffix}"
#   }
    
    # Mount the passed ISO filename to the desired mount path.
    #
    # Note that this does not pass the ",user" option when mounting, as doing so
    # would implicitly enables unhelpful mount options (e.g., "noexec").
#   utter "mounting \"${iso_filename}\" to \"${iso_mount_path}\"..."
#   make_dir_if_not_found "${iso_mount_path}" 
#   mount -t iso9660 -o 'exec,loop'\
#       "${iso_filename}" "${iso_mount_path}" or
#       die "\"${iso_filename}\" not mountable to \"${iso_mount_path}\""
#}
#       if is_one_argument and is "${1}" == *.iso si; then
#           mount_iso "${1}"

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#FIXME: This is *TERRIBLE*. Just use "mount -l" to list current mount points.
#Grepping this Linux-specific file is horrible.
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# * If only one argument was passed and:
#   * ...this is an existing file with filetype "ISO", mount this file as an ISO
#     image to the current user's mount home.
#   * ...otherwise, raise an exception.

# char *get_mount_points_filename(void)
#
# Get the name of the system file listing current mount points.
#get_mount_points_filename() {
#    die_unless_no_arguments
#    print '/proc/mounts'
#}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
