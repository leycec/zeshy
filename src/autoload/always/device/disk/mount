#!/usr/bin/env zsh
# ====================[ mount                              ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Mount, implementing filesystem mounting and unmounting functionality.

# ....................{ ALIASES                            }....................
#FIXME: Alias "mount" to "mount_safely", or perhaps simply rename the latter the
#former and improve such function so as to defer to "command mount" when non-
#interactive (much like grep()).
interactive_alias mo='mount_safely'
interactive_alias umo='umount'

# ....................{ EXCEPTIONS                         }....................
# void die_if_mount_point(
#   char *pathname, char *error_message = 'currently mounted')
#
# Raise an exception if the passed path is a mount point.
die_if_mount_point() {
    die_unless_one_or_two_args\
        'expected one pathname and optional error message'
    string pathname="${1}"
    #FIXME: Print what it's actually mounted to, for clarity.
    is_mount_point "${pathname}" and
        die "${2:-\"${pathname}\" mounted}"
}

# void die_if_mountable_point(
#   char *pathname, char *error_message = 'not listed by "/etc/fstab"')
#
# Raise an exception unless the passed path is listed by "/etc/fstab" and hence
# mountable without explicitly specifying a source device file.
die_unless_mountable_point() {
    die_unless_one_or_two_args\
        'expected one pathname and optional error message'
    string pathname="${1}"
    is_mountable_point "${pathname}" or
        die "${2:-\"${pathname}\" not listed by \"/etc/fstab\"}"
}

# void die_unless_unmounted_disk(
#   char *pathname, char *error_message = 'currently mounted')
#
# Raise an exception unless the passed device file corresponds to an unmounted
# disk (i.e., neither the disk itself or any partition of such disk is mounted).
die_unless_unmounted_disk() {
    die_unless_one_or_two_args\
        'expected one pathname and optional error message'
    string pathname="${1}"
    is_disk_device "${pathname}" and not is_disk_mounted "${pathname}" or
        die "${2:-\"${pathname}\" not found or not an unmounted disk}"
}

# ....................{ TESTS                              }....................
# bool is_disk_mounted(char *pathname)
# 
# Return true if the passed device file corresponds to a mounted disk (i.e.,
# either the disk itself or some partition of such disk is currently mounted).
is_disk_mounted() {
    die_unless_one_arg 'expected exactly one device filename'
    string device_filename="${1}"

    # Genius. Unless "blkid -o list" reports the passed disk under column "mount
    # point" as "(not mounted)", either the disk itself or some partition of
    # such disk is currently mounted. There appears to be other reasonable means
    # of testing such transitive dependencies, so this is quite essential.
    is '(not mounted)' !=\
      "$(blkid -o list | awk -v DEV="${device_filename}" '$1 == DEV { print $4, $5 }')" si
}

# bool is_device_mounted_to(char *device_filename, char *mount_dirname)
#
# Return true if the device with the passed filename is mounted to the directory
# with the passed dirname.
is_device_mounted_to() {
    die_unless_two_args\
        'expected exactly one device filename and mount dirname'
    string device_filename="${1}" mount_dirname="${2}"
    
    # If the passed pathname does not correspond to an existing directory, it
    # cannot correspond to a valid mount point.
    is_disk_device "${device_filename}" and is_dir "${mount_dirname}" or
        return_failure

    #FIXME: Also implement without "mountpoint", if feasible.
    die_unless_installed mountpoint
    is "$(mountpoint -x "${device_filename}" 2>&1)" ==\
       "$(mountpoint -d "${mount_dirname}"   2>&1)" si
}

# ....................{ TESTS ~ mount points               }....................
# bool is_mountable_point(char *dirname)
#
# Return true if the passed directory is listed by "/etc/fstab" and hence
# mountable without explicitly specifying a source device file.
is_mountable_point() { 
    die_unless_one_arg 'expected exactly one dirname'
    awk -v DIR="${1}" '
BEGIN { CODE = 1}
!/^[[:blank:]]*#/ && $2 == DIR { CODE = 0 }
END { exit CODE }' '/etc/fstab'
}

#FIXME: Use of "| return_exit_status" below, while amusing, *SHOULD* be
#completely unnecessary. (I suspect we needed such expressions previously due
#to internal bugs in Zeshy's TRAPZERR() implementation, hopefully now fixed.
#Excise "| return_exit_status" below and test again.)
# bool is_mount_point(char *dirname)
#
# Return true if the passed directory currently mounts some disk.
is_mount_point() {
    die_unless_one_arg 'expected exactly one dirname'
    string mount_dirname="${1}"

    # If the passed path is not a directory readable by the current user, fail.
    if not is_dir "${mount_dirname}"
    then return_failure
    # If the cross-platform portable "mountpoint" is installed, defer to such
    # command. This is more reliable than grepping file content.
    elif is_installed mountpoint; then
        mountpoint -q "${mount_dirname}" | return_exit_status
    # If the Linux-specific "/proc/mounts" exists, grep its content. This is
    # more reliable than matching "mount" output. (See "man mount".)
    elif is_file '/proc/mounts'; then
        awk -v DIR="${mount_dirname}"\
            'BEGIN {CODE=1} $2 == DIR {CODE=0} END {exit CODE}' '/proc/mounts' |
            return_exit_status
    # Otherwise, manually match "mount" output.
    else
        command mount | awk -v DIR="${mount_dirname}"\
            'BEGIN {CODE=1} $3 == DIR {CODE=0} END {exit CODE}' |
            return_exit_status
    fi
}

# bool is_writable_mount_point(char *dirname)
#
# Return true if the passed directory currently mounts some disk writably.
is_writable_mount_point() {
    die_unless_one_arg 'expected exactly one dirname'
    string mount_dirname="${1}"
    
    # If the passed path is not a directory writable by the current user, fail.
    if not is_writable_dir "${mount_dirname}"
    then return_failure
    # Since "mountpoint" has no writability option, we manually match strings.
    # This is hardly ideal, but there you are. If the Linux-specific
    # "/proc/mounts" exists, grep its content.
    elif is_file '/proc/mounts'; then
#       utter 'testing...'
        awk -v DIR="${mount_dirname}" '
BEGIN { CODE = 1 }
$2 == DIR && $4 ~ /(^|,)rw($|,)/ { CODE = 0 }
END { exit CODE }' '/proc/mounts' | return_exit_status
#       utter 'failed...'
    # Otherwise, manually match "mount" output.
    else
        command mount | awk -v DIR="${mount_dirname}" '
BEGIN { CODE = 1 }
$3 == DIR && $NF ~ /(,|\()rw(,|\))/ { CODE = 0 }
END { exit CODE }' | return_exit_status
    fi
}

# ....................{ GETTERS                            }....................
# char *get_mount_home(void)
#
# Get the absolute path of the canonical directory to which the current user has
# write permissions sufficient for mounting devices. Rather than returning a
# static path, this function iteratively tests the following directories for
# writability (in order):
# 
# * "/media".
# * "/mnt".
# * "${HOME}/media".
# * "${HOME}/mnt".
#
# If no such directory exists or is writable, raise an exception.
get_mount_home() {
    die_unless_no_args
    get_first_writable_dir '/media' '/mnt' "${HOME}/media" "${HOME}/mnt"
}

# ....................{ PRINTERS                           }....................
# char *print_mount_points(void)
#
# Print a detailed human-readable list of current mount points.
print_mount_points() {
    die_unless_no_args

    # Dismantled, this is:
    #
    # * "print '...'", prefixing output with a header line.
    # * "print '-'", prefixing output with a banner line. (This is a temporary
    #   placeholder to be entirely replaced with a true banner line, below).
    # * "LC_ALL=C ", guaranteeing output from "mount" in the default format.
    # * "mount | awk", formatting output from "mount" through an "awk" script
    #   cutting the extraneous second and fourth columns.
    # * "(...)", aggregating such output into a single output stream.
    # * "column -t", reformatting output into a whitespace-delimited table.
    # * "awk", substituting commas with spaces in the flags column. Since
    #   "column -t" tabulates with such spaces, we must defer such substitution
    #   until after tabulating. Dismantled, this is:
    #   * "-v banner="$(utter_banner)"", passing the desired banner line to awk
    #     as an option variable.
    #   * "-F'[ ]'", preserving whitespace by treating individual spaces rather
    #     than contiguous "runs" of spaces as column delimiters.
    #   * "NR == 1", matching the first and hence header line. 
    #   * "NR == 2", matching the second and hence banner line. 
    #   * "NR >= 3", matching all subsequent lines output from "mount". 
    #   * "$NF", the last and hence flags column. We can't simply write "$4", as
    #     treating individual spaces as delimiters creates "dummy" columns.
    #
    # This one-liner inspired by Peteris Krumin's magical bash one-liner at:
    # http://www.catonmat.net/blog/another-ten-one-liners-from-commandlinefu-explained
    (
        print 'device directory type flags'
        print '???'
        LC_ALL=C command mount | awk '{$2=$4=""; print}'
    ) | tabulate | awk -v BANNER="$(utter_banner)" -F'[ ]' '
NR == 1 { print }
NR == 2 { print BANNER }
NR >= 3 {
    gsub(/\(|\)/, "", $NF)
    gsub(/,/, " ", $NF)
    print
}'
}

# ....................{ MOUNTERS                           }....................
# void mount_safely(void) --OR--
# void mount_safely(char *mount_dirname) --OR--
# void mount_safely(
#   char *mount_option1, char *mount_option2, ..., char *device_filename) --OR--
# void mount_safely(
#   char *mount_option1, char *mount_option2, ...,
#   char *device_filename, char *mount_dirname)
#
# Mount the device with the passed filename to the mount point with the passed
# dirname and options. This function safely (and sanely) interprets the passed
# arguments as follows:
#
# * If this is an interactive shell and no arguments were passed, print a human-
#   readable list of current mount points.
# * If the passed device does not exist, attempt to find a device with such
#   basename under these directories (in order):
#   * "/dev/disk/by-label'.
#   * "/dev'.
#   * ...otherwise, raise an exception.
# * If no mount point was passed, assume a mount point with the passed device
#   basename under the current user's mount home.
# * If the passed mount point does not exist, recursively make it.
# * If the passed mount point is already mounted to:
#   * ...the passed device, do nothing.
#   * ...otherwise, raise an exception.
# * If the passed device is:
#   * ...a device file, perform the expected mount.
#   * ...a file with filetype ".iso", mount this file as an ISO image.
#
# In other words, this function quasi-intelligently accepts darn near anything.
mount_safely() {
    #FIXME: Add a dash of commentary, here and below.
    if is_no_args
    then print_mount_points
    elif is_one_arg
    then mount_point "${1}"
    else mount_disk  "${@}"
    fi
}

# ....................{ MOUNTERS ~ points                  }....................
# void mount_writable_boot_dir(void)
#
# Mount the "/boot" partition if such partition exists and is not already
# mounted writably; otherwise, no-op. 
mount_writable_boot_dir() {
    die_if_args

    # If "/etc/fstab" maps some device to "/boot", mount such device.
    if is_mountable_point '/boot'
    then mount_writable_point '/boot'
    # Otherwise, raise an exception unless "/boot" is already writable.
    elif not is_writable_dir "${mount_dirname}"
    then die\
        "\"${mount_dirname}\" neither writable or listed by \"/etc/fstab\""
    fi
}

# void mount_point(
#   char *mount_option1, char *mount_option2, ..., char *mount_dirname)
#
# Mount the device that "/etc/fstab" maps to the passed dirname to that
# directory with the passed options.
mount_point() {
    # Localize and validate passed arguments.
    die_unless_args 'expected optional mount options and one mount dirname'
    string mount_dirname="${@[-1]}"

    #FIXME: O.K.; for orthogonality with mount_disk(), we should really avoid
    #remounting to an already mounted directory only if such mount point
    #corresponds to the current mapping defined by /etc/fstab. (Annoying, but
    #certainly feasible.)
    # If this directory is already a mount point, return immediately.
    is_mount_point "${mount_dirname}" and return_success

    # If this directory is not listed by "/etc/fstab", raise an exception.
    die_unless_mountable_point "${mount_dirname}"

    # Mount.
    make_dir_safely         "${mount_dirname}" 
    die_unless_writable_dir "${mount_dirname}"
    interactively utter\
        "mounting \"${mount_dirname}\" via \"/etc/fstab\"..."
    command mount "${@}"
}

# void mount_writable_point(
#    char *mount_option1, char *mount_option2, ..., char *mount_dirname)
#
# Mount the device that "/etc/fstab" maps to the passed dirname to that
# directory writably with the passed options.
mount_writable_point() {
    # Localize passed arguments.
    die_unless_args 'expected optional mount options and one mount dirname'
    string mount_dirname="${@[-1]}"

    # If this directory is already a writable point, return immediately.
    is_writable_mount_point "${mount_dirname}" and return_success

    # If this directory is already mounted (and hence read-only, since the prior
    # test fell through), remount "/boot" read-write; otherwise, mount "/boot"
    # read-write.
    if is_mount_point "${mount_dirname}"
    then mount_point -o remount,rw "${@}"
    else mount_point -o         rw "${@}"
    fi
}

# ....................{ MOUNTERS ~ disks                   }....................
# void mount_disk(
#   char *mount_option1, char *mount_option2, ..., char *device_filename) --OR--
# void mount_disk(
#   char *mount_option1, char *mount_option2, ...,
#   char *device_filename, char *mount_dirname)
mount_disk() {
    # Localize passed arguments.
    die_unless_args\
        'expected optional mount options, one device filename, and optional mount dirname'
    string device_filename mount_dirname

    if is_writable_dir "${@[-1]}"; then
        die_unless_at_least_two_args\
            'expected optional mount options, one device filename, and one mount dirname'
        device_filename="${@[-2]}"
        mount_dirname="${@[-1]}"
        pop_two_args
    else
        device_filename="${@[-1]}"
        mount_dirname="$(get_mount_home)/$(get_basename "${device_filename}")"
        pop_one_arg
    fi

    if not is_found "${device_filename}"; then
        is_absolute_path "${device_filename}" and
            die "\"${device_filename}\" not found"

        #FIXME (new): O.K.; we need a new function testify(). (Clever, no?
        #Also consider falsify(), though that name doesn't accurately describe
        #its purpose.) Call it like this:
        #device_filename="$(testify get_first_device "/dev/disk/by-label/${device_filename}" "/dev/${device_filename}")" or die "device \"${device_filename}\" not found"
        #Simple. testify() calls the passed command via the typical run()
        #construct *BUT WRAPPED IN AN EXCEPTION HANDLER* implicitly squelching
        #any caught exception and simply converting it into a false return value.
        #That then causes the entire equality to evaluate to "false" and hence
        #implicitly throw an exception. Phew! Solved.
        #
        #FIXME: Hmm; this doesn't appear to behave as expected. If
        #get_first_device() raises an exception, I'd expect that to unwind
        #this function's stack frame as well. It doesn't. Instead, "device_filename"
        #just gets the output of get_first_device(), which in the case of a
        #raised exception is a stack trace. Of course, that isn't a file, so
        #the subsequent call to die_unless_disk_device() fails as well. This
        #strikes me as a bug, perhaps corrected by a subsequent Zsh update?
        device_filename="$(get_first_device "/dev/disk/by-label/${device_filename}" "/dev/mapper/${device_filename}" "/dev/vg/${device_filename}" "/dev/${device_filename}")"
    fi

    # If the passed device is already mounted to the passed directory, noop.
    # By default, "mount" unhelpfully fails with error.
    if is_device_mounted_to "${device_filename}" "${mount_dirname}"; then
        interactively utter "\"${device_filename}\" already mounted to \"${mount_dirname}\"."
        return_success
    fi

    # Make the mount point if non-extant.
    die_if_mount_point "${mount_dirname}"
    make_dir_safely         "${mount_dirname}" 
    die_unless_writable_dir "${mount_dirname}"
    interactively utter\
        "mounting \"${device_filename}\" to \"${mount_dirname}\"..."

    # Mount.
    if is_device "${device_filename}"; then
        die_unless_unmounted_disk "${device_filename}"
        command mount "${@}" "${device_filename}" "${mount_dirname}"
    #FIXME: This globs case-insensitively, no?
    elif is "${device_filename}" == *.iso si; then
        command mount "${@}" -t iso9660 -o 'exec,loop'\
            "${device_filename}" "${mount_dirname}"
    else die "\"${device_filename}\" neither a device or ISO file"
    fi
}

#FIXME: Obsolete.
#       mountpoint -q "${mount_dirname}" | true; return_exit_status
#       print 'here'
#       mountpoint -q "${mount_dirname}"
#       print "returned: $?"
#       mountpoint -q "${mount_dirname}" and return_success or return_failure
#       mountpoint -q "${mount_dirname}" | true and return ${pipestatus[-2]}
#       mountpoint -q "${mount_dirname}" | return 1
#       mountpoint -q "${mount_dirname}" | return_exit_status
#       print 'there'
#   else is_nonempty "$(mount | awk '$3 == "/boot" {print $3}')"

#NR == 1 {
#    sub(/-/, " ")
#    print
#}

#   if is_nonempty\
#       "$(awk '!/^[[:blank:]]*#/ && $2 == "/boot" {print $2}' /etc/fstab)"; then
#   if is '/boot' == "$(awk '!/^[[:blank:]]*#/ {print $2}' /etc/fstab)" si; then

#is_disk_device "${device_filename}" and 

# void mount_iso(char *filename)
#
# Mount the ISO image with the passed filename to a temporary directory under
# the current user's mount home.
#mount_iso() {
    # Localize and validate passed arguments.
#   die_unless_one_arg 'expected exactly one ISO filename'
#   string iso_filename="${1}"
#   is "${iso_filename}" == *.iso si or
#       die "\"${iso_filename}\" not an ISO"
#   die_unless_file "${iso_filename}"
#   string ZESHY_SCRIPT_NAME='mount_iso'

    # Find a suitable mount path.
#   integer iso_mount_path_suffix=0
#   string  iso_mount_path_prefix="${ZESHY_MOUNT_ISO_PATH}"\
#           iso_mount_path="${iso_mount_path_prefix}"
#   utter 'searching for available mount point...'
#   while (is_mount_point "${iso_mount_path}") {
#       (( iso_mount_path_suffix++ ))
#       iso_mount_path="${iso_mount_path_prefix}${iso_mount_path_suffix}"
#   }
    
    # Mount the passed ISO filename to the desired mount path.
    #
    # Note that this does not pass the ",user" option when mounting, as doing so
    # would implicitly enables unhelpful mount options (e.g., "noexec").
#   utter "mounting \"${iso_filename}\" to \"${iso_mount_path}\"..."
#   make_dir_safely "${iso_mount_path}" 
#   mount -t iso9660 -o 'exec,loop'\
#       "${iso_filename}" "${iso_mount_path}" or
#       die "\"${iso_filename}\" not mountable to \"${iso_mount_path}\""
#}
#       if is_one_arg and is "${1}" == *.iso si; then
#           mount_iso "${1}"

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#FIXME: This is *TERRIBLE*. Just use "mount -l" to list current mount points.
#Grepping this Linux-specific file is horrible.
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# * If only one argument was passed and:
#   * ...this is an existing file with filetype "ISO", mount this file as an ISO
#     image to the current user's mount home.
#   * ...otherwise, raise an exception.

# char *get_mount_points_filename(void)
#
# Get the name of the system file listing current mount points.
#get_mount_points_filename() {
#    die_unless_no_args
#    print '/proc/mounts'
#}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
