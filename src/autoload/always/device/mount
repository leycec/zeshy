#!/usr/bin/env zsh
# ====================[ mount                              ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Mount, implementing filesystem mounting and unmounting functionality.

# ....................{ ALIASES                            }....................
#interactive_alias mo="mount | column -t"
#FIXME: O.K.; implement a new zmount() function that, when called with no arguments,
#runs "mount | column -t" (...looks awesome; trust me), or, when called with arguments,
#defers to simply "mount "${@}"". Yum.
interactive_alias mo="mount"
interactive_alias umo="umount"

# ....................{ TESTS                              }....................
# bool is_mount_point(char *dirname)
#
# Return true if the directory with the passed dirname is hosting a mount point.
is_mount_point() {
    die_unless_one_argument 'expected exactly one dirname'
    string mount_dirname="${1}"
    
    # If the passed pathname does not correspond to an existing directory, it
    # cannot correspond to a valid mount point.
    is_dir "${mount_dirname}" or return_failure

    # If the "mountpoint" binary is available, use that.
    if is_installed mountpoint
    then mountpoint -q "${mount_dirname}"
    #FIXME: This test requires we convert relative to absolute dirnames, here.
    # Otherwise, manually search the file listing current mount points.
    else is_file_contains "$(get_mount_dirnames_filename)" "${mount_dirname}"
    fi
}

# bool is_device_file_mounted_to(char *device_filename, char *mount_dirname)
#
# Return true if the device with the passed filename is mounted to the directory
# with the passed dirname.
is_device_file_mounted_to() {
    die_unless_two_arguments\
        'expected exactly one device filename and mount dirname'
    string device_filename="${1}" mount_dirname="${2}"
    
    # If the passed pathname does not correspond to an existing directory, it
    # cannot correspond to a valid mount point.
    { is_device_file_file "${device_filename}" and is_dir "${mount_dirname}" } or
        return_failure

    #FIXME: Also implement without "mountpoint", if feasible.
    die_unless_installed mountpoint
    is "$(mountpoint -d "${devile_filename}" 2>&1)" ==\
       "$(mountpoint -x "${mount_dirname}"   2>&1)" si
}

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#FIXME: This is *TERRIBLE*. Just use "mount -l" to list current mount points.
#Grepping this Linux-specific file is horrible.
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# ....................{ GETTERS                            }....................
# char *get_mount_home(void)
#
# Get the absolute path of the canonical directory to which the current user has
# write permissions sufficient for mounting devices. Rather than returning a
# static path, this function iteratively tests the following directories for
# writability (in order):
# 
# * "/media".
# * "/mnt".
# * "${HOME}/media".
# * "${HOME}/mnt".
#
# If no such directory exists or is writable, raise an exception.
get_mount_home() {
    die_unless_no_arguments
    print '/proc/mounts'
}

# char *get_mount_points_filename(void)
#
# Get the name of the system file listing current mount points.
#get_mount_points_filename() {
#    die_unless_no_arguments
#    print '/proc/mounts'
#}

#FIXME: Make mount_safely() subsume mount_iso(). Should be pretty simple; I'd
#much rather have one intelligent command than two sub-intelligent commands.
# ....................{ WRITERS                            }....................
# void mount_safely(
#   char *device_filename, char *mount_dirname,
#   char *mount_option1, char *mount_option2, ...)
#
# Mount the device with the passed filename to the mount point with the passed
# dirname and options. If this mount point already mounts this device, do *NOT*
# remount this device. If this mount point does not exist, make it.
mount_safely() {
    # Localize and validate passed arguments.
    die_unless_at_least_two_arguments\
        'expected one device filename, one mount dirname, and optional mount options'
    string device_filename="${1}" mount_dirname="${2}"
    die_unless_devile_file "${device_filename}"
    shift_two_arguments

    # If the passed device is already mounted to the passed directory, noop.
    is_device_file_mounted_to "${device_filename}" "${mount_dirname}" and
        return

    # If the passed device is already mounted *NOT* to the passed directory,
    # raise an exception.
    is_mount_point "${mount_dirname}" and
        die "\"${mount_dirname}\" already mounted"

    # Mount.
    make_dir_if_not_found "${mount_dirname}" 
    mount "${@}" "${device_filename}" "${mount_dirname}"
}

# void mount_iso(char *filename)
#
# Mount the ISO with the passed filename to directory ${ZESHY_MOUNT_ISO_PATH}.
# If this directory already hosts a mount point, iteratively uniquify this
# dirname until finding one hosting no mount point.
mount_iso() {
    # Localize and validate passed arguments.
    die_unless_one_argument 'expected exactly one ISO filename'
    string iso_filename="${1}"
    is "${iso_filename}" == *.iso si or
        die "\"${iso_filename}\" not an ISO"
    die_unless_file "${iso_filename}"
    string ZESHY_SCRIPT_NAME='mount_iso'

    # Find a suitable mount path.
    integer iso_mount_path_suffix=0
    string  iso_mount_path_prefix="${ZESHY_MOUNT_ISO_PATH}"\
            iso_mount_path="${iso_mount_path_prefix}"
    utter 'searching for available mount point...'
    while (is_mount_point "${iso_mount_path}") {
        (( iso_mount_path_suffix++ ))
        iso_mount_path="${iso_mount_path_prefix}${iso_mount_path_suffix}"
    }
    
    # Mount the passed ISO filename to the desired mount path.
    #
    # Note that this does not pass the ",user" option when mounting, as doing so
    # would implicitly enables unhelpful mount options (e.g., "noexec").
    utter "mounting \"${iso_filename}\" to \"${iso_mount_path}\"..."
    run_as_superuser make_dir_if_not_found "${iso_mount_path}" 
    run_as_superuser mount -t iso9660 -o 'exec,loop'\
        "${iso_filename}" "${iso_mount_path}" or
        die "\"${iso_filename}\" not mountable to \"${iso_mount_path}\""
}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
