#!/usr/bin/env zsh
# ====================[ process                            ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Process, implementing supplementary process-handling functionality (over
# and above that already implemented in Zeshy Core).

# ....................{ ALIASES                            }....................
interactive_alias ka='killall'
interactive_alias ka9='killall -9'

# ....................{ ERRORS                             }....................
# int exit_success(void)
# 
# Exit the current process with a successful return code.
exit_success() {
    die_if_args
    exit ${ZESHY_SUCCESS_CODE}
}

# int exit_failure(void)
# 
# Exit the current process with a failure return code.
exit_failure() {
    die_if_args
    exit ${ZESHY_FAILURE_CODE}
}

# ....................{ EXCEPTIONS                         }....................
# void die_if_piped_command_failed(
#   int pipe_position = -2, char *error_message = "prior command failed")
#
# Throw an exception if the command with the passed position (defaulting to -2
# and hence the second-to-last command) in the prior pipe failed with non-zero
# exit status. Zeshy already implicitly throws an exception if the command in
# the last position fails, thus requiring this function be called *ONLY* when
# the last command erroneously succeeds despite the prior command in its pipe
# failing. This is, thankfully, rare.
die_if_piped_command_failed() {
    die_unless_at_most_two_args\
        'expected optional pipe position and error message'

    #FIXME: How often do we check success? Perhaps an is_successful() function
    #is soon in order.
    (( pipestatus[${1:--2}] == ZESHY_SUCCESS_CODE )) or
        die "${2:-prior command failed}"
}

# ....................{ TESTS                              }....................
# bool is_cronjob(void)
#
# Return true if the current process is the grandchild of a "cron" process.
is_cronjob() {
    die_if_args
    is_nonempty "${ZESHY_IS_CRONJOB}"
}

# bool is_running(char *command_name)
#
# Return true if some process is running the passed command.
is_running() {
    die_unless_one_arg 'expected one filename'
    quietly get_pids_running "${@}"
}

# bool is_running_as(char *username, char *command_name)
#
# Return true if some process is running the passed command under the passed
# user.
is_running_as() {
    die_unless_two_args 'expected one username and filename'
    quietly get_pids_running_as "${@}"
}

# bool is_pid_running(int pid)
#
# Return true if some process is running under the passed process ID: e.g.,
#
#     >>> sleep 10s &; is_running_pid $! and print "Awaken, Young Master."
#     Awaken, Young Master.
is_pid_running() {
    die_unless_one_arg 'expected one process ID'
    quietly kill -0 "${1}"
}

# ....................{ GETTERS ~ pids                     }....................
# int get_pid(void)
#
# Return the PID (i.e., process ID) of the current process.
get_pid() {
    die_if_args
    return_integer ${$}
}

#FIXME: Generalize to not require "pgrep".
# char *get_pids_running(char *command_name)
#
# Return a newline-delimited string of process IDs for all processes running the
# passed command. If no such process exists, return the empty string and fail.
get_pids_running() {
    die_unless_one_arg 'expected one command name'
    die_unless_installed pgrep

    string command="${1}"
    if is_absolute_path "${command}"
    then pgrep -fx "${command}" 2>/dev/null
    else pgrep  -x "${command}" 2>/dev/null
    fi
}

#FIXME: Generalize to not require "pgrep".
# char *get_pids_running_as(char *username, char *command_name)
#
# Return a newline-delimited string of process IDs for all processes having the
# passed command name running under the passed user. If no such process exists,
# return the empty string and a failure return code.
get_pids_running_as() {
    die_unless_two_args 'expected one username and command name'
    die_unless_installed pgrep

    string username="${1}" command="${2}"
    if is_absolute_path "${command}"
    then pgrep -u "${username}" -fx "${command}" 2>/dev/null
    else pgrep -u "${username}"  -x "${command}" 2>/dev/null
    fi
}

# ....................{ GETTERS ~ commands                 }....................
#FIXME: This probably doesn't work as expected for scripts preceeded by set
#variables (e.g., "TMP=~/.tmp script.zeshy"). Test; hack; fix! Actually,
#stackoverflow can probably help us here. Google us up the fix, yo!
# char *get_process_command_name(int pid = PID)
#
# Get the name of the command the process with the passed PID (defaulting to
# that of the current process) is running.
get_process_command_name() {
    # List splitting the command-line the current process is running on words.
    # Dismantled, this is:
    #
    # * "(0)", split the command-line on null bytes. By Linux convention (and
    #   hence probably not applicable to other *nix), a null byte delimits each
    #   shell word of such line.
    list command_line_words
         command_line_words=( "${(0)$(get_process_command_line "${@}")}" )
#   curse "pclp: ${command_line_words[@]}"
    
    # The name and absolute path of the command the current process is running.
    string command_name="${command_line_words[1]}" command_path

    # If this process is a Zsh script (which it usually is), the absolute path
    # to this command is given by the third string in this array: e.g.,
    #
    #   # For a Zeshy script "h3110", this array resembles...
    #   command_line_words=( zsh /usr/bin/zeshy h3110 )
    if is "${command_name}" == *sh si and (( ${#command_line_words} >= 3 ))
    then command_path="${command_line_words[3]}"
    else command_path="${command_name}"
    fi

    # If the command path is "-su" (as occurs under "su"), strip the hyphen.
    is "${command_path}" == '-'* si and command_path="${command_path[2,-1]}"

    # Return the basename of this command path.
#   print "\ncommand_line_words: ${command_line_words[@]}"
#   print "command_path: ${command_path}"
    get_basename "${command_path}"
}

# char *get_process_command_line(int pid = PID)
#
# Get the command line the process with the passed PID (defaulting to that of
# the current process) is running. This is a string consisting of (in order):
#
# * Either the absolute or relative path to the command. In the latter case,
#   there is no reliable means of resolving this path into an absolute path.
# * Each command line argument passed to such command prefixed by a null
#   delimiter (i.e., "\x00").
#
# Due to such inconsistencies, use such strings *ONLY* for non-critical
# display purposes rather than critical functionality.
get_process_command_line() {
    die_unless_at_most_one_arg 'expected one optional process ID'
    integer pid=${1:-$(get_pid)}

    # Absolute path to the file with the command line for the passed process.
    string command_line_file="/proc/${pid}/cmdline"
    die_unless_file "${command_line_file}"
    cat "${command_line_file}"
}

# ....................{ WASTELANDS                         }....................

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
