#!/usr/bin/env zsh
# ====================[ process                            ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Process, implementing supplementary process-handling functionality (over
# and above that already implemented in Zeshy Core).

# ....................{ ALIASES                            }....................
interactive_alias ka='killall'
interactive_alias ka9='killall -9'

# ....................{ ERRORS                             }....................
# int exit_success(void)
# 
# Exit the current process with a successful return code.
exit_success() {
    die_unless_no_args
    exit ${ZESHY_SUCCESS_CODE}
}

# int exit_failure(void)
# 
# Exit the current process with a failure return code.
exit_failure() {
    die_unless_no_args
    exit ${ZESHY_FAILURE_CODE}
}

# ....................{ TESTS                              }....................
# bool is_cronjob(void)
#
# Return true if the current process is the grandchild of a "cron" process.
is_cronjob() {
    die_unless_no_args
    is_nonempty "${ZESHY_IS_CRONJOB}"
}

# bool is_running(char *command_name)
#
# Return true if some process is running the passed command.
is_running() {
    die_unless_one_arg 'expected exactly one filename'
    quietly get_pids_running "${@}"
}

# bool is_running_as(char *username, char *command_name)
#
# Return true if some process is running the passed command under the passed
# user.
is_running_as() {
    die_unless_two_args 'expected exactly one username and filename'
    quietly get_pids_running_as "${@}"
}

# bool is_pid_running(int pid)
#
# Return true if some process is running under the passed process ID: e.g.,
#
#     >>> sleep 10s &; is_running_pid $! and print "Awaken, Young Master."
#     Awaken, Young Master.
is_pid_running() {
    die_unless_one_arg 'expected exactly one process ID'
    quietly kill -0 "${1}"
}

# ....................{ GETTERS ~ pids                     }....................
# int get_pid(void)
#
# Return the PID (i.e., process ID) of the current process.
get_pid() {
    die_unless_no_args
    print "${$}"
}

#FIXME: Generalize to not require "pgrep".
# char *get_pids_running(char *command_name)
#
# Return a newline-delimited string of process IDs for all processes running the
# passed command. If no such process exists, return the empty string and fail.
get_pids_running() {
    die_unless_one_arg 'expected exactly one command name'
    die_unless_installed pgrep

    string command="${1}"
    if is_absolute_path "${command}"
    then pgrep -fx "${command}" 2>/dev/null
    else pgrep  -x "${command}" 2>/dev/null
    fi
}

#FIXME: Generalize to not require "pgrep".
# char *get_pids_running_as(char *username, char *command_name)
#
# Return a newline-delimited string of process IDs for all processes having the
# passed command name running under the passed user. If no such process exists,
# return the empty string and a failure return code.
get_pids_running_as() {
    die_unless_two_args 'expected exactly one username and command name'
    die_unless_installed pgrep

    string username="${1}" command="${2}"
    if is_absolute_path "${command}"
    then pgrep -u "${username}" -fx "${command}" 2>/dev/null
    else pgrep -u "${username}"  -x "${command}" 2>/dev/null
    fi
}

# ....................{ GETTERS ~ commands                 }....................
#FIXME: This probably doesn't work as expected for scripts preceeded by set
#variables (e.g., "TMP=~/.tmp script.zeshy"). Test; hack; fix! Actually,
#stackoverflow can probably help us here. Google us up the fix, yo!
# char *get_process_command_name(int pid = PID)
#
# Get the name of the command the process with the passed PID (defaulting to
# that of the current process) is running.
get_process_command_name() {
    # List splitting the command-line the current process is running on words.
    # Dismantled, this is:
    #
    # * "(0)", split the command-line on null bytes. By Linux convention (and
    #   hence probably not applicable to other *nix), a null byte delimits each
    #   shell word of such line.
    list command_line_words
         command_line_words=( "${(0)$(get_process_command_line "${@}")}" )
#   curse "pclp: ${command_line_words[@]}"
    
    # The name and absolute path of the command the current process is running.
    string command_name="${command_line_words[1]}" command_path

    # If this process is a Zsh script (which it usually is), the absolute path
    # to this command is given by the third string in this array: e.g.,
    #
    #   # For a Zeshy script "h3110", this array resembles...
    #   command_line_words=( zsh /usr/bin/zeshy h3110 )
    if is "${command_name}" == *sh si and (( ${#command_line_words} >= 3 ))
    then command_path="${command_line_words[3]}"
    else command_path="${command_name}"
    fi

    # If the command path is "-su" (as occurs under "su"), strip the hyphen.
    is "${command_path}" == '-'* si and command_path="${command_path[2,-1]}"

    # Return the basename of this command path.
#   print "\ncommand_line_words: ${command_line_words[@]}"
#   print "command_path: ${command_path}"
    get_basename "${command_path}"
}

# char *get_process_command_line(int pid = PID)
#
# Get the command line the process with the passed PID (defaulting to that of
# the current process) is running. This is a string consisting of (in order):
#
# * Either the absolute or relative path to the command. In the latter case,
#   there is no reliable means of resolving this path into an absolute path.
# * Each command line argument passed to such command prefixed by a null
#   delimiter (i.e., "\x00").
#
# Due to such inconsistencies, use such strings *ONLY* for non-critical
# display purposes rather than critical functionality.
get_process_command_line() {
    die_unless_at_most_one_arg 'expected one optional process ID'
    integer pid=${1:-$(get_pid)}

    # Absolute path to the file with the command line for the passed process.
    string command_line_file="/proc/${pid}/cmdline"
    die_unless_file "${command_line_file}"
    cat "${command_line_file}"
}

# ....................{ PRIORITIES                         }....................
# char *quickly(char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed command "quickly" under prioritized CPU and I/O scheduling.
quickly() {
    run_with_priorities\
        ${ZESHY_NICE_PRIORITY_LOW}\
        ${ZESHY_IONICE_CLASS_LOW}\
        ${ZESHY_IONICE_CLASS_PRIORITY_LOW}\
        "${@}"
}

# char *slowly(char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed command "slowly" under deprioritized CPU and I/O scheduling.
slowly() {
    run_with_priorities\
        ${ZESHY_NICE_PRIORITY_LOW}\
        ${ZESHY_IONICE_CLASS_LOW}\
        ${ZESHY_IONICE_CLASS_PRIORITY_LOW}\
        "${@}"
}

# ....................{ RUNNERS                            }....................
# int one_if(
#   char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed command quietly (i.e., squelching output) and, if exiting
# with success, return "1"; otherwise, return the empty string: e.g.,
#
#     >>> integer IS_MUTT_INSTALLED=$(one_if 'is_installed mutt')
#     >>> is_nonzero "${IS_MUTT_INSTALLED}" and print '"mutt" is installed'
#     "mutt" is installed
one_if() {
    quietly "${@}" and print 1 or true
}

#FIXME: Rename to merely stderr_to_stdout().
# char *jointly(
#   char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed command, diverting standard error to standard output.
jointly() {
    run "${(q)@}" 2>&1
}

# ....................{ RUNNERS ~ quietly                  }....................
# void quietly_as(
#   char *username,
#   char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed command as the passed user quietly (i.e., squelching output).
quietly_as() {
    run_as "${@}" 1>/dev/null 2>&1
#   run_as "${@}"
}

# void quietly(
#   char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed command quietly (i.e., squelching output).
quietly() {
    run "${(q)@}" 1>/dev/null 2>&1
}

# ....................{ RUNNERS ~ users                    }....................
# void run_as_superuser(
#   char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed command as the superuser.
run_as_superuser() {
    run_as root "${@}"
}

# void run_as(
#   char *username,
#   char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed command as the passed user.
run_as() {
    die_unless_at_least_two_args\
        'expected one username and one or more command strings'

    # Locally set "${ZESHY_RUN_AS}". The run() function notes this variable as
    # set and behaves accordingly...
    string ZESHY_RUN_AS="${1}"
    shift_one_arg

    # Call run() with all remaining arguments: the command to be run.
#   print "running as ${ZESHY_RUN_AS}: ${@}"
    run "${(q)@}"
}

# ....................{ RUNNERS ~ helpers                  }....................
# char *run_with_options(
#   char *command, char *list_options_name,
#   char *command_arg1, char *command_arg2, ...)
#
# Run the passed command with the passed options and arguments. Unlike most
# functions in the run*() family, this function requires the passed command be a
# single string. This function creates the command line to be run as follows:
#
# * Begin with the passed command.
# * Append the contents of the list with the passed name.
# * If interactive, append the contents of the list with name
#   "${list_options_name}_IF_INTERACTIVE"; otherwise, of the list with name
#   "${list_options_name}_IF_NON_INTERACTIVE".
# * Append "--", treating subsequent command arguments as non-options. This
#   precaution prevents treating option-like arguments as options (e.g., if a
#   file "-l" exists, "ls -- -l" lists that file while "ls -l" does not).
# * Append the passed command arguments.
run_with_options() {
    # Localize passed arguments.
    die_unless_at_least_two_args\
        'expected one command prefix, one list name, and zero or more command arguments'
    string options_list_name="${2}" interactive_options_list_name

    # Validate passed arguments.
    is_interactive and
        interactive_options_list_name="${options_list_name}_IF_INTERACTIVE" or
        interactive_options_list_name="${options_list_name}_IF_NON_INTERACTIVE"
    die_unless_list "${options_list_name}"
    die_unless_list "${interactive_options_list_name}"

    # Command line to be run. Dismantled, this is:
    #
    # * "(z)", splitting the passed command prefix into shell words.
    # * "(@P)", expanding the passed list name into the shell words of the
    #   corresponding external lists.
    list command_line; command_line=(
        "${(z)1}"
        "${(@P)options_list_name}"
        "${(@P)interactive_options_list_name}"
    )

    # Append the passed command arguments.
    shift_two_args
    command_line+=( -- "${@}" )

    # Run.
#   utter "running \"${command_line[@]}\"..."
    run "${(q)command_line[@]}"
}

# char *run_with_priorities(
#   int nice_priority, int ionice_class, int ionice_class_priority,
#   char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed command under the passed "nice" and "ionice" priorities.
run_with_priorities() {
    # Localize passed arguments.
    die_unless_args
    integer\
        nice_priority="${1}"\
        ionice_class="${2}"\
        ionice_class_priority="${3}"

    # Command line to be run, prefixed by commands prioritizing the passed
    # command. All systems provide "nice" but not necessarily "ionice".
    list command_line; command_line=( nice -n${nice_priority} )
    is_installed ionice and command_line+=( ionice
        -c${ionice_class}
        -n${ionice_class_priority}
    )

    # Append the passed command arguments.
    shift_three_args
    command_line+=( "${@}" )

    # Run.
    run "${(q)command_line[@]}"
}

# ....................{ RUNNERS ~ core                     }....................
# void run(char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed builtin or command, ideally quote-protected to avoid premature
# parsing of shell-specific syntax (e.g., pipes, redirections). Where passing a
# parameter expansion to this function, force such protection with "(q)": e.g.,
#
#   # Good! Manually quote-protect with single or double quotes.
#   >>> run 'screen -list | grep --count eschaton'
#   969
#
#   # Good! Automatically quote-protect with parameter expansion flag "(q)".
#   >>> string command=$(screen -list | grep --count singularity)
#   >>> run "${(q)command}"
#   696
#
#   # Doubleplusungood. Zsh parses the pipe prior to calling run().
#   >>> run screen -list | grep --count eschaton
run() {
    die_unless_args 'expected one or more command strings'

    # Command line to run. Dismantled, this is:
    #
    # * "Q", stripping one level of quote protection from the passed parameters,
    #   undoing prior "(q)" quote protection.
    # * "z", splitting such parameters into Zsh-specific words.
#   print "command line: ${@}"
    list command_line; command_line=( "${(Qz)@}" )
#   list command; command=( "${(Qz)@}" )
#   print "second arg: ${command_line[2]}"
    
    # Command name to run as the first word of such command line.
#   string command_name="${(Q)command_line[1]}"
    string command_name="${command_line[1]}"
    
    # A string conditionally defined to (in order):
    #
    # * If a Zsh alias, function, or builtin has the command name, that name.
    # * Otherwise, if the current $PATH contains the command name, the absolute
    #   path to that command.
    # * Otherwise, raise an exception.
    string command_path
    command_path="$(whence "${command_name}")" or
        die "\"${command_name}\" not found in \$PATH"

    # If the passed command has not been overridden by a shell alias or
    # function, run it as a command. Do not call the customary is_installed()
    # function, as that does not test whether or not a command is overridden.
    if is_absolute_path "${command_path}"; then
        # If running this command under a different user, do so.
        if is_set_nonempty 'ZESHY_RUN_AS' and
           is "${ZESHY_RUN_AS}" != "${USER}" si; then
            # If the target user is the superuser, use "sudo" to take
            # advantage of password caching. Do *NOT* use the "(@)" expansion in
            # either of the following two commands, as that would split the line
            # into discrete command arguments.
            if is "${ZESHY_RUN_AS}" == root si and is_installed sudo; then
#               echo "sudoing as ${ZESHY_RUN_AS}: ${command}"
                sudo -E "${command_line}"
            # Otherwise, use "su".
            else
#               echo "suing as ${ZESHY_RUN_AS}: ${command}"
                su --preserve-environment\
                   --command "${command_line}" "${ZESHY_RUN_AS}"
            fi
        # Otherwise, run this command as the current user. Use the "[@]"
        # expansion here, as calling the command manually requires we split the
        # line into discrete command arguments. Evaluate this command to ensure
        # the shell correctly handles shell constructs (e.g., "|").
        else
#           print "evaling: ${command_line[@]}"
            eval "${command_line[@]}"
        fi
    #FIXME: Incomplete. How does one run a builtin as another user? Implement.
    # Otherwise, the passed command must be a shell built-in. Evaluate it!
    else
#       print "evaling: ${command_line[@]}"
        eval "${command_line[@]}"
    fi
}

#FIXME: Obsolete.
# char *testify(
#   char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed command, converting raised exceptions to non-zero exit status.
# This function is particularly helpful for propagating exceptions thrown by
# subshells up the call stack of the current shell. (By default, Zsh does *NOT*
# propagate such exceptions.)
# reliably capturing the standard
# output of exception-throwing functions: e.g.,
#
#     # Bad. Regardless of whether get_first_file() throws an exception, the
#     # declaration of "first_file" silently succeeds.
#     >>> string first_file="$(testify get_first_file /rache /bartmoss)" or
#     ...   die 'neither "/rache" or "/bartmoss" found'
#     
#     # Good. If get_first_file() throws an exception, the declaration of
#     # "first_file" explicitly fails by propagating such exception.
#     >>> string first_file="$(testify get_first_file /rache /bartmoss)" or
#     ...   die 'neither "/rache" or "/bartmoss" found'
#testify() {
#    {
#        run "${(q)@}" 2>&1
#    } always {
#        integer exit_status=${?}
#        (( ${exit_status} )) and exit ${exit_status}
#    }
#}

    #FIXME: ...we appear to no longer require the "Q". (Naturally, I have no
    #firm idea why.)

#   string command_line="$(get_command_line "${@}")"

# Note, commands should be passed as quoted strings to prevent the calling
# shell from evaluating pipes, redirections, et al. prior to passing the
# command. (See the run() function, above.)

    #FIXME: This only strips one dash. How to strip more?
    # Strip prefixing dashes from this string to prevent the "basename" command
    # from intepreting such dashes as options to that command. This is actually
    # a real-world concern. By convention, for example, Linux prefixes login
    # shell command lines with one dash.
#   string process_command_line="${$(get_process_command_line)#-}"
#   string process_command_line="$(get_process_command_line)"
#   process_command_line="${process_command_line#-}"

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
