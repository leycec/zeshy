#!/usr/bin/env zsh
# ====================[ type                               ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Type, handling core type reflection.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_runnable(
#   char *runnable_name, char *error_message = 'not runnable')
#
# Raise an exception unless some alias, builtin, command, or function has the
# passed name.
die_unless_runnable() {
    die_unless_one_or_two_args 'expected one name and optional error message'
    string runnable_name="${1}"
    is_runnable "${runnable_name}" or
        die "${2:-\"${runnable_name}\" not runnable}"
}

# ....................{ TESTS                              }....................
# bool is_runnable(char *name)
#
# Return true if a Zsh alias, builtin, or function or external command with the
# passed name exists.
is_runnable() {
    die_unless_one_arg 'expected one name'
    quietly whence -- "${1}"
#   is $(whence -w "${1}") == *': (alias|builtin|function)' si
}

# bool is_builtin(char *builtin_name)
#
# Return true if a Zsh builtin (i.e., C function accessible to all Zsh shells
# and scripts) with the passed name exists.
is_builtin() {
    die_unless_one_arg 'expected one name'
    is "$(whence -w -- "${1}")" == *': builtin' si
}

# ....................{ ALIASES                            }....................
# bool is_alias(char *alias_name)
#
# Return true if a Zsh alias with the passed name exists.
is_alias() {
    die_unless_one_arg 'expected one name'
    quietly alias -- "${1}"
}

# bool is_suffix_alias(char *alias_name)
#
# Return true if a Zsh suffix alias with the passed name exists.
is_suffix_alias() {
    die_unless_one_arg 'expected one name'
    quietly suffix_alias -- "${1}"
}

# ....................{ TESTS ~ variables                  }....................
#FIXME: Uhm... what? I'm fairly certain we never call this. Doesn't is_set()
#suffice? We probably want to replace this with a new is_global() function.
# bool is_variable(char *variable_name)
#
# Return true if there exists a variable with the passed name.
is_variable() {
    die_unless_one_arg 'expected one name'
    is_nonempty "${(tP)1}"  # see get_type() for details
}

#FIXME: Rename is_local().
# bool is_local_variable(char *variable_name)
#
# Return true if there exists a local variable with the passed name.
is_local_variable() {
    die_unless_one_arg 'expected one name'
    string variable_type="${(tP)1}"  # see get_type() for details
    is_nonempty "${variable_type}" and is "${variable_type}" == *-local si
}

# ....................{ GETTERS                            }....................
# char *get_type(void *name)
#
# Get the type of the object (e.g., function, string) with the passed name or
# throw an exception if no such object exists.
get_type() {
    # Localize passed arguments.
    die_unless_one_arg 'expected one name'
    string object_name="${1}"

    # If the object with the passed name is a variable, return its type.
    if is_set "${object_name}"; then
        # Dismantled, this is:
        #
        # * "P", expanding to the variable with the passed name.
        # * "t", expanding to the variable's type.
        sputter "${(tP)object_name}"
    # Otherwise, this object is a callable or does not exist. Determine which by
    # calling whence() and stripping the resulting string of the prefix
    # consisting only of that name (e.g., assuming object with passed name "dmt"
    # a Zsh function, stripping "dmt: function" to merely "function"). If no
    # such callable exists, whence() outputs a type of "none" under an error exit
    # code ignored with "or true".
    else
        string object_type; object_type="$(whence -w -- "${object_name}")"
        sputter "${object_type##*: }"
    fi
}

# --------------------( WASTELANDS                         )--------------------
#       string object_type
#       object_type="$(whence -w -- "${object_name}")" or true  # ignore errors

# * Reflection functionality for dynamically inspecting functions and aliases
#   like first-class constructs.
#FIXME: Uhm; shouldn't "_runnable" be "_callable" everywhere below? Do we really
#need a distinction between the two? Arguably, functions aren't runnable and
#commands and builtins aren't callable. Perhaps

# ....................{ DEPENDENCIES                       }....................
#FIXME: This is generic functionality which should probably be provided by
#"core". Shift us up the genericity!
# void _zeshy_type(void)
#
# Import Zeshy components specific to the current OS.
#_zeshy_type() {
#    string current_dir="$(dirname "${zeshy_script_path}")"
#    is_dir "${current_dir}" and zimport "${current_dir}"
#}

# ....................{ MAIN                               }....................
# Call and then immediately unset (i.e., delete) _zeshy_os().
#_zeshy_os
#unset _zeshy_os

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#
# Copyright 2007-2012 by Cecil Curry.
#
#   http://www.raiazome.com
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
