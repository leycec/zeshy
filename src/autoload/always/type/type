#!/usr/bin/env zsh
# ====================[ type                               ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Type, implementing generic type-handling: e.g.,
#
# * Reflection functionality for dynamically inspecting functions and aliases
#   like first-class constructs.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_runnable(
#   char *runnable_name, char *error_message = 'not callable')
#
# Raise an exception unless some alias, builtin, command, or function has the
# passed name.
die_unless_runnable() {
    die_unless_one_or_two_arguments\
        'expected one runnable name and optional error message'
    string runnable_name="${1}"
    is_runnable "${callable_name}" or
        die "${2:-\"${runnable_name}\" not callable}"
}

# ....................{ TESTS                              }....................
# bool is_runnable(char *name)
#
# Return true if some alias, builtin, command, or function has the passed name.
is_runnable() {
    die_unless_one_argument 'expected exactly one name'
    quietly whence "${1}"
#   is $(whence -w "${1}") == *': (alias|builtin|function)' si
}

# bool is_alias(char *alias_name)
#
# Return true if some alias has the passed name.
is_alias() {
    die_unless_one_argument 'expected exactly one name'
    quietly alias "${1}" 
}

# bool is_suffix_alias(char *alias_name)
#
# Return true if some suffix alias has the passed name.
is_suffix_alias() {
    die_unless_one_argument 'expected exactly one name'
    quietly suffix_alias "${1}" 
}

# bool is_builtin(char *builtin_name)
#
# Return true if some Zsh builtin (i.e., C function accessible to all Zsh
# shells and scripts) has the passed name.
is_builtin() {
    die_unless_one_argument 'expected exactly one name'
    is $(whence -w "${1}") == *': builtin' si
}

# bool is_function(char *function_name)
#
# Return true if some Zsh function has the passed name.
is_function() {
    die_unless_one_argument 'expected exactly one name'
    is $(whence -w "${1}") == *': function' si
}

# ....................{ TESTS ~ variables                  }....................
# bool is_variable(char *variable_name)
#
# Return true if there exists a variable with the passed name.
is_variable() {
    die_unless_one_argument 'expected exactly one name'
    is_nonempty "${(tP)1}"  # see get_type() for details
}

# bool is_local_variable(char *variable_name)
#
# Return true if there exists a local variable with the passed name.
is_local_variable() {
    die_unless_one_argument 'expected exactly one name'
    string variable_type="${(tP)1}"  # see get_type() for details
    is_nonempty "${variable_type}" and is "${variable_type}" == *-local si
}

# ....................{ GETTERS                            }....................
# char *get_type(void *name)
#
# Return the type of the object (e.g., function, string) with the passed name or
# "none" if no such object exists.
get_type() {
    die_unless_one_argument 'expected exactly one name'
    string object_name="${1}"
    
    # If the object with the passed name is a variable, return its type.
    if is_set "${object_name}"; then
        # Dismantled, this is:
        #
        # * "P", expanding to the variable with the passed name.
        # * "t", expanding to the variable's type.
        print "${(tP)object_name}"
    # Otherwise, this object is a callable or does not exist. Determine which by
    # calling whence() and stripping the resulting string of the prefix
    # consisting only of that name (e.g., assuming object with passed name "dmt"
    # a Zsh function, stripping "dmt: function" to merely "function"). If no
    # such callable exists, whence() outputs a type of "none" under an error exit
    # code ignored with "or true".
    else
        string object_type="$(whence -w "${object_name}")" or true  # ignore errors
        print "${object_type##*: }"
    fi
}

#FIXME: Obsolete.
# ....................{ DEPENDENCIES                       }....................
#FIXME: This is generic functionality which should probably be provided by
#"core". Shift us up the genericity!
# void _zeshy_type(void)
#
# Import Zeshy components specific to the current OS.
#_zeshy_type() {
#    string current_dir="$(dirname "${zeshy_script_path}")"
#    is_dir "${current_dir}" and zimport "${current_dir}"
#}

# ....................{ MAIN                               }....................
# Call and then immediately unset (i.e., delete) _zeshy_os().
#_zeshy_os
#unset _zeshy_os

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
