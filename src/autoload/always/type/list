#!/usr/bin/env zsh
# ====================[ list                               ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy List, handling lists (i.e., non-associative arrays).
#
# --------------------( TODO                               )--------------------
# * Incorporate difference and intersect list operations from "src/load".
# * Incorporate set operations from:
#   http://www.catonmat.net/blog/set-operations-in-unix-shell

# ....................{ EXCEPTIONS                         }....................
# void die_unless_map_or_list(
#   char *variable_name, char *error_message = 'not a map or list')
#
# Die unless the variable with the passed name is a map or list.
die_unless_map_or_list() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    is_map_or_list "${1}" or die "${2:-\"${1}\" not a declared map or list}"
}

# void die_unless_list(char *variable_name, char *error_message = 'not a list')
#
# Die unless the variable with the passed name is a list.
die_unless_list() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    is_list "${1}" or die "${2:-\"${1}\" not a declared list}"
}

# void die_unless_list_nonempty(
#   char *variable_name, char *error_message = 'not a list')
#
# Die unless the variable with the passed name is a non-empty list.
die_unless_list_nonempty() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    is_list_nonempty "${1}" or die "${2:-\"${1}\" not a non-empty list}"
}

# ....................{ TESTS                              }....................
# bool is_map_or_list(char *variable_name)
#
# Return true if the variable with the passed name is a map or list.
is_map_or_list() {
    die_unless_one_arg 'expected one variable name'
    
    is $(get_type "${1}") == (list|array|association)* si
}

# bool is_list(char *variable_name)
#
# Return true if the variable with the passed name is a list (i.e., array).
is_list() {
    die_unless_one_arg 'expected one variable name'
    
    # Global lists have type "list", local lists "list-local", and internal
    # structures (e.g., "${path}") "array" or "array-special". Match all.
    is $(get_type "${1}") == (list|array)* si
}

# bool is_list_empty(char *variable_name)
#
# Return true if the variable with the passed name is an empty list. 
is_list_empty() {
    die_unless_one_arg 'expected one variable name'
    string list_name="${1}"
    is_list "${list_name}" and (( ${#${(@P)list_name}} == 0 ))
}

# bool is_list_nonempty(char *variable_name)
#
# Return true if the variable with the passed name is a non-empty list. 
is_list_nonempty() {
    die_unless_one_arg 'expected one variable name'
    string list_name="${1}"
    is_list "${list_name}" and (( ${#${(@P)list_name}} ))
}

# bool is_list_element(char *list_name, char *element)
#
# Return true if the list with the passed name contains an element with the
# passed value. 
is_list_element() {
    # Localize and validate arguments.
    die_unless_two_args 'expected one list name and one element'
    string list_name="${1}" element="${2}"
    die_unless_list "${list_name}"
    
    #FIXME: This is extendable into an is_list_element_globbing() function
    #by simple expanding ${element} as ${~element} here.
    # Dismantled, this is:
    #
    # * 'P', the scalar name of the desired list in the caller's scope.
    # * '@', as a list rather than a scalar.
    # * "${(M)", ":#", and "}", excluding all but the passed element.
    is_nonempty "${(M)${(@P)list_name}:#${element}}"
}

# ....................{ GETTERS                            }....................
# int get_list_size(char *variable_name)
#
# Get the number of elements in the list with the passed name.
get_list_size() {
    die_unless_one_arg 'expected one variable name'
    die_unless_list "${1}"

    # Dismantled, this is:
    #
    # * '1', the passed list name.
    # * 'P', the scalar name of the desired list in the caller's scope.
    # * '@', as a list rather than a scalar.
    # * '#', the size of this list.
    print ${#${(@P)1}}
}

#FIXME: Once we validate this works as expected, implement the converse
#get_first_list_element_globbing() function by using flag "(R)" where we
#currently use flag "(r)".

# ....................{ GETTERS ~ elements                 }....................
# char *get_first_list_element_globbing(char *list_name, char *glob_pattern)
#
# Get the first element of the list with the passed name matching the passed
# glob pattern.
get_first_list_element_globbing() {
    # Localize and validate arguments.
    die_unless_two_args 'expected one list name and one glob pattern'
    string list_name="${1}" glob_pattern="${2}" element
    die_unless_list "${list_name}"
    
    # Dismantled, this is:
    #
    # * 'P', the scalar name of the desired list in the caller's scope.
    # * '@', as a list rather than a scalar.
    # * 'r', expanding to the first element matching the passed pattern.
    element="${${(@P)list_name}[(r)"$glob_pattern"]}"

    # Throw an exception if no such element matches.
    die_unless_nonempty "${element}"\
        "pattern \"${glob_pattern}\" not matched in list \"${list_name}\""

    # Otherwise, return such element.
    return_string ${element}
}

# ....................{ PASS-BY-VALUE                      }....................
# char *return_list(char *variable_name)
#
# Convert the list with the passed name to a string. Call restore_list() to
# perfectly expand this string back to the original list: e.g.,
#
#   # Declare a function returning a stringified list.
#   >>> get_list() {
#   ...     list asbestos=( 'nephrite' 'porphyry' 'glauconite' 'mafic' )
#   ...     return_list asbestos
#   ... }
#
#   # Expand the stringified list back into a list with a convenience function.
#   >>> get_list | restore_list
#   >>> print "first list element: ${list[1]}"  # as in the original list!
#   nephrite
return_list() {
    die_unless_one_arg 'expected one variable name'
    string list_name="${1}"
    die_unless_list "${list_name}"

    # Dismantled, this is:
    #
    # * '1:-list' expands to the passed list name or 'list' if no such name
    #   was passed.
    # * 'P' transitively expands this name to the actual name of the desired
    #   associative list in the caller's scope.
    # * '@' interprets this expansion as a list rather than scalar.
    # * 'qq' protectively embeds all reserved shell characters in such names
    #   and values in single quotes.
    return_string "${(qq@P)list_name}"
}

#FIXME: Fix now-broken examples in "README.dev".
# void restore_list(void)
#
# Convert the string piped on standard input to a local list named "list",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_list().
alias restore_list='{
    is -p /dev/stdin si or die "\"/dev/stdin\" not a pipe";
    list list; list=( ${(z)"$(< /dev/stdin)"} )
}'

# ....................{ WASTELANDS                         }....................
#   >>> string List="$(get_list)"
#   >>> expand_List_to_list

#FIXME: This is silly. No one's *EVER* going to call this function. It's simply
#too obscure. Fold its implementation into expand_List(), which should
#incidentally be renamed to expand_...

#   # Expand the stringified list back into a list with a brute-force "eval".
#   >>> eval 'expand_list list $(make_list)'
#   >>> print "last list element: ${list[-1]}"  # as in the original list!
#   mafic

# void expand_list(char *list_name, char *string1, char *string2, ...)
#
# Return a string that, when "eval"-ed by the caller, expands the passed strings
# having a stringified list previously produced by return_list() into the list
# with the passed name. See expand_List() for a concise alternative.
#expand_list() {
#    die_unless_at_least_two_args\
#        'expected one variable name and one or more strings'
#    string list_name="${1}"
#    shift_one_arg
#
#    # Dismantled, this is:
#    #
#    # * '@' expands to all remaining passed parameters: the stringified list.
#    # * 'z' splits the stringified list into a numeric list of words,
#    #   effectively undoing the prior 'kv' flag.
#    print "list ${list_name}; ${list_name}=( ${(z)@} )"
#}

# void expand_List()
#
# Expand stringified list "List" to list "list", a convenience alias simplifying
# the more generalized expand_list() function. See return_list() for examples.
#alias expand_List='
#is_set List or die "\"List\" not defined";
#eval "$(expand_list list ${List})"'

    # Declare a list with the passed name if no such list exists.
#   is_unset "${list_name}" or print "list ${list_name}; "

#   die_unless_list "${list_name}"
#
# Map-specific analogues of the above list-specific functions.
# ....................{ INITIALIZATION                     }....................
#   die_unless_two_to_three_args\
#       'expected one string name, one list name, and one optional separator'
#   string string_name="${1}" list_name="${2}" separator="${3}"

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
