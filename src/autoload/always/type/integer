#!/usr/bin/env zsh
# ====================[ integer                            ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Integer, handling core integer functionality.

#FIXME: Rename "_number" to "_integer", everywhere. Do this because it only
#makes sense.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_number(
#   char *string, char *error_message = 'not an integer')
#
# Throw an exception unless the passed string is strictly numeric (i.e., a
# string of digits optionally prefixed with a negative sign "-").
die_unless_number() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    is_number "${1}" or die "${2:-\"${1}\" not an integer}"
}

# void die_unless_positive_number(
#   char *string, char *error_message = 'not a positive integer')
#
# Throw an exception unless the passed string is strictly positive (i.e., > 0).
die_unless_positive_number() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    is_positive_number "${1}" or die "${2:-\"${1}\" not a positive integer}"
}

# void die_unless_negative_number(
#   char *string, char *error_message = 'not a negative integer')
#
# Throw an exception unless the passed string is strictly negative (i.e., < 0).
die_unless_negative_number() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    is_negative_number "${1}" or die "${2:-\"${1}\" not a negative integer}"
}

# void die_unless_nonnegative_number(
#   char *string, char *error_message = 'not a nonnegative integer')
#
# Throw an exception unless the passed string is strictly nonnegative (i.e.,
# >= 0).
die_unless_nonnegative_number() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    is_nonnegative_number "${1}" or
        die "${2:-\"${1}\" not a nonnegative integer}"
}

# void die_unless_nonpositive_number(
#   char *string, char *error_message = 'not a nonpositive integer')
#
# Throw an exception unless the passed string is strictly nonpositive (i.e.,
# <= 0).
die_unless_nonpositive_number() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    is_nonpositive_number "${1}" or
        die "${2:-\"${1}\" not a nonpositive integer}"
}

# ....................{ TESTS                              }....................
# bool is_number(char *string)
#
# Return true if the passed string is strictly numeric.
is_number() {
    die_unless_one_arg 'expected one string'

    # Dismantled, this is:
    #
    # * "(-|)", matching an optional prefixing negative sign.
    # * "<->", matching one or more digits. An obscure, but helpful, Zsh-ism.
    is "${1}" == (-|)<-> si
}

# bool is_positive_number(char *string)
#
# Return true if the passed string is strictly positive (i.e., > 0).
is_positive_number() {
    die_unless_one_arg 'expected one string'
    string number="${1}"
    is_number "${number}" and (( number > 0 ))
}

# bool is_negative_number(char *string)
#
# Return true if the passed string is strictly negative (i.e., < 0).
is_negative_number() {
    die_unless_one_arg 'expected one string'
    string number="${1}"
    is_number "${number}" and (( number < 0 ))
}

# bool is_nonnegative_number(char *string)
#
# Return true if the passed string is strictly nonnegative (i.e., >= 0).
is_nonpositive_number() {
    die_unless_one_arg 'expected one string'
    string number="${1}"
    is_number "${number}" and (( number >= 0 ))
}

# bool is_nonpositive_number(char *string)
#
# Return true if the passed string is strictly nonpositive (i.e., <= 0).
is_nonpositive_number() {
    die_unless_one_arg 'expected one string'
    string number="${1}"
    is_number "${number}" and (( number <= 0 ))
}

# ....................{ TESTS ~ parity                     }....................
# bool is_even(char *string)
#
# Return true if the passed string is an even number.
is_even() {
    die_unless_one_arg 'expected one string'
    string number="${1}"
    is_number "${number}" and not (( number & 1 ))
}

# bool is_odd(char *string)
#
# Return true if the passed string is an odd number.
is_odd() {
    die_unless_one_arg 'expected one string'
    string number="${1}"
    is_number "${number}" and (( number & 1 ))
}

# ....................{ GETTERS                            }....................
#FIXME: Provide a function based on the rand48() function, if available. The
#implementation is somewhat incricate, since such function returns floats from
#0 to 1. See:
#    http://osdir.com/ml/shells.zsh.devel/2007-11/msg00150.html

# int get_random_number(int min = 0, int max = 32767)
#
# Get a random integer in the range [${min}, ${max}].
get_random_number() {
    die_unless_at_most_two_args\
        'expected at most one minimum and maximum number'
    string min="${1:-0}" max="${2:-32767}"
    die_unless_number "${min}"
    die_unless_number "${max}"

    #FIXME: Raise an exception if the passed "max" is larger than 32767? We can
    #fake larger ranges by simply multiplying with float arithmetic and capping
    #the output to the desired max, which seems preferable.

    # The current time in seconds since the first expansion of ${SECONDS} to six
    # fractional decimal places of accuracy: the maximum under Linux.
    float_with_fractional_digit_length 6 SECONDS

    # Prior to returning a random number, force Zsh's internal random number
    # generator to iterate to the next such number by reseeding with such time
    # discarding the separating decimal place ".". Failure to do so returns the
    # same initial number of such sequence on each call to this function.
    RANDOM=${SECONDS/./}

    # Randomize.
    print $[(${RANDOM} % (${max} - ${min} + 1)) + ${min}]
}

# ....................{ GETTERS ~ units                    }....................
# 1KB, 1MB, 1GB, and 1TB as base 2 rather than metric (i.e., base 10) integers.
KB() {
    die_if_args
    sputter $(( 1 << 10 ))
}

MB() {
    die_if_args
    sputter $(( 1 << 20 )) 
}

GB() {
    die_if_args
    sputter $(( 1 << 30 )) 
}

TB() {
    die_if_args
    sputter $(( 1 << 40 )) 
}

# ....................{ CONVERTERS ~ type                  }....................
# char *convert_integer_to_comma_separated_string(int integer)
#
# Convert the passed integer to a comma-separated string: e.g.,
#     comma_separate_integer 1776  # sputters 1,776
convert_integer_to_comma_separated_string() {
    die_unless_one_arg 'expected one integer'
    die_unless_number "${1}"

    #FIXME: Be nice to find a pure Zsh analogue to this.
    sputter "${1}" | awk "{ sputterf \"%'d\n\", \$1 }"
}

#FIXME: Obsolete.
#FIXME: Hmm. A tad excessive. Do we actually use these anywhere? Consider
#replacing with "type/integer" functions of the same name. Then, these are
#accessed via, say, $(KB) rather than ${KB}.

# For convenience, this function also accepts "stdin"-style piped input: e.g.,
#     echo 1776 | comma_separate_integer #     1,776

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
