#!/usr/bin/env zsh
# ====================[ number                             ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Integer, handling core integer functionality.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_integer(
#   char *string, char *error_message = 'not an integer')
#
# Throw an exception unless the passed string is strictly numeric (i.e., a
# string of digits optionally prefixed with a negative sign "-").
die_unless_integer() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    is_integer "${1}" or die "${2:-\"${1}\" not an integer}"
}

# ....................{ TESTS                              }....................
# bool is_integer(char *string)
#
# Return true if the passed string is strictly numeric.
is_integer() {
    die_unless_one_arg 'expected one string'

    # Dismantled, this is:
    #
    # * "(-|)", matching an optional prefixing negative sign.
    # * "<->", matching one or more digits. An obscure, but helpful, Zsh-ism.
    is "${1}" == (-|)<-> si
}

# ....................{ TESTS ~ parity                     }....................
# bool is_even(char *string)
#
# Return true if the passed string is an even number.
is_even() {
    die_unless_one_arg 'expected one string'
    string number="${1}"
    is_integer "${number}" and not (( number & 1 ))
}

# bool is_odd(char *string)
#
# Return true if the passed string is an odd number.
is_odd() {
    die_unless_one_arg 'expected one string'
    string number="${1}"
    is_integer "${number}" and (( number & 1 ))
}

# ....................{ GETTERS                            }....................
#FIXME: Provide a function based on the rand48() function, if available. The
#implementation is somewhat incricate, since such function returns floats from
#0 to 1. See:
#    http://osdir.com/ml/shells.zsh.devel/2007-11/msg00150.html

# int get_random_number(int min = 0, int max = 32767)
#
# Get a random integer in the range [${min}, ${max}].
get_random_number() {
    die_unless_at_most_two_args\
        'expected at most one minimum and maximum number'
    string min="${1:-0}" max="${2:-32767}"
    die_unless_integer "${min}"
    die_unless_integer "${max}"

    #FIXME: Raise an exception if the passed "max" is larger than 32767? We can
    #fake larger ranges by simply multiplying with float arithmetic and capping
    #the output to the desired max, which seems preferable.

    # The current time in seconds since the first expansion of ${SECONDS} to six
    # fractional decimal places of accuracy: the maximum under Linux.
    float_with_fractional_digit_length 6 SECONDS

    # Prior to returning a random number, force Zsh's internal random number
    # generator to iterate to the next such number by reseeding with such time
    # discarding the separating decimal place ".". Failure to do so returns the
    # same initial number of such sequence on each call to this function.
    RANDOM=${SECONDS/./}

    # Randomize.
    print $[(${RANDOM} % (${max} - ${min} + 1)) + ${min}]
}

# ....................{ GETTERS ~ units                    }....................
# 1KB, 1MB, 1GB, and 1TB as base 2 rather than metric (i.e., base 10) integers.
KB() {
    die_if_args
    return_integer $(( 1 << 10 ))
}

MB() {
    die_if_args
    return_integer $(( 1 << 20 )) 
}

GB() {
    die_if_args
    return_integer $(( 1 << 30 )) 
}

TB() {
    die_if_args
    return_integer $(( 1 << 40 )) 
}

# ....................{ CONVERTERS ~ type                  }....................
# char *convert_integer_to_comma_separated_string(int integer)
#
# Convert the passed integer to a comma-separated string: e.g.,
#     comma_separate_integer 1776  # return_integers 1,776
convert_integer_to_comma_separated_string() {
    die_unless_one_arg 'expected one integer'
    die_unless_integer "${1}"

    #FIXME: Be nice to find a pure Zsh analogue to this.
    return_integer "${1}" | awk "{ return_integerf \"%'d\n\", \$1 }"
}

#FIXME: Obsolete.
#FIXME: Hmm. A tad excessive. Do we actually use these anywhere? Consider
#replacing with "type/integer" functions of the same name. Then, these are
#accessed via, say, $(KB) rather than ${KB}.

# For convenience, this function also accepts "stdin"-style piped input: e.g.,
#     echo 1776 | comma_separate_integer #     1,776

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
