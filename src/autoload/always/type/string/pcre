#!/usr/bin/env zsh
# ====================[ pcre                               ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy PCRE, handling Perl-Compatible Regular Expression (PCRE) matching and
# substitution.
#
# --------------------( TODO                               )--------------------
# * Uhm; the "[[ ... =~ ... ]]" operator sets globals "${MATCH}" and "${match}"
#   on success, thus providing a far more concise and probably efficient
#   alternative to our current implementation. That said, the current
#   implementation does permit the user of caller-specific variables, which is
#   nice. Hence, we could improve the match() function with an optimization in
#   the case the caller accepts the default variable names. For further details,
#   see section "Conditional Expressions" under "info zsh".
# * Provide a glob-specific equivalent to the get_*match() family of functions.
#   The (M) flag to #- and %-style matches appears to support this, if crudely.

#FIXME: We really want to eliminate the *_multiline() functions. Nice idea, but
#there are simply too many useful permutations (e.g., multiline_caseless,
#multiline_extended). Rather, use a similar mechanism as the
#get_pcre_match_count() function whereby options are passed after all other
#parameters. (Somewhat awkward, but... *shrug*)

# ....................{ TESTS                              }....................
# bool is_matching_pcre(
#   char *string, char *pcre, char *pcre_arg1, char *pcre_arg2, ...)
#
# Return true if some substring of the passed string matches the passed PCRE
# with the passed PCRE options. See pcre_compile in "man zshmodules" for further
# details on such options.
is_matching_pcre() {
    # Localize passed arguments.
    die_unless_two_or_three_args\
        'expected one string, one regex, and optional regex options'
    string text="${1}" pcre="${2}"
    shift_two_args
    list pcre_args; pcre_args=( "${@}" )

    # Compile the passed PCRE for optimum matching with the passed options.
    pcre_compile "${pcre_args[@]}" -- "${pcre}"
    pcre_study

    # Attempt matching.
    pcre_match -- "${text}" or false
}

# bool is_line_matching_pcre(
#   char *string, char *pcre, char *pcre_arg1, char *pcre_arg2, ...)
#
# Return true if some line of the passed string matches the passed PCRE with
# option "-m" for multiline matching and the additional passed PCRE options. See
# pcre_compile in "man zshmodules" for further details on such options.
is_line_matching_pcre() {
    # Localize passed arguments.
    die_unless_two_or_three_args\
        'expected one string, one regex, and optional regex options'
    string text="${1}" pcre="${2}" 
    shift_two_args

    # If the passed regex is not explicitly anchored to newlines with a "^"
    # prefix and "$" suffix, add such anchors.
    is "${pcre[1]}"  == '^' si or pcre="^.*${pcre}"
    is "${pcre[-1]}" == '$' si or pcre="${pcre}.*$"

    # Attempt matching.
    is_matching_pcre "${text}" "${pcre}" "${@}" -m
}

# ....................{ GETTERS                            }....................
# int get_pcre_match_count(
#   char *string, char *pcre, char *pcre_arg1, char *pcre_arg2, ...)
#
# Get the number of substrings in the passed string matching the passed PCRE
# with the passed PCRE options. See pcre_compile in "man zshmodules" for further
# details on PCRE options: e.g.,
#
#     >>> get_pcre_match_count 'anthropocene tropes' '
#     ...   # This is an extended regular expression matching "ropo" and "rope".
#     ...   rop[aeiou]' -x
#     2
get_pcre_match_count() {
    # Localize passed arguments.
    string text pcre
    if is_piped_input; then
        die_unless_one_or_two_args\
            'expected one regex and optional regex options'
        text="$(get_piped_input)"
        pcre="${1}" 
        shift_one_arg
    else
        die_unless_two_or_three_args\
            'expected one string, one regex, and optional regex options'
        text="${1}"
        pcre="${2}" 
        shift_two_args
    fi
    list pcre_args; pcre_args=( "${@}" )

    # If either the passed string or PCRE is empty, return 0.
    { is_empty "${text}" or is_empty "${pcre}" } and sputter 0

    # Compile the passed PCRE for optimum matching with the passed options.
    pcre_compile "${pcre_args[@]}" -- "${pcre}"
    pcre_study

    # Count with brute-force iteration. While Zsh offers no flags or
    # functions for optimizing counting, iterating a counter while matching
    # until no matches remain yields the number of matches. Dismantled, this is:
    #
    # * "ZPCRE_OP='0 0'", initializing a Zsh global tracking the first and last
    #   0-based byte indices of the currently matched substring in ${text}.
    # * "pcre_match", matching the next substring given:
    #   * "-b", tracking indices in the ${ZPCRE_OP} global.
    #   * "-n", starting matching at the passed string index:
    #     * "${ZPCRE_OP[(w)2]}", expanding to the byte immediately following the
    #       last byte index of the previously matched substring.
    integer pcre_match_count=0
    global_string ZPCRE_OP='0 0'
    while pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${text}"; do
        (( ++pcre_match_count ))
    done
    sputter ${pcre_match_count}
}

# int get_line_count_matching_pcre(char *string, char *pcre)
#
# Get the number of lines in the passed string matching the passed multiline
# PCRE (i.e., such that "^" and "$" also match newlines).
get_line_count_matching_pcre() {
    if is_piped_input; then
        (( # >= 1 )) or
            die 'expected one regex and optional regex options'
        pass_piped_input_to get_pcre_match_count "${@}" -m
    else
        (( # >= 2 )) or
            die 'expected one string, one regex, and optional regex options'
        get_pcre_match_count "${@}" -m
    fi
}

# ....................{ MATCHES                            }....................
#FIXME: Completely rewrite. First, note that I've already stored the current
#implementation of this function in the WASTELANDS. Second, stop accepting
#"match_variable_name" and "group_array_name"; instead, force use of $MATCH and
#$match. The alternative is simply unreadable, unmanageable, and exceptionally
#confusing when read as a function call. Third, shift to a function parameter
#style as in the above functions. This reduces the function to something very
#sensible. Oh, and support is_piped_input() and get_piped_input(), as above.

# void match_pcre(
#   char *regular_expression, char *string = null,
#   char *match_variable_name = "MATCH", char *group_array_name = "match")
#
# Match the passed string or stdin if no such string is passed against the
# passed Perl-compatible regular expression (PCRE). This function returns
# failure if this string does not match and success otherwise, as well as
# setting match group-specific variables in the latter case:
#
# * The name of the scalar variable to which this function puts the whole match,
#   defaulting to the global variable "${MATCH}".
# * The name of the array variable to which this function puts all match groups,
#   defaulting to the global variable "${match}".
#
# This function never prints output in either case. Hence if you require the
# exact text matched, you must either access the above match group-specific
# variables or call a helper function defined by Zeshy Regex.
#
# This function also accepts a hidden "fifth parameter": the global variable
# "${ZESHY_MATCH_OPTIONS}", which when set causes this function to pass those
# options to the pcre_compile() built-in when compiling the passed pattern.
#
# For convenience, this function also accepts "stdin"-style piped input rather
# than an explicit passed string: e.g.,
#
#     >>> print 1776 | match '^\d'
#     >>> print "${MATCH}" 
#     1
match_pcre() {
    # Parse parameters.
    die_unless_at_least_two_args\
        'expected at least one regular expression and one string'
    string regex="${1}" text="${2}"\
        match_variable_name="${3:-MATCH}" group_array_name="${4:-match}"
#   print "pattern: "${(q)regex}" | string: ${string} | match_variable_name: ${match_variable_name} | group_array_name: ${group_array_name} "
#   print "mo: ${ZESHY_MATCH_OPTIONS[@]}"

    # Compile the match. (Yes, Zsh requires this regardless of whether we intend
    # to actually reuse this match.)
    if is_set 'ZESHY_MATCH_OPTIONS'; then 
#       print "ZESHY_MATCH_OPTIONS: ${ZESHY_MATCH_OPTIONS}"
#       pcre_compile -m "${pattern}" ||
        pcre_compile "${ZESHY_MATCH_OPTIONS[@]}" "${regex}" or
            die "\"${regex}\" not a valid regular expression under match options \"${ZESHY_MATCH_OPTIONS[@]}\""
    else
        pcre_compile "${regex}" or
            die "\"${regex}\" not a valid regular expression"
    fi
    
    # Match.
    pcre_match -v "${match_variable_name}" -a "${group_array_name}" -- "${text}"
}

# void match_pcre_multiline(...)
#
# Match the passed string against the passed Perl-compatible regular expression
# (PCRE) in a multi-line fashion (e.g., matching '^' and '$' at both newline and
# the beginning and end of the string, respectively). In all other respects,
# this function is identical to the match() function.
match_pcre_multiline() {
    list ZESHY_MATCH_OPTIONS; ZESHY_MATCH_OPTIONS=( -m )
    match_pcre "${@}"
}

# ....................{ MATCHES ~ by groups                }....................
# char *match_pcre_first_group(...)
#
# Return the first group to successfully match in the passed string against the
# passed regex. If no group matched, fail. See match() comments for further
# details: e.g.,
#
#     >>> match_first_group '(\d)$' '1984'
#     4
match_pcre_first_group() {
    # Match.
    match_pcre "${@}"

    # If at least one group matched, return the first such group.
    string group_array_name="${4:-match}"
    is_set "${group_array_name}" si and
        sputter "${${(@P)group_array_name}[1]}"
#   is -n "${(@P)group_array_name}" si and print "${${(@P)group_array_name}[1]}"
}

# void match_pcre_multiline_first_group(...)
#
# Return the first group to successfully match in the passed string against the
# passed regex, in a multi-line fashion (e.g., matching '^' and '$' at both
# newline and the beginning and end of the string). If no group matched, fail.
#
# This function is otherwise identical to the match_multiline() function.
match_pcre_multiline_first_group() {
    list ZESHY_MATCH_OPTIONS; ZESHY_MATCH_OPTIONS=( -m )
    match_pcre_first_group "${@}"
}

# ....................{ MATCHES ~ by lines                 }....................
# char *match_pcre_first_line(...)
#
# Match the passed string against the passed Perl-compatible regular expression
# (PCRE) and return the first matched line, if at least one such line matched,
# or the empty string otherwise.
#
# In all other respects, this function is identical to the match() function.
# In particular, note groups may still be obtained via the "${match}" array.
match_pcre_first_line() {
    die_unless_at_least_two_args\
        'expected at least one regular expression and one string'

    # Guarantee the passed regular expression roots itself to single rather than
    # multiple lines (i.e., begins with '^' and ends with '$').
    string regex="${1}"
    shift_one_arg

    # No, I don't know why the former requires a '.' while the latter does not.
    # I'm sure there's a highly rational reason within the musty bowels of ZSH.
#   print "regex: "${regex}
    is "${regex}" == ^.* si or regex="^.*${regex}"
    is "${regex}" == *$  si or regex="${regex}.*$"
#   print "regex: "${regex}
    
    # Pack this modified regular expression back into the array of all passed
    # arguments, for convenience.
    set_args "${regex}" "${@}"

    # Match.
    match_pcre_multiline "${@}"

    # Print the first matching line.
    string match_string_name="${3:-MATCH}"
    sputter "${(P)match_string_name}"
}

# ....................{ WASTELANDS                         }....................
    #FIXME: Hmm; we should probably anchor the passed PCRE with "^.*" and ".*$"
    #unless already beginning with "^" and ending with "$". Otherwise, we're not
    #actually matching within lines. Too much work, for the present.
    #FIXME: Silly. get_pcre_match_count() should be revised to accept piped
    #stdin, and this revised to pass_piped_stdin_to() and manual dying on args.
    # If the string was passed to this function from piped standard input, then
    # die_unless_two_args() erroneously reversed the argument order. Reverse it
    # back. Otherwise, we're good to go.
#   die_unless_two_args 'expected one string and one PCRE'
#   then get_pcre_match_count "${@[-1]}" "${@[1,-2]}" -m

# void match_pcre(
#   char *regular_expression, char *string = null,
#   char *match_variable_name = "MATCH", char *group_array_name = "match")
#
# Match the passed string or stdin if no such string is passed against the
# passed Perl-compatible regular expression (PCRE). This function returns
# failure if this string does not match and success otherwise, as well as
# setting match group-specific variables in the latter case:
#
# * The name of the scalar variable to which this function puts the whole match,
#   defaulting to the global variable "${MATCH}".
# * The name of the array variable to which this function puts all match groups,
#   defaulting to the global variable "${match}".
#
# This function never prints output in either case. Hence if you require the
# exact text matched, you must either access the above match group-specific
# variables or call a helper function defined by Zeshy Regex.
#
# This function also accepts a hidden "fifth parameter": the global variable
# "${ZESHY_MATCH_OPTIONS}", which when set causes this function to pass those
# options to the pcre_compile() built-in when compiling the passed pattern.
#
# For convenience, this function also accepts "stdin"-style piped input rather
# than an explicit passed string: e.g.,
#
#     >>> print 1776 | match '^\d'
#     >>> print "${MATCH}" 
#     1
#match_pcre() {
    # Parse parameters.
#    die_unless_at_least_two_args\
#        'expected at least one regular expression and one string'
#    string regex="${1}" text="${2}"\
#        match_variable_name="${3:-MATCH}" group_array_name="${4:-match}"
#   print "pattern: "${(q)regex}" | string: ${string} | match_variable_name: ${match_variable_name} | group_array_name: ${group_array_name} "
#   print "mo: ${ZESHY_MATCH_OPTIONS[@]}"

    # Compile the match. (Yes, Zsh requires this regardless of whether we intend
    # to actually reuse this match.)
#    if is_set 'ZESHY_MATCH_OPTIONS'; then 
#       print "ZESHY_MATCH_OPTIONS: ${ZESHY_MATCH_OPTIONS}"
#       pcre_compile -m "${pattern}" ||
#        pcre_compile "${ZESHY_MATCH_OPTIONS[@]}" "${regex}" or
#            die "\"${regex}\" not a valid regular expression under match options \"${ZESHY_MATCH_OPTIONS[@]}\""
#    else
#        pcre_compile "${regex}" or
#            die "\"${regex}\" not a valid regular expression"
#    fi
    
    # Match.
#    pcre_match -v "${match_variable_name}" -a "${group_array_name}" -- "${text}"
#}

#FIXME: This is uniformly terrible, any way you dice it. Slice this apart.
# char *get_matching_lines(...)
#
# Get all lines matching the passed regex. Unlike most Zeshy matching
# functions, this function uses "grep" rather than the "zsh/pcre" module as the
# latter provides no efficient means of obtaining non-overlapping matches.
#
# Unfortunately, this implies groups to be inaccessible.
#get_matching_lines() {
#    die_unless_at_least_two_args\
#        'expected at least one regular expression and one string'
#   local regexp="${1}" string="${2}"
#    sputter "${2}" | grep --perl-regexp "${1}"
#}

#   print "arg1: ${1}\narg2: ${2}"

# int get_matching_lines_count(...)
#
# Return the number of lines matching the passed regex. See the
# get_matching_lines() function for caveats.
#get_matching_lines_count() {
#    die_unless_at_least_two_args\
#        'expected at least one regular expression and one string'
##    sputter "${2}" | grep --perl-regexp --count "${1}"
#}

#   pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${text}"
#   print "pmc: ${pcre_match_count}\nop: ${ZPCRE_OP[(w)2]}"
#   pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${text}"
#   print "pmc: ${pcre_match_count}\nop: ${ZPCRE_OP[(w)2]}"
#       print "pmc: ${pcre_match_count}\nop: ${ZPCRE_OP[(w)2]}"
#   while (pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${text}") {
#       (( pcre_match_count++ ))
#   }
# int get_pcre_match_count(char *pcre_options, char *string, char *pcre)
#   string error_message='expected optional options, one string, and one PCRE'
#   die_unless_args "${error_message}"
#   if si "${1[1]}" == '-' si; then
#       die_unless_three_args "${error_message}"
#   else
#       die_unless_two_args "${error_message}"
#   fi

#FIXME: This is horrible. IT'S ALL HORRIBLE! Use pure Zsh expressions rather
#than this nonsense. There exists no guarantee that grep's "--perl-regexp" are
#anything like Zsh's. The implementation should resemble that of
#get_match_count(). (Yes, I've searched for better ways. They don't exist.)
#
#That said; it'd be a shame to jettison this. Instead, just shift the existing
#function into Zeshy Grep, perhaps renamed to get_grep_match_count(...).

# See also the get_number_of_glob_matches() function, which behaves similarly
# but less efficiently -- matching via multiple glob rather than one regular
# expression.

# --------------------( CONVENTIONS                        )--------------------
# All regular expressions matched by this component are Perl-compatible regular
# expressions (PCRE), unless otherwise stated. Thus, we abbreviate such regular
# expressions "regexes."
# 
# All functions defined by this component accept the same number and type of
# parameters as the core match() function, unless otherwise stated. Thus, we
# abbreviate such parameters "...". 
#
# ....................{ GROUPS ~ last                      }....................
#FIXME: Does this actually work? And even if it does, we really should be using
#the ZSH "pcre" facility to guarantee as-expected interpretation of the regex.
# char *match_last_group(char *regular_expression, char *string)
#
# Match the passed string against the passed Perl-compatible regular expression
# (PCRE) and return the last matched group, if at least one such group matched.
#match_last_group() {
#    die_unless_at_least_two_args\
#        'expected exactly one regular expression and one string'
#        
#    # Parse parameters.
#    string regexp="${1}" string="${2}"
#
#    # Match. For simplicity, use "grep" rather than Zsh's "pcre" module.
#    try "echo '${string}' | tac | grep --perl-regexp -m 1 '${regexp}'"
#}

    #FIXME: Uncommenting this causes *HORRIBLE, UTTERLY IMPOSSIBLE TO DEBUG*
    #issues. And it shouldn't. But there it is.
    # Localize the group array.
#   typeset -Ag ${group_array_name}

    # Retrieve the first group.
#   string first_group_name="${group_array_name}[1]"

    # If this match matched at least one group, return that. Otherwise, nil.
#   print "first_group_name: ${first_group_name}"
#   string first_group="${(P)first_group_name}"
#   print "first_group: ${first_group}"

    # If there exists at least one group, print the first and return success;
    # otherwise, print nothing and return failure.
#   is_nonempty "${first_group}" and print "${first_group}"

#   local regexp="${1}" string="${2}"
#   try "get_matching_lines '${@}' | get_line_count"
#   try "echo '${string}' | sed 's/${regex}/${regex}\n/g' | grep --perl-regexp --count '${regex}'"
#   return
#       die "\"${string}\" not matched by regular expression \"${regex}\""
    # If the passed regex contains no groups, embed that regex in a group
    # matching the entire prior regex.
#   [[ "${1}" == *\(*\)* ]] || set -- "(${regex})" "${@}"

    # Match.
#   match "${@}" || return ${?}
#   echo "${#match}"

    # Print the number of matches.
#   local group_array_name="${4:-match}"
#   print "${(P)#group_array_name}"

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
