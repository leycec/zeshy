#!/usr/bin/env zsh
# ====================[ glob                               ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Glob, handling glob expression matching and substitution.
#
# --------------------( SEE ALSO                           )--------------------
# "man zshexpn/FILENAME GENERATION"
#     Glob syntax details.
#
# --------------------( TODO                               )--------------------
# * Ah-ha! I finally found how to do proper matching with glob expressions:
#   flag "b". To quote, "Activate backreferences for parenthesised groups in the
#   pattern...". See "man zshexpn" for details. Sweetness.
# * Also, note that glob expressions *CAN* match at the beginning and end of
#   strings: flags "s" and "e" in the same section as above. Between this and
#   backreferencing, I believe we've largely obsoleted our need for regular
#   expression matching in the Zeshy codebase and should probably substitute all
#   such matching with more efficient and certainly elegant glob matching.

# ....................{ TESTS                              }....................
# bool is_glob(char *string)
#
# Return true if the passed string resembles a glob expression (i.e.,
# contains at least one glob-reserved character).
is_glob() {
    die_unless_one_arg 'expected exactly one string'
    is "${1}" == *[\[\]\<\>\(\)\|+*?#~^]* si
}

#FIXME: Ehrm; I'm quite sure there's a simple parameter expansion flag already
#implementing this. Man up "zshexpn", please. 

# ....................{ GETTERS                            }....................
# int get_glob_match_count(char *string, char *glob_expression)
#
# Return the number of glob matches in the passed string. Among other uses, this
# function counts occurrences of characters and substrings in strings: e.g.,
#
#     >>> get_number_of_glob_matches '[bsz]o' 'bosozoku'
#     3
#
# See also get_number_of_matches(), similar but slightly more efficient by
# matching via one regular rather than multiple glob expressions.
get_glob_match_count() {
    die_unless_two_args\
        'expected one string and one glob expression'
    string text="${1}" glob="${2}" 

    # If the passed string is empty, print 0 to avoid nonsense.
    if is_empty "${text}"; then
        print 0
    # If the passed glob expression contains no glob-reserved characters (e.g.,
    # *, /), we optimize match counting by noting the size of each match to be
    # "${#glob}". The difference between the original string and a string with
    # all such matches removed divided by the length of each match yields the
    # number of matched substrings. This obscene logic comes courtesy
    # LinuxQuestions user "unSpawn" in the following thread:
    #
    #     http://www.linuxquestions.org/questions/linux-newbie-8/bash-command-to-count-particular-character-in-a-string-645005/
    elif not is_glob "${glob}"; then
        string text_matches_deleted="${text//${~glob}/}"
        print $(( (${#text} - ${#text_matches_deleted}) / ${#glob} ))
    # Otherwise, perform brute-force iteration.
    #
    # Sadly, neither sed, awk, grep, or zsh itself have any coherent means of
    # matching individual occurences of a substring. Fortunately, zsh does have
    # a simple mechanism for *ELIMINATING* such matches. Hence, we do so
    # iteratively until all such matches are eliminated.
    else
        string text_old
        integer matches='-1'
        until is "${text_old}" == "${text}" si; do
            (( matches++ ))
            text_old="${text}"
            text="${text/${~glob}/}"
        done
        print ${matches}
    fi
}

# ....................{ WRITERS                            }....................
# char *remove_prefix_matching(char *string, char *glob_expression)
#
# Remove the longest prefix from the passed string matching the passed glob
# expression and return the resulting string: e.g.,
#
#     >>> remove_prefix_matching 'north by northwest' '*n{o,d}?th'
#     west
remove_prefix_matching() {
    die_unless_two_args\
        'expected one string and one glob expression'
    string text="${1}" glob="${2}"
    utter_raw "${text##${~glob}}"
}

# char *remove_suffix_matching(char *string, char *glob_expression)
#
# Remove the longest suffix from the passed string matching the passed glob
# expression and return the resulting string: e.g.,
#
#     >>> remove_suffix_matching 'dial.m.for.murder' '.m?????*'
#     dial.
remove_suffix_matching() {
    die_unless_two_args\
        'expected one string and one glob expression'
    string text="${1}" glob="${2}"
    utter_raw "${text%%${~glob}}"
}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
