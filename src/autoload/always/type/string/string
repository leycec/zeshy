#!/usr/bin/env zsh
# ====================[ string                             ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy String, handling core string functionality.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_string(char *map_name, char *error_message = 'not a string')
#
# Die unless the variable with the passed name is a string.
die_unless_string() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    is_string "${1}" or die "${2:-\"${1}\" not a declared string}"
}

# void die_unless_char(char *map_name, char *error_message = 'not a character')
#
# Die unless the variable with the passed name is a single character.
die_unless_char() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    is_char "${1}" or die "${2:-\"${1}\" not a declared character}"
}

# ....................{ TESTS                              }....................
# bool is_string(char *variable_name)
#
# Return true if the variable with the passed name is a string.
is_string() {
    die_unless_one_arg 'expected one variable name'
    is $(get_type "${1}") == 'scalar'* si
}

# bool is_char(char *variable_name)
#
# Return true if the variable with the passed name is a single character.
is_char() {
    die_unless_one_arg 'expected one variable name'
    is_string "${1}" and (( $(get_length "${(P)1}") == 1 ))
}

# ....................{ GETTERS ~ length                   }....................
# int get_length(char *string)
#
# Get the length of the passed string in single-byte characters. If such string
# contains multibyte characters (e.g., UTF-8-encoded Unicode), this may not be
# what you expect.
get_length() {
    die_unless_one_arg 'expected one string'
    return_integer ${#1}
}

# int get_multibyte_length(char *string)
#
# Get the length of the passed string in multibyte characters.
get_multibyte_length() {
    die_unless_one_arg 'expected one string'
    return_integer ${(m)#1}
}

# ....................{ GETTERS ~ lines                    }....................
# Curiously, Zsh expands parameter flag "(f)" to scalar strings rather single
# element lists when the parameter contains no newlines. Since this is probably
# never what anyone wants, this is probably a bug... To subdue this bug, always
# split the parameter into an explicit list prior to use: e.g.,
#
#     # Bad. Never do this. If "${1}" contains no newline, this prints the first
#     # character rather than first line of the parameter.
#     print ${#${(f)1}}
#
#     # Good. Always do this. While cumbersome, there's no avoiding some cumber.
#     list lines; lines=( ${(f)1} )
#     print ${#lines}

# char *get_line(char *string, int line_number = 1)
#
# Get the line corresponding to the passed line number from the passed string.
# If positive, this is the nth line from the beginning starting at 1. Conversely
# if negative, this is the nth line from the end starting at -1.
get_line() {
    # Localize passed arguments.
    die_unless_one_or_two_args\
        'expected one string and optional line number'
    integer line_number=${2:-1}
    get_lines "${1}" ${line_number} ${line_number}
}

# char *get_first_lines(char *string, int last_line_number = 1)
#
# Get the first n lines (defaulting to the first line) from the passed string.
get_first_lines() {
    die_unless_one_or_two_args\
        'expected one string and optional last line number'
    get_lines "${1}" 1 ${2:-1}
}

# char *get_last_lines(
#   char *string, int first_line_number = get_line_length(string))
#
# Get the last n lines (defaulting to the last line) from the passed string.
get_last_lines() {
    die_unless_one_or_two_args\
        'expected one string and optional last line number'
    string text="${1}"
    integer line_length; line_length=$(get_line_length "${text}")
    get_lines "${text}" ${2:-${line_length}} ${line_length}
}

# char *get_lines(
#   char *string,
#   int first_line_number = 1, last last_line_number = get_line_length(string))
#
# Get the list of lines starting at the passed first line number (defaulting to
# the first line) and concluding at the passed last line number (defaulting to
# the last line) from the passed string.
get_lines() {
    # Localize passed arguments.
    die_unless_one_to_three_args\
        'expected one string and optional first and last line numbers'
    list lines; lines=( "${(f)1}" )
    integer line_length=${#lines}
    integer first_line_number=${2:-1} last_line_number=${3:-${line_length}} 

    # Validate passed arguments. Negative line numbers are permissible.
    (( -line_length <= first_line_number && first_line_number <= line_length )) or
        die "line ${first_line_number} not in [-${line_length}, ${line_length}]"
    (( -line_length <= last_line_number && last_line_number <= line_length )) or
        die "line ${last_line_number} not in [-${line_length}, ${line_length}]"
    (( first_line_number <= last_line_number )) or
        die "first line number ${first_line_number} > last line number ${last_line_number}"

    # Get the desired line.
    return_string ${lines[${first_line_number},${last_line_number}]}
}

# char *get_line_length(char *string1, char *string2, ...)
#
# Get the total number of lines in the passed strings.
get_line_length() {
    die_unless_args 'expected at least one string'
    list lines; lines=( "${(f)@}" )
    print ${#lines}
}

#FIXME: I'm fairly sure that, as with the "(f)" flag above, the "(w)" flag
#erroneously operates on characters if there exists only one such word. Fix.
# ....................{ GETTERS ~ words                    }....................
# char *get_first_word(char *string, char *string2, ...)
#
# Get the first word from the passed string.
get_first_word() {
    die_unless_args 'expected at least one string'
    return_string "${*[(w)1]}"
}

# char *get_word(char *string, int word_number = 1)
#
# Get the word corresponding to the passed word number from the passed string.
get_word() {
    die_unless_one_or_two_args\
        'expected one string and optional word number'
    return_string "${1[(w)${2:-1}]}"
}

# char *get_word_length(char *string, char *string2, ...)
#
# Get the number of words in the passed string, aggregating each quoted
# substring into one word. Hence, this is the Zsh-specific word length.
get_word_length() {
    die_unless_args 'expected at least one string'
    print ${#${(z)*}}
}

# char *get_word_length_unquoted(char *string1, char *string2, ...)
#
# Get the number of words in the passed string, *NOT* aggregating quoted
# substrings. Hence, this is the conventional document word length.
get_word_length_unquoted() {
    die_unless_args 'expected at least one string'
    print ${#${=*}}
}

#FIXME: By definition, you only join a list to a string and split a list to a
#string. Hence, these function names are overly verbose. Rename
#join_list_to_string() to join_list_with() and
#join_list_to_string_prefixing_last_with() to join_list_prefixing_last_element_with().
#This produces much more legible code.

#FIXME: Right. list_to_string() is simply too brief. join_list_to_string() reads
#better.

# ....................{ WRITERS                            }....................
# char *suffix_if_not_already(char *string, char *suffix)
#
# Suffix the passed string with the passed suffix, if not already: e.g.,
#
#     >>> suffix_if_not_already '/habitat/failing/flailing/habits' '/'
#     /habitat/failing/flailing/habits/
suffix_if_not_already() {
    die_unless_two_args 'expected one string and one suffix'
    return_string "${1%${2}}${2}"
}

# char *tabulate(char *string, char *delimiter = ' ')
#
# Horizontally align the passed strings on the passed delimiter (defaulting to
# whitespace) into table columns.
tabulate() {
    die_unless_one_or_two_args 'expected one string and optional delimiter'
    if is_one_arg
    then return_string "${1}" | column -t
    else return_string "${1}" | column -t -s "${2}"
    fi
}

# ....................{ WRITERS ~ joiners                  }....................
# void list_to_string(char *separator, char *string1, char *string2, ...)
#
# Join the passed list elements into a string separated by the passed separator.
# The separator may be of any non-zero length: e.g.,
#
#     >>> list_to_string ', ' 'The' 'Moon' 'Is' 'a' 'Harsh' 'Mistress.'
#     The, Moon, Is, a, Harsh, Mistress.
list_to_string() {
    die_unless_args\
        'expected one separator and zero or more list elements'

    # Shift off the separator argument, the remainder thus signifying the list
    # to be joined.
    string separator="${1}"
    shift_one_arg

    # If no list elements were passed, print the empty string and return.
    is_args or return_success
    
    # If the passed separator is a colon, delimit such separator by periods.
    if is "${separator}" == ':' si
    then return_string ${(j.:.)@}
    # Otherwise, delimit such separator by colons. Since Zsh appears to
    # expand no parameters embedded in parameter expansion flags (e.g.,
    # "print ${(j:${separator}:)@}", joining list elements with the raw string
    # "${separator}" rather than the expansion of such parameter), wrap the
    # desired expression in an "eval" to force such expansion.
    else eval "print -- \${(j:${separator}:)@}"
    fi
}
 
# void list_to_human_readable_string(
#   char *last_element_prefix, char *string1, char *string2, ...)
#
# Join the passed elements into a human-readable string separated by commas,
# prefixing the last such element with the passed string: e.g.,
#
#     >>> list_to_human_readable_string 'or' 'Wingnut' 'Dishwashers' 'Union'
#     Wingnut, Dishwashers, or Union
list_to_human_readable_string() {
    die_unless_at_least_two_args\
        'expected one separator, one last element prefix, and zero or more list elements'

    # Shift off the separator and last element prefix arguments, the remainder
    # thus signifying the list to be joined.
    string last_element_prefix="${1}"
    shift_one_arg

    # If more than two list elements were passed, join such elements and prefix
    # the last such element.
    if is_at_least_three_args; then
        list_to_string\
            ', ' "${@[1,-2]}" "${last_element_prefix} ${@[-1]}"
    # If only two list elements were passed, print the first element, the last
    # element prefix, and the third element.
    elif is_two_args
    then return_string "${1} ${last_element_prefix} ${2}"
    # If only one list element was passed, print that element as is.
    else return_string "${1}"
    fi
}
 
# ....................{ WRITERS ~ splitters                }....................
# char *split_string_to_list(char separator, char *string, char *variable_name)
#
# Split the passed string on all substrings of the passed separating character
# into a list of the results. If no separator is passed, split words by default
# parsing (i.e., first by quote- and then whitespace-delimited words): e.g.,
#
#     >>> list array
#     >>> split_string_to_list '/' 'Obseqious/Deep/Journeys' array
#     >>> utter_raw "${array[1]}"
#     Obseqious

# See split_string_on_first() for alternative splitting into string variables.
split_string_to_list() {
    die_unless_three_args\
        'expected one separator, source string, and target list variable name'

    # Localize and validate arguments.
    string separator="${1}" text="${2}" list_name="${3}"
    die_unless_char 'separator'
    die_unless_list "${list_name}"

    # If the passed separator is a colon, delimit such separator by periods.
    if is "${separator}" == ':' si
    then eval "${list_name}=( \${(s.:.)text} )"
    # Otherwise, delimit such separator by colons.
    else eval "${list_name}=( \${(s:${separator}:)text} )"
    fi
}

# void split_string_to_strings_on_first(
#   char *separator, char *string, char *variable_name1, char *variable_name2)
#
# Split the passed string on the first substring of the passed separator into:
#
# * The string with the former name to the substring preceding such separator.
# * The string with the latter name to the substring following such separator.
#
# The separator may be of any non-zero length: e.g.,
#
#     >>> string prefix suffix
#     >>> split_string_to_strings_on_first\
#       '==' 'wolfs==head==society' 'prefix' 'suffix'
#     >>> utter_raw "prefix: ${prefix}\nsuffix: ${suffix}"
#     prefix: wolfs
#     suffix: head==society
# 
# See split_string_to_list() for alternative splitting on all substrings.
split_string_to_strings_on_first() {
    die_unless_four_args\
        'expected one separator, source string, and target prefix and suffix variable names'

    # Localize arguments.
    string\
        separator="${1}"\
        source_text="${2}"\
        target_name_prefix="${3}"\
        target_name_suffix="${4}"

    # Validate arguments.
    die_unless_string "${target_name_prefix}"
    die_unless_string "${target_name_suffix}"

    # Fail if the passed string contains no such separator.
    is "${source_text}" == *"${separator}"* si or
        die "\"${source_text}\" contains no \"${separator}\" to be split on"

    # Split.
    eval\
        "${target_name_prefix}=\"${source_text%%${separator}*}\"; "\
        "${target_name_suffix}=\"${source_text#*${separator}}\""
}

# ....................{ WRITERS ~ case                     }....................
# char *capitalize(char *string)
#
# Capitalize the first letter of each word in the passed string: e.g.,
#
#     >>> capitalize "phase three: profit"
#     Phase Three: Profit
capitalize() {
    die_unless_one_arg 'expected one string'
    return_string "${(C)1}"
}

# char *lowercase(char *string)
#
# Convert the passed string to all lowercase: e.g.,
#
#     >>> lowercase "The Wind in the Pillows"
#     the wind in the pillows
lowercase() {
    die_unless_one_arg 'expected one string'
    return_string "${(L)1}"
}

# char *uppercase(char *string)
#
# Convert the passed string to all uppercase: e.g.,
#
#     >>> uppercase "The Pyre of My Loins"
#     THE PYRE OF MY LOINS
uppercase() {
    die_unless_one_arg 'expected one string'
    return_string "${(U)1}"
}

# ....................{ WRITERS ~ lines                    }....................
# char *number_lines(char *string)
#
# Prefix each line of the passed string with that line's number.
number_lines() {
    utter_raw "${@}" |
        run_with_options 'page_safely command nl' 'ZESHY_NL_OPTIONS'
}

#FIXME: Should probably be theme-specific.
# char *number_lines_highlighting_line(
#   int highlight_line_number,
#   char *string1, char *string2, ...)
#
# Prefix each line of the passed string with that line's number and highlight
# the passed line number. Since "nl" supports no highlighting, this function
# accepts no "nl"-specific options.
number_lines_highlighting_line() {
    # Localize passed arguments.
    die_unless_at_least_two_args\
        'expected one line number and one or more strings'
    integer highlight_line_number="${1}" line_length
    shift_one_arg
    string text="${@}"

    # Validate passed arguments. Negative line numbers are impermissible.
    line_length="$(get_line_length "${text}")"
    (( 1 <= highlight_line_number && highlight_line_number <= line_length )) or
        die "highlight line ${highlight_line_number} not in [1, ${line_length}]"

    # Number lines.
    utter_raw "${text}" | awk -vNRHI=${highlight_line_number} '
# If any line other than the highlight line, print the current line number
# followed by the line.
NR != NRHI { printf("%6d%7s%s\n", NR, "", $0) }
# If the highlight line, print the current line number prefixed and suffixed by
# pleasing ASCII arrows. (See print_stack_trace() for similar logic.)
NR == NRHI {
    # Number of digits in the current line number.
    NRLEN = length(NR);
         if (NRLEN==1) {NRNOW = " <-~ " NR}
    else if (NRLEN==2) {NRNOW = "<-~ " NR}
    else if (NRLEN==3) {NRNOW = "<- " NR}
    else               {NRNOW = NR}       # if true, your string is horrid.
    printf("%s ~->   %s\n", NRNOW, $0)
}'
}

# ....................{ WRITERS ~ removers                 }....................
# char *remove_prefix(char *string, char *prefix)
#
# Remove the passed prefix from the passed string: e.g.,
#
#     >>> remove_prefix 'zealia brown' 'zeal'
#     ia brown
remove_prefix() {
    die_unless_two_args 'expected one string and one prefix'
    string text="${1}" prefix="${2}"
    return_string "${text##${prefix}}"
}

# char *remove_suffix(char *string, char *suffix)
#
# Remove the passed suffix from the passed string: e.g.,
#
#     >>> remove_suffix 'august derleth' 'leth'
#     august der
remove_suffix() {
    die_unless_two_args 'expected one string and one suffix'
    string text="${1}" suffix="${2}"
    return_string "${text%%${suffix}}"
}

#FIXME: Obsolete.
    # Localize passed arguments.
#   die_unless_args\
#       'expected zero or more "nl" options and one string'
#   string text="${@[-1]}"
#   pop_one_arg

    # Prefix.
#   list nl; nl=( nl "${ZESHY_NL_OPTIONS[@]}" )
#   utter_raw "${text}" | {
#       if is_interactive
#       then "${nl[@]}" "${ZESHY_NL_OPTIONS_IF_INTERACTIVE[@]}"     "${@}"
#       else "${nl[@]}" "${ZESHY_NL_OPTIONS_IF_NON_INTERACTIVE[@]}" "${@}"
#       fi
#   }

    #FIXME: Implementable with pure-Zsh.
#   utter_raw "${1}" | head --lines="${2:-1}"

#   list newline_split; newline_split=( "${(s:\n:)1}" )
#   print "first line: ${newline_split[1]}"

# char *get_first_line(char *string)
#
# Get the first line from the passed string.
#get_first_line() {
#    die_unless_one_arg 'expected one string'
#   utter_raw "${1[(f)1]}"
#}

#   # Localize passed arguments.
#   (( # >= 1 && # <= 2 )) ||
#       die 'expected one string and optional first line number'
#   local text="${1}"
#   integer first_line_number="${2}"

    # Prefix.
#   nl -v${first_line_number} "${text}"

    # Bizarrely, the "(f)" no longer appears to behave as advertised on my
    # install. In fact, it no longer does anything at all. Consequently, we
    # perform a brute-force split on newlines. Ideally, this should be:
    #
    #     print "${#${(f)1}}"
    # 
    # Unfortunately, we can't even expand this to:
    # 
    #     print "${#${(s:\n:)1}}"
    # 
    # Doing so behaves correctly for all input *EXCEPT* that without newlines.
    # Consequently, we perform an even more brute-force split into a list.
#     >>> split_string_to_list '"Contumely Hard" Climaxes' array
#     >>> print "${array[1]}"
#     Contumely Hard
#    # If the caller passed no separator, default to word splitting.
#   if is_empty "${separator}"
#   then eval ${list_name}'=( ${(z)text} )'

#   is_set "${target_name_prefix}" or string ${target_name_prefix}
#   is_set "${target_name_suffix}" or string ${target_name_suffix}
#   is_set "${list_name}" or list "${list_name}"

#   die_unless_string "${target_name_prefix}"
#   die_unless_string "${target_name_suffix}"

#Compare the lengths of the original and resulting strings.
#   local string_matches_deleted="${string//${~glob}/}"
#   local glob_characters="${#glob//}"
#   print $(((${#string} - ${#string_matches_deleted}) / ${#glob}))
#   print "string_newlined: ${string_newlined}"

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
