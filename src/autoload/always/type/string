#!/usr/bin/env zsh
# ====================[ string                             ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy String, implementing string-handling functionality.
#
# --------------------( SEE ALSO                           )--------------------
# "man zshexpn/FILENAME GENERATION"
#     Glob syntax details.
#
# --------------------( TODO                               )--------------------
# * Ah-ha! I finally found how to do proper matching with glob expressions:
#   flag "b". To quote, "Activate backreferences for parenthesised groups in the
#   pattern...". See "man zshexpn" for details. Sweetness.
# * Also, note that glob expressions *CAN* match at the beginning and end of
#   strings: flags "s" and "e" in the same section as above. Between this and
#   backreferencing, I believe we've largely obsoleted our need for regular
#   expression matching in the Zeshy codebase and should probably substitute all
#   such matching with more efficient and certainly elegant glob matching.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_string(char *map_name, char *error_message = 'not a string')
#
# Die unless the variable with the passed name is a string.
die_unless_string() {
    die_unless_one_or_two_arguments\
        'expected one variable name and optional error message'
    is_string "${1}" or die "${2:-\"${1}\" not a declared string}"
}

# void die_unless_char(char *map_name, char *error_message = 'not a character')
#
# Die unless the variable with the passed name is a single character.
die_unless_char() {
    die_unless_one_or_two_arguments\
        'expected one variable name and optional error message'
    is_char "${1}" or die "${2:-\"${1}\" not a declared character}"
}

# ....................{ TESTS                              }....................
# bool is_string(char *variable_name)
#
# Return true if the variable with the passed name is a string.
is_string() {
    die_unless_one_argument 'expected exactly one variable name'
    is $(get_type "${1}") == 'scalar'* si
}

# bool is_char(char *variable_name)
#
# Return true if the variable with the passed name is a single character.
is_char() {
    die_unless_one_argument 'expected exactly one variable name'
    is_string "${1}" and (( $(get_length "${(P)1}") == 1 ))
}

# bool is_glob(char *string)
#
# Return true if the passed string resembles a glob expression (i.e.,
# contains at least one glob-reserved character).
is_glob() {
    die_unless_one_argument 'expected exactly one string'
    is "${1}" == *[\[\]\<\>\(\)\|+*?#~^]* si
}

# ....................{ GETTERS                            }....................
# int get_length(char *string)
#
# Get the length of the passed string in multibyte characters.
get_length() {
    die_unless_one_argument 'expected exactly one string'
    print "${#1}"
}

# int get_glob_match_count(char *glob_expression, char *string)
#
# Return the number of glob matches in the passed string. Among other uses, this
# function counts occurrences of characters and substrings in strings: e.g.,
#
#     >>> get_number_of_glob_matches '[bsz]o' 'bosozoku'
#     3
#
# See also get_number_of_matches(), similar but slightly more efficient by
# matching via one regular rather than multiple glob expressions.
get_glob_match_count() {
    die_unless_two_arguments\
        'expected exactly one glob expression and one string'
    string glob="${1}" text="${2}"

    # If the passed string is empty, print 0 to avoid nonsense.
    if is_empty "${text}"; then
        print 0
    # If the passed glob expression contains no glob-reserved characters (e.g.,
    # *, /), we optimize match counting by noting the size of each match to be
    # "${#glob}". The difference between the original string and a string with
    # all such matches removed divided by the length of each match yields the
    # number of matched substrings. This obscene logic comes courtesy
    # LinuxQuestions user "unSpawn" in the following thread:
    #
    #     http://www.linuxquestions.org/questions/linux-newbie-8/bash-command-to-count-particular-character-in-a-string-645005/
    elif not is_glob "${glob}"; then
        string text_matches_deleted="${text//${~glob}/}"
        print $(( (${#text} - ${#text_matches_deleted}) / ${#glob} ))
    # Otherwise, perform brute-force iteration.
    #
    # Sadly, neither sed, awk, grep, or zsh itself have any coherent means of
    # matching individual occurences of a substring. Fortunately, zsh does have
    # a simple mechanism for *ELIMINATING* such matches. Hence, we do so
    # iteratively until all such matches are eliminated.
    else
        string text_old= 
        integer matches=-1
        until is "${text_old}" == "${text}" si; do
            (( matches++ ))
            text_old="${text}"
            text="${text/${~glob}/}"
        done
        print "${matches}"
    fi
}

# ....................{ GETTERS ~ lines                    }....................
# char *get_first_lines(char *string, int last_line_number = 1)
#
# Get lines [1, "last_line_number"] inclusive from the passed string.
get_first_lines() {
    die_unless_one_or_two_arguments\
        'expected exactly one string and optional last line number'
    print "${1}" | head --lines="${2:-1}"
}

# char *get_first_line(char *string)
#
# Get the first line from the passed string.
get_first_line() {
    die_unless_one_argument 'expected exactly one string'
    print "${1[(f)1]}"
}

# char *get_line(char *string, int line_number = 1)
#
# Get the line corresponding to the passed line number from the passed string.
get_line() {
    die_unless_one_or_two_arguments\
        'expected exactly one string and optional line number'
    print "${1[(f)${2:-1}]}"
}

# char *get_line_length(char *string)
#
# Get the number of lines in the passed string.
get_line_length() {
    die_unless_one_argument 'expected exactly one string'
    print "${#${(f)1}}"
}

# ....................{ GETTERS ~ words                    }....................
# char *get_first_word(char *string, char *string2, ...)
#
# Get the first word from the passed string.
get_first_word() {
    die_unless_at_least_one_argument 'expected at least one string'
    print "${*[(w)1]}"
}

# char *get_word(char *string, int word_number = 1)
#
# Get the word corresponding to the passed word number from the passed string.
get_word() {
    die_unless_one_or_two_arguments\
        'expected one string and optional word number'
    print "${1[(w)${2:-1}]}"
}

# char *get_word_length(char *string, char *string2, ...)
#
# Get the number of words in the passed string, aggregating each quoted
# substring into one word. Hence, this is the Zsh-specific word length.
get_word_length() {
    die_unless_at_least_one_argument 'expected at least one string'
    print "${#${(z)*}}"
}

# char *get_word_length_unquoted(char *string1, char *string2, ...)
#
# Get the number of words in the passed string, *NOT* aggregating quoted
# substrings. Hence, this is the conventional document word length.
get_word_length_unquoted() {
    die_unless_at_least_one_argument 'expected at least one string'
    print "${#${=*}}"
}

#FIXME: By definition, you only join a list to a string and split a list to a
#string. Hence, these function names are overly verbose. Rename
#join_list_to_string() to join_list_with() and
#join_list_to_string_prefixing_last_with() to join_list_prefixing_last_element_with().
#This produces much more legible code.

# ....................{ JOINERS                            }....................
# void list_to_string(char *separator, char *string1, char *string2, ...)
#
# Join the passed list elements into a string separated by the passed separator.
# The separator may be of any non-zero length: e.g.,
#
#     >>> list_to_string ', ' 'The' 'Moon' 'Is' 'a' 'Harsh' 'Mistress.'
#     The, Moon, Is, a, Harsh, Mistress.
list_to_string() {
    die_unless_arguments\
        'expected one separator and zero or more list elements'

    # Shift off the separator argument, the remainder thus signifying the list
    # to be joined.
    string separator="${1}"
    shift_one_argument

    # If no list elements were passed, print the empty string and return.
    is_arguments or return_success
    
    # If the passed separator is a colon, delimit such separator by periods.
    if is "${separator}" == ':' si
    then print ${(j.:.)@}
    # Otherwise, delimit such separator by colons. Since Zsh appears to
    # expand no parameters embedded in parameter expansion flags (e.g.,
    # "print ${(j:${separator}:)@}", joining list elements with the raw string
    # "${separator}" rather than the expansion of such parameter), wrap the
    # desired expression in an "eval" to force such expansion.
    else eval "print \${(j:${separator}:)@}"
    fi
}
 
# void list_to_human_readable_string(
#   char *last_element_prefix, char *string1, char *string2, ...)
#
# Join the passed elements into a human-readable string separated by commas,
# prefixing the last such element with the passed string: e.g.,
#
#     >>> list_to_human_readable_string 'or' 'Wingnut' 'Dishwashers' 'Union'
#     Wingnut, Dishwashers, or Union
list_to_human_readable_string() {
    die_unless_at_least_two_arguments\
        'expected one separator, one last element prefix, and zero or more list elements'

    # Shift off the separator and last element prefix arguments, the remainder
    # thus signifying the list to be joined.
    string last_element_prefix="${1}"
    shift_one_argument

    # If more than two list elements were passed, join such elements and prefix
    # the last such element.
    if is_at_least_three_arguments; then
        list_to_string\
            ', ' "${@[1,-2]}" "${last_element_prefix} ${@[-1]}"
    # If only two list elements were passed, print the first element, the last
    # element prefix, and the third element.
    elif is_two_arguments; then
        print "${1} ${last_element_prefix} ${2}"
    # If only one list element was passed, print that element as is.
    elif is_one_argument; then
        print "${1}"
    fi
}
 
# ....................{ SPLITTERS                          }....................
# char *split_string_to_list(char separator, char *string, char *variable_name)
#
# Split the passed string on all substrings of the passed separating character
# into a list of the results. If no separator is passed, split words by default
# parsing (i.e., first by quote- and then whitespace-delimited words): e.g.,
#
#     >>> list array
#     >>> split_string_to_list '/' 'Obseqious/Deep/Journeys' array
#     >>> print "${array[1]}"
#     Obseqious

# See split_string_on_first() for alternative splitting into string variables.
split_string_to_list() {
    die_unless_three_arguments\
        'expected one separator, source string, and target list variable name'

    # Localize and validate arguments.
    string separator="${1}" text="${2}" list_name="${3}"
    die_unless_char 'separator'
    die_unless_list "${list_name}"

    # If the passed separator is a colon, delimit such separator by periods.
    if is "${separator}" == ':' si
    then eval "${list_name}=( \${(s.:.)text} )"
    # Otherwise, delimit such separator by colons.
    else eval "${list_name}=( \${(s:${separator}:)text} )"
    fi
}

# void split_string_to_strings_on_first(
#   char *separator, char *string, char *variable_name1, char *variable_name2)
#
# Split the passed string on the first substring of the passed separator into:
#
# * The string with the former name to the substring preceding such separator.
# * The string with the latter name to the substring following such separator.
#
# The separator may be of any non-zero length: e.g.,
#
#     >>> string prefix suffix
#     >>> split_string_to_strings_on_first\
#       '==' 'wolfs==head==society' 'prefix' 'suffix'
#     >>> print "prefix: ${prefix}\nsuffix: ${suffix}"
#     prefix: wolfs
#     suffix: head==society
# 
# See split_string_to_list() for alternative splitting on all substrings.
split_string_to_strings_on_first() {
    die_unless_four_arguments\
        'expected exactly one separator, source string, and target prefix and suffix variable names'

    # Localize arguments.
    string\
        separator="${1}"\
        source_text="${2}"\
        target_name_prefix="${3}"\
        target_name_suffix="${4}"

    # Validate arguments.
    die_unless_string "${target_name_prefix}"
    die_unless_string "${target_name_suffix}"

    # Fail if the passed string contains no such separator.
    is "${source_text}" == *"${separator}"* si or
        die "\"${source_text}\" contains no \"${separator}\" to be split on"

    # Split.
    eval\
        "${target_name_prefix}=\"${source_text%%${separator}*}\"; "\
        "${target_name_suffix}=\"${source_text#*${separator}}\""
}

# ....................{ CONVERTERS                         }....................
# char *to_lowercase(char *string)
#
# Convert the passed string to all lowercase: e.g.,
#
#     >>> to_lowercase "The Wind in the Pillows"
#     the wind in the pillows
to_lowercase() {
    die_unless_one_argument 'expected exactly one string'
    print "${(L)1}"
}

# char *to_uppercase(char *string)
#
# Convert the passed string to all uppercase: e.g.,
#
#     >>> to_uppercase "The Pyre of My Loins"
#     THE PYRE OF MY LOINS
to_uppercase() {
    die_unless_one_argument 'expected exactly one string'
    print "${(U)1}"
}

# ....................{ SETTERS                            }....................
# char *suffix_if_not_already(char *string, char *suffix)
#
# Suffix the passed string with the passed suffix, if not already: e.g.,
#
#     >>> suffix_if_not_already '/habitat/failing/flailing/habits' '/'
#     /habitat/failing/flailing/habits/
suffix_if_not_already() {
    die_unless_two_arguments 'expected exactly one string and one suffix'
    print "${1%${2}}${2}"
}

#FIXME: Obsolete.
#     >>> split_string_to_list '"Contumely Hard" Climaxes' array
#     >>> print "${array[1]}"
#     Contumely Hard
#    # If the caller passed no separator, default to word splitting.
#   if is_empty "${separator}"
#   then eval ${list_name}'=( ${(z)text} )'

#   is_set "${target_name_prefix}" or string ${target_name_prefix}
#   is_set "${target_name_suffix}" or string ${target_name_suffix}
#   is_set "${list_name}" or list "${list_name}"

#   die_unless_string "${target_name_prefix}"
#   die_unless_string "${target_name_suffix}"

#Compare the lengths of the original and resulting strings.
#   local string_matches_deleted="${string//${~glob}/}"
#   local glob_characters="${#glob//}"
#   print $(((${#string} - ${#string_matches_deleted}) / ${#glob}))
#   print "string_newlined: ${string_newlined}"

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
