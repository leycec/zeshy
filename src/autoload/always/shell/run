#!/usr/bin/env zsh
# ====================[ run                                ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Run, handling command, builtin, and function execution.

# ....................{ ALIASES                            }....................
#FIXME: Uncomment when working, below.
#interactive_alias cat='print_file'

# ....................{ RUNNERS                            }....................
# char *run(char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed command. While Zsh and hence Zeshy already run strings as
# commands if in command position, strings containing shell-reserved characters
# (e.g., "|", "<", ">") do not run as expected. This function amends that: e.g.,
#
#   # Command to be run.
#   >>> string command='screen -list | grep --count 'eschaton emtombed'
#
#   # Doubleplusungood. Zsh parses the former as one composite command name and
#   # the pipe in the latter as a raw command argument. In either case, failure.
#   >>> ${command}     # bad
#   >>> ${(z)command}  # equally bad
#
#   # Ohsonice. Run the expected command.
#   >>> run ${command}
#   969
run() {
    die_unless_args 'expected one command'

    # If one argument was passed, such argument signifies a command line to be
    # run. Otherwise, only the concatenation of such arguments signifies the
    # line. In the latter case, embedded escapes and quotes (e.g., "\ ", "'''")
    # in such arguments must be preserved in the expansion with "(q)".
#   sputter_unescaped "running: ${(q)@}..."
    if is_one_arg
    then eval "${1}"
    else eval "${(q)@}"
    fi
}

# ....................{ RUNNERS ~ output                   }....................
# void quietly_as(
#   char *username,
#   char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed command as the passed user quietly (i.e., squelching output).
quietly_as() {
    run_as "${@}" 1>/dev/null 2>&1
}

# void quietly(
#   char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed command quietly (i.e., squelching output).
quietly() {
    run "${@}" 1>/dev/null 2>&1
}

# char *unify_output(
#   char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed command, diverting standard error to standard output.
unify_output() {
    run "${@}" 2>&1
}

# ....................{ RUNNERS ~ mapfile                  }....................
# char *run_with_mapfile(
#   char *command_name, char *command_arg1, char *command_arg2, ...)
# 
# Run the passed command with the Zsh "mapfile" module loaded before and
# unloaded after running the command. "mapfile" is inherently unsafe, though
# more efficient than alternatives (e.g., "$(< ${filename})"), and so should be
# available only as long as is necessary.
run_with_mapfile() {
    # Load Zsh module "mapfile".
    load_zsh_module zsh/mapfile

    #FIXME: When enabled, this sporadically fails with an inscrutible error like:
    #    "(anon):82: bad math expression: operand expected at `/usr/share...'"
    #File a bug report if this is still the case under recent Zsh versions.
    # Forcibly prevent harmful ${mapfile} and hence filesystem changes.
#   freeze_variable mapfile

    # Run the passed command.
    run "${@}"

    # Unload "mapfile", for safety.
    unload_zsh_module zsh/mapfile
}

# ....................{ RUNNERS ~ options                  }....................
# char *run_with_options(
#   char *command, char *list_options_name,
#   char *command_arg1, char *command_arg2, ...)
#
# Run the passed command with the passed options and arguments. Unlike most
# functions in the run*() family, this function requires the passed command be a
# single string. This function creates the command line to be run as follows:
#
# * Begin with the passed command.
# * Append the contents of the list with the passed name.
# * If interactive, append the contents of the list with name
#   "${list_options_name}_IF_INTERACTIVE"; otherwise, of the list with name
#   "${list_options_name}_IF_NON_INTERACTIVE".
# * Append "--", treating subsequent command arguments as non-options. This
#   precaution prevents treating option-like arguments as options (e.g., if a
#   file "-l" exists, "ls -- -l" lists that file while "ls -l" does not).
# * Append the passed command arguments. This completes the command line.
# * If this function was called with piped input, pipe such input to the command
#   line; otherwise, run the command line as is.
run_with_options() {
    # Localize passed arguments. Do *NOT* call die_unless_at_least_two_args(),
    # as such function suffixes the argument list with piped input. While this
    # is typically what we want, this function already pipes piped input to the
    # command to be run... Suffixing the argument list passes such input to such
    # command twice, therefore. Which is blatantly bad.
    (( # >= 2 )) or
        die 'expected one command prefix, one list name, and zero or more command arguments'
    string\
        command_line_prefix="${1}"\
        options_list_name="${2}" interactive_options_list_name
    list command_line
    shift_two_args

    # Validate passed arguments, uppercasing the desired interactive list name
    # regardless of the original case of the passed list name.
    is_interactive and
        interactive_options_list_name="${(U)options_list_name}_IF_INTERACTIVE" or
        interactive_options_list_name="${(U)options_list_name}_IF_NON_INTERACTIVE"
    die_unless_list "${options_list_name}"
    die_unless_list "${interactive_options_list_name}"

    # If passed piped input, propagate such input to the desired command.
    is_piped_input and command_line=( cat '/dev/stdin' \| )

    # Dismantled, this is:
    #
    # * "(z)", splitting the passed command prefix into shell words.
    # * "(@P)", expanding the passed list name into the shell words of the
    #   corresponding external lists.
    command_line+=(
        "${(z)command_line_prefix}"
        "${(@P)options_list_name}"
        "${(@P)interactive_options_list_name}"
        -- "${@}"
    )

    # Run.
#   sputter_unescaped "running \"${command_line[@]}\"..."
    run "${command_line[@]}"
}

# ....................{ RUNNERS ~ pages                    }....................
# char *run_paged(
#   char *command_name, char *command_arg1, char *command_arg2, ...)  --OR--
#
# Run the passed command with standard output and error piped to the current
# pager when such output exceeds the terminal height or as is (i.e., without
# paging) if not. In other words, this function implements an intelligent pager.
#
# Customary pager commands block on standard input, thus delaying output until
# after the input command completes operation. Resource-intensive commands not
# completing immediately (e.g., "ls -R *") thus block paging with no
# intermediate output until such commands eventually complete. To rectify such
# interface woes, this function immediately prints all output as received from
# the passed command to standard error prior to paging such output, if needed.
run_paged() {
    die_unless_args 'expected one command'

    # If not attached to a terminal, run the passed command as is and
    # immediately return without paging.
    is_terminal or {
        run "${@}"
        return_true
    }

    # Otherwise, run the passed command with redirection. Dismantled, this is:
    #
    # * "2>&2", preserving standard error prior to its subsequent redirection.
    # * "2>&1", redirecting standard error to output. Since command substitution
    #   only captures the latter, only such redirection captures standard error.
    # * "1>&1", preserving standard output prior to its subsequent redirection.
    # * "1>&2", redirecting standard output to error. Since command substitution
    #   only captures the former, this immediately prints all output produced by
    #   running such command.
    string output; output="$(run "${@}" 2>&2 2>&1 1>&1 1>&2)"
    list lines; lines=( ${(f)output} )

    # Ascertain whether such output's logical line length (i.e., accounting for
    # implicit wrapping of long lines) exceeds the current terminal height. The
    # algorithm resembles get_displayed_line_length(), but differs by
    # immediately stopping iteration on exceeding terminal height rather than
    # continuing to accumulate total line length. This reduces an otherwise O(N)
    # algorithm to effectively O(1), assuming non-ludicrous terminal height.
    integer displayed_line_length="${#lines}" terminal_height terminal_width
    terminal_height=$(get_terminal_height)
    (( displayed_line_length > terminal_height )) or {
        # Width of the current terminal, incremented by one to avoid counting
        # maximally long lines as requiring wrapping.
        terminal_width=$(get_terminal_width)
        (( ++terminal_width ))

        # Calculate line wrapping.
        for line ("${(f)output}") {
            (( displayed_line_length += ${#line} / terminal_width ))
            (( displayed_line_length > terminal_height )) and break
        }
    }

    # If the terminal is sufficiently tall to display all output without paging,
    # return. Our job is done here, folks.
#   utter "line length: ${displayed_line_length}\nterminal height: ${terminal_height}"
    (( displayed_line_length > terminal_height )) or return_true

    # Pager command to be run.
    list pager; pager=( "${PAGER}" )

    # Name of the list with pager options specific to the current pager. If such
    # list exists, append such options to the pager command to be run.
    string pager_options_list_name
    pager_options_list_name="ZESHY_$(get_basename "${PAGER}")_OPTIONS"
    is_list "${pager_options_list_name}" and
        pager+=( "${(@P)pager_options_list_name}" )
    
    # Page.
    sputter "${output}" | "${pager[@]}"
}

#FIXME: Implement me, sometime. Shift to "file/content/content", as well.
# char *print_file_paged(
#   char *filename1, char *filename2, ...)
print_file_paged() {
    die_unless_args 'expected at least one filename'
    string output

    #FIXME: This probably isn't behaving as intended. It *SHOULD* be printing
    #file contents to stderr while concatenating together file contents. In
    #practice, it probably just exhumes an error. Hurk!
    for filename ("${@}") {
        output+="$(< "${filename}" 1>&1 1>&2)"
    }
}

# ....................{ RUNNERS ~ priority                 }....................
# char *quickly(char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed command "quickly" under prioritized CPU and I/O scheduling.
quickly() {
    run_with_priorities\
        ${ZESHY_NICE_PRIORITY_LOW}\
        ${ZESHY_IONICE_CLASS_LOW}\
        ${ZESHY_IONICE_CLASS_PRIORITY_LOW}\
        "${@}"
}

# char *slowly(char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed command "slowly" under deprioritized CPU and I/O scheduling.
slowly() {
    run_with_priorities\
        ${ZESHY_NICE_PRIORITY_LOW}\
        ${ZESHY_IONICE_CLASS_LOW}\
        ${ZESHY_IONICE_CLASS_PRIORITY_LOW}\
        "${@}"
}

# char *run_with_priorities(
#   int nice_priority, int ionice_class, int ionice_class_priority,
#   char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed command under the passed "nice" and "ionice" priorities.
run_with_priorities() {
    # Localize passed arguments.
    die_unless_args
    integer\
        nice_priority="${1}"\
        ionice_class="${2}"\
        ionice_class_priority="${3}"
    shift_three_args

    # Command line to be run, prefixed by commands prioritizing the passed
    # command. All systems provide "nice" but not necessarily "ionice".
    list command_line; command_line=( nice -n${nice_priority} )
    is_installed ionice and command_line+=( ionice
        -c${ionice_class}
        -n${ionice_class_priority}
    )

    # Run.
    command_line+=( "${@}" )
    run "${command_line[@]}"
}

# ....................{ RUNNERS ~ users                    }....................
# void run_as_superuser(
#   char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed command as the superuser.
run_as_superuser() {
    run_as root "${@}"
}

# void run_as(
#   char *username,
#   char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed command as the passed user.
run_as() {
    # Localize passed arguments, stripping off the prefixing username.
    die_unless_at_least_two_args 'expected one username and one command'
    string username="${1}"
    shift_one_arg

    # If the user under which to run the passed command is the current user,
    # defer to the run() command and immediately return.
    is "${username}" == "$(get_current_username)" si and {
        run "${@}"
        return_true
    }

    # Command line to run. Dismantled, this is:
    #
    # * "Q", stripping one level of quote protection from the passed parameters,
    #   undoing prior "(q)" quote protection.
    # * "z", splitting such parameters into Zsh-specific words.
#   sputter_unescaped "command line: ${@}"
    list command_line; command_line=( "${(z)@}" )
#   list command_line; command_line=( "${(Qz)@}" )
    
    #FIXME: Insufficient. Consider "LC_ALL=C ls".
    # Command name to run.
    string command_name="${command_line[1]}"

    #FIXME: Insufficient. Zsh builtins and functions should be executable as
    #other users, though it's probably non-trivial to do so. Perhaps prefix the
    #command line with "zeshy" and augment "bin/zeshy" to handle passed commands?
    die_unless_installed "${command_name}"
    
    # If the target user is the superuser, use "sudo" to take advantage of
    # password caching. Avoid "@", as that splits the command line into discrete
    # arguments. "sudo" and "su" can split their own arguments, thank you.
    if is_superuser "${username}" and is_installed sudo
    then sudo -E  "${command_line}"
    # Otherwise, use "su".
    else su -p -c "${command_line}" "${username}"
    fi
}

# ....................{ WASTELANDS                         }....................
#FIXME: Pretty silly. We don't use this. Consider excising. Actually, it could
#be helpful to generalize this to something like:
#   return_exit_status_if_false
# int one_if(
#   char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed command quietly (i.e., squelching output) and, if exiting
# with success, return "1"; otherwise, return the empty string: e.g.,
#
#     >>> integer IS_MUTT_INSTALLED=$(one_if is_installed mutt)
#     >>> is_nonzero "${IS_MUTT_INSTALLED}" and print '"mutt" is installed'
#     "mutt" is installed
#one_if() {
#    quietly "${@}" and return 1 or return_true
#}

# that preserving escapes and quotes (e.g., "\ ", "'''") in command arguments
# requires protecting arguments with "(q)" prior to calling this function: e.g.,
#
#   # Command to be run.
#   >>> list command_line
#   >>> command_line=( screen -list | grep --count ' )
#
#   # Command arguments to be passed to "grep".
#   >>> list grep_args; grep_args=( --count 'eschaton' )
#   sputter_unescaped "last... \"${command_line[-1]}\"..."
#   eval command ls -l "${command_line[-1]}"
#   eval run_paged command ls -l "${command_line[-1]}"
#   run_it run_paged command ls -l "${command_line[-1]}"
#   run ${command_line[@]}

#FIXME: This function should really be cleaved into two: all of the user-
#specific logic shifted into run_as() and only the eval() retained in this
#function. That shouldn't leave terribly much here... which is good. You know;
#the more I consider it, the more I wonder if run() shouldn't simply be a
#straightforward alias for 'alias'. That would single-handedly eliminate all of
#the "(q)" nonsense... and thereby break everything! The solution is simple:
#
#* Create a new "alias run='eval'" alias.
#* Transition all existing run() calls to run().
#* Rename run() to run_as(), probably with slight implementation changes.

#FIXME: This function should really be cleaved into two: all of the user-
#specific logic shifted into run_as() and only the eval() retained in this
#function. That shouldn't leave terribly much here... which is good. You know;
#the more I consider it, the more I wonder if run() shouldn't simply be a
#straightforward alias for 'alias'. That would single-handedly eliminate all of
#the "(q)" nonsense... and thereby break everything! The solution is simple:
#
#* Create a new "alias run='eval'" alias.
#* Transition all existing run() calls to run().
#* Rename run() to run_as(), probably with slight implementation changes.

# void run(char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed builtin or command, ideally quote-protected to avoid premature
# parsing of shell-specific syntax (e.g., pipes, redirections). Where passing a
# parameter expansion to this function, force such protection with "(q)": e.g.,
#
#   # Good! Manually quote-protect with single or double quotes.
#   >>> run 'screen -list | grep --count eschaton'
#   969
#
#   # Good! Automatically quote-protect with parameter expansion flag "(q)".
#   >>> string command=$(screen -list | grep --count singularity)
#   >>> run "${(q)command}"
#   696
#
#   # Doubleplusungood. Zsh parses the pipe prior to calling run().
#   >>> run screen -list | grep --count eschaton
#run() {
#    die_unless_args 'expected one or more command strings'

    # Command line to run. Dismantled, this is:
    #
    # * "Q", stripping one level of quote protection from the passed parameters,
    #   undoing prior "(q)" quote protection.
    # * "z", splitting such parameters into Zsh-specific words.
#   print "command line: ${@}"
#    list command_line; command_line=( "${(Qz)@}" )
#   list command; command=( "${(Qz)@}" )
#   print "second arg: ${command_line[2]}"
    
    # Command name to run as the first word of such command line.
#   string command_name="${(Q)command_line[1]}"
#    string command_name="${command_line[1]}"
    
    # A string conditionally defined to (in order):
    #
    # * If a Zsh alias, function, or builtin has the command name, that name.
    # * Otherwise, if the current $PATH contains the command name, the absolute
    #   path to that command.
    # * Otherwise, raise an exception.
#    string command_path
#    command_path="$(whence "${command_name}")" or
#        die "\"${command_name}\" not found in \$PATH"

    # If the passed command has not been overridden by a shell alias or
    # function, run it as a command. Do not call the customary is_installed()
    # function, as that does not test whether or not a command is overridden.
#    if is_absolute_path "${command_path}"; then
        # If running this command under a different user, do so.
#        if is_set_nonempty 'ZESHY_RUN_AS' and
#           is "${ZESHY_RUN_AS}" != "${USER}" si; then
            # If the target user is the superuser, use "sudo" to take
            # advantage of password caching. Do *NOT* use the "(@)" expansion in
            # either of the following two commands, as that would split the line
            # into discrete command arguments.
#            if is "${ZESHY_RUN_AS}" == root si and is_installed sudo; then
#               echo "sudoing as ${ZESHY_RUN_AS}: ${command}"
#                sudo -E "${command_line}"
            # Otherwise, use "su".
#            else
#               echo "suing as ${ZESHY_RUN_AS}: ${command}"
#                su --preserve-environment\
#                   --command "${command_line}" "${ZESHY_RUN_AS}"
#            fi
        # Otherwise, run this command as the current user. Use the "[@]"
        # expansion here, as calling the command manually requires we split the
        # line into discrete command arguments. Evaluate this command to ensure
        # the shell correctly handles shell constructs (e.g., "|").
#        else
##           print "evaling: ${command_line[@]}"
#            eval "${command_line[@]}"
#        fi
    #FIXME: Incomplete. How does one run a builtin as another user? Implement.
    # Otherwise, the passed command must be a shell built-in. Evaluate it!
#    else
#       print "evaling: ${command_line[@]}"
#        eval "${command_line[@]}"
#    fi
#}
    # If the second-to-last passed argument is "--", treat the last passed
    # argument as a command line suffix to be appended to the command line.
#   if is_at_least_two_args and is "${@[-2]}" == '--' si; then
#       command_line_suffix="${@[-1]}"
#       pop_two_args
#   fi

    #FIXME: This isn't quite right. The reason why, of course, is long lines.
    #Technically, such lines contain a single newline; when displayed, such
    #lines implicitly force more than a single newline. To account for this,
    #we'll need add a new function get_displayed_line_length() to
    #"shell/terminal". Its implication returns an integer as follows:
    #
    #* For each physical line in the passed string, increment line length by one.
    #* For each 80th character (or what have you) in each physical line in the
    #  passed string, increment line length by one. A simple calculation
    #  obtains this:
    # If not outputting to a terminal of height less than the height of the
    # output produced by this command, immediately return.

#   is_terminal and
#     (( $(get_displayed_line_length "${output}") >  )) or
#     return_true

    # Localize passed arguments.
#   list lines; lines=( "${(f)@}" )

    #FIXME: Is this really the most efficient means of propagating pipes?
#   then run "print -- $(< /dev/stdin)' | ${(q)command_line[@]}"

#   die_unless_at_least_two_args\

# char *testify(
#   char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed command, converting raised exceptions to non-zero exit status.
# This function is particularly helpful for propagating exceptions thrown by
# subshells up the call stack of the current shell. (By default, Zsh does *NOT*
# propagate such exceptions.)
# reliably capturing the standard
# output of exception-throwing functions: e.g.,
#
#     # Bad. Regardless of whether get_first_file() throws an exception, the
#     # declaration of "first_file" silently succeeds.
#     >>> string first_file="$(testify get_first_file /rache /bartmoss)" or
#     ...   die 'neither "/rache" or "/bartmoss" found'
#     
#     # Good. If get_first_file() throws an exception, the declaration of
#     # "first_file" explicitly fails by propagating such exception.
#     >>> string first_file="$(testify get_first_file /rache /bartmoss)" or
#     ...   die 'neither "/rache" or "/bartmoss" found'
#testify() {
#    {
#        run "${(q)@}" 2>&1
#    } always {
#        integer exit_status=${?}
#        (( ${exit_status} )) and exit ${exit_status}
#    }
#}

    #FIXME: ...we appear to no longer require the "Q". (Naturally, I have no
    #firm idea why.)

#   string command_line="$(get_command_line "${@}")"

# Note, commands should be passed as quoted strings to prevent the calling
# shell from evaluating pipes, redirections, et al. prior to passing the
# command. (See the run() function, above.)

    #FIXME: This only strips one dash. How to strip more?
    # Strip prefixing dashes from this string to prevent the "basename" command
    # from intepreting such dashes as options to that command. This is actually
    # a real-world concern. By convention, for example, Linux prefixes login
    # shell command lines with one dash.
#   string process_command_line="${$(get_process_command_line)#-}"
#   string process_command_line="$(get_process_command_line)"
#   process_command_line="${process_command_line#-}"

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
