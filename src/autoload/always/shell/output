#!/usr/bin/env zsh
# ====================[ output                             ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Output, handling standard output and error.
#
# --------------------( TODO                               )--------------------
# * Wherever we currently call "print" unsafely (which is pretty much
#   everywhere), we should instead call utter_raw().

# ....................{ ALIASES                            }....................
#FIXME: Uncomment when working, below.
#interactive_alias cat='page_path_safely'

# ....................{ PRINTERS                           }....................
# void utter_raw(char *string1, char *string2, ...)
#
# Print the passed strings to standard output with default trailing newline.
# Unlike utter(), print no theme-specific nonsense (e.g., ANSI color codes).
# Avoid calling echo() or print(), which fail on hyphen-prefixed strings: e.g.,
#
#     # Bad. Never do this, unless guaranteed no hyphens prefix such string.
#     # If "is ${1} == -* si", Zsh interprets the first word of such string as
#     # options to the "print" command.
#     print "${1}"
#
#     # Good. Always do this.
#     utter_raw "${1}"
utter_raw() {
    die_unless_args 'expected at least one string'
    print -- "${@}"
}

# void curse_raw(char *string1, char *string2, ...)
#
# Print the passed strings to standard error with default trailing newline.
# Unlike curse(), print no theme-specific nonsense (e.g., ANSI color codes).
curse_raw() {
    die_unless_args 'expected at least one string'
    print -- "${@}" 2>&1
}

# ....................{ PRINTERS ~ nulls                   }....................
# void utter_null_delimited(char *string1, char *string2, ...)
#
# Print the passed strings to standard output delimited and terminated by nulls
# (i.e., such that a null '\0' separates each such string from the next and the
# last such string is followed by a null '\0').
utter_null_delimited() {
    die_unless_args 'expected at least one string'
    print -N -- "${@}"
}

# ....................{ PRINTERS ~ newlines                }....................
# void utter_newline_delimited(char *string1, char *string2, ...)
#
# Print the passed strings to standard output delimited by newlines (i.e., such
# that a newline separates each such string from the next).
utter_newline_delimited() {
    die_unless_args 'expected at least one string'
    print -l -- "${@}"
}

# void utter_no_newline_raw(char *string1, char *string2, ...)
#
# Print the passed strings to standard output with no default trailing newline.
utter_no_newline_raw() {
    die_unless_args 'expected at least one string'
    print -n -- "${@}"
}

# void curse_no_newline_raw(char *string1, char *string2, ...)
#
# Print the passed strings to standard error with no default trailing newline.
curse_no_newline_raw() {
    die_unless_args 'expected at least one string'
    print -n -- "${@}"
}

# ....................{ PRINTERS ~ blank lines             }....................
# void utter_blank_line(void)
#
# Print a blank line to standard output.
utter_blank_line() {
    die_if_args
    print
}

# void curse_blank_line(void)
#
# Print a blank line to standard error.
curse_blank_line() {
    die_if_args
    print 2>&1
}

#FIXME: Rename page_safely() to page_nicely(). Rename all other *_safely()-style
#functions, as well. (Other possible suffixes: page_well(), page_truly()). Hmmm;
#no, page_nicely is the best fit. It reads well and best describes the
#underlying intent.

# ....................{ REDIRECTS                          }....................
# char *page_nicely(
#   char *command_name, char *command_arg1, char *command_arg2, ...)  --OR--
#
# Run the passed command with standard output and error piped to the current
# pager if exceeding the terminal height or as is (i.e., without paging) if not,
# returning the exit status of this command as its own.
#
# Customary pager commands block on standard input, thus delaying output until
# after the input command completes operation. Resource-intensive commands not
# completing immediately (e.g., "ls -R *") thus block paging with no
# intermediate output until such commands eventually complete. To rectify such
# interface woes, this function immediately prints all output as received from
# the passed command prior to actually paging such output, as necessary.
page_safely() {
    die_unless_args 'expected one command'

    # Dismantled, this is:
    #
    # * "${(q)@}", quoting this command as required by the run() function.
    # * "1>&1", preserving standard output prior to its subsequent redirection
    #   and hence the assignment of output to variable "output".
    # * "1>&2", redirecting standard output to error. Since command substitution
    #   only captures the former, this immediately prints all output produced by
    #   running such command.
    string output; output="$(run "${(q)@}" 1>&1 1>&2)"

    # If not outputting to a terminal of height less than the height of the
    # output produced by this command, immediately return.
    is_terminal and
      (( $(get_line_length "${output}") > $(get_terminal_height) )) or
      return_success

    # Pager command to be run.
    list pager; pager=( "${PAGER}" )

    # Name of the list with pager options specific to the current pager. If such
    # list exists, append such options to the pager command to be run.
    string pager_options_list_name
    pager_options_list_name="ZESHY_$(get_basename "${PAGER}")_OPTIONS"
    is_list "${pager_options_list_name}" and
        pager+=( "${(@P)pager_options_list_name}" )
    
    # Page.
    utter_raw "${output}" | "${pager[@]}"
}

#FIXME: Implement me, sometime.
# char *page_path_nicely(
#   char *filename1, char *filename2, ...)
page_path_safely() {
    die_unless_args 'expected one or more filenames'
    string output

    #FIXME: This probably isn't behaving as intended. It *SHOULD* be printing
    #file contents to stderr while concatenating together file contents. In
    #practice, it probably just exhumes an error. Hurk!
    for filename ("${@}") {
        output+="$(< "${filename}" 1>&1 1>&2)"
    }
}

#FIXME: Obsolete.
#   die_unless_args 'expected one command or one or more files to be paged'

    # If the first passed argument is a runnable command, assume the argument
    # list is a command line to be run and do so. Dismantled, this is:
    #
    # * "${(q)@}", quoting this command as required by the run() function.
    # * "1>&1", preserving standard output prior to its subsequent redirection
    #   and hence the assignment of output to variable "output".
    # * "1>&2", redirecting standard output to error. Since command substitution
    #   only captures the former, this immediately prints all output produced by
    #   running such command.
#   string first_arg="${1}" output
#   if is_installed "${first_arg}"
#   then output="$(run "${(q)@}" 1>&1 1>&2)"
    # If the first passed argument is a readable file, assume the argument list
    # is a list of files to be paged and do so.
#   elif is_file "${first_arg}"; then
#       for filename ("${@}") {
#           output+="$(< "${filename}" 1>&1 1>&2)"
#       }
    # Otherwise, throw an exception.
#   else die "\"${first_arg}\" neither an installed command or readable file"
#   fi

#   integer exit_status=${ZESHY_SUCCESS_CODE}
# ....................{ PRINTERS                           }....................
# char *utter_raw(char *string1, char *string2, ...)
#
# Print the passed strings to standard output. Unlike utter(), this function
# prints no theme-specific embellishment (e.g., ANSI color codes).
#utter_raw() {
#    die_unless_args 'expected at least one string'
#    print -- "${@}"
#}

# char *curse_raw(char *string1, char *string2, ...)
#
# Print the passed strings to standard error. Unlike curse(), this function
# prints no theme-specific embellishment (e.g., ANSI color codes).
#curse_raw() {
#    die_unless_args 'expected at least one string'
#    print -- "${@}" 2>&1
#}

# char *utter_no_newline_raw(char *string1, char *string2, ...)
#
# Print the passed strings to standard output with no default trailing newline.
#utter_no_newline_raw() {
#    die_unless_args 'expected at least one string'
#    print -n -- "${@}"
#}

# char *curse_no_newline_raw(char *string1, char *string2, ...)
#
# Print the passed strings to standard output with no default trailing newline.
#curse_no_newline_raw() {
#    die_unless_args 'expected at least one string'
#    print -n -- "${@}" 2>&1
#}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
