#!/usr/bin/env zsh
# ====================[ terminal                           ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Terminal, handling terminal emulation attributes (e.g., VT100).
#
# --------------------( SEE ALSO                           )--------------------
# http://ciembor.github.com/4bit
#   4bit, arguably the best (and probably only) terminal color scheme designer.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_terminal(char *error_message = 'not a terminal')
#
# Raise an exception unless the current shell is attached to a terminal device.
die_unless_terminal() {
    die_unless_at_most_one_arg 'expected optional error message'
    is_terminal or die "${1:-not attached to a terminal device}"
}

# ....................{ TESTS                              }....................
# bool is_terminal(void)
#
# Return true if shell output is attached to a terminal device.
#
# Never call this function from a subshell (e.g., "$(is_terminal and print ok)"!
# Subshells cannot readily test file descriptors of their parent shells.
is_terminal() {
    # Return true if the file descriptor for standard output is open and
    # attached to a terminal. (Avoid testing standard input, as commands passed
    # piped input may still be attached to a terminal.)
    die_if_args
    is -t ${ZESHY_STDOUT} si
}

# bool is_color_terminal(void)
#
# Return true if shell output is attached to a terminal device supporting at
# least 8 common colors: black, white, red, green, blue, yellow, magenta, cyan.
#
# Never call this function from a subshell (e.g., "$(is_color_terminal and print
# ok)"! Subshells cannot readily test file descriptors of their parent shells.
is_color_terminal() {
    die_if_args
    is_terminal and (( terminfo[colors] >= 8 ))
}

# ....................{ GETTERS                            }....................
# int get_terminal_height(void)
#
# Get the height in lines of the current terminal device.
get_terminal_height() {
    # Do not call die_unless_terminal(), as subshells have no terminals.
    die_if_args
    sputter "${LINES}"  # also gettable with "tput lines" (overkill)
}

# int get_terminal_width(void)
#
# Get the width in characters of the current terminal device.
get_terminal_width() {
    # Do not call die_unless_terminal(), as subshells have no terminals.
    die_if_args
    sputter "${COLUMNS}"  # also gettable with "tput columns" (overkill)
}

# int get_displayed_line_length(char *string1, char *string2, ...)
#
# Get the total number of lines in the passed strings when displayed on the
# current terminal (i.e., accounting for long lines). This is a number strictly
# greater than or equal to that returned by get_line_length().
get_displayed_line_length() {
    die_unless_args 'expected at least one string'

    # For each line of the passed string, increment line length by the sum of:
    #
    # * "1", for the physical trailing newline.
    # * The number of logical newlines Zsh injects into such string for wrapping
    #   purposes, calculated as the physical line length divided by terminal
    #   width (i.e., maximum logical line length). Add 1 to avoid off-by-one.
    integer displayed_line_length terminal_width
    terminal_width=$(get_terminal_width)
    for line ("${(f)@}") {
        displayed_line_length+=$(( 1 + ${#line} / (terminal_width + 1) ))
    }

    sputter ${displayed_line_length}
}

#FIXME: Provide additional terminfo-based capabilities. See "man terminfo".
# ....................{ WRITERS                            }....................
# void clear_terminal_screen(void)
#
# Clear the current terminal of all prior output. This function implements a
# pure-Zsh analogue of the "clear" command.
clear_terminal_screen() {
    die_if_args
    die_unless_terminal

    # Oddly, the terminfo "clear" capability moves the cursor to the second
    # rather than first line after clearing the screen. Amend this.
    echoti clear
    move_terminal_cursor_to 1 1
}

#FIXME: Add support for negative index offsets.
# void move_terminal_cursor_to(int column, int row)
#
# Move the cursor on the current terminal to the passed 1-based column and row
# indices.
move_terminal_cursor_to() {
    # Validate passed arguments.
    die_unless_two_args 'expected one column and one row index'
    die_unless_terminal
    die_unless_nonnegative_integral "${1}"
    die_unless_nonnegative_integral "${2}"
    integer column="${1}" row="${2}"
    (( column <= $(get_terminal_width) )) or die\
        "column ${column} exceeds terminal width $(get_terminal_width)"
    (( row <= $(get_terminal_height) )) or die\
        "row ${row} exceeds terminal height $(get_terminal_height)"

    # Convert Zsh-style 1-based indices to "terminfo"-style 0-based indices.
    echoti cup $(( ${row} - 1 )) $(( ${column} - 1 ))
}

# ....................{ SETUP                              }....................
setup_terminal() {
    die_if_args
    die_unless_terminal
    setup_terminal_options
    setup_terminal_colors
}

setup_terminal_options() {
    # Permit use of meta characters (i.e., characters setting the high bit).
    set meta-flag    on
    set input-meta   on
    set output-meta  on
    set convert-meta off

    # Numerous applications complain under long ${TERM} strings (e.g.,
    # "rtorrent"). Truncate such strings to equivalent abbreviations.
    is "${TERM}" == 'rxvt-unicode-256color' si and {
        utter 'truncating ${TERM} to "rxvt-unicode" for safety...'
        TERM='rxvt-unicode'
    }
}

# void setup_terminal_colors()
#
# Define colors only under color-aware terminals. When under color-unaware
# terminals, the variables below are left undefined and thus expand without
# error to nothing when evaluated in the context of an actual prompt.
setup_terminal_colors() {
    die_if_args
    is_color_terminal or return_true

    # Colorize "ls" by importing the ${LS_COLORS} global.
    is_installed dircolors and
        source_safely_command_output 'sh' 'dircolors --sh'

    # Declare color-specific dictionaries: $fg, $fg_bold, $fg_no_bold, $bg,
    # $bg_bold, and $bg_no_bold. In each such dictionary, keys are color
    # names (e.g., "red") and values terminal-specific strings activating that
    # color combination under the current output.
    colors

    # Surround each color definition in "%{...%}"; this informs ZSH that, when
    # performing prompt expansion, these strings do not contribute to the length
    # of that prompt.
    string color_name_lowercase_string
    for color_name (WHITE BLACK RED GREEN BLUE YELLOW MAGENTA CYAN) {
        color_name_lowercase_string="$(lowercase_string ${color_name})"
        eval "global_string\
            FG_${color_name}='%{${fg_no_bold[${color_name_lowercase_string}]}%}'\
            FG_${color_name}_BOLD='%{${fg_bold[${color_name_lowercase_string}]}%}'\
            BG_${color_name}='%{${bg_no_bold[${color_name_lowercase_string}]}%}'\
            BG_${color_name}_BOLD='%{${bg_bold[${color_name_lowercase_string}]}%}'"
#           eval global_string FG_${color_name}='%{$fg_no_bold[${(L)color_name}]%}'
#           eval global_string FG_${color_name}_BOLD='%{$fg_bold[${(L)color_name}]%}'
#           eval global_string BG_${color_name}='%{$bg_no_bold[${(L)color_name}]%}'
#           eval global_string BG_${color_name}_BOLD='%{$bg_bold[${(L)color_name}]%}'
    }

    # Define hard-coded ANSI color codes for use below.
    integer ansi_black=0 ansi_white=7 ansi_intense=9

    # Define reset "colors" (i.e., resetting colors to their defaults).
    global_string FG_RESET="%{${reset_color}%}" BG_RESET="%{${reset_color}%}"

    # Redefine foreground greyscale colors. The above definitions assign
    # FG_BLACK a somewhat unreadable pure-black color value and FG_WHITE a
    # grey rather than white color value.
    #
    # Note: the substring "$'\033['" cannot be interpolated into the prior
    # and subsequent strings as "\$\033[". (We can't recall why; do you?)
    global_string\
        FG_BLACK="${FG_RESET}%{"$'\033['"${ansi_intense}${ansi_black}m%}"\
        FG_WHITE="${FG_RESET}%{"$'\033['"${ansi_intense}${ansi_white}m%}"\
        FG_WHITE_BOLD="%{${fg_bold[white]}%}"\
        FG_GREY="%{${fg_no_bold[white]}%}"\
        FG_GREY_BOLD="${FG_WHITE}"
#           FG_GREY_BOLD="%{${fg_bold[black]}%}"
}

# --------------------( WASTELANDS                         )--------------------
    # Exit status of this command.
#   string output; output="$(run "${(q)@}" 1>&1 1>&2)" or exit_status=${?}
#   integer exit_status="${?}"
#   string output="$(eval "${(q)@}" 1>&1 1>&2)"
#   string output="$((eval "${@}") 1>&1 1>&2)"
#   utter "running: ${*}"
#   utter "output: ${output}"
#   mutter 'line_length: '; print $(get_line_length "${output}")
#   utter "terminal_height: $(get_terminal_height)"

    # Return the exit status of this command.
#   false
#   utter "running: ${*}"
#   return "${exit_status}"

#FIXME: We currently define the "LESS" global (probably in "zshrc"), defining
#global "less" options. Shift to Zeshy "config", renamed to
#"ZESHY_PAGER_OPTIONS", and explicitly apply such global below. (We don't need
#interactive and non-interactive forms, obviously -- it's always interactive!)

        #FIXME: Ugh. This should just go into "ZESHY_PAGER_OPTIONS", clearly.
        # If "less" is the current pager, pass the following options:
        #
        # * "--no-init", avoiding clearing the screen on initialization.
#       if is "${PAGER}" == less si
#       then pager+=( '--no-init' )
#       fi

#   string output="$(unify_output "${@}")"
#   utter "output: ${output}"
    # Otherwise, print as is.
#   else
#       print "${output}" 
#   fi

#   print "page command line: ${*}"
#   print "page second arg: ${2}"
#   run "${(q)@} 2>&1 | '${PAGER:-less}'"

# char *ask_yes_or_no(char *question, char *choices = 'yn', char *true_answer = 'y')
#
# Ask the user an interactive yes or no question suffixed by the passed choices,
# returning false unless the user responds with exactly the passed true answer.
#ask_yes_or_no() {
#    die_unless_at_least_one_arg 'expected exactly one question'
#
#    string question="${1}"
#    string choices="${2:-yn}"
#    string true_answer="${3:-y}"
#
#    # Sow the question and harvest the response.
#    mutter "${question} [${choices}] "
#    string answer
#
#    # If the caller requests the default choices, read exactly one 
#    read   answer
#    is "${answer}" == "${true_answer}" si
#} 

#emulate -R sh -c 'eval "$(dircolors --sh)"'
# Dismantled, this is:
        # * "(L}", lowercasing the current color name. The maps colors() defines
        #   have lowercase_string rather than uppercase_string keys.

    # Coerce the response to lowercase_string for comparability and compare.
#   is_sure="$(lowercase_string "${is_sure}")"
#   is "${is_sure}" == y || "${is_sure}" == ye || "${is_sure}" == yes si
#
    # Define ANSI colors for the ANSI shell prompt, below.
    #export   PROMPT_BLACK="%{"$'\033[${FG_BLACK_HIGH}m'"%}"
    #export    PROMPT_GREY="%{"$'\033[${FG_BLACK}m'"%}"
    #export     PROMPT_RED="%{"$'\033[${FG_RED_HIGH}m'"%}"
    #export   PROMPT_GREEN="%{"$'\033[${FG_GREEN_HIGH}m'"%}"
    #export  PROMPT_YELLOW="%{"$'\033[${FG_YELLOW_HIGH}m'"%}"
    #export    PROMPT_BLUE="%{"$'\033[${FG_BLUE_HIGH}m'"%}"
    #export PROMPT_MAGENTA="%{"$'\033[${FG_MAGENTA_HIGH}m'"%}"
    #export    PROMPT_CYAN="%{"$'\033[${FG_CYAN_HIGH}m'"%}"
    #export   PROMPT_WHITE="%{"$'\033[${FG_WHITE}m'"%}"

    # Define ANSI colors for "print" and "echo" uses, below.
    #export   BLACK="\e[${FG_BLACK_HIGH}m"
    #export     RED="\e[${FG_RED_HIGH}m"
    #export   GREEN="\e[${FG_GREEN_HIGH}m"
    #export  YELLOW="\e[${FG_YELLOW_HIGH}m"
    #export    BLUE="\e[${FG_BLUE}m"
    #export MAGENTA="\e[${FG_MAGENTA_HIGH}m"
    #export    CYAN="\e[${FG_CYAN}m"
    #export   WHITE="\e[${FG_WHITE}m"
    #export    BOLD="\e[${INTENSITY_BOLD};${FG_RESET}m"
    #export  NORMAL="\e[${INTENSITY_NORMAL};${FG_RESET}m"
    #export   RESET="\e[${FG_RESET}m"
# ....................{ STREAMS                            }....................
# Load the "colors" module. This defines the function "colors" that, when
# called, itself defines in excess of six associative arrays: $fg, $fg_bold,
# $fg_no_bold, $bg, $bg_bold, and $bg_no_bold. Each array, when indexed by
# color name (e.g., $bg_bold{red}), further expands to the terminal-specific
# string activating that color combination under the current output.
#autoload -U colors

#FIXME: Causes the "su" command to fail to output its data. Hm; obviously, this
#is a flawed approach. Research alternatives.
# Color all debug, warning, and error output for all processes: in particular,
# color all output sent by each process to the process-specific stderr "file".
#exec 2>>(\
#    while read LINE; do \
#        print -P "${FG_RED_BOLD}${(q)LINE}${FG_RESET}" > '/dev/tty'; \
#        print -n $'\0'; \
#    done &)

# ....................{ COLORS                             }....................
# See "http://en.wikipedia.org/wiki/ANSI_escape_code", for further details.

# Color bases.
#  BASE_BLACK="0"
#  FG_BLACK_HIGH="9${BASE_BLACK}"
#  PROMPT_BLACK="%{"$'\033[${FG_BLACK_HIGH}m'"%}"
#    BASE_RED="1"
#  BASE_GREEN="2"
# BASE_YELLOW="3"
#   BASE_BLUE="4"
#BASE_MAGENTA="5"
#   BASE_CYAN="6"
#  BASE_WHITE="7"
#  BASE_RESET="9"

# Color foregrounds.
#  FG_BLACK="3${BASE_BLACK}"
#    FG_RED="3${BASE_RED}"
#  FG_GREEN="3${BASE_GREEN}"
# FG_YELLOW="3${BASE_YELLOW}"
#   FG_BLUE="3${BASE_BLUE}"
#FG_MAGENTA="3${BASE_MAGENTA}"
#   FG_CYAN="3${BASE_CYAN}"
#  FG_WHITE="3${BASE_WHITE}"
#  FG_RESET="3${BASE_RESET}"

# Color backgrounds.
#  BG_BLACK="4${BASE_BLACK}"
#    BG_RED="4${BASE_RED}"
#  BG_GREEN="4${BASE_GREEN}"
# BG_YELLOW="4${BASE_YELLOW}"
#   BG_BLUE="4${BASE_BLUE}"
#BG_MAGENTA="4${BASE_MAGENTA}"
#   BG_CYAN="4${BASE_CYAN}"
#  BG_WHITE="4${BASE_WHITE}"
#  BG_RESET="4${BASE_RESET}"

# Color foregrounds (high intensity).
#  FG_BLACK_HIGH="9${BASE_BLACK}"
#  PROMPT_BLACK="%{"$'\033[${FG_BLACK_HIGH}m'"%}"
#    FG_RED_HIGH="9${BASE_RED}"
#  FG_GREEN_HIGH="9${BASE_GREEN}"
# FG_YELLOW_HIGH="9${BASE_YELLOW}"
#   FG_BLUE_HIGH="9${BASE_BLUE}"
#FG_MAGENTA_HIGH="9${BASE_MAGENTA}"
#   FG_CYAN_HIGH="9${BASE_CYAN}"
#  FG_WHITE_HIGH="9${BASE_WHITE}"
#  FG_RESET_HIGH="9${BASE_RESET}"

# Color backgrounds (high intensity).
#  BG_BLACK_HIGH="10${BASE_BLACK}"
#    BG_RED_HIGH="10${BASE_RED}"
#  BG_GREEN_HIGH="10${BASE_GREEN}"
# BG_YELLOW_HIGH="10${BASE_YELLOW}"
#   BG_BLUE_HIGH="10${BASE_BLUE}"
#BG_MAGENTA_HIGH="10${BASE_MAGENTA}"
#   BG_CYAN_HIGH="10${BASE_CYAN}"
#  BG_WHITE_HIGH="10${BASE_WHITE}"
#  BG_RESET_HIGH="10${BASE_RESET}"

# Color attributes.
#           RESET="00"
#INTENSITY_NORMAL="22"
#  INTENSITY_BOLD="01"
# INTENSITY_FAINT="02"
#       ITALIC_ON="03"
#UNDERLINE_SINGLE="04"
#UNDERLINE_DOUBLE="21"
#   UNDERLINE_OFF="24"
#      BLINK_SLOW="05"
#      BLINK_FAST="06"
#       BLINK_OFF="25"
#  IMAGE_NEGATIVE="07"  # inverse (reverse), swapping foreground and background
#  IMAGE_POSITIVE="27"
#         CONCEAL="08"
#          REVEAL="28"

# Define (but do not export) ANSI colors for the ANSI shell prompt, below.
#  PROMPT_BLACK="%{"$'\033[${FG_BLACK_HIGH}m'"%}"
#    PROMPT_RED="%{"$'\033[${FG_RED_HIGH}m'"%}"
#  PROMPT_GREEN="%{"$'\033[${FG_GREEN_HIGH}m'"%}"
# PROMPT_YELLOW="%{"$'\033[${FG_YELLOW_HIGH}m'"%}"
#   PROMPT_BLUE="%{"$'\033[${FG_BLUE}m'"%}"
#PROMPT_MAGENTA="%{"$'\033[${FG_MAGENTA_HIGH}m'"%}"
#   PROMPT_CYAN="%{"$'\033[${FG_CYAN_HIGH}m'"%}"
#  PROMPT_WHITE="%{"$'\033[${FG_WHITE}m'"%}"

# Define (but do not export) ANSI colors for "print" and "echo" uses, below.
#  BLACK="\e[${FG_BLACK_HIGH}m"
#    RED="\e[${FG_RED_HIGH}m"
#  GREEN="\e[${FG_GREEN_HIGH}m"
# YELLOW="\e[${FG_YELLOW_HIGH}m"
#   BLUE="\e[${FG_BLUE}m"
#MAGENTA="\e[${FG_MAGENTA_HIGH}m"
#   CYAN="\e[${FG_CYAN_HIGH}m"
#  WHITE="\e[${FG_WHITE}m"
#   BOLD="\e[${INTENSITY_BOLD};${FG_RESET}m"
# NORMAL="\e[${INTENSITY_NORMAL};${FG_RESET}m"
#  RESET="\e[${FG_RESET}m"
