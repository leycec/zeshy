#!/usr/bin/env zsh
# ====================[ terminal                           ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Terminal.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_terminal(char *error_message = 'not a terminal')
#
# Raise an exception unless the current shell is attached to a terminal device.
die_unless_terminal() {
    die_unless_at_most_one_arg 'expected optional error message'
    is_terminal or die "${1:-not attached to a terminal device}"
}

# ....................{ TESTS                              }....................
# bool is_terminal(void)
#
# Return true if the current shell is attached to a terminal device, especially
# useful for avoiding "stty"-related errors when not attached to such a device
# resembling "stty: standard input: Invalid argument".
is_terminal() {
    # Return true if file descriptor 0 (i.e., standard input) is open and
    # attached to a terminal device, an admittedly circuitous test.
    die_unless_no_args
    is -t 0 si
}

# ....................{ GETTERS                            }....................
# int get_terminal_height(void)
#
# Get the height in lines of the current terminal device.
get_terminal_height() {
    die_unless_no_args
    die_unless_terminal
    print "${LINES}"  # also retrievable with "tput lines" (...overkill)
}

# int get_terminal_width(void)
#
# Get the width in characters of the current terminal device.
get_terminal_width() {
    die_unless_no_args
    die_unless_terminal
    print "${COLUMNS}"  # also retrievable with "tput columns" (...overkill)
}

# ....................{ REDIRECTS                          }....................
# char *page_safely(
#   char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Run the passed command with standard output and error piped to the current
# pager if exceeding the terminal height or as is (i.e., without paging) if not.
#
# Customary pager commands block on standard input, thus delaying output until
# after the input command completes operation. Resource-intensive commands not
# completing immediately (e.g., "ls -R *") thus block paging with no
# intermediate output until such commands eventually complete. To rectify such
# interface woes, this function immediately prints all output as received from
# the passed command prior to actually paging such output, as necessary.
page_safely() {
    # Run the passed command. Dismantled, this is:
    #
    # * "${(q)@}", quoting this command as required by the run() function.
    # * "1>&1", preserving standard output prior to its subsequent redirection
    #   and hence the assignment of output to variable "output".
    # * "1>&2", redirecting standard output to error. Since command substitution
    #   only captures the former, this immediately prints all output produced by
    #   running such command.
    die_unless_at_least_one_arg 'expected a command'
    string output="$(run "${(q)@}" 1>&1 1>&2)"
#   string output="$(eval "${(q)@}" 1>&1 1>&2)"
#   string output="$((eval "${@}") 1>&1 1>&2)"
#   utter "running: ${*}"
#   utter "output: ${output}"
#   mutter 'line_length: '; print $(get_line_length "${output}")
#   utter "terminal_height: $(get_terminal_height)"

    # If not outputting to a terminal of height less than the height of the
    # output produced by such command, immediately return; otherwise, page.
    if is_terminal and
      (( $(get_line_length "${output}") > $(get_terminal_height) )); then
        # Pager command to be run.
        list pager; pager=( "${PAGER}" )

        # Name of the list with pager options specific to this pager command.
        string pager_options_list_name="ZESHY_$(get_basename "${PAGER}")_OPTIONS"

        # If such list exists, append its options to the pager command.
        is_list "${pager_options_list_name}" and
            pager+=( "${(@P)pager_options_list_name}" )
        
        # Page.
        print "${output}" | "${pager[@]}"
    fi
}

# ....................{ SETUP                              }....................
setup_terminal() {
    die_unless_no_args
    setup_terminal_options
    setup_terminal_colors
}

setup_terminal_options() {
    # Permit use of meta characters (i.e., characters setting the high bit).
    set meta-flag    on
    set input-meta   on
    set output-meta  on
    set convert-meta off

    # Numerous applications complain under long ${TERM} strings (e.g.,
    # "rtorrent"). Truncate such strings to equivalent abbreviations.
    if is "${TERM}" == 'rxvt-unicode-256color' si; then
        utter 'truncating ${TERM} to "rxvt-unicode" for safety...'
        TERM='rxvt-unicode'
    fi
}

# void setup_terminal_colors()
#
# Define colors only under color-aware terminals. When under color-unaware
# terminals, the variables below are left undefined and thus expand without
# error to nothing when evaluated in the context of an actual prompt.
setup_terminal_colors() {
    die_unless_no_args

    # If the current terminal supports at least the customary eight colors
    # (i.e., white, red, green, blue, yellow, magenta, cyan), support colors.
    if (( terminfo[colors] >= 8 )); then
        # Colorize "ls" by importing the ${LS_COLORS} global.
        is_installed dircolors and
            source_safely_command_output 'sh' 'dircolors --sh'

        # Declare color-specific dictionaries: $fg, $fg_bold, $fg_no_bold, $bg,
        # $bg_bold, and $bg_no_bold. In each such dictionary, keys are color
        # names (e.g., "red") and values terminal-specific strings activating that
        # color combination under the current output.
        colors

        # Surround each color definition in "%{...%}"; this informs ZSH that, when
        # performing prompt expansion, these strings do not contribute to the length
        # of that prompt.
        string color_name_lowercase
        for color_name (WHITE BLACK RED GREEN BLUE YELLOW MAGENTA CYAN) {
            color_name_lowercase="$(to_lowercase ${color_name})"
            eval "global_string\
                FG_${color_name}='%{${fg_no_bold[${color_name_lowercase}]}%}'\
                FG_${color_name}_BOLD='%{${fg_bold[${color_name_lowercase}]}%}'\
                BG_${color_name}='%{${bg_no_bold[${color_name_lowercase}]}%}'\
                BG_${color_name}_BOLD='%{${bg_bold[${color_name_lowercase}]}%}'"
#           eval global_string FG_${color_name}='%{$fg_no_bold[${(L)color_name}]%}'
#           eval global_string FG_${color_name}_BOLD='%{$fg_bold[${(L)color_name}]%}'
#           eval global_string BG_${color_name}='%{$bg_no_bold[${(L)color_name}]%}'
#           eval global_string BG_${color_name}_BOLD='%{$bg_bold[${(L)color_name}]%}'
        }

        # Define hard-coded ANSI color codes for use below.
        integer ansi_black=0 ansi_white=7 ansi_intense=9
     
        # Define reset "colors" (i.e., resetting colors to their defaults).
        global_string FG_RESET="%{${reset_color}%}" BG_RESET="%{${reset_color}%}"

        # Redefine foreground greyscale colors. The above definitions assign
        # FG_BLACK a somewhat unreadable pure-black color value and FG_WHITE a
        # grey rather than white color value.
        #
        # Note: the substring "$'\033['" cannot be interpolated into the prior
        # and subsequent strings as "\$\033[". (We can't recall why; do you?)
        global_string\
            FG_BLACK="${FG_RESET}%{"$'\033['"${ansi_intense}${ansi_black}m%}"\
            FG_WHITE="${FG_RESET}%{"$'\033['"${ansi_intense}${ansi_white}m%}"\
            FG_WHITE_BOLD="%{${fg_bold[white]}%}"\
            FG_GREY="%{${fg_no_bold[white]}%}"\
            FG_GREY_BOLD="%{${fg_bold[black]}%}"
    fi
}

#FIXME: Obsolete.
#FIXME: We currently define the "LESS" global (probably in "zshrc"), defining
#global "less" options. Shift to Zeshy "config", renamed to
#"ZESHY_PAGER_OPTIONS", and explicitly apply such global below. (We don't need
#interactive and non-interactive forms, obviously -- it's always interactive!)

        #FIXME: Ugh. This should just go into "ZESHY_PAGER_OPTIONS", clearly.
        # If "less" is the current pager, pass the following options:
        #
        # * "--no-init", avoiding clearing the screen on initialization.
#       if is "${PAGER}" == less si
#       then pager+=( '--no-init' )
#       fi

#   string output="$(jointly "${@}")"
#   utter "output: ${output}"
    # Otherwise, print as is.
#   else
#       print "${output}" 
#   fi

#   print "page command line: ${*}"
#   print "page second arg: ${2}"
#   run "${(q)@} 2>&1 | '${PAGER:-less}'"

# char *ask_bool(char *question, char *choices = 'yn', char *true_answer = 'y')
#
# Ask the user an interactive yes or no question suffixed by the passed choices,
# returning false unless the user responds with exactly the passed true answer.
#ask_bool() {
#    die_unless_at_least_one_arg 'expected exactly one question'
#
#    string question="${1}"
#    string choices="${2:-yn}"
#    string true_answer="${3:-y}"
#
#    # Sow the question and harvest the response.
#    mutter "${question} [${choices}] "
#    string answer
#
#    # If the caller requests the default choices, read exactly one 
#    read   answer
#    is "${answer}" == "${true_answer}" si
#} 

#emulate -R sh -c 'eval "$(dircolors --sh)"'
# Dismantled, this is:
        # * "(L}", lowercasing the current color name. The maps colors() defines
        #   have lowercase rather than uppercase keys.

    # Coerce the response to lowercase for comparability and compare.
#   is_sure="$(to_lowercase "${is_sure}")"
#   is "${is_sure}" == y || "${is_sure}" == ye || "${is_sure}" == yes si
#
    # Define ANSI colors for the ANSI shell prompt, below.
    #export   PROMPT_BLACK="%{"$'\033[${FG_BLACK_HIGH}m'"%}"
    #export    PROMPT_GREY="%{"$'\033[${FG_BLACK}m'"%}"
    #export     PROMPT_RED="%{"$'\033[${FG_RED_HIGH}m'"%}"
    #export   PROMPT_GREEN="%{"$'\033[${FG_GREEN_HIGH}m'"%}"
    #export  PROMPT_YELLOW="%{"$'\033[${FG_YELLOW_HIGH}m'"%}"
    #export    PROMPT_BLUE="%{"$'\033[${FG_BLUE_HIGH}m'"%}"
    #export PROMPT_MAGENTA="%{"$'\033[${FG_MAGENTA_HIGH}m'"%}"
    #export    PROMPT_CYAN="%{"$'\033[${FG_CYAN_HIGH}m'"%}"
    #export   PROMPT_WHITE="%{"$'\033[${FG_WHITE}m'"%}"

    # Define ANSI colors for "print" and "echo" uses, below.
    #export   BLACK="\e[${FG_BLACK_HIGH}m"
    #export     RED="\e[${FG_RED_HIGH}m"
    #export   GREEN="\e[${FG_GREEN_HIGH}m"
    #export  YELLOW="\e[${FG_YELLOW_HIGH}m"
    #export    BLUE="\e[${FG_BLUE}m"
    #export MAGENTA="\e[${FG_MAGENTA_HIGH}m"
    #export    CYAN="\e[${FG_CYAN}m"
    #export   WHITE="\e[${FG_WHITE}m"
    #export    BOLD="\e[${INTENSITY_BOLD};${FG_RESET}m"
    #export  NORMAL="\e[${INTENSITY_NORMAL};${FG_RESET}m"
    #export   RESET="\e[${FG_RESET}m"
# ....................{ STREAMS                            }....................
# Load the "colors" module. This defines the function "colors" that, when
# called, itself defines in excess of six associative arrays: $fg, $fg_bold,
# $fg_no_bold, $bg, $bg_bold, and $bg_no_bold. Each array, when indexed by
# color name (e.g., $bg_bold{red}), further expands to the terminal-specific
# string activating that color combination under the current output.
#autoload -U colors

#FIXME: Causes the "su" command to fail to output its data. Hm; obviously, this
#is a flawed approach. Research alternatives.
# Color all debug, warning, and error output for all processes: in particular,
# color all output sent by each process to the process-specific stderr "file".
#exec 2>>(\
#    while read LINE; do \
#        print -P "${FG_RED_BOLD}${(q)LINE}${FG_RESET}" > '/dev/tty'; \
#        print -n $'\0'; \
#    done &)

# ....................{ COLORS                             }....................
# See "http://en.wikipedia.org/wiki/ANSI_escape_code", for further details.

# Color bases.
#  BASE_BLACK="0"
#  FG_BLACK_HIGH="9${BASE_BLACK}"
#  PROMPT_BLACK="%{"$'\033[${FG_BLACK_HIGH}m'"%}"
#    BASE_RED="1"
#  BASE_GREEN="2"
# BASE_YELLOW="3"
#   BASE_BLUE="4"
#BASE_MAGENTA="5"
#   BASE_CYAN="6"
#  BASE_WHITE="7"
#  BASE_RESET="9"

# Color foregrounds.
#  FG_BLACK="3${BASE_BLACK}"
#    FG_RED="3${BASE_RED}"
#  FG_GREEN="3${BASE_GREEN}"
# FG_YELLOW="3${BASE_YELLOW}"
#   FG_BLUE="3${BASE_BLUE}"
#FG_MAGENTA="3${BASE_MAGENTA}"
#   FG_CYAN="3${BASE_CYAN}"
#  FG_WHITE="3${BASE_WHITE}"
#  FG_RESET="3${BASE_RESET}"

# Color backgrounds.
#  BG_BLACK="4${BASE_BLACK}"
#    BG_RED="4${BASE_RED}"
#  BG_GREEN="4${BASE_GREEN}"
# BG_YELLOW="4${BASE_YELLOW}"
#   BG_BLUE="4${BASE_BLUE}"
#BG_MAGENTA="4${BASE_MAGENTA}"
#   BG_CYAN="4${BASE_CYAN}"
#  BG_WHITE="4${BASE_WHITE}"
#  BG_RESET="4${BASE_RESET}"

# Color foregrounds (high intensity).
#  FG_BLACK_HIGH="9${BASE_BLACK}"
#  PROMPT_BLACK="%{"$'\033[${FG_BLACK_HIGH}m'"%}"
#    FG_RED_HIGH="9${BASE_RED}"
#  FG_GREEN_HIGH="9${BASE_GREEN}"
# FG_YELLOW_HIGH="9${BASE_YELLOW}"
#   FG_BLUE_HIGH="9${BASE_BLUE}"
#FG_MAGENTA_HIGH="9${BASE_MAGENTA}"
#   FG_CYAN_HIGH="9${BASE_CYAN}"
#  FG_WHITE_HIGH="9${BASE_WHITE}"
#  FG_RESET_HIGH="9${BASE_RESET}"

# Color backgrounds (high intensity).
#  BG_BLACK_HIGH="10${BASE_BLACK}"
#    BG_RED_HIGH="10${BASE_RED}"
#  BG_GREEN_HIGH="10${BASE_GREEN}"
# BG_YELLOW_HIGH="10${BASE_YELLOW}"
#   BG_BLUE_HIGH="10${BASE_BLUE}"
#BG_MAGENTA_HIGH="10${BASE_MAGENTA}"
#   BG_CYAN_HIGH="10${BASE_CYAN}"
#  BG_WHITE_HIGH="10${BASE_WHITE}"
#  BG_RESET_HIGH="10${BASE_RESET}"

# Color attributes.
#           RESET="00"
#INTENSITY_NORMAL="22"
#  INTENSITY_BOLD="01"
# INTENSITY_FAINT="02"
#       ITALIC_ON="03"
#UNDERLINE_SINGLE="04"
#UNDERLINE_DOUBLE="21"
#   UNDERLINE_OFF="24"
#      BLINK_SLOW="05"
#      BLINK_FAST="06"
#       BLINK_OFF="25"
#  IMAGE_NEGATIVE="07"  # inverse (reverse), swapping foreground and background
#  IMAGE_POSITIVE="27"
#         CONCEAL="08"
#          REVEAL="28"

# Define (but do not export) ANSI colors for the ANSI shell prompt, below.
#  PROMPT_BLACK="%{"$'\033[${FG_BLACK_HIGH}m'"%}"
#    PROMPT_RED="%{"$'\033[${FG_RED_HIGH}m'"%}"
#  PROMPT_GREEN="%{"$'\033[${FG_GREEN_HIGH}m'"%}"
# PROMPT_YELLOW="%{"$'\033[${FG_YELLOW_HIGH}m'"%}"
#   PROMPT_BLUE="%{"$'\033[${FG_BLUE}m'"%}"
#PROMPT_MAGENTA="%{"$'\033[${FG_MAGENTA_HIGH}m'"%}"
#   PROMPT_CYAN="%{"$'\033[${FG_CYAN_HIGH}m'"%}"
#  PROMPT_WHITE="%{"$'\033[${FG_WHITE}m'"%}"

# Define (but do not export) ANSI colors for "print" and "echo" uses, below.
#  BLACK="\e[${FG_BLACK_HIGH}m"
#    RED="\e[${FG_RED_HIGH}m"
#  GREEN="\e[${FG_GREEN_HIGH}m"
# YELLOW="\e[${FG_YELLOW_HIGH}m"
#   BLUE="\e[${FG_BLUE}m"
#MAGENTA="\e[${FG_MAGENTA_HIGH}m"
#   CYAN="\e[${FG_CYAN_HIGH}m"
#  WHITE="\e[${FG_WHITE}m"
#   BOLD="\e[${INTENSITY_BOLD};${FG_RESET}m"
# NORMAL="\e[${INTENSITY_NORMAL};${FG_RESET}m"
#  RESET="\e[${FG_RESET}m"

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
