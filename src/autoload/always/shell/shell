#!/usr/bin/env zsh
# ====================[ shell                              ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Shell, implementing shell-handling functionality: e.g.,
#
# * Command-line argument parsing fuctionality for specifying and obtaining
#   shell script arguments. 

# ....................{ EXCEPTIONS                         }....................
# void die_unless_set(char *variable_name, char *error_message = 'not set')
#
# Raise an exception unless the passed variable is set in the current scope.
die_unless_set() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    string variable_name="${1}"
    is_set "${variable_name}" or die "${2:-\"${variable_name}\" not set}"
}

# void die_unless_unset(char *variable_name, char *error_message = 'already set')
#
# Raise an exception unless the passed variable is unset in the current scope.
die_unless_unset() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    string variable_name="${1}"
    is_unset "${variable_name}" or die "${2:-\"${variable_name}\" already set}"
}

# ....................{ TESTS ~ variables                  }....................
# bool is_set_nonempty(char *variable_name)
#
# Return true if the variable with the passed name is set and non-empty.
is_set_nonempty() {
    die_unless_one_arg 'expected exactly one variable name'
    is -n "${(P)1-}" si    # See below.
}

# bool is_set(char *variable_name)
#
# Return true if the variable with the passed name is set (i.e., declared).
is_set() {
    die_unless_one_arg 'expected exactly one variable name'

    # Dismantled, this is:
    # 
    # * "1", the passed name.
    # * "(P)", the variable the passed name refers to.
    # * "+x", the value to expand this variable to if set. Since any non-empty
    #   value will do, arbitrarily use "x".
    # * "-n", true only if this variable is "x" and hence set.
    is -n "${(P)1+x}" si
}

# bool is_unset(char *string)
#
# Return true if the  variable with the passed name is unset (i.e., undeclared).
is_unset() {
    die_unless_one_arg 'expected exactly one variable name'
    is -z "${(P)1+x}" si  # negate the condition is_set() tests for
}

#FIXME: Rename is_nonzero(), in keeping with Zsh nomenclature.
# bool is_nonempty(char *string)
#
# Return true if the passed string is non-empty (i.e., not "").
is_nonempty() {
    die_unless_one_arg 'expected exactly one string'
    is -n "${1}" si
}

#FIXME: Rename is_zero(), in keeping with Zsh nomenclature.
# bool is_empty(char *string)
#
# Return true if the passed string is empty (i.e., "").
is_empty() {
    die_unless_one_arg 'expected exactly one string'
    is -z "${1}" si
}

# ....................{ TESTS ~ modules                    }....................
#FIXME: Uhm; how actually does one do this? The Zsh manual explicitly suggests
#the best method is:
#
#    quietly zmodload "${1}"
#
#But this is demonstrably silly. A test method shouldn't actually have non-
#idempotent side effects.

# void is_module(char *module_name)
#
# Return true if Zsh provides some module with the passed name.
#is_module() {
#    die_unless_one_arg 'expected exactly one module name'
#    zmodload "${1}"
#}

# ....................{ VARIABLES                          }....................
# void freeze_variable(char *variable_name)
#
# Freeze the variable with the passed name, rendering such variable read-only
# (i.e., "const", "final").
freeze_variable() {
    die_unless_one_arg 'expected exactly one variable name'
    string variable_name="${1}"
    die_unless_set "${variable_name}"
    typeset -r     "${variable_name}"
}

# ....................{ CALLABLES                          }....................
# void disable_function(char *function_name1, char *function_name2, ...)
#
# Globally disable the function with the passed name. This function remains
# defined but uncallable until reenabled with a call to enable_function().
disable_function() {
    die_unless_args
    disable -f "${@}"
}

# void enable_function(char *function_name)
#
# Globally re-enable the function with the passed name, presumably previously
# disabled with a call to disable_function().
enable_function() {
    die_unless_args
    enable -f "${@}"
}

#FIXME: Also destroy all Zeshy-specific globals excluding "ZESHY_HOME". 
# void undefine_callables_matching(string pattern = '*')
#
# Destroy all existing aliases and functions matching the passed pattern
# (defaulting to '*', implying all callables). This is, of course, fairly
# destructive but does guard against desynchronization issues resulting from
# modification to this Zeshy installation (e.g., when upgrading).
undefine_callables_matching() {
    die_unless_at_most_one_arg 'expected at most one pattern'
    string pattern="${1:-*}"

    unalias    -m "${pattern}"
    unfunction -m "${pattern}"
}

# ....................{ ARGUMENTS                          }....................
#FIXME: This no longer works as intended, due to TRAPZERR(). Contemplate. Ah.
#Yes. The simple solution is to require the parse_args() alias to feed into
#this command: e.g.,
#
#   parse_args d e -ad -crest: -wing:: | check_args_with_help_string 'Help!'
#
#Bit awkward, but nothing too onerous. Alternatively, couldn't we define the
#parse_args() alias to simply temporarily disable TRAPZERR() by.... hmm; I
#don't believe the disable() builtin accepts a command to be run, unfortunately.

# void check_args_with_help_string(char *help_message)
#
# Check the set of all parsed arguments for unknown options. If the caller
# passed at least one unknown option OR the "-h" or "--help" options, die with
# the passed help message. This function expects to be called immediately after
# calling the parse_args() function.
check_args_with_help_string() {
    # If the immediately prior command failed, assume that was a call to the
    # parse_args() function and enable a boolean noting this fact.
    is_ok and bool is_parse_args_failed=1
    
    die_unless_one_arg 'expected exactly one help string'
    string help_message="${1}"
    
    # If the caller passed the "-h" or "--help" options, die without error.
    if (( "${+ARGS[-h]}" + "${+ARGS[--help]}" )); then
        print "${help_message}"
        exit_with_success
    # If the caller passed unknown options, die without error.
    elif (( "${+is_parse_args_failed}" )); then
        print "${help_message}"
        exit_with_failure
    fi
}

# ....................{ MODULES                            }....................
# void load_zsh_module(char *module_name)
#
# Load the module with the passed name.
load_zsh_module() {
    die_unless_one_arg 'expected exactly one module name'
    zmodload "${1}"
}

# void unload_zsh_module(char *module_name)
#
# Unload the module with the passed name.
unload_zsh_module() {
    die_unless_one_arg 'expected exactly one module name'

    # Dismantled, this is:
    #
    # * "u", unloading this module.
    # * "i", a noop if this module is not currently loaded.
    zmodload -ui "${1}"
}

# ....................{ SCRIPTS                            }....................
# char *source_safely(char *script_filename)
#
# Safely source the passed shell script by emulating the shell environment
# expected by that script with default shell options and traps (e.g., a script
# "mandibles_of_joy.sh" expects a Bourne rather than Zsh shell environment).
source_safely() {
    die_unless_args 'expected at least one filename'

    # Localize and validate arguments. If the passed filename is not absolute,
    # resolve its absolute path by iteratively searching the current working
    # directory, "${PATH}", and "${FPATH}" (in that order).
    string script_shell='zsh' script_shells='zsh|sh|ksh|csh'\
           script_filename="$(get_script_path "${1}")"
    string script_filetype="$(get_filetype "${script_filename}")"
#   print "filetype: ${script_filetype}"

    # Identify the shell to be emulated. If the passed filename's type
    # identifies an emulatable shell, assume that. 
    if is "${script_filetype}" == ${~script_shells} si; then
        script_shell="${script_filetype}"
    # Otherwise, attempt to match the passed file's first line for a shebang
    # referencing an emulatable shell. When no such match, default to "zsh".
    else
        string script_shebang_regex="^#.*[/ ](${script_shells})($| )"

        #FIXME: Insufficient. Search, say, the first eight lines for a shebang.
        string script_shebang="$(get_file_first_line "${script_filename}")"
        script_shell="$(match_first_group "${script_shebang_regex}" "${script_shebang}")" or
            script_shell='zsh'
#       script_shell="$(match_first_group "${script_shebang_regex}" "${script_shebang}")" or true
#       print "regex::: ${script_shebang_regex}"
#       print "shebang: ${script_shebang}"
#       print "script_shell=${script_shell}"
    fi
   
    # Safely source the passed shell script. Dismantled, this is:
    # 
    # * "-L", localizing the redefinition of TRAPZERR() to this function call.
    # * "-R", resetting shell options to the default expected by such shell.
    # * "TRAPZERR()", disabling exception raising on command and function
    #   failure. (External scripts except no such exceptions, by default.)
    # 
    # Do not redefine TRAPINT(), since printing stack traces on user interrupts
    # is universally useful and not conflicting with script expectations.
    {
        emulate -LR "${script_shell}"
        TRAPZERR() { return $(( 128 + ${1} )) }
        PATH="${PATH}:${FPATH}" source "${@}"
    }

    # Interestingly, Zsh fails to signal ZERR when the sourced script fails with
    # non-zero exit status. Let's signal ZERR ourselves, shall we?
    integer exit_status=${?}
    (( exit_status == ZESHY_SUCCESS_CODE )) or
        die "\"${@}\" failed with exit status ${exit_status}"
}

# char *source_safely_command_output(
#   char *shell_name,
#   char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Emulate the passed command under the passed shell (e.g., "sh", "csh") and, if
# successful, source the command's standard output.
source_safely_command_output() {
    # Localize and validate arguments.
    die_unless_at_least_two_args\
        'expected at least one shell name and one command name'
    string shell_name="${1}"; shift
    is "${shell_name}" == (zsh|sh|ksh|csh) si or
        die "\"${shell_name}\" not an emulatable shell"
#   string command_name="${1}"
#   die_unless_installed "${command_name}"

    # Source safely.
    emulate -R sh -c "eval \$(${@})"
}

# ....................{ RELOADING                          }....................
# void reload_shell(void)
#
# Resource all Zsh startup scripts in the same order Zsh sources these scripts
# on initial login for the current user. This function is of principal use for
# Zeshy developers (making frequent changes to Zeshy itself) as well as Zsh
# dot-file hackers (making frequent changes to Zsh dot-files).
reload_shell() {
    die_unless_no_args

    # Undefine all existing aliases and functions, thus forcing Zeshy to
    # reinitialize itself if re-sourced below.
    undefine_callables_matching

    # Source startup control scripts in the default Zsh order.
    for script_file (
        '/etc/zsh/zprofile'
        "${HOME}/.zprofile"
        '/etc/zsh/zshrc'
        "${HOME}/.zshrc"
        '/etc/zsh/zlogin'
        "${HOME}/.zlogin"
    ) {
        [[ -f "${script_file}" && -r "${script_file}" ]] &&
            source "${script_file}"
    }

    # Force successful exit status. The prior loop appears to occasionally set
    # error exit status despite succeeding, which lacking the following command
    # then returns such error from this function.
    return_success
}

#FIXME: Obsolete.
#   string ZESHY_SCRIPT_NAME='redot'
#   false
#   TRAPZERR() {
#       # Save the return code of the prior command prior to overwriting this code
#       # by printing a stack trace.
#       typeset -i exit_status=${?}
#       print_stack_trace

#       # Terminate the current shell, returning the non-zero exit status of the prior
#       # command. This effectively enables "set -e" (i.e., the ERR_EXIT option,
#       # terminating the current shell on SIGZERR signals).
#       die_with ${exit_status}
#   }
#   false
#   source "${ZESHY_SOURCE_DIR}/main"
#   false
#   utter "sourced as ${script_shell}: ${@}"

#   # void source_if_found(char *filename)
#   #
#   # Source the passed filename if found and readable by the current user. Note
#   # this function definition calls no Zeshy-specific aliases or functions; the
#   # the above call to the undefine_callables() function has already killed them.
#   source_if_found() {
#       local script_name="${1}"
#       if [[ -f "${script_name}" && -r "${script_name}" ]]; then
#           print "redot: loading \"${script_name}\"..."
#           source "${script_name}"
#       fi
#   }

#   utter "reloading zeshy..."
#   utter "reloading user ${USER}..."
#
    # Force reimportation of all Zeshy components. Then, as the importations
    # below redefine all defined callables, destroy all such callables to
    # avoid desynchronization issues.
    #
    # Do this prior to calling the utter() function for obvious reasons.
#   _zeshy_initialize_imports
#   undefine_callables

#   die_unless_file "${script_filename}"
# elif is_file "${script_filename}"; then
#       match_first_group "${script_shebang_regex}" "${script_shebang}"

#
# * "-c", run the following command under such emulation.
#interactive_alias_if_installed au='aouauauauau'

#This is a no-op if the
# builtin or command to be aliased does not exist.
#
#   print "shell: ${script_shell}"
#   emulate -R ${script_shell} -c "ls"
#   emulate -R ${script_shell} -c "${@}"
#   emulate -LR "${script_shell}"
#   source ${@}

    # Disable shell strictness for the duration of the sourcing. External shell
    # scripts often assume laxness thus breaking under strictness.
#   setopt nounset            # attempting to expand unset parameters raises an error
#   setopt warn_create_global # attempting to set untyped parameters raises an error
 
    # Reenable shell strictness. 

#   of $(whence -w "${1}") =~ ': alias$' fo

#   if [[ "${type}" == none ]]; then
#       echo "not-found"
#   else
#   is "${variable_type}" or die "\"${1}\" not a variable"
#   if not is_array array; then local -A array; fi;
#   local array_name="${1:-array}"
#   die_unless_is_array "${array_name}"
#   echo "${(qqkv@P)array_name}"

#FIXME: Rename.
#alias Return_array='eval return_array'
#alias Obtain_array='eval obtain_array'
#alias Return_array='eval "$(return_array array)"'
#alias expand_stray_to_array='eval "$(obtain_array array ${stray})"'
#alias Obtain_array_from_command='eval "$(obtain_array array $(command))"'

    #FIXME: Die if return code is failure?
#   local command="${@}"
#   echo "local _zeshy_obtained_array_as_scalar=\$(${command}); "
#   echo "${array_name}=( "${(Q@)${(z)_zeshy_obtained_array_as_scalar}}" ); "
#   echo "unset _zeshy_obtained_array_as_scalar"

#   echo "${${(qqkv@P)array_name}[@]}"
#   echo "${${(@qqkvP)array_name}[@]}"
#   "echo \"${${(@qqkvP)array_name}[@]}\""
#   echo "echo \"${${(@qqkvP)array_name}[@]}\""   # ; return_success"

#   echo "string_array=${@}"
#   echo "${array_name}="'"'"${(z)@}"'"'
#   echo "${array_name}=( ${(Q)${(z)@}} )"
#   echo "${array_name}=( \"${(Q@)${(z)string_array}}\" )"
#   echo "${array_name}=( ${(Q@)${(z)string_array}} )"
#   echo "${array_name}=( "${(Q@)${(z)@}}" )"

#obtain_array_from_command() {
#    #FIXME: Test to make sure the passed array name actually is. How?
#    die_unless_at_least_two_args 'expected one array name and one runnable command'
#    local array_name="${1}"; shift
#    local command="${@}"
#
#    echo "${array_name}=( "${(Q@)${(z)_zeshy_obtained_array_as_scalar}}" ); "
#
#    #FIXME: Die if return code is failure?
#   echo "local _zeshy_obtained_array_as_scalar=\$(${command}); "
#   echo "${array_name}=( "${(Q@)${(z)_zeshy_obtained_array_as_scalar}}" ); "
#   echo "unset _zeshy_obtained_array_as_scalar"
#
#    # Let's dismantle this, one to two parameter expansion flags at a time:
#    # * 'z' splits the passed string into a numeric array of words.
#   echo "${array_name}=( ${(z)string_array} )"
#}

#oa() {
#    #FIXME: Test to make sure the passed array name actually is. How?
#    die_unless_at_least_two_args 'expected one array name and one stringified array'
#    local string_array="${@}"
#
#    # Let's dismantle this, one to two parameter expansion flags at a time:
#    # * 'z' splits the passed string into a numeric array of words.
#    echo "${array_name}=( ${(z)string_array} )"
#}

    # * '@' splits the array of such words into (still quote-protected!) words.
    # * 'Q' strips the single quotes protectively added by the prior 'qq' flag.
    # * The second '@' refers to the passed 
# ....................{ PASS-BY-VALUE                      }....................
#FIXME: Document!
#return_value() {
#   [[ ${#} -ge 1 ]] || die 'expected at least one value'
#   echo "echo \"${@}\"; return ${ZESHY_SUCCESS_CODE}"
#}

# void PATH_append_if_root(char *pathname)
#
# Add the passed pathname to this user's "$PATH", if the above conditions hold
# and if this user is the superuser (i.e., root).
#PATH_append_if_root() {
#    is_superuser && PATH_append "${@}"
#}

# void redit(void)
#redit() {
#  if [ "$USER" = "root" ]
#  then sudo $EDITOR /etc/zsh/zshrc
#  else      $EDITOR $HOME/.zshrc
#  fi
#
#  redot
#}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
