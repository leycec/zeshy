#!/usr/bin/env zsh
# ====================[ X                                  ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle X11 and all forks thereof:
#       X.org, we're winking at you.

# ....................{ ALIASES                            }....................
interactive_substitution {s}tart{x}='start_x'

#FIXME: Hmm.
interactive_alias lxf='x_list_cached_fonts'
#interactive_alias xfc='x_cache_font_dir'

# ....................{ SETUP                              }....................
# void start_x(string startx_option1, string startx_option2, ...)
#
# Start the X.org server and a client session connecting to such server under
# the passed "startx" options. This function is a helper wrapping the "startx"
# command, itself a helper wrapping the "xinit" command, supporting:
#
# * Implicit logging of X.org standard error and output to "~/.xsession",
#   silently overwriting any prior such log.
function start_x() {
    # ">!" truncates the log prior to writing.
    run_with_unified_output startx "${@}" >! "${HOME}/.xsession"
}

# ....................{ PRINTERS                           }....................
# string print_x_keyboard_info(void)
#
# Print a human-readable synopsis of current X.org keyboard settings, including:
function print_x_keyboard_info() {
    die_if_args

    # Print all "setxkbmap" information, as even the most verbose of the
    # information output by this utility is informatively brief.
    say_first_section 'setxkbmap'
    setxkbmap -print -verbose 10

    # Print all display-specific "xset" information.
    say_next_section 'xset'
    #FIXME: Ugh.
    xset -q | grep '^Keyboard Control:$' --after-context=13
}

# string print_x_screen_info(void)
#
# Print a human-readable synopsis of current X.org display settings, including:
#
# * Current resolution.
# * Dots per inch (DPI).
function print_x_screen_info() {
    die_if_args

    # Print a subset of all "xdpyinfo" information, as most of the information
    # output by this utility is considerably more verbose than usually desired.
    say_first_section 'xdpyinfo'

    # Copy the output of "xdpyinfo" into a local variable.
    string display_info; display_info="$(xdpyinfo)"

    # Grep this variable for relevant lines.
    match_first_line ' *dimensions: ' "${display_info}"
    match_first_line ' *resolution: ' "${display_info}"
    match_first_line ' *depth of root window: ' "${display_info}"

    # Print all "xrandr" information, as most of the information output by this
    # utility is informatively brief enough to be of general use. 
    say_next_section 'xrandr'
    xrandr

    # Print all display-specific "xset" information.
    say_next_section 'xset'
    _print_x_dpms_info
    #FIXME: Uhm.
    xset -q | grep '^Colors:$' --after-context=1
}

# ....................{ PRINTERS ~ dpms                    }....................
# string print_x_dpms_info(void)
#
# Print X11 Display Power Management Signaling (DPMS) and screen saver
# information.
function print_x_dpms_info() {
    die_if_args
    say 'displaying X.org DPMS settings...'
    _print_x_dpms_info
}

function _print_x_dpms_info() {
    die_if_args
    string xset_output="$(xset -q)"
    print "${xset_output}" | grep '^Screen Saver:$'       --after-context=2
    print "${xset_output}" | grep '^DPMS (Energy Star):$' --after-context=2
}

# ....................{ SETTERS                            }....................
# void disable_x_dpms(void)
#
# Disable screen blanking (i.e., DPMS-managed monitor shutdown on inactivity).
# This is particularly helpful while enjoying media but should be manually re-
# enabled when done.
function disable_x_dpms() {
    die_if_args
    interactively say 'disabling X.org DPMS...'
    xset s off
    xset -dpms
    print_x_dpms_info
}

# void enable_x_dpms(void)
#
# Enable screen blanking (i.e., DPMS-managed monitor shutdown on inactivity).
function enable_x_dpms() {
    die_if_args
    interactively say 'enabling X.org DPMS...'
    xset s on
    xset +dpms
    print_x_dpms_info
}

# ....................{ VIDEO ~ fonts                      }....................
# string x_list_cached_fonts(void)
#
# List all currently cached fonts in the system-wide X11 font cache.
function x_list_cached_fonts() {
    die_if_args
    run_paged fc-cat -rv
}

# void x_font_dir_cache(string dirname = PWD)
#
# Permanently add all fonts in the passed directory to the system-wide X11 font
# cache. This addition makes these fonts accessible to all subsequent "X11-
# aware" applications. This directory defaults to the current working directory,
# if not passed.
function x_cache_font_dir() {
    die_unless_no_or_one_arg 'expected at most one font directory'

    # If non-empty, this function pushed the passed directory onto the stack and
    # must thus pop it from the stack prior to returning
    bool is_pushing_directory

    # Font directory to be cached.
    string font_dir
    if is_nonempty "${1}"; then
        font_dir="${1}"
        is_pushing_directory=1
        pushd "${font_dir}"
    else
        font_dir="${PWD}"
    fi
    font_dir="$(canonicalize_path "${font_dir}")"

    say "preparing \"${font_dir}\" for caching..."
    mkfontscale
    mkfontdir

    say "caching \"${font_dir}\"..."
    xset fp+ "${font_dir}"

    say "updating X.org font list..."
    xset fp rehash

    # "fc-cache" is a dynamic alternative to the above. Older systems have no
    # "fc-cache" installed, however. For safety, do both.
    if is_installed fc-cache; then
        say 'updating fontcache...'
        run_as_superuser fc-cache -v
    fi

    #FIXME: Call the proper Zeshy function.
    is_empty "${is_pushing_directory}" or popd
}

# ....................{ STARTUP                            }....................
#FIXME: Interesting, but not terribly relevant to most people. Still, it'd be
#nice to integrate... Right; just shift into a new "X"-specific config file.
#Done! I'm not convinced we need to create such directory if not found but such
#global is set, so just excise this function.

# void setup_x(void)
#
# Initialize Zeshy-specific X.org integration.
function setup_x() {
    #FIXME: "XAPPLRESDIR" now obsoleted by "XUSERFILESEARCHPATH". Delete the
    #former; retain the latter, after upgrading X.org.
    # Absolute path of the user-specific directory with Xt-driven (e.g., Xaw,
    # Motif) configuration files containing application resources.
    string_global_export\
        XAPPLRESDIR\
        XUSERFILESEARCHPATH

    #FIXME: What's the *REAL* canonical name for such dir?
    XAPPLRESDIR="${HOME}/.Xt"
    XUSERFILESEARCHPATH="${XUSERFILESEARCHPATH:-${XAPPLRESDIR}/%N}"
#   make_dir_if_not_found "$(get_path_dirname "${XUSERFILESEARCHPATH}")"
}

# --------------------( WASTELANDS                         )--------------------
#   string_global\
#       XUSERFILESEARCHPATH="${XUSERFILESEARCHPATH:-${HOME}/.Xt/%N}"
