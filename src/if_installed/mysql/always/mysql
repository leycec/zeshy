#!/usr/bin/env zsh
# ====================[ mysql                              ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy MySQL.
#
# --------------------( SECURITY                           )--------------------
# For security, no functions accept passwords as arguments. Doing so would,
# without further management, cache passwords in the Zsh history. Hence, all
# functions requiring passwords do so interactively.

# ....................{ ALIASES                            }....................
interactive_abbreviation mysql='mysql_shell'

# ....................{ SETTERS                            }....................
# void set_mysql_user_password(string username = 'root')
#
# Set the passed password for the passed MySQL username. Username defaults to
# "root", if not passed. Note that new users are best created via interactive
# "CREATE USER" SQL commands entered as the root user: e.g.,
#
#     # Enter the interactive MySQL shell.
#     >>> mysql
#     # Create a new user and password.
#     CREATE USER 'new_username'@'localhost' IDENTIFIED BY 'password_for_new_username';
#     # Assign privileges to this user.
#     GRANT ALL ON *.* TO 'new_username'@'localhost';
#     # And... we're done.
#     exit
set_mysql_user_password() {
    # Validate passed arguments.
    die_unless_no_or_one_arg 'expected optional username'
    string username="${1:-root}"

    #FIXME: Does MySQL attempt to read an interactive password or do we need do
    #it ourselves? Not terribly hard, but...
#   read password
    mysqladmin -u "${username}" password
}

# ....................{ PRINTERS                           }....................
#FIXME: Trivially silly as defined. Improve in accordance with Zeshy apache2.

# string print_mysql(void)
#
# Print MySQL-specific metadata, including:
#
# * Version.
print_mysql_info() {
    die_if_args
    mysql -V
}

# ....................{ MAKERS                             }....................
# void make_mysql_database(string database_name, string username = 'root')
#
# Make a new database using the passed MySQL username. The username defaults to
# the "root" user. MySQL
# interactively queries you for that user's password.
make_mysql_database() {
    # Validate passed arguments.
    die_unless_one_or_two_args\
        'expected one database name and optional username'
    string database_name="${1}" username="${2:-root}"

    say "creating database \"${database_name}\" as user \"${username}\"..."
    mysqladmin -u "${username}" -p "${password}" create "${database_name}"
}

# ....................{ SHELL                              }....................
# void mysql_shell(string username = 'root', string mysql_arg1) --OR--
#
# Run the interactive MySQL shell with sane option defaults under the passed
# username and password. Username defaults to "root", if not passed.
mysql_shell() {
    # Validate passed arguments.
    die_unless_no_or_one_arg\
        'expected one database name and optional username'
    string username="${1:-root}"

    # Run the MySQL shell.
    command mysql "${ZESHY_MYSQL_OPTIONS[@]}" -u "${username}" "${@}"
}

# --------------------( WASTELANDS                         )--------------------
#FIXME: Unsafe. Passwords should only be accepted as stdin -- not cached in the
#Zsh history as recallable commands.
#   if is_two_args; then
#       username="${1}"; shift
#       password="${2}"; shift
#   elif is_variable '1'
#   then username="${1}"; shift
#   else username=root
#   fi
    # Yes, the absence of a space after "-p" is intentional. Thanks, MySQL!
#   say "logging in as \"${username}\"..."
#   interactively say "setting \"${username}\" password..."
