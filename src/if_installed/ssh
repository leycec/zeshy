#!/usr/bin/env zsh
# ====================[ ssh                                ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy SSH, implementing "scp" and "ssh"-specific functionality. See also
# Zeshy SSHfs, implementing SSH mounting with FUSE filesystems.
#
# --------------------( TODO                               )--------------------
# * Implement a "mosh" Zeshy component. Since "mosh" depends on "ssh", such
#   component should resemble the current "sshfs" component.

# ....................{ ALIASES                            }....................
#FIXME: We really want a configuration file-based alias calling a Zeshy
#function, here.
interactive_substitution scp='scp -Crv'

# ....................{ GETTERS                            }....................
#FIXME: It'd be nice to generalize such getters to accept an optional username.
# string get_ssh_dot_dir(void)
#
# Get the absolute path of the current user's SSH dot directory (e.g.,
# "~/.ssh/") regardless of whether such path exists.
function get_ssh_dot_dir() {
    die_if_args
    sputter "${HOME}/.ssh"
}

# string get_ssh_public_key_file(void)
#
# Get the absolute path of the first public key in the current user's SSH dot
# directory. If multiple keys exist, prefer the first such key with a basename:
#
# * Prefixed by "id_" and suffixed by ".pub" (i.e., protocol 2 public key).
# * Prefixed by "identity" and suffixed by ".pub" (i.e., protocol 1 public key).
# * Suffixed by ".pub".
function get_ssh_public_key_file() {
    die_if_args
#   list filenames; filenames=( "$(get_ssh_dot_dir)"/{id_,identity,}*.pub(.) )
    get_first_file 
#   sputter "${${HOME}/.ssh}"
}

# ....................{ PRINTERS                           }....................
# string print_ssh_key_fingerprint(
#   string ssh_key_filename = "~/.ssh/id_rsa.pub")
#
# Print the fingerprint of the passed SSH public or private key file.
function print_ssh_key_fingerprint() {
    # Validate passed arguments, defaulting such argument to the first SSH key
    # in the current user's SSH dot directory (in the following order):
    #
    # * public or
    # private key in the 
    die_unless_at_most_one_arg 'expected optional public key filename'

    #FIXME: Call which_files_nonfatal() to test any number of possible keys
    #(e.g., "id_dsa.pb"). Actually, just glob!
    string ssh_key_filename
    is_no_args and {
        list ssh_key_filenames
        ssh_key_filenames=( "$(get_ssh_home)"/*.pub )
        die_if_list_empty 
        ="${1:-${HOME}/.ssh/id_rsa.pub}"
    }
    die_unless_file "${ssh_key_filename}"

    # Print.
    ssh-keygen -lf  "${ssh_key_filename}"
}

# --------------------( WASTELANDS                         )--------------------
#interactive_alias ssh='TERM="xterm" ssh -v'
#alias ssh-secondary-control-master="ssh -o \"ControlPath ~/tmp/ssh_controlmaster2-%r@%h:%p\""

#FIXME: Sensible, but doesn't belong here. Hmm...
# ....................{ GLOBALS                            }--------------------
# If "cvs" is also installed, encrypt non-pserver CVS connections via "ssh".
#is_installed cvs and global_string CVS_RSH=ssh
