#!/usr/bin/env zsh
# ====================[ main                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Bootstrap Zeshy into the current shell environment.
#
# --------------------( SEE ALSO                           )--------------------
# http://zsh.sourceforge.net/Doc/Release/Functions.html
#   Detailed description of trap functions.
# http://www.bash2zsh.com/essays/essay1_file_manager.html
#   Concise introduction to suffix aliases, mime types, and file magic.
#
# --------------------( TODO                               )--------------------
# * Zeshy's complexity and hence fragility is beginning to enter the caustic
#   zone. We *REEEALLY* need to add unit tests, post-haste. This will entail a
#   massive effort, but be well worthwhile. It's nigh impossible to keep up with
#   the current pace of new regressions without installing at least:
#
#   * One unit test per function intended to execute successfully.
#   * One unit test per function intended to execute unsuccessfully.
#
#   Thanks to our dependency on exception handling, it *SHOULD* be exceedingly
#   simple to doctor up a small unit test framework. When we expect unsuccessful
#   execution and hence a thrown exception, such framework will need a function
#   accepting the name of the expected thrown exception; on catching an
#   exception, such function must dynamically inspect the call stack for such
#   function. Alternatively, it'd be great if the exception thrown by both die()
#   and our TRAPZERR() function itself performed such inspection and *SET THE
#   NAME OF THE FUNCTION TO BE THE RESPONSIBLE die_*() FUNCTION NAME*. Pretty
#   sweet! We currently use a useless exception name (e.g., "ZeshyException");
#   so, this would be quite a welcome change.
# * Pretty sweet snippet adding a Vim-style modeline in vi-keys mode showing
#   whether currently in INSERT or NORMAL mode. I reckon we could ably integrate
#   this into the default theme, which would go a long way to converting me to
#   the vi-keys ZLE. See:
#   http://www.zsh.org/mla/users/2006/msg01180.html
#   http://www.gott-gehabt.de/800_wer_wir_sind/thomas/Homepage/Computer/zsh/vi-showmode
#   Perhaps there's a more recent working solution, as well?
# * Zsh helpfully provides a "DVORAK" setopt option, only of interest if
#   interactive. It'd be quite nice to dynamically determine whether a dvorak
#   keymap is currently in use and, if so, implicitly enable such option.
#   However, this fails to account for hardware-based keymapping (e.g.,
#   Kinesis). Perhaps a "config" global -- say, ZESHY_IS_KEYMAP_DVORAK" -- would
#   be of assistance here.
# * Use the "vcs_info" Zsh module for displaying VCS-specific metadata in a VCS-
#   agnostic fashion.
# * Incorporate grml-zshrc functionality where helpful, currently available at:
#   http://git.grml.org/f/grml-etc-core/etc/zsh/zshrc
# * Incorporate ZSH-lovers fixes, including:
#   * Use suffix aliases.
# * The new trap support obsoletes an astonishing quantity of prior
#   functionality (e.g., try()). Such functionality should be retained (???...
#   perhaps not), but exported out of this component into a new component: say,
#   "zeshy/shell/job".
# * zimport() can profitably be renamed require(). The latter captures the
#   intent and implementation much more succinctly and without the awkward
#   prefixing 'z'.
# * We only call a match_*() function once in this file. It's absurd to maintain
#   such complexity here; offload all match_*() functionality to
#   "zeshy/type/regex" and, if still required here, simply inline. I believe we
#   can use simple glob-style matching, instead.
# * Ultimately, Zeshy should auto-compile the recursive entirety of all Zeshy
#   function definitions into a single so-called "digest" file at, say,
#   "~/.zeshy/digest.zwc". Such a file is autoloadable by:
#
#       # ...implicitly autoloading such digest.
#       fpath=( "~/.zeshy/digest.zwc" "${fpath[@]}" )
#
#       # ...explicitly autoloading such digest.
#       autoload -Uw "~/.zeshy/digest.zwc"
#
#   I'm unsure if the former supercedes the latter. (Probably not, no.) Both
#   required, perhaps.
#
#   What's nice about this is that such a digest file appears to come prepended
#   with a list of all functions defined by such digest, thus rendering
#   autoloading of digest files terrifically fast. Auto-generating such a digest
#   on any change to any Zeshy file or directory is, unfortunately, not quite so
#   easy. We'll need to write something resembling:
#
#       if is "$(get_path_mtime "~/.zeshy/digest.zwc") equals SOMETHING si; then
#           zcompile "~/.zeshy/digest.zwc" "${ZESHY_HOME}/src/"**/*(.)
#       fi
#
#   However, it's unclear just how aggregating multiple files into one handles
#   initialization code. Clearly, it either doesn't or does but simply lumps all
#   initialization together. Either case is bad. We'll need to rewrite Zeshy to:
#
#   * Perform all non-costly initialization up-front in Zeshy .main or core.
#   * Perform all costly initialization in the functions requiring such
#     initialization as the first line of such functions. You know that grind...

# ....................{ SANITY                             }....................
# Oldest Zsh version under which Zeshy runs without error.
typeset -x ZESHY_NEEDS_ZSH_VERSION=5.0.0

# Exit with fatal error if not running such version.
autoload -U is-at-least
if ! is-at-least ${ZESHY_NEEDS_ZSH_VERSION}; then
    # Print an error message to standard error.
    print "zeshy: requires zsh ${ZESHY_NEEDS_ZSH_VERSION} but running zsh ${ZSH_VERSION}" 1>&2

    # If interactive, immediately return back to Zsh; otherwise, exit the
    # current script.
    if [[ -o interactive ]]
    then return 1
    else exit 1
    fi
fi

# ....................{ PATHS                              }....................
#FIXME: Woops. This is pretty much completely wrong for actual Zeshy
#installations (e.g., into "/usr/share/zeshy", containing the current contents
#of "~/zsh/zeshy/src"). ZESHY_HOME and ZESHY_OVERLAY_ROOT should *ALWAYS* be the
#same exact thing. Hence, remove the latter and set the former as follows:
#
#[[ -n "${ZESHY_HOME-}" ]] || export ZESHY_HOME="${0:h}"(:A)
#
#We should probably remove all setting of such variable from
#"etc/{zlogin,zprofile,zshrc}", perhaps suggesting "etc/{zlogin,zshrc}" should
#be removed entirely and "etc/zprofile" reduced to just running "zeshy".

# Absolute directory of the Zeshy codebase.
[[ -n "${ZESHY_HOME-}" ]] || export ZESHY_HOME="${0:h}/.."(:A)

# Absolute directory of the Zeshy library.
export ZESHY_OVERLAY_ROOT="${ZESHY_HOME}/src"

# ....................{ OPTIONS                            }....................
# Enforce strictness, as under conventional high-level languages.
setopt no_unset           # attempting to expand unset parameters raises an error
setopt warn_create_global # attempting to set untyped parameters raises an error

# Core parsing.
setopt no_ksh_arrays     # enable 1-based lists subscriptable without braces
setopt no_ksh_autoload   # treat autoloaded files as function definitions
setopt no_ksh_typeset    # enable word splitting on variable assignment
setopt magic_equal_subst # enable filename expansion on "="-prefixed strings
setopt short_loops       # enable "for ... (...) { ... }"-style shell constructs

# Core quoting.
setopt no_csh_junkie_quotes  # allow unescaped newlines in quotes
setopt no_sh_word_split  # do not field split unquoted parameters
setopt rc_quotes         # parse '' as ' in single quotes (e.g., '''' == "'")

# Command execution.
setopt no_print_exit_value  # do not print "zsh: exit $?" on command failure

# Command history.
setopt append_history    # share history between multiple ZSH sessions
setopt inc_append_history  # incrementally add items to history
setopt extended_history  # save timestamps in history
setopt hist_ignore_all_dups # do not ignore dups in history
setopt hist_ignore_dups  # ignore consecutive dups in history
setopt hist_ignore_dups  # ignore consecutive dups in history
setopt hist_lex_words    # ensure accurate parsing of commands saved to disk
setopt hist_no_store     # do not store history-related functions

# Path changing.
setopt auto_cd           # automatically "cd" to directories in command position
setopt auto_pushd        # automatically "pushd" directories onto the dirstack
setopt pushd_ignore_dups # do not push duplicate directories onto the dirstack
setopt pushd_silent      # run "pushd" and "popd" silently

# File globbing.
setopt no_case_glob      # glob case-insensitively
setopt no_glob_assign    # do not glob variable assignments (use lists instead)
setopt no_ignore_braces  # enable "{...}"-style brace expansion
setopt no_ignore_close_braces  # render ";" optional for single-line functions
setopt extended_glob     # enable extended globbing (e.g., "#", "~", "^")
setopt glob              # enable globbing
setopt glob_dots         # permit "*" to match "."-prefixed pathnames

# Silently delete non-matching globs rather than raising exceptions. While the
# latter is certainly preferable, Zsh fails both to:
#
# * Signal ZERR and hence call TRAPZERR(), printing a full stack trace.
# * Permit the printed error message to be customized. The error messages Zsh
#   prints are largely unhelpful for non-interactive scripts (e.g.,
#   "zsh: no matches found: Tomoe(:A)"), offering no human-readable context for
#   script debugging or development.
#
# Hence, we reluctantly disable errors on non-matching globs. Zeshy scripts and
# functions must test for glob failure by testing emptiness: e.g.,
#
#     >>> string glob_match=( "PiKHAL/TiKHAL"(:A) )
#     >>> is_nonempty "${glob_match}" or die "\"PiKHAL/TiKHAL\" not found"
setopt null_glob

# File writing.
setopt no_clobber        # forbid ">" from truncating existing files

# PCRE matching.
#
# This enables Perl-Compatible Regular Expression (PCRE) matching via the "=~"
# test operator, by implicitly loading the "zsh/pcre" module when requested.
# This module matches the entire match into "${MATCH}" and each group match
# into array elements of "${match[@]}" where the first match is "${match[1]}".
# For additional documentation on the "zsh/pcre" module, see:
# http://zsh.sourceforge.net/Doc/Release/Zsh-Modules.html#SEC192
#
# Note that traditional glob matching is always available via the "==" test
# operator: e.g.,
#     [[ $(whence -cp fahey) == *" not found" ]] && echo "Farewell."
setopt rematch_pcre      # prefer Perl-Compatible Regular Expression matching

# Process control.
setopt long_list_jobs    # list jobs in long format
setopt no_notify         # report job status only before prompt printing

# Shell I/O.
setopt no_flow_control   # disable interactive flow control (e.g., ^S, ^Q)
setopt ignore_eof        # do not treat ^D as "exit", interactively
setopt interactive_comments  # enable "#" comments in interactive commands
setopt print_eight_bit   # enable 8-bit output for completion lists

# Shell prompt.
#
# Enable variable substitution in prompt definitions. This dynamically re-
# expands each prompt definition and variables referenced in that definition
# immediately prior to displaying that prompt; by default, on the other hand,
# Zsh statically caches the expansion of each prompt definition for quick re-
# use when displaying those prompts. (While marginally faster, the latter is
# remarkably less useful as it requires redefining and exporting a prompt to
# alter the display of that prompt.)
setopt prompt_subst

# Tab completion.
setopt auto_menu         # use menu completion after two tabs
setopt complete_in_word  # complete inside words
setopt no_list_ambiguous # only list matches if ambiguous

# Variable expansion.
setopt c_bases           # print non-base 10 integers in C format (e.g., "0x33")

# ....................{ MODULES                            }....................
# Explicitly load only the subset of requisite Zsh modules (i.e., C-based shared
# libraries bundled with Zsh) for which no appropriate autoloadable function
# exists. Since all other requisite Zsh modules supply autoloadable functions
# implicitly loading their parent module on the first call to such function, we
# explicitly load no other modules.

# Stat module wrapping the stat() system call with the zstat() Zsh function. Do
# not load this module via "zmodload zsh/stat", as that wraps the stat() system
# call with a stat() Zsh function conflicting with the "stat" command.
zmodload -F zsh/stat b:zstat

# Black box module exposing Zsh's C-based internal dictionaries as Zsh-based
# associative arrays, including:
#
# * "$funcstack", having the current function call stack for user inspection.
# * "$functions", having the current set of all functions for redefinition and
#   subsequent restoration of alternate function definitions.
zmodload zsh/parameter

# ....................{ RETURN VALUES                      }....................
# Success code, as returned by successful processes on process completion.
typeset -ix ZESHY_SUCCESS_CODE=0

# Failure code, as returned by failed processes on process completion. Note
# that, technically, any return code greater than or equal to this value
# constitutes a process failure.
typeset -ix ZESHY_FAILURE_CODE=1

# void return_true(void)
#
# Return from the current function with success.
alias return_true="return ${ZESHY_SUCCESS_CODE}"

# void return_false(void)
#
# Return from the current function with failure.
alias return_false="return ${ZESHY_FAILURE_CODE}"

# ....................{ GETTERS                            }....................
# string get_script_name(void)
#
# Get the script name for the current script. This is a string succinctly
# describing the script under execution, typically of one to two words.
#
# Scripts may safely redefine this function to return another name; in this
# case, scripts called by the script redefining this function will still call
# this original definition (since functions are not inherited via script
# calls).
function get_script_name() {
    (( # == 0 )) || die 'expected no arguments'

    # If the caller set a non-empty ${ZESHY_SCRIPT_NAME}, return that name.
    if [[ -n  "${ZESHY_SCRIPT_NAME-}" ]]; then
        print -- "${ZESHY_SCRIPT_NAME}"
    # If the current process is an interactive shell, then return the name of
    # the function that called this function excluding all intermediary I/O-
    # and error handling-specific function calls. Typically, that function is
    # the function that called the function that called this function (i.e.,
    # the function two calls earlier in the function callstack). Insert magical
    # handwaving here.
    elif (( ${#funcstack} > 0 )); then
        # If this name is an absolute path, return that path's basename.
        if [[ "${funcstack[-1]}" == /* ]]
        then print -- "${funcstack[-1]:t}"
        # Otherwise, return this name as is.
        else print -- "${funcstack[-1]}"
        fi
    # Otherwise, return the default name.
    else print 'zeshy'
    fi
}

#FIXME: Add ANSI coloring to sayed messages if on an ANSI-capable terminal.
#Also, consider prefixing messages under cron with: "["$(date +'%F %T')"].

#FIXME: *WAIT*. We only need to define a placeholder say() and cry() here
#prefixing *ALL* passed messages with "zeshy: ".
#The real say() and cry() implementations should be subsequently defined by
#the currently enabled theme. Make it so with a sprinkle of ANSI excellence.

# ....................{ PRINTERS                           }....................
# For safety, trap functions and functions transitively called by such functions
# require only Zsh functionality (i.e., no Zeshy-specific syntactic sugar). This
# comprises all functions defined up to and including the "TRAPS" section.

# void say(string message = '')
#
# Print the passed message suffixed by a trailing newline to the notice stream
# of the cron logging facility if a cron-job and to the standard output stream
# otherwise.
function say() {
    local message; message="$(get_script_name): ${@}"
    print -- "${message}"
}

# void cry(string message = '')
#
# Echo the passed message to the standard error stream. Specifically:
#
# * If a cronjob, echo to the error stream of the cron logging facility.
# * Otherwise, to "stderr".
function cry() {
    # Print this message. Do *NOT* call print() as "print -u2 -- "${message}".
    # While that appears superficially identical to the following call, passing
    # the desired file descriptor as an argument fails to preserve interleaving
    # with prior commands printing to file descriptor 1 (i.e., standard out).
    local message; message="$(get_script_name): ${@}"
    print -- "${message}" 1>&2
}

# ....................{ PRINTERS ~ stack                   }....................
# string print_stack_trace(string message = "")
#
# Print to standard error a trace of the current call stack of all stack frames
# (i.e., previously called functions, sourced files, and "eval" statement),
# excluding the stack frame of the call to this function.
#
# Printing to standard error rather than output ensures that stack traces
# printed within command substitution (e.g., by thrown exceptions and/or errors)
# are not hidden by such substitution: e.g.,
#
#     # Assuming neither "/spider" or "/murphy" exist, the following command
#     # substitution internally throws an exception printing a stack trace.
#     >>> string first_file; first_file="$(get_first_file /spider /murphy)"
function print_stack_trace() {
    # Localize passed arguments.
    (( # <= 1 )) || die 'expected at most one optional message'
    integer i\
        fileline fileline_first\
        funcstack_size=${#funcstack}
    local filename\
        funcname funcname_first\
        frame_prefix='    \\_'
#       ZESHY_SCRIPT_NAME='print_stack_trace'\

    # Omit the current function call by starting from the second stack frame.
    # If there exists no such frame, return with failure.
    (( funcstack_size >= 2 )) || {
        print -- 'print_stack_trace: call stack empty.' 1>&2
        return_failure
    }

    # Print a prefixing header with the passed message.
    print -- "\nprint_stack_trace: ${1:-}" 1>&2

    # Print the current call stack.
    for (( i = 2; i <= funcstack_size; i++ )) {
        # Split the current stack frame's funcfiletrace entry on the last colon
        # in that entry into this frame's filename and line number, thus
        # accounting for possible colons in filenames (e.g., from "colon:blow:7"
        # to filename "colon:blow" and line number 7).
        funcname="${funcstack[${i}]}"
        filename="${funcfiletrace[${i}]%:*}"
        fileline="${funcfiletrace[${i}]##*:}"

        # If this frame signifies an actual function rather than a sourced
        # filename or "eval" statement, append "()" for aesthetics.
        [[ "${funcname}" == '(eval)' ]] || funcname="${funcname}()"

        # If this is the most recent stack frame, recall the name of the second-
        # most recent stack frame that called that frame and line number of that
        # call for subsequent pretty printing.
        (( i == 2 )) && fileline_first="${fileline}"
        (( i == 3 )) && funcname_first="${funcname}"

        # Print the current stack frame to standard error.
        print -- "${frame_prefix} ${funcname} { ${filename}: ${fileline} }" 1>&2

        # Indent the next stack frame one space to the right.
        frame_prefix=" ${frame_prefix}"
    }

    #FIXME: Sadly, this isn't quite right. The line number appears to be
    #relative to the original function definition in the source file. Here's a
    #simple test:
    #    command dirs -p | number_lines_highlighting_line 0
    #Zsh reports the failing command on a line number that could only be the
    #original file including comments and blank lines. Sadly, that means we
    #can't reliably highlight line numbers for any functions except those defined
    #in the Zeshy digest. It also means we have to manually map the function
    #name to the exact block of code in the exact Zeshy file defining such
    #function, taking into account things like conditional themes. (Commands
    #needn't be considered. But themes must.) It's all highly annoying, and
    #frankly somewhat out of bounds at the moment.
    #
    #How about this: for the moment, drop the line number highlighting. It's
    #erroneous and unhelpful. When time permits re-implement this conditional to:
    #
    #* If this function is a Zeshy function (i.e., is compiled into the Zeshy
    #  digest), perform the above behavior with line number highlighting using
    #  "awk" and a similar script to below.
    #* Otherwise, print a code listing with no such highlighting using "nl".
    #
    #Because this probably relies on advanced Zeshy functionality not readily
    #implementable without access to the Zeshy codebase, we should segregate
    #this into an autoload function (say, print_function_highlighting_line()).
    #Then test here for the existence of such function. If available, call it;
    #otherwise, do nothing. (No error, if it doesn't exist yet.)

    # If the most recent stack frame signifies an existing function, print that
    # function's definition to standard error as line-numbered code. Since line
    # numbers in stack frames start from the first line of such definition while
    # the default printer for such definitions starts from the prior line
    # declaring the function name, do *NOT* number the first printed line.
    if [[ -n "${ZESHY_IS_DEBUG-}" && -n "${funcname_first}" &&\
          "$(whence -w -- "${funcname_first}")" == *': function' ]]; then
        print -- "\n${funcname_first}() failed on line ${fileline_first}."
        whence -f -- "${funcname_first}" | awk -vNRBAD=${fileline_first} '
# If the function name, print a hyphen in place of the current line number
# followed by the name.
NR == 1 {
    printf("%6s   %s\n", "-", $0)
}
# If any line other than the erroneous line, print the current line number
# followed by the line. (Due to the prefixing function name declaration, the
# current line number is one larger than expected. Subtract one for comparison.)
NR > 1 && NR-1 != NRBAD {
    # If this line is "}" and hence the end of this function definition, print
    # hyphens in place of the current line number followed by the "}".
    if ($0 == "}") {
        NREND=NR
        gsub(/./, "-", NREND)
        printf("%6s   }\n", NREND)
    }
    else {
        printf("%6d   %s\n", NR-1, $0)
    }
}
# If the erroneous line, print the current line number prefixed and suffixed by
# pleasing ASCII arrows. (What? YOU CAN DO BETTER!?)
NR-1 == NRBAD {
    # Number of digits in the current line number.
    NRLEN = length(NR-1);
         if (NRLEN==1) {NRNOW = " <-~ " NR-1}
    else if (NRLEN==2) {NRNOW = "<-~ " NR-1}
    else if (NRLEN==3) {NRNOW = "<- " NR-1}
    else               {NRNOW = NR-1}       # if true, your function is horrid.
    printf("%s ~->   %s\n", NRNOW, $0)
}' 2>&1
    fi
}

# ....................{ TRAPS                              }....................
# int TRAPINT(int signal_number = SIGINT)
#
# Trap SIGINT (i.e., signal interrupt, as after a user-driven <Ctrl-C> event).
function TRAPINT() {
    integer signal_number=${1}

    # Print a complete stack trace.
    print_stack_trace

    # Store the interrupted line in the history. By default, Zsh omits such
    # lines -- somewhat unhelpfully. Dismantled, this is:
    #
    # * "zle", true only if the history is currently active.
    # * "-s", output the interrupted line to the history rather than stdout.
    # * "-r", preserve escapes from "echo" command manipulation.
    # * "--", prevent dash prefixes in the interrupted line from being
    #   misinterpreted as "print" command options.
    # * "${BUFFER}", the interrupted line.
    zle && print -sr -- "${BUFFER}"

    # Arcanely uncanny bit-munging. Exit status is always a 1-byte integer.
    # Non-zero exit status with:
    #
    # * The high bit unset signifies a command or function-specific error.
    # * The high bit set signifies a signal-specific error. All bits excluding
    #   the high bit signify the signal number.
    #
    # Hence, constructing a signal-specific exit status requires merely adding
    # 128 to the desired signal number. Moreover, Zsh interprets non-zero trap
    # function return values as the exit status to be returned from running the
    # default handler for the trap. Since we would like to continue running the
    # default handler for the trap (SIGINT, in this case), this function returns
    # a non-zero value. Rather than hard-coding the desired signal number, reuse
    # the number Zsh passed as the first argument to this function.
    return $(( 128 + ${signal_number} ))
}

# ....................{ TRAPS ~ errors                     }....................
# Globally enable "setopt ERR_RETURN" by trapping ZERR. Specifically, print a
# complete stack trace and immediately unwind the call stack on *ANY* command
# returning non-zero exit status. Such unwind exits all intermediate subshells
# (e.g., non-interactive Zeshy functions or scripts) to the originating shell
# (e.g., the interactive Zeshy or Zsh shell transitively responsible for running
# the failed command).
#
# Unlike "setopt ERR_RETURN", this prints stack traces. Unlike "setopt
# ERR_EXIT", this merely unwinds the call stack rather than coercively exiting
# both intermediate subshells *AND* the originating shell.

# int TRAPZERR(int signal_number = SIGZERR)
#
# Trap SIGZERR, a Zsh-specific signal on non-zero exit status from Zsh builtins,
# Zsh functions, and external commands.
function TRAPZERR() {
    # Save the return code of the prior command prior to overwriting this code
    # by printing a stack trace.
    integer signal_number=${1} exit_status=${?}

    # Print a complete stack trace. If some function called this function (i.e.,
    # this function was not called directly from the prompt), prefix such trace
    # with that function's name and exit status; otherwise, no such prefix.
    if (( ${#funcstack} >= 2 ))
    then print_stack_trace\
        "\"${funcstack[2]}\" failed with exit status ${exit_status}."
    else print_stack_trace
    fi

    # Mimic "setopt ERR_RETURN". See "man zshoptions" for further details.
    return ${exit_status}
}

# void die(string error_message = '')
#
# Print the passed error message and a stack trace to standard error, then exit
# the current shell with an error exit status.
function die() {
    # Exit status of the prior command. Zsh defines "pipestatus" to be a global
    # list with elements the return values of each subcommand of the prior pipe
    # command or of the prior command if not a pipe command. Conversely, Zsh
    # defines "?" to be a global integer with the return value of the prior
    # command. Since the former subsumes the latter *AND* the latter fails to
    # provide the return value of the prior command when a subcommand of a pipe
    # command, we defer to the former. For example, consider:
    #
    #     # Define helper functions.
    #     >>> pipe_status() { print ${pipestatus[-1]} }
    #     >>> exit_status() { print $? }
    #
    #     # Show "pipestatus" to return the required values.
    #     >>> true; pipe_status  # this works...
    #     0
    #     >>> true; true | false || pipe_status  # ...and so does this.
    #     1
    #
    #     # Show "?" to *NOT* return the required values.
    #     >>> true; exit_status  # this works...
    #     0
    #     >>> true; true | false || exit_status  # ...but this doesn't.
    #     0
    integer exit_status=${pipestatus[-1]}

    # If the prior command succeeded, coerce the exit status into an error.
    (( ${exit_status} == ${ZESHY_SUCCESS_CODE} )) &&
       exit_status=${ZESHY_FAILURE_CODE}

    # Print the passed error message.
    cry "${@}"

    # Print a complete stack trace.
    if (( ${#funcstack} >= 2 ))
    then print_stack_trace\
        "\"${funcstack[2]}\" failed with exit status ${exit_status}."
    else print_stack_trace
    fi

    # If called under an interactive shell, unwind the call stack to return the
    # current user to an interactive prompt; otherwise, exit this shell script.
    #
    # Note that the simpler command "return ${exit_status}" implicitly invokes
    # the "err_return" and TRAPZERR() handlers and hence (ultimately) performs
    # the same logic, but that such invocation produces less readable stack
    # traces. Consequently, we prefer the present implementation.
    if [[ -o interactive ]]
    then throw ZeshyException
    else exit ${exit_status}
    fi
}

# void source_zeshy_component(
#   string component_name1, string component_name2, ...)
#
# Source the passed Zeshy components (i.e., Zsh scripts in this directory).
function source_zeshy_component() {
    (( # >= 1 )) || die 'expected at least one component name'
    for filename ("${@}") {
#       say "sourcing \"${ZESHY_OVERLAY_ROOT}/${filename}\"..."
        source "${ZESHY_OVERLAY_ROOT}/${filename}"
    }
}

# ....................{ BOOTSTRAP                          }....................
# Bootstrap Zeshy by loading core aliases, globals, and autoloads, the minimal
# clique of Zeshy components. All subsequent Zeshy functions are implicitly
# loaded on the first call to such functions by the autoload system.
source_zeshy_component alias global autoload

# Having now compiled Zeshy's digest file and hence defined all autoloads
# applicable to the current user, call a top-level autoload finalizing setup.
setup_zeshy

# --------------------( WASTELANDS                         )--------------------
#say 'finalizing aliases...'
#source "${ZESHY_OVERLAY_ROOT}/alias"
#say 'finalizing globals...'
#source "${ZESHY_OVERLAY_ROOT}/global"
#say 'finalizing autoloads...'
#source "${ZESHY_OVERLAY_ROOT}/import"
#say 'finalizing startup...'
#   [[ -f  "${filename}" ]] || die "\"${filename}\" not found"
#   source "${filename}"
# * I've been operating under the assumption Zsh variables require quoting to
#   preserve spaces. It appears that is *NOT* the case, under default Zsh shell
#   options. It doesn't hurt anything as is, but we could probably stand to
#   remove most if not all existing quoting. Ah; I see, somewhat. Lists must
#   always be quoted, but scalars need never be. Still, 'tis a confusing
#   distinction. We're better off persisting with the current method, I reckon.

# zeshy: consider upgrading zsh to ${ZESHY_NEEDS_ZSH_VERSION}" 2>&1

#FIXME: *BRILLIANT IDEA*. Stack traces are great. But, with longer function
#implementations, output like:
#
#   print_stack_trace: make_and_install_kernel() failed with exit status 1
#        \_ TRAPZERR() { /root/.zeshy/digest.zwc/make_and_install_kernel: 34 }
#         \_ make_and_install_kernel() { /bin/zsh: 130 }
#
#...isn't really helpful. What is the 34th line of that function excluding
#comments? Right. There's no easy way to peruse that function's commented
#implementation and discern just where the fault lies. Hence, a solution:
#
#* Add a new "ZESHY_DEBUG" config global. (Think we might have one already, yes?)
#* If enabled, print_stack_trace() should implicitly with no external effort
#  append something resembling "which ${funcname[2]}" to its output. That's
#  closer to what we want, but still incomplete: "which" has no option for
#  prefixing each line of output with its line number, which is what we need.
#  I guarantee there's an "awk" script to do it, though. Search us up the fix!

#       (( i == 3 )) && {
#           funcname_first="${funcname}"
#           fileline_first="${fileline}"
#       }
    # Message to print. (Yes, its declaration and definition must be separate.)
    # Message to print. (Yes, its declaration and definition *MUST* be separate.
    # I'm not entirely clear why, but declaring and defining the message in the
    # same command induces inexplicably, undebuggably subtle errors.)
#   print "script name: $(get_script_name)"
#   [[ -n "${ZESHY_IS_CRONJOB}" ]] && logger -p cron.notice -- "${message}"
#   [[ -n "${ZESHY_IS_CRONJOB}" ]] && logger -p cron.err -- "${message}"
#   elif [[ "${#funcstack}" -gt 0 &&
#            "${funcstack[-1]}" != (get_script_name|say|msay|cry) ]]; then

#       if "${funcstack[${i}]}" == "${funcfiletrace[${i}]}"
#       print "${frame_prefix} ${funcname}() {${filename}:${fileline}}"

# This
# Each such frame signifies a previously called function, sourced file, or evaluated "eval". Each call
# stack of such frames signifies a stack trace of the complete code path from
# the most to least recently called function, source file, or evaluated "eval".

    # Continue the default trap handler, as under TRAPZERR(). 

# After any command returns non-zero exit status but prior to executing the next
# such command, instruct Zsh to:
#
# * Execute the TRAPZERR() trap function.
# * Unwind the call stack, exiting all intermediate shells, back to the
#   originating shell -- typically, the interactive shell from which the failing
#   command was transitively run.
# * If the failing command was run directly by some Zsh function:
#   * Return from that function with that command's non-zero exit status.
# Terminate the current shell, returning the non-zero exit status of the prior
# command.
#
# The combination of enabling this option and defining TRAPZERR() as below
# offers a robust alternative to the customary command "set -e", whose
# default implementation dangerously terminates the current shell on failure.
#setopt err_return

# * Execute the ZERR trap, if set.
# * Execute the TRAPZERR trap function, if defined.
# * If the failing command or function was itself called from a function:
#   * Return from that function with that command or function e return value .
# Terminate the current shell, returning the non-zero exit status of the prior
# command.
#
# The combination of enabling this option and defining TRAPZERR() as below
# offers a robust alternative to the customary command "set -e", whose
# default implementation dangerously terminates the current shell on failure.
#setopt err_return

    #FIXME: Hmm. If called from a pipe (e.g., "false or die "false!"), we really
    #want to use "${pipestatus[-2]}" here rather than "${?}".
#   if (( # == 0 ))
#   then say
#   else say "${1:-}"
#   fi

    #FIXME: Truncate.
    # Arcane bit-munging. Exit codes are of size "char" (i.e., a single byte).
    # Non-zero exit statuss with high bit set signify signal-driven fatal errors
    # and with high bit unset signify command-specific fatal errors. In the
    # former case, all bits excluding the high bit signify the signal number.
    # Hence, signal-driven exit statuss are constructable by adding 128 to the
    # signal number.
    #
    # SIGINT signifies fatal error of signal number 2. Rather than hard-code
    # that constant, we note:
    #
    # * Zsh passes the signal number as the first argument to trap functions.
    # * Zsh continues handling trap function-trapped signals as if untrapped
    #   when receiving non-zero exit statuss from such functions. In such cases,
    #   Zsh returns this exit status as the signal result to calling processes.
    # 
    # Since we prefer Zsh handle the actual interrupt as such with the same
    # exit status as it would customarily return, the result follows.
#   return ${exit_status}
#   return $(( ${exit_status} + 128 + ${signal_number} ))

    # Die with the prior return code.
#   die_with_exit_status ${exit_status}

# void die_with_exit_status(int exit_status = 1)
#
# Exit the currently executed script or function with the passed return code.
#die_with_exit_status() {
#   for ((i = 1; i <= ${#funcstack}; i++)) { print "${i}: ${funcstack[${i}]}" }
#   if is_interactive; then
#   then print 'throwing exception'; throw ZeshyException

    # If the current context is a function called from an interactive and/or
    # login shell, unwind the call stack; otherwise, kill the current process.
#    if is_interactive
#    then throw ZeshyException
#    else exit ${1:-${ZESHY_FAILURE_CODE}}
#    fi
#    print 'still here!'
#}

#set -e

#FIXME: Zsh fails to trigger ZERR traps from within the sourcing of zprofile and
#zshrc. I have no idea why. Since the following line does nothing to help,
#however, I can only assume this is somehow the intended behavior. Nonetheless,
#file a mailing list comment.
#trap TRAPZERR ZERR
#trap 'print_stack_trace; throw ZeshyException' ZERR

#   if is_interactive
#   then return $(( ${exit_status} + 128 + ${signal_number} ))
#   else exit       ${exit_status}
#   fi
 #   throw ZeshyException
#   print 'still here...'
#   for ((i = 1; i <= ${#funcstack}; i++)) { print "${i}: ${funcstack[${i}]}" }

    # Terminate the current shell, returning the non-zero exit status of the prior
    # command. This effectively enables "set -e" (i.e., the ERR_EXIT option,
    # terminating the current shell on SIGZERR signals).
#   eval 'throw ZeshyException'; return ${exit_status}
#   die_with_exit_status ${exit_status}

# * Uhm; how did I never see this? Zsh supports loop syntax resembling:
#   for d (../**/*) {
#   }
#   No need for cumbersome "for d in (../**/*); do ... done" nonsense. 

#FIXME: This is likely a Zsh bug, perhaps corrected in some subsequent version.
#But throwing uncaught exceptions from interactive functions appears to
#literally undefine the calling function. Yes, this makes no sense.

    #FIXME: Given the new stack trace facilities, this probably no longer applies.
    # Unset the script name, if set. This forces the get_script_name() function
    # to obtain the name of the most recently called non-trivial function, which
    # is of considerably more assistance when an error occurs.
#   local ZESHY_SCRIPT_NAME=

#   print
#   print     -- "${message} (stdout)"
#   print -u2 -- "${message} (stderr)"

#   elif is_interactive; then
        #FIXME: This is actually the reverse of what one might want. We should
        #select the *LAST* function on the function stack. 
#       typeset -i i
#       for (( i = ${#funcstack}; i >= 1; i-- )); do
#           print "${i}th function: ${funcstack[${i}]}"
#           [[ "${funcstack[${i}]}" == /* ]] && 
#
#           case "${funcstack[${i}]}" in
#               run*|die*|say*|msay*|cry*|ask_*) continue ;;
#               *) break ;;
#           esac
#       done
 
        # Ignore all intermediary I/O- and error handling-specific function
        # calls. Skip the first stack frame corresponding to the current
        # function by starting at the second stack frame.
#       typeset -i funcstack_size=${#funcstack}
#       for (( i = 2; i <= funcstack_size; i++ )); do
#           print "${i}th function: ${funcstack[${i}]}"
            # Order ignorable function names by likelihood, for "efficiency."
#           case "${funcstack[${i}]}" in
#               run*|die*|say*|msay*|cry*|ask_*) continue ;;
#               *) break ;;
#           esac
#       done
         
        # If after ignoring non-relevant functions there still exists at least
        # one function on the callstack, return that function's name.
#       if (( i <= funcstack_size )); then
            # If this name is an absolute path, return that path's basename.
#           if [[ "${funcstack[${i}]}" == /* ]]
#           then print "${funcstack[${i}]:t}"
            # Otherwise, return this name as is.
#           else print "${funcstack[${i}]}"
#           fi
        # Otherwise, return the default name.
#       else print 'zeshy'
#       fi
    # Otherwise, return the default name.
#   else print 'zeshy'
#   fi

# Math module supplementing Zsh's rudimentary math functionality with essential
# math operations (e.g., exponentiation).
#zmodload zsh/mathfunc

# Load broadly applicable Zsh modules.
#load_default_modules

# ....................{ DEFAULTS                           }....................
# void load_default_modules()
#
# Load broadly applicable Zsh modules.
#load_default_modules() {
    # Stat module wrapping the stat() system call with the zstat() Zsh function. Do
    # not load this module via "zmodload zsh/stat", as that wraps the stat() system
    # call with a stat() Zsh function, conflicting with the "stat" command.
#   zmodload -F zsh/stat b:zstat

    # Math module. While Zsh provides rudimentary math functionality out of the box,
    # some pivotal functions (e.g., exponentiation) are only provided by this.
#   zmodload zsh/mathfunc

    # Module exposing Zsh's C-based internal dictionaries as Zsh-based associative
    # arrays, including:
    #
    # * "$funcstack", having the current function call stack for user inspection.
    # * "$functions", having the current set of all functions for redefinition and
    #   later restoration of differing function definitions.
#   zmodload zsh/parameter

    # Perl-Compatible Regular Expression (PCRE) module. Note that, although
    # enabling the "rematch_pcre" option below implicitly loads this module on the
    # first use of the "=~" operator in a test, all code prior to that will not
    # have access to methods exposed by this module. Thus, simply import it
    # explicitly.
    #
    # See "String matching" below for use notes.
#   zmodload zsh/pcre

    # Utility module adding additional built-ins, including the commonly called
    # "zformat", "zparseopts", and "zstyle" functions.
#   zmodload zsh/zutil

# void _zeshy_bootstrap(string filename1, string filename2, ...)
#
# Source the passed Zeshy components in the passed order.
#_zeshy_bootstrap() {
#    for script_file in "${@}"; do
#        if [[ ! -f "${script_file}" ]]; then
#            print "zeshy: \"${script_file}\" not found or not a file" 1>&2
#            exit 1
#        fi
#        
#        source "${script_file}"
#    done
#}

#   _zeshy_init_bootstrap "${ZESHY_HOME}/src/init/if_shell_interactive/"*
## void _zeshy_init(void)
#_zeshy_init() {
#}
#
## Call and then immediately unset (i.e., delete) _zeshy_main().
#_zeshy_init
#unfunction _zeshy_init

# Import Zeshy Core defining import() prior to importing other dependencies.
#[[ $(whence -w zimport) =~ ': function' ]] ||
#    source "${ZESHY_HOME}/src/init/core"

# in a
# "system-sensitive" manner: i.e., importing only specific dependencies
# relevant to the current system.
    # Add Zeshy's "site-functions/" to the function path, if that directory exists.
#   is_dir "${ZESHY_HOME}/site-functions" and
#       fpath=( "${ZESHY_HOME}/site-functions" "${fpath[@]}" )

    #FIXME: Old.
    # Match all non-dotfiles in the current directory via the "(^D)" modifier:
    # i.e., all files and directories except this one. Since Zeshy components 
    # explicitly import dependencies, importation order is *NOT* important.
#   string import_script_path
#   for import_script_path in "${ZESHY_HOME}/src/zeshy"/*(^D); do
#       zimport "${import_script_path}"
#   done
#       [[ $(basename "${import_script_path}") =~\
#           "^(\..*|${ZESHY_MAIN_SCRIPT_BASENAME})$" ]] ||

# ....................{ PATHS                              }....................
# Absolute path to the current script.
#local zeshy_core_path=$(readlink --canonicalize-existing "${0}")

# Directory having the current script. This environment variable should have
# been permanently added to the current system on Zeshy installation. If it was
# not, however, ensure that it at least temporarily exists now.
#[[ -n "${ZESHY_HOME-}" ]] ||
#    export ZESHY_HOME=$(readlink --canonicalize-existing $(dirname "${zeshy_core_path}")"/../..")

    # Import all non-dotfiles in this directory with the "(^D)" modifier (i.e.,
    # all files and directories *NOT* prefixed by a "."). Since Zeshy scripts
    # explicitly import dependencies, order of import is mostly insignificant.

#   if is -z\
#       "${ZESHY_IMPORTED_PATH_TO_MTIME[(I)"${zeshy_script_path}"]}" or
#       "${ZESHY_IMPORTED_PATH_TO_MTIME["${zeshy_script_path}"]}" -ne\
#       "${zeshy_script_mtime}" si; then

# This glob expression matches the basename of all non-executable readable
# files residing under every path in the function path list, "${fpath}". Via
# Zsh mandate, every such file basename corresponds to the autoloadable
# function name defined in the file. Thus, matching these basenames also
# matches all autoloadable function names.
#
# * "-.x" ignores non-executable files. While not strictly necessary, forum
# posters suggest this beneficially permits you to ignore undesirable autoloads
# by chmodding away their executable bit.  * "-.r" ignores non-readable files.
# This is strictly necessary.  * ":t" extracts the "tail" (i.e., basename) of
# the current file. This is a history modifier extracting each file's filename
# sans absolute path.
# 
#for autoload_function_name in ${^fpath}/*(N-.r:t); do

#FIXME: I suppose I don't quite understand why we can't simply implement this as
#some variant of '"${@}" 1>/dev/null 2>&1'. Doesn't that work as is?
#run_quietly() { run "${(q)@}" 1>/dev/null 2>&1 }

#   is "${#command}" exceeds 0 si or die 'expected exactly one command'
#
#global_alias to='|'

    # Decompacted:
    # 
    # * "1", the passed name.
    # * "(P)", the variable the passed name refers to.
    # * "-", the value to expand this variable to if unset:
    #   in this case, simply the empty string.
    # * "-z", true only if this variable is the empty string and hence unset.
#    is -z "${(P)1-}" si

# ....................{ COMMANDS ~ return codes            }....................
# void try_as_superuser(string command)
#
# Run the passed command as the superuser and, if it fails with error,
# terminate the current execution environment with the same error.
#try_as_superuser() {
#    run_as_superuser "${@}" or die
#}

# int get_last_exit_status(void)
# 
# Return the return code returned by the previous command.
#alias get_last_exit_status='is_ok'

# bool is_ok(void)
#
# Return success if the previous command succeeded. Otherwise, return failure.
#is_ok() {
#    # Cache the prior command's return code, as our initial sanity check on
#    # arguments replaces this code with its own.
#    integer prior_command_exit_status=${?}
#    die_unless_no_args
#    return ${prior_command_exit_status}
#}

# bool is_error(void)
#
# Return success if the previous command failed. Otherwise, return failure.
#is_error() {
#    # Cache the prior command's return code, as our initial sanity check on
#    # arguments replaces this code with its own.
#    integer prior_command_exit_status=${?}
#    die_unless_no_args
#    is ${prior_command_exit_status} -ne ${ZESHY_SUCCESS_CODE} si
#}

# string canonicalize_path_nonfatal(string pathname)
#
# Get the canonicalized form of the passed absolute path. Unlike the
# canonicalize_path() function, this function does not raise an exception when
# the passed path does not exist; it simply canonicalizes as much of this path
# as exists.
#canonicalize_path_nonfatal() {
#    die_unless_one_arg 'expected exactly one pathname'
#    readlink --canonicalize-missing "${1}"
#}

#FIXME: This and try() now obsolete by TRAPZERR(). Excise everywhere.
# void try_run_quietly_as(string username, string command)
#
# Run the passed command as the passed user run_quietly and, if it fails with error,
# terminate the current execution environment with the same error.
#try_as() {
#    die_unless_at_least_two_args\
#        'expected exactly one username and one command'
#
#    # Locally set "${ZESHY_RUN_AS}". The run() function notes this variable as
#    # set and behaves accordingly...
#    string ZESHY_RUN_AS="${1}"; shift
#
#    # Call try() with all remaining arguments: the command to be run.
#    try "${(q)@}"
#}

# void try(string command)
#
# Run the passed command and, if it fails with error, terminate the current
# execution environment with the same error.
#try() {
#    run "${(q)@}" or die "\"${@}\" returned error code ${?}"
#}

# void try_run_quietly(string command)
#
# Run the passed command run_quietly and, if it fails with error, terminate the
# current execution environment with the same error.
#try_run_quietly() {
#    run_quietly try "${@}" or die "\"${@}\" returned error code ${?}"
#}

# void try_run_quietly_as(string username, string command)
#
# Run the passed command as the passed user run_quietly and, if it fails with error,
# terminate the current execution environment with the same error.
#try_run_quietly_as() {
#    run_quietly try_as "${@}" or die "\"${@}\" returned error code ${?}"
#}

# bool or(...)
#
# Return true if at least one of the passed command's returned successfully.
#global_alias or='||'

# bool and(...)
#
# Return true if both of the passed command's returned successfully.
#global_alias and='&&'

# bool not(...)
#
# Negate the passed command's return code.
#alias not='!'

#FIXME: This function appears to be functionally obsolete now. If so, kill and
#rename which_command() to this.
# Aliases.
#alias which_binary="which_command"
#alias which_binary_nonfatal="which_command"

# string which_command(string command)
#
# Print the absolute path to the passed command: e.g.,
#
#     >>> which_command zsh /bin/zsh
#
# If the passed command is a string, all but the first whitespace-delimited word
# of the string is ignored: e.g.,
#
#     >>> which_command "zsh -x -o shwordsplit scr" /bin/zsh
#
# If the passed command is not found, if multiple binaries are passed, or if no
# command is passed, prints an error and dies.
#which_command() {
#Call the whence() built-in outside of "local" so as to retain the return
    # code. (ZSH == FAIL on that one.) 
#    string command_path; command_path="$(which_command "${@}")"
#    die_unless_ok "\"${1}\" not found"
#    print "${command_path}"
#}
#
# Identical to the which_command() function except that, if the passed command
# does not exist, returns nothing rather than dies.

#FIXME: No longer meaningful under TRAPZERR(); excise.
# void die_unless_ok(string error_message)
#
# Die with the passed error message unless the previous command succeeded.
#die_unless_ok() {
#    # Cache the prior command's return code, as our initial sanity check on
#    # arguments replaces this code with its own.
#    integer prior_command_exit_status=${?}
#    die_unless_one_arg 'expected exactly one error message'
#    is ${prior_command_exit_status} -eq ${ZESHY_SUCCESS_CODE} si or die "${1}"
#}

# void say_import(string script_name)
#
# Echo a message informing the user that the passed script name is being
# imported. This function should be called prior to actually importing that
# script if feasible.
#say_import() {
#    die_unless_one_arg 'expected exactly one script name'
#
#    say "loading \"${1}\"..."
#}

    # If the caller has supplied no explicit "${ZESHY_SCRIPT_NAME}", supply a
    # default.  Failing to do this encourages the say() function to use the
    # name of this function as its script name, producing unaesthetic results.
#   "${ZESHY_SCRIPT_NAME:=zeshy}"

        # Print the passed error message followed by a complete backtrace.
#   cry "${@}"
#   print_stack_trace
 #
    # Shells differentiate
    # fatal from non-fatal errors by setting the high bit (i.e., 2^7 = 128).
    # According to "zshbuiltins", this forces Zsh to continue handling the
    # signal as if untrapped and hence returning the same exit status. Having no
    # arcanely carnal knowledge of the Linux signal implementation, it's unclear
    # why setting the high bit 

    #FIXME: Old.
    # If the passed path is a directory, only import filename
    # "${ZESHY_MAIN_SCRIPT_BASENAME}" in this directory.
#   is -d "${zeshy_script_path}" si and
#       zeshy_script_path="${zeshy_script_path}/${ZESHY_MAIN_SCRIPT_BASENAME}"
    
    # If this path does not exist, die.
#   is -f "${zeshy_script_path}" si or die "\"${zeshy_script_path}\" not found"
 #
#FIXME: Impossible to remember, I'm afraid. Perhaps "fail_if_error", instead?
# int fail_if_previous_command_failed(void)
# 
# Return from the current function with failure if the previous command or
# function also returned with failure.
#alias fail_if_previous_command_failed="is_ok || return ${ZESHY_FAILURE_CODE}"

#; ZESHY_IMPORTED_PATH_TO_MTIME=( )
#   typeset -Ax ZESHY_IMPORTED_PATH_TO_MTIME; ZESHY_IMPORTED_PATH_TO_MTIME=( )
 # The "-Ax" option to the "typeset" commands defines each such variable as an
# [A]ssociative array (i.e., a dictionary) and e[x]ported to the global
# environment for later access.

# Ascertain whether we are running as a cronjob and, if so, alter output
# appropriately. In particular, print the current date as a timestamp prior to
# printing all other output.

#   die_unless_at_least_one_arg 'expected at least one string'

#   # If no string was passed, attempt to read "stdin" for piped input.
#   if is_one_arg; then
#       set -- "${1}" "$(< /dev/stdin)"
#   fi

#   pcre_compile "${1}" || die "\"${1}\" not a valid regular expression"
#   pcre_match "${2}" || return ${?}
#   return ${ZESHY_SUCCESS_CODE}

# This function returns success 
# If this regular expression matched at least one group, this function returns
# this group as a string for caller convenience... Else, this function returns
# nothing. In the former case, callers may retrieve the set of all groups via
# the global "${match}" array. (See above.)

    # When the whence() built-in fails, it prints the name of the passed command
    # followed by "not found". Thus, if it prints such a message, the passed
    # command does not exist. Note that testing the return code is problematic
    # here, since setting a local variable always forces the return code to 0
    # (i.e., success). 
#   if [[ "${command_path}" == *" not found" ]]; then
#       return ${ZESHY_FAILURE_CODE}
#   else
#       echo "${command_path}"
#       return ${ZESHY_SUCCESS_CODE}
#   fi

    # O.K., this is tricksy: if the eventual caller explicitly quote-protected
    # the passed command name, there exists another "layer" of quote-protection
    # to unravel. Do so, alas.
#   if ! is_installed "${command_name}" && is_installed "${(Q)command[1]}"; then
#       command_name="${(Q)command[1]}"
#   fi

    #echo "PID: $$"
    #echo "current_process_basename:"
    #get_current_process_basename
    #echo "current_process_command_line:"
    #get_current_process_command_line

# ....................{ GLOB EXPRESSIONS                   }....................
# string *glob_non_dotfiles_in(string dirname)
#
# Glob all non-dotfiles (i.e., all files and directories whose first character
# is not a '.' dot) in the passed directory.
#glob_non_dotfiles_in() {
#    [[ ${#} -eq 1 ]] || die "expected exactly one directory name"
#    local dirname="${1}"
#    [[ -d "${dirname}" ]] || "\"${dirname}\" not a directory"
#
#    # Glob all non-dotfiles via the "(^D)" modifier.
#    echo "${dirname}"/*(^D)
#}

 # Enable variable substitution in prompt expansions in a "synchronous" fashion.
# Enabling this re-evaluates each prompt expansion after perform each
# interactive command with the current values of those variables without
# having to manually recreate the prompt each time.
#setopt promptsubst

#The existence of this variable also
# serves to inform callers as to whether or not this script has been imported
# yet and, when it has, to avoid reimporting it.

# Directory above the directory having the current script. This environment
# variable should have been permanently added to the current system as well.
#[[ -n "${ZESHY_ROOT}" ]] ||  
#    export ZESHY_ROOT=$(readlink --canonicalize-existing "${ZESHY_HOME}/..")

#FIXME: Harvest comments from the now-dead portion of zimport_file().
#
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#O.K.; the game plan:
#* Separate each function into a separate file. No symlinks. I know; I know.
#  This is awful. But Zsh is as it is on this score. There's no fixing that.
#* Initialization needs to be centralized into a set of core files. Here's
#  what I'm thinking, now: cleave the "src/" directory into:
#  * "src/root", containing "zprofile", "zlogin", and "zshrc".
#  * "src/main", containing this file, "core", and all other initialization as
#    perhaps another file or two ("globals"? bah!). All global variable
#    declarations need to be shifted here.
#  * "src/auto/generic", containing the bulk of Zeshy as such autoloadable function
#    files. All such functions are safely applicable to all systems.
#  * "src/auto/command", allowing for conditionally autoloaded command-specific
#    function directories (e.g., "src/auto/command/ssh").
# * We need one digest for all of "generic" and one digest for each immediate
#   subdirectory of "src/auto/command", the latter conditionally autoloaded if
#   such command exists.
# * This scheme clearly allows for things like "src/auto/os", should we require
#   it. I'm currently considering trashing that... just assume GNU/Linux, for
#   the moment. (Time!)
# * Hmm; perhaps?:
#   "src/catabolize/".
#   "src/initialize/".
#   "src/bootstrap/".
#   "src/framework/".
#   "src/profile/".
#   "src/context/".
# * Ah; O.K.; how about just:
#   "src/construct/".
#   "src/bootstrap/".
#   "src/autoload/always".
#   "src/autoload/if_installed".
# * Or mayhap:
#   "src/boot/".
#   "src/init/".
#   "src/auto/always".
#   "src/auto/if_installed".
#
#Yes, it's lame. But our hands are really constrained, here.
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!
