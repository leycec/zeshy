#!/usr/bin/env zsh
# ====================[ main                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Bootstrap Zeshy, a high-level shell scripting lingua franca implemented in
# pure zsh, into the current zsh shell environment.
#
# --------------------( SEE ALSO                           )--------------------
# http://zsh.sourceforge.net/Doc/Release/Functions.html
#   Detailed description of trap functions.
#
# http://www.bash2zsh.com/essays/essay1_file_manager.html
#   Concise introduction to suffix aliases, mime types, and file magic.
#
# --------------------( TODO                               )--------------------
# * Zeshy's complexity and hence fragility is beginning to enter the caustic
#   zone. We *REEEALLY* need to add unit tests, post-haste. This will entail a
#   massive effort, but be well worthwhile. It's nigh impossible to keep up with
#   the current pace of new regressions without installing at least:
#
#   * One unit test per function intended to execute successfully.
#   * One unit test per function intended to execute unsuccessfully.
#
#   Thanks to our dependency on exception handling, it *SHOULD* be exceedingly
#   simple to doctor up a small unit test framework. When we expect unsuccessful
#   execution and hence a thrown exception, such framework will need a function
#   accepting the name of the expected thrown exception; on catching an
#   exception, such function must dynamically inspect the call stack for such
#   function. Alternatively, it'd be great if the exception thrown by both die()
#   and our TRAPZERR() function itself performed such inspection and *SET THE
#   NAME OF THE FUNCTION TO BE THE RESPONSIBLE die_*() FUNCTION NAME*. Pretty
#   sweet! We currently use a useless exception name (e.g., "ZeshyException");
#   so, this would be quite a welcome change.
# * Pretty sweet snippet adding a Vim-style modeline in vi-keys mode showing
#   whether currently in INSERT or NORMAL mode. I reckon we could ably integrate
#   this into the default theme, which would go a long way to converting me to
#   the vi-keys ZLE. See:
#   http://www.zsh.org/mla/users/2006/msg01180.html
#   http://www.gott-gehabt.de/800_wer_wir_sind/thomas/Homepage/Computer/zsh/vi-showmode
#   Perhaps there's a more recent working solution, as well?
# * Sweet! While zsh itself doesn't provide a visual mode for its emulation, an
#   enterprising zsh user has written a set of ZLE functions doing so; see:
#   https://bazaar.launchpad.net/~raybuntu/+junk/ZSH_stuff/view/head:/zle_vi_visual.zsh
#   The same code includes an incredibly helpful series of functions
#   automatically copying text yanked at the zsh command line into the X
#   clipboard. Definitely essential. I've wanted that *FOREVER*!
# * zsh helpfully provides a "DVORAK" setopt option, only of interest if
#   interactive. It'd be quite nice to dynamically determine whether a dvorak
#   keymap is currently in use and, if so, implicitly enable such option.
#   However, this fails to account for hardware-based keymapping (e.g.,
#   Kinesis). Perhaps a "config" global -- say, ZESHY_IS_KEYMAP_DVORAK" -- would
#   be of assistance here.
# * Use the "vcs_info" zsh module for displaying VCS-specific metadata in a VCS-
#   agnostic fashion.
# * Incorporate grml-zshrc functionality where helpful, currently available at:
#   http://git.grml.org/f/grml-etc-core/etc/zsh/zshrc

#FIXME: Given short form while, case, etc. statements, there's no longer a need
#for long form-specific reserved words. I believe the full set of such words is,
#according to section "RESERVED WORDS" of "man zshmisc": "esac", "do", "done",
#"fi", and "end". To minimize the number of reserved words, disable such
#reservation as follows:
#
#   disable -r do done end esac fi
#
#Note that we'll probably need to temporarily re-enable such words when sourcing
#exogenous zsh shell scripts. Replacing "disable" with "enable" above should do it.

#FIXME: O.K.; I conceived a simple, but critical, technique for improving
#Zeshy's robustness on upgrades: namely, *ALWAYS* explicitly source *ALL*
#configuration files supplied by the current overlay on digest file recompilation
#(i.e., from the overlay itself before copying such files to "~/.zeshy/config/"),
#*BEFORE* resourcing configuration files from "~/.zeshy/config/". What does this
#achieve? Simple. It ensures that any globals that might be missing from the
#current user's configuration will simply be set to default Zeshy settings. This
#is substantially better than the current approach, which basically ensures
#"zsh: ZESHY_EUEUEUBLAHBLAH not defined" errors on upgrades. Given how easy this
#is, there's really no (or only little) downside to ramming it through.
#FIXME: When "zsh" is upgraded while Zeshy is running, things go downhill pretty
#quickly until such Zeshy sessions are restarted. For example, if no exception
#has yet been thrown and hence functions throw() and catch() not autoloaded,
#then the next fatal error will trigger unhelpful zsh errors resembling
#"zsh: throw: command not found". It'd be quite nice to detect such upgrade and:
#
#* For each running interactive Zeshy shell, implicitly restart such shell on
#  the next prompt display (i.e., after completing the current command).
#* For each running non-interactive Zeshy shell, well... there's probably not
#  much we can efficiently do. Hopefully, such shell completes quickly!
#FIXME: It'd be nice to profile Zeshy a bit to see what's consuming the most
#time. (I suspect the single "autoload -w" statement loading the digest, but
#one never knows, really.) Perhaps add a new "--profile-zeshy-startup" option.
#FIXME: It'd be *GREAT* to optimize release builds by stripping all comments
#from components -- particularly for top-level components sourced over and over.
#Unfortunately, we basically need a zsh parser to do so reliably; also, note
#that the license-specific comments must *NOT* be deleted. (Though, presumably
#one could delete all comments indiscriminantly and then manually prepend back
#the canonical license comments.) Hmm; a bit odd, but zsh introduces the
#following parameter expansion flag: "${(Z:C:)string_name}". Basically, "Z" is
#the bigger brother of "z" splitting strings on shell words. To quote the
#release notes, "(Z:C:) parses comments and strips them". At also strips
#extraneous unquoted whitespace, which also seems desirable. So... this seems
#like a hell of a long shot, but couldn't we just:
#
#* Load the file to be stripped into a local string variable.
#* Strip comments from such variable with "${(Z:C)...}", implicitly also
#  converting such string into a list.
#* Convert such list back into a string with a simple
#  'print_string "${list[@]}"', or some such.
#* Serialize out the resulting string. Would it actually work? I have no idea.
#  But the following command-line test run looks *REALLY* promising:
#
#    >>> string m; m="$(< main)"
#    >>> print "${(Z:C:)m}" | less
#
#  Wow! The output looks perfectly safe for sourcing. It does include redundant
#  substrings of semicolons (e.g., "; ; ; ; ; ; ; ;"), but that at least is
#  easily globally substituted out. To truly test this, we'll want to take
#  something that's genuinely zsh with no extraneous Zeshy -- say
#  "/usr/share/zsh/5.0.0/functions/v Completion/Unix/_git", the largest such
#  autoloadable function. If this works on *THAT* file, it probably works
#  anywhere. Worth a shot, anyway, due to the simplicity of the implementation.
#  zsh does all the heavy lifting here, as is sensible and gentlemanly.

# ....................{ PROFILING                          }....................
# Set the current time since the Unix epoch *BEFORE* all subsequent operations
# to ensure reasonable profiling results.

# Load module "datetime", providing timing-related globals expanded below. Defer
# loading all other modules *AFTER* initiating such timing to improve fidelity.
zmodload zsh/datetime

# Time in partial seconds since the Unix epoch at which zeshy was first loaded
# (i.e., at which the current script was first sourced).
float ZESHY_STARTUP_TIME_SECONDS="${EPOCHREALTIME}"

# ....................{ DOCUMENTATION                      }....................
# Lists of alias, function, and global documentation specific to top-level zeshy
# components (e.g., "main", "compile"). Each list element is a help string
# documenting some alias, function, or global defined by such a component. Avoid
# documenting such lists formally, which we delete below to conserve space.
local -a\
    ZESHY_CORE_HELP_ALIASES\
    ZESHY_CORE_HELP_FUNCTIONS\
    ZESHY_CORE_HELP_GLOBALS

# ....................{ GLOBALS                            }....................
ZESHY_CORE_HELP_GLOBALS+='
string ZESHY_ZSH_VERSION_REQUIRED

Oldest `zsh` version under which `zeshy` is known to run without error.
'
export ZESHY_ZSH_VERSION_REQUIRED=5.0.0

# ....................{ VERSION                            }....................
#FIXME: Non-ideal. Ideally, replace this with a generic zeshy function accepting
#two version specifiers and returning success if the former exceeds the latter.

# If *NOT* running under such version, print an error message to standard error
# and return rather than exiting to avoid exiting interactive shells with non-
# zero exit status.
autoload -U is-at-least
is-at-least ${ZESHY_ZSH_VERSION_REQUIRED} || {
    print "zeshy: installed zsh ${ZSH_VERSION} < required zsh ${ZESHY_ZSH_VERSION_REQUIRED}" 1>&2
    return 1
}

# Prohibit duplicate paths from being added to canonical global lists, removing
# any such duplicates that may already have been added. Since ${path} in
# particular is central to sane shell operation, do so before subsequent logic.
#
# Unlike *SOME* typeset options (e.g., "-r"), typeset option "-U" does not
# entirely destroy the contents of such lists. Rather helpful, that.
typeset -U path cdpath fpath manpath

# ....................{ OPTIONS                            }....................
# Enforce strictness, as under conventional high-level languages.
setopt no_unset           # exception on attempting to expand unset parameters
setopt warn_create_global # warning on attempting to set undeclared parameters
setopt no_err_exit        # Zeshy implements more robust error handling
setopt no_err_return      # Zeshy implements more robust error handling

# Variable assignment.
setopt no_global_export   # prevent "typeset -x" from implying "typeset -xg"
setopt no_ksh_typeset     # perform word splitting on variable assignment

# Avoid printing previously assigned variables when calling typeset() with
# variables with no new assignments (e.g., "typeset specular_reflection").
setopt typeset_silent

# Variable expansion.
setopt c_bases           # print non-base 10 integers in C format (e.g., "0x33")

# Shell parsing.
setopt no_ksh_arrays      # enable 1-based lists subscriptable without braces
setopt no_ksh_autoload    # treat autoloaded files as function definitions
setopt magic_equal_subst  # enable filename expansion on "="-prefixed strings
setopt short_loops        # enable "for ... (...) { ... }"-style shell constructs

# Shell quoting.
setopt no_csh_junkie_quotes  # allow unescaped newlines in quotes
setopt no_sh_word_split  # do not field split unquoted parameters
setopt rc_quotes         # parse '' as ' in single quotes (e.g., '''' == "'")

# Command execution.
setopt no_print_exit_value  # do not print "zsh: exit $?" on command failure

# Track and hence print line numbers for eval() expressions relative to the
# environment enclosing such eval() rather than such expressions themselves. The
# latter, which remains the zsh default, produces largely unreadable errors.
setopt no_eval_lineno

# Command history.
setopt hist_fcntl_lock   # prefer fcntl()- to ad hoc-based history file locking
setopt hist_lex_words    # ensure accurate parsing of commands saved to disk
setopt hist_no_store     # do not add history-specific command lines
setopt hist_reduce_blanks # reduce extraneous whitespace in history items

# When adding history items, also remove all older duplicates of such items.
setopt hist_ignore_all_dups

# Do not add whitespace-prefixed command lines to the history.
setopt hist_ignore_space

# Reload command lines performing history expansion into the editing buffer
# rather than executing such lines immediately.
setopt hist_verify

# Append history items to the history file as such items are entered rather than
# when the shell exits, for safety. This also has a pleasant side effect of
# sharing the history file between multiple shell sessions.
setopt inc_append_history

# Path changing.
setopt auto_cd           # automatically "cd" to directories in command position
setopt auto_pushd        # automatically "pushd" directories onto the dirstack
setopt pushd_ignore_dups # do not push duplicate directories onto the dirstack
setopt pushd_silent      # run "pushd" and "popd" silently

# File globbing.
setopt no_case_glob      # glob case-insensitively
setopt no_glob_assign    # do not glob variable assignments (use lists instead)
setopt no_ignore_braces  # enable "{...}"-style brace expansion
setopt no_ignore_close_braces  # render ";" optional for single-line functions
setopt extended_glob     # enable extended globbing (e.g., "#", "~", "^")
setopt glob              # enable globbing
setopt glob_dots         # permit "*" to match "."-prefixed pathnames

# Avoid interactively confirming star-style path removal (e.g., "rm *"). While
# nice, zeshy already interactively confirms *ALL* attempted path removals.
# Since zeshy's default behavior is arguably safer than zsh's, avoid redundant
# confirmations of such removal.
setopt rm_star_silent

# Silently reduce non-matching globs to the empty string rather than printing an
# error message. While the latter appears preferable, zsh fails to also:
#
# * Signal ZERR and hence call TRAPZERR() on non-matching globs, thus failing to
#   throw exceptions or print stack traces on glob failure.
# * Permit the printed error message to be customized. The error messages zsh
#   prints are largely unhelpful for non-interactive scripts (e.g.,
#   "zsh: no matches found: Tomoe(:A)"), offering no human-readable context for
#   script debugging or development.
#
# Hence, we reluctantly disable errors on non-matching globs. Zeshy scripts and
# functions must test for glob failure by testing list emptiness. With practice,
# this should (!) become second nature: e.g.,
#
#     >>> list glob_match; glob_match=( "PiKHAL/TiKHAL"(:A) )
#     >>> is_nonempty "${glob_match}" or die "\"PiKHAL/TiKHAL\" not found"
setopt null_glob

# File writing.
setopt no_clobber        # forbid ">" from truncating existing files

# PCRE matching.
#
# This enables Perl-Compatible Regular Expression (PCRE) matching via the "=~"
# test operator, by implicitly loading the "zsh/pcre" module when requested.
# This module matches the entire match into "${MATCH}" and each group match
# into array elements of "${match[@]}" where the first match is "${match[1]}".
# For additional documentation on the "zsh/pcre" module, see:
# http://zsh.sourceforge.net/Doc/Release/zsh-Modules.html#SEC192
#
# Note that traditional glob matching is always available via the "==" test
# operator: e.g.,
#     [[ $(whence -cp fahey) == *" not found" ]] && echo "Farewell."
setopt rematch_pcre      # prefer Perl-Compatible Regular Expression matching

# Process control.
setopt long_list_jobs    # list jobs in long format
setopt no_notify         # report job status only before prompt printing

# Shell I/O.
setopt no_flow_control   # disable interactive flow control (e.g., ^S, ^Q)
setopt ignore_eof        # do not treat ^D as "exit", interactively
setopt interactive_comments  # enable "#" comments in interactive commands
setopt print_eight_bit   # enable 8-bit output for completion lists

# Shell prompt.
#
# Enable variable substitution in prompt definitions. This dynamically re-
# expands each prompt definition and variables referenced in that definition
# immediately prior to displaying that prompt; by default, on the other hand,
# zsh statically caches the expansion of each prompt definition for quick re-
# use when displaying those prompts. (While marginally faster, the latter is
# remarkably less useful as it requires redefining and exporting a prompt to
# alter the display of that prompt.)
setopt prompt_subst

# Tab completion.
setopt auto_menu         # use menu completion after two tabs
setopt complete_in_word  # complete inside words
setopt no_list_ambiguous # only list matches if ambiguous

# ....................{ MODULES                            }....................
# Load all zsh modules required by this parcel or parcel "digest". Note zsh
# module "zsh/datetime" to have already been loaded above.

# Wrap system call stat() with zsh function zstat(). Do not load this module
# with "zmodload zsh/stat", as that wraps such call with zsh function stat()
# conflicting with external POSIX command "stat". Do not bother autoloading such
# module on the first call to zstat(), as zeshy startup *ALWAYS* calls such
# function. See parcel "digest" for further details.
zmodload -F zsh/stat b:zstat

# Expose zsh's internal C-based hash tables as zsh-based dictonaries. Do not
# bother autoloading such module on the first expansion of such a dictionary,
# due to the overwhelming number and basic essentiality of such dictionaries.
# These include:
#
# * ${funcstack}, the stack of functions, scripts, and "eval" statements on the
#   current call path.
# * ${functions}, the set of all currently defined functions, permitting
#   redefinition and subsequent restoration of new function implementations.
zmodload zsh/parameter

# ....................{ EXCEPTIONS                         }....................
# Astonishingly, zsh implements throw() and catch() as user-defined functions
# autoloaded from list ${fpath} for the current user. Autoload such functions
# before called by functions below. Defer all other autoloads to
# startup_zeshy_autoloads().
autoload -U throw catch

# The catch() implementation selectively disables filename globbing for such
# function by defining an alias of the same name. Since such alias is
# unavailable on the first call to catch(), define such alias here.
alias catch='noglob catch'

#FIXME: The documentation could certainly use streamlining.
ZESHY_CORE_HELP_FUNCTIONS+='
integer TRAPZERR(integer signal_number = SIGZERR)

Trap SIGZERR, a zsh-specific signal on non-zero exit status from zsh builtins
and functions and external commands. Doing so effectively globally enables
"setopt ERR_RETURN", such that on any command returning non-zero exit status:

* If the current shell is interactive, implicitly throw an exception unwinding
  the call stack of such shell. If such exception is uncaught, return the
  current user to the prompt.
* Else, the current shell is non-interactive. Immediately exit such shell with
  non-zero exit status.
* If the calling shell fails to handle such exit status (e.g., by using
  "or true") and is also running Zeshy, repeat the above logic until either
  exiting all non-interactive shells or returning to an interactive shell.

In either case, handle such error according to the current user''s Zeshy
configuration (e.g., by printing a stack trace, documentation, and/or source
code related to such error). See die() for further details.

Unlike "setopt ERR_EXIT", this handler explicitly unwinds the call stack of
only the current shell rather than all parent shells.
'
function TRAPZERR() {
    # Save the exit status of the prior command prior to overwriting this status
    # by handling such error.
    integer exit_status=${?}

    # Handle such exception and return such command's exit status, mimicking the
    # action of "setopt ERR_RETURN". (See "man zshoptions" for further details.)
    die_with_exit_status "${exit_status}"
    return ${exit_status}
}

ZESHY_CORE_HELP_FUNCTIONS+='
string die(string error_message1, string error_message2, ...)

Print the passed exception message and related metadata requested by the current
user to standard error and throw an exception. Metadata includes the following:

* If boolean ${ZESHY_ERROR_HANDLER_IS_PRINTING_CALL_STACK} is enabled, a stack
  trace of the current call path. See print_call_stack() for further details.
* If boolean ${ZESHY_ERROR_HANDLER_IS_PRINTING_DOCUMENTATION} is enabled,
  documentation for the function or script throwing such exception. See
  print_exception_thrower_documentation() for further details.
* If boolean ${ZESHY_ERROR_HANDLER_IS_PRINTING_CALL_SOURCE} is enabled, the
  source code of the function or script throwing such exception. See
  print_exception_thrower_implementation() for further details.
'
function die() {
    # Exit status of the prior command. zsh defines "pipestatus" to be a global
    # list with elements the return values of each subcommand of the prior pipe
    # command or of the prior command if not a pipe command. Conversely, zsh
    # defines "?" to be a global integer with the return value of the prior
    # command. Since the former subsumes the latter *AND* the latter fails to
    # provide the return value of the prior command when a subcommand of a pipe
    # command, we defer to the former. For example, consider:
    #
    #     # Define helper functions.
    #     >>> pipe_status() { print ${pipestatus[-1]} }
    #     >>> exit_status() { print $? }
    #
    #     # Show "pipestatus" to return the required values.
    #     >>> true; pipe_status  # this works...
    #     0
    #     >>> true; true | false || pipe_status  # ...and so does this.
    #     1
    #
    #     # Show "?" to *NOT* return the required values.
    #     >>> true; exit_status  # this works...
    #     0
    #     >>> true; true | false || exit_status  # ...but this doesn't.
    #     0
    integer exit_status=${pipestatus[-1]}

    # If the prior command succeeded, coerce such exit status into an error.
    (( ${exit_status} == 0 )) && exit_status=1

    # Handle such exception.
    die_with_exit_status "${@}" "${exit_status}"

    #FIXME: Suffix the exception name by the name of the function directly
    #responsible for throwing this exception. See curse_exception_exit_status()
    #for simple logic getting this function name.

    # If canonical function throw() is defined, unwind the current call stack,
    # returning the current user to an interactive prompt if the current shell
    # is interactive or exiting such shell otherwise.
    if { typeset -f throw &>/dev/null } {
        throw ZeshyException
    # Else, something awful. Print a bleak warning.
    } else {
        print 'zeshy: throw() undefined, probably as exception handler threw exception' 1>&2
    }

    # Return success to avoid triggering TRAPZERR and hence another exception.
    return 0
}

ZESHY_CORE_HELP_FUNCTIONS+='
string die_with_exit_status(
    string error_message1 = "", string error_message2, ..., integer exit_status)

Print the passed exception message (defaulting to the empty string) and related
metadata requested by the current user to standard error. See die() for further
details, which calls this function to perform such printing.
'
function die_with_exit_status() {
    # Redirect all output printed below to standard error. Yes, a single
    # suffixing "} 1>&2" actually suffices. You rock, zsh! (Sometimes.)
    {
        # If the current call stack contains this function at any position other
        # than the first (corresponding to the current call), this function
        # transitively threw an exception. Blithely continuing on is likely to
        # transitively throw another such exception, resulting in infinite
        # recursion. To halt such recursion before it obliterates existence,
        # print an error and return immediately on detecting such recursion. To
        # do so efficiently, search from the end (i.e., root) of such stack; if
        # the first matching caller is not the first, a witch! As below, return
        # success to avoid triggering TRAPZERR and hence another exception.
        (( ${funcstack[(I)die_with_exit_status]} == 1 )) || {
            # For safety, print a mini rather than full stack trace.
            print
            print "zeshy: exception handler threw exception: ${*}"
            print "zeshy: exception handler failed with exit status ${exit_status}"
            print "zeshy: current call stack: ${funcstack[*]}"
            return 0
        }

        # Validate passed arguments. See is_integer_nonnegative() for details.
        (( # )) || die 'expected optional error messages and one exit status'
        local exit_status="${@[-1]}"
        [[ "${exit_status}" == <-> ]] ||
            die "exit status \"${exit_status}\" not a positive integer"

        # Pop such status from the list of passed arguments.
        set -- ${@[1,-2]}

        # If called directly from the command line, no such exception exists.
        (( ${#funcstack} >= 2 )) || die 'exception not thrown'

        # If such message exists, print such message.
        (( # )) &&
            # If print_error() is defined, call such function.
            if { typeset -f print_error &>/dev/null } {
                print_error "${@}"
            # Else, print such message with a one-liner.
            } else {
                print "zeshy: ${*}"
            }

        # Print a blank line.
        print

        # Print a description of the passed non-zero exit status.
        # If print_exception_message() is defined, call such function.
        if { typeset -f print_exception_exit_status &>/dev/null } {
            print_exception_exit_status "${exit_status}"
        # Else, print such message with a one-liner.
        } else {
            print "zeshy: failed with exit status ${exit_status}"
        }
#       print "printed exit status"

        # If the current user's zeshy configuration requests printing stack
        # traces on exceptions, do so. If the zeshy function to do so has not
        # yet been defined, attempt a stub implementation... Printing such
        # traces is essential *ESPECIALLY* at zeshy bootstrap, before such
        # function is autoloaded from zeshy's user digest file.
        [[ -n "${ZESHY_ERROR_HANDLER_IS_PRINTING_CALL_STACK-}" ]] && {
#           print "printing call stack"
            # If print_call_stack() is defined, call such function.
            if { typeset -f print_call_stack &>/dev/null } {
#               print "calling print_call_stack()"
                print_call_stack
            # Else, print such stack with an implementation distilled from
            # print_call_stack(). See such function for further details.
            } else {
                integer funcstack_size=${#funcstack} i caller_line
                local frame_prefix='    \\_' filename caller_name
#               print "printing stack frame"

                for (( i = 1; i <= funcstack_size; i++ )) {
                    caller_name="${funcstack[${i}]}"
                    caller_line="${funcfiletrace[${i}]##*:}"
                       filename="${funcfiletrace[${i}]%:*}"

                    typeset -f -- "${caller_name}" &>/dev/null &&
                        caller_name="${caller_name}()"
                    print --\
                        "${frame_prefix} ${caller_name} { ${filename}: ${caller_line} }"

                    frame_prefix=" ${frame_prefix}"
                }
            }
        }
    # If such handling itself throws an exception, catch such exception here to
    # prevent uncaught exceptions from recursively triggering TRAPZERR(). Since
    # zeshy functions may sadly be the source of such exception, avoid calling
    # zeshy functions in catch logic.
    } always {
        # If an exception was thrown...
        (( ${+EXCEPTION} )) &&
            # ...and if canonical function catch() is defined, catch such
            # exception and print a warning.
            if { typeset -f catch &>/dev/null } {
                # If catch() sets global ${CAUGHT} to the name of the uncaught
                # exception, print such name. We disable filename globbing for
                # catch() with the above alias and hence could write "catch *"
                # rather than "catch '*'". However, note that the former fails
                # with obscure errors when such alias is (either intentionally
                # or unintentionally) deleted. For safety, quote such glob.
                catch '*' &&
                    if [[ -n "${CAUGHT-}" ]] {
                        print "zeshy: exception handler threw exception \"${CAUGHT}\""
                    # Unfortunately, catch() may not set such global! *shrug*
                    } else {
                        print "zeshy: exception handler failed with non-zero exit status"
                    }
            # ...else, something awful. Print a despicable warning.
            } else {
                print 'zeshy: catch() undefined, probably as exception handler threw exception'
            }
    } 1>&2

    # Return success to avoid triggering TRAPZERR and hence another exception.
    return 0
}

# ....................{ INTERRUPTION                       }....................
#FIXME: It appears this may encourage non-halting interrupts, which is bad. I
#have no idea why, but strongly suspect calling curse_call_stack() in this
#context to be the culprit. Disable for now.
# integer TRAPINT(integer signal_number = SIGINT)
#
# Trap SIGINT (i.e., signal interrupt, as after a user-driven <Ctrl-C> event).
#function TRAPINT() {
#    integer signal_number=${1}

    # Print the current call stack to indicate the point of interruption.
#    curse_call_stack

    # Store the interrupted line in the history. By default, zsh omits such
    # lines -- somewhat unhelpfully. Dismantled, this is:
    #
    # * "zle", true only if the history is currently active.
    # * "-s", output the interrupted line to the history rather than stdout.
    # * "-r", preserve escapes from "echo" command manipulation.
    # * "--", prevent dash prefixes in the interrupted line from being
    #   misinterpreted as "print" command options.
    # * "${BUFFER}", the interrupted line.
#    zle && print -sr -- "${BUFFER}"

    # Arcanely uncanny bit-munging. Exit status is always a 1-byte integer.
    # Non-zero exit status with:
    #
    # * The high bit unset signifies a command or function-specific error.
    # * The high bit set signifies a signal-specific error. All bits excluding
    #   the high bit signify the signal number.
    #
    # Hence, constructing a signal-specific exit status requires merely adding
    # 128 to the desired signal number. Moreover, zsh interprets non-zero trap
    # function return values as the exit status to be returned from running the
    # default handler for the trap. Since we would like to continue running the
    # default handler for the trap (SIGINT, in this case), this function returns
    # a non-zero value. Rather than hard-coding the desired signal number, reuse
    # the number zsh passed as the first argument to this function.
#    return $(( 128 + ${signal_number} ))
#}

# ....................{ OPTIONS                            }....................
# Map from parsed option name to optional value. As expected, unparsed options
# remain preserved in the current argument list.
local -A arg_options

# List of shell commands to be run parsed from options "-c" and "--command".
local -a arg_shell_commands

# List of shell options to be enabled parsed from options "-o" and "--option".
local -a arg_shell_options

#FIXME: I'm fairly assured that passing multiple commands and options with
#long-form options works as advertised. I strongly doubt, however, that passing
#multiple commands and options with short-form options works as advertised. If
#not, we'll probably want to drop the "-M" and manually map short- to long-form
#arguments following option parsing. (Simple, if a tad tedious.)
#FIXME: Add an option for profiling zsh startup. Yes, zsh supports this.
#Exceptionally cool; I had no idea! See Dennis' great answer here:
#
#http://stackoverflow.com/questions/4351244/can-i-profile-my-zshrc-zshenv
#http://stackoverflow.com/questions/6693515/zsh-how-to-time-a-block-of-code
#
#We should most certainly add a run_profiled() function for printing a timing
#profile after running the passed command. There appear to be several ways of
#doing this: the "setopt xtrace" approach of the first URL above; the
#"time ( ... )" approach of the second URL above; and the "zprof" module. I'm
#unclear which is better but am currently leaning towards the latter. Regardless
#of which approach we choose, output to standard error by default, so as to
#ensure expected behavior under process substitution. (Naturally, a secondary
#function could be implemented to log to a passed file, instead.)
#FIXME: Hmm; yes, the "zprof" approach appears superior. Its output rocks, as
#expected. Mimics "gprof", so there you go. It's a bit wieldy to use, requiring
#unload of the module to disable profiling, but... no problems, given a
#run_profiled() helper.

# Parse passed options *BEFORE* operating on any Zeshy files, as the former
# could modify the behavior of the latter (e.g., by preventing Zeshy from
# recompiling and loading its digest file). If such parsing fails, set option
# "-h" to non-zero exit status, instructing the end of this script to print help
# to standard error and return with such status. See
# set_map_to_arg_options_with_help_from<>.
#
# For readability, map short- to long-form options. Map option
# "--no-zeshy-dot-dir" to "--zeshy-dot-dir", thus implicitly setting the latter
# to the empty string on parsing the former.
zparseopts -M -D -E -A arg_options --\
    h=-help -help \
    v=-verbose -verbose\
    -recompile-digest\
    -recompile-digest-if-zeshy-home-changed\
    -version\
    c+:=arg_shell_commands -command+:=arg_shell_commands\
    o+:=arg_shell_options -option+:=arg_shell_options\
    -zeshy-dot-dir:: -no-zeshy-dot-dir=-zeshy-dot-dir ||
    arg_options[--help]='failed'
#print -- "passed option names (${#arg_options}): ${(k)arg_options}"

# ....................{ OPTIONS ~ paths                    }....................
#FIXME: Actually, move the commentary from "bin/zeshy" to here.
ZESHY_CORE_HELP_GLOBALS+='
string ZESHY_HOME

Absolute path of the system-wide directory containing the codebase for the
currently installed version of `zeshy`.
'
export ZESHY_HOME
[[ -n "${ZESHY_HOME}" ]] || ZESHY_HOME="$(print -- "${0:h}"(:A))" || {
    print "zeshy: main script \"${0}\" not found" 1>&2
    return 1
}

ZESHY_CORE_HELP_GLOBALS+='
string ZESHY_OVERLAY_DIR

Absolute path of the system-wide directory containing all `zeshy` scripts in the
codebase for the currently installed version of `zeshy`.
'
# While currently synonymous with ${ZESHY_HOME}, it's depressingly easy to
# conceive of situations in which the two differ.
export ZESHY_OVERLAY_DIR="${ZESHY_HOME}"

ZESHY_CORE_HELP_GLOBALS+='
string ZESHY_DOT_DIR_BASENAME

Basename of `zeshy`\''s user-specific dot directory.
'
export ZESHY_DOT_DIR_BASENAME='.zeshy'

#FIXME: Rename to ZESHY_DOT_DIR
ZESHY_CORE_HELP_GLOBALS+='
string ZESHY_DOT_DIR

Absolute path of `zeshy`\''s user-specific dot directory, defaulting to
"${HOME}/${ZESHY_DOT_DIR_BASENAME}". If `zeshy` was passed command-line option:

* `--zeshy-dot-dir={dot_dir}`, this is such directory instead.
* `--zeshy-dot-dir=` or `--no-zeshy-dot-dir`, this is the empty string instead.

If this path is the empty string, `zeshy` avoids reading from or writing to this
directory or files or subdirectories of this directory. For sanity, `zeshy` loads
with default user settings _and_ sources the entire `zeshy` codebase. Since this
is understandably slow, avoid passing option `--no-zeshy-dot-dir` except where
required (e.g., package manager installation).
'
# Default such directory to "~/.zeshy".
export ZESHY_DOT_DIR="${HOME}/${ZESHY_DOT_DIR_BASENAME}"

#FIXME: Replace "[[ -n "${ZESHY_DOT_DIR}" ]] ||" with a similar alias to
#is_zeshy_verbose_and<>, probably named is_zeshy_dot_dir_or<>. See below!
#FIXME: Actually, setting such global to the empty string is somewhat dangerous
#as Zeshy functions failing to properly test such global for emptiness prior to
#expansion will end up attempting to read and write from directories resembling
#"/.zeshy/config/posix", *WHICH IS TOTALLY BAD.* To avert this, there's really
#no choice but to *UNSET* this global here at the top-level and then define a
#convenience alias resembling:
#
#    alias is_zeshy_dot_dir_or='(( ${+ZESHY_DOT_DIR} )) ||'
#
#Dead simple, really. We just need to do it. *AND DO IT SOON.* This is bloody
#dangerous, and quite unfriendly.
#FIXME: I see two amenable solutions (in no particular order):
#
#1. If passed "--no-zeshy-dot-dir", unset *ALL* such globals. This is a pretty
#   sweet solution, frankly. We could simply perform such unsetting *AFTER*
#   exporting all such globals here. (Should work, no?)
#2. If passed "--no-zeshy-dot-dir", be clever and set ZESHY_DOT_DIR="/dev/null".
#   This is the one system-wide path pretty much guaranteed to exist on all
#   *nix's and *NOT* be a directory. Hence, any attempt to read from or write
#   no any path "${ZESHY_DOT_DIR}/pathname" will always and reliably fail. That
#   said, it's a tad lazy: the failure doesn't show up until attempting an
#   actual file operation. The former solution spits up an error much earlier,
#   which is great.
#2a. If we adopt the approach of 2., note that we setting ZESHY_DOT_DIR=$'\0' is
#    a much better solution *GUARANTEED* to always produce failure.
#FIXME: Actually test this. Shouldn't be terribly difficult: just temporarily
#move "~leycec/.zeshy" aside and pass "--no-zeshy-dot-dir" to an interactively
#run "zeshy" process. If "~leycec/.zeshy" doesn't appear, we've done something
#spectacularly right. Huzza!
#FIXME: We should automatically enable option "--no-zeshy-dot-dir" whenever the
#filesystem hosting the desired ${ZESHY_DOT_DIR} is read-only. This is
#particularly important for running Zeshy under read-only filesystems (e.g.,
#squashfs), as required for running from archival media (e.g., CD, DVD) or
#read-only flash hardware (e.g., routers).

# If passed the dot directory option, replace such default. If passed the non-
# dot directory option, this silently replaces such default with the empty
# string, thus disabling use of such directory.
if (( ${+arg_options[--zeshy-dot-dir]} )) {
    ZESHY_DOT_DIR="${arg_options[--zeshy-dot-dir]}"
# If the current user's ${HOME} is the root directory, the current user is
# either "cron" or a subsidiary thereof. In such case, default this directory to
# under "/var/".
} elif [[ "${HOME}" == '/' ]] {
    ZESHY_DOT_DIR='/var/cache/zeshy'
}

ZESHY_CORE_HELP_GLOBALS+='
string ZESHY_USER_CONFIG_DIR

Absolute path of the user-specific directory containing `zeshy`''s configuration.
'
export ZESHY_USER_CONFIG_DIR="${ZESHY_DOT_DIR}/config"

ZESHY_CORE_HELP_GLOBALS+='
string ZESHY_USER_OVERLAY_DIR

Absolute path of the user-specific directory containing third-party `zeshy`
components (e.g., plugins, styles, themes).
'
export ZESHY_USER_OVERLAY_DIR="${ZESHY_DOT_DIR}/overlay"

# ....................{ OPTIONS ~ paths : cache            }....................
ZESHY_CORE_HELP_GLOBALS+='
string ZESHY_USER_CACHE_DIR

Absolute path of the user-specific directory caching `zeshy`-specific paths.
'
export ZESHY_USER_CACHE_DIR="${ZESHY_DOT_DIR}/cache"

ZESHY_CORE_HELP_GLOBALS+='
string ZESHY_USER_DIGEST_FILE

Absolute path of the user-specific digest file to which `zeshy` compiles itself.
Such compilation assumes system- and user-specific state (e.g., command paths),
implying such file to be system- and user-specific and hence _not_ reliably
portable between systems and users.
'
export ZESHY_USER_DIGEST_FILE="${ZESHY_USER_CACHE_DIR}/digest.zwc"

ZESHY_CORE_HELP_GLOBALS+='
string ZESHY_USER_VERSION_FILE

Absolute path of the user-specific file caching `zeshy`\''s current version.
'
export ZESHY_USER_VERSION_FILE="${ZESHY_USER_CACHE_DIR}/version"

# ....................{ OPTIONS ~ startup                  }....................
#FIXME: Zeshy's install script should replace such string with a value
#corresponding to whether or not a release or debug build is being installed.

ZESHY_CORE_HELP_GLOBALS+='
boolean ZESHY_IS_DEBUGGING

If true, enable expensive developer-specific logic. This includes:

* Printing verbose debug messages on `zeshy` startup.
* Printing verbose trace messages on `zeshy` startup to measure startup cost.
* Recompiling `zeshy`''s user digest file on changes to the `zeshy` codebase. For
  `zeshy` developers, such recompilation is essential to fast development. For
  `zeshy` non-developers, detecting such changes is unnecessarily wasteful.
'
# Zeshy's installation script defaults such boolean to "true" if installing a
# debug build and to the empty string (i.e., false) otherwise. When uninstalled
# (e.g., when run from a git repository), the non-empty placeholder value
# effectively defaults such boolean to "true".
export ZESHY_IS_DEBUGGING="${ZESHY_IS_DEBUGGING-@ZESHY_IS_DEBUGGING@}"

# If debugging Zeshy, forcefully enable debug-specific options *BEFORE* testing
# whether or not at least one such option was passed.
[[ -n "${ZESHY_IS_DEBUGGING}" ]] && {
    arg_options[--compile-digest-if-zeshy-home-changed]=
    arg_options[--verbose]=
}

#FIXME: Document option "--compile-digest".

# If true, recompile Zeshy's user digest file -- regardless of whether a
# dependency of such file has changed since such file's last compilation. Do
# *NOT* bother exporting this boolean. Unlike
# ${ZESHY_USER_DIGEST_FILE_IS_DEPENDENT_ON_ZESHY_HOME}, of which post-startup
# testing by is_zeshy_dot_digest_outdated() appears reasonable, post-startup
# testing by the same function of this global is nonsensical. When the caller
# passes "--compile-digest", they expect such recompilation to occur only once
# at initial startup and then subsequently revert to normalcy -- *NOT* to force
# is_zeshy_dot_digest_outdated() to return true on all subsequent calls.
#
# While other methods for achieving the same effect exist (e.g., touching
# Zeshy's user configuration directory when passed option "--compile-digest"),
# such methods have non-idempotent and hence unexpected side effects.
local ZESHY_USER_DIGEST_FILE_IS_COMPILING=

ZESHY_CORE_HELP_GLOBALS+='
boolean ZESHY_USER_DIGEST_FILE_IS_DEPENDENT_ON_ZESHY_HOME

If true, Zeshy''s user digest file depends on all files and directories within
Zeshy''s codebase, in which case changing any such file or directory triggers
recompilation of such digest on the next Zeshy startup. Note that regardless of
the value of this boolean, Zeshy always recompiles such digest on upgrading
Zeshy''s codebase to a new version.
'
export ZESHY_HOME_IS_DOT_DIGEST_FILE_DEPENDENCY=

ZESHY_CORE_HELP_ALIASES+='
string is_zeshy_verbose_and(
  string command_name, string command_arg1, string command_arg2, ...)

If Zeshy''s user configuration enables debugging, run the passed command; else,
perform a no-op (i.e., return true without running anything).
'
# If the caller requests verbosity, define is_zeshy_verbose_and<> to run the
# passed command; else, define such alias to ignore such command. The latter
# reduces debug statements to constant time noops, simulating the "compiling
# away" of such statements under conventional high-level language optimization.
alias is_zeshy_verbose_and='true ||'

# If at least one command-line option was passed, handle all options upon which
# Zeshy startup subsequently depends (e.g., digest-specific options).
if (( ${#arg_options} )) {
    (( ${+arg_options[--verbose]} )) && alias is_zeshy_verbose_and=''
    (( ${+arg_options[--compile-digest]} )) &&
        ZESHY_USER_DIGEST_FILE_IS_COMPILING='true'
    (( ${+arg_options[--compile-digest-if-zeshy-home-changed]} )) &&
        ZESHY_USER_DIGEST_FILE_IS_DEPENDENT_ON_ZESHY_HOME='true'
}

# ....................{ LOAD                               }....................
# If sourcing the current script under zsh startup logic (e.g., from a zsh
# script with basename matching either ".zlogin", ".zprofile", or ".zshrc"),
# prevent zsh from reloading Zeshy if already loaded earlier during such logic.
#
# Ideally, the current script should only ever be sourced by the "zeshy" script
# installed with Zeshy. Ideally, zsh startup logic should avoid sourcing the
# current script. Since Zeshy is valid zsh, however, this script is sourceable
# as is by any zsh script or shell -- including zsh startup scripts. In such a
# case, failing to prevent zsh from reloading Zeshy induces the following:
#
# * Some process runs the "zeshy" script as a new child process.
# * This process runs under "zsh" due to such script's shebang line.
# * This process sources at least ".zshrc" and possibly also ".zlogin" and
#   ".zprofile", depending on runtime context.
# * Sourcing such script could source the current script, loading Zeshy.
# * After sourcing the current script, control returns to the "zeshy" script,
#   which either:
#   * Sources the current script, reloading Zeshy.
#   * Replaces this process with a new process running "zsh" passed the current
#     script as its first argument and hence reloading Zeshy twice:
#     * Once by zsh startup logic, as above.
#     * Once by the first argument passed to such script.
#
# In either case, zsh loads Zeshy at least twice and possibly more. Avoid this!
#print "zeshy: argv[0]=$0}"
#print "zeshy: command line=$(< /proc/$$/cmdline)"
#print "zeshy: process ID (current)=$$"
#print "zeshy: process ID (parent!)=${PPID}"
#print "zeshy: process ID (cached.)=${ZESHY_PID_LAST_LOADED_BY-}"
#print "zeshy: passed option names=${(k)arg_options}"

ZESHY_CORE_HELP_GLOBALS+='
integer ZESHY_PID_LAST_LOADED_BY

Process ID of the most recent `zsh` process in the call stack to load `zeshy`.
'
export -i ZESHY_PID_LAST_LOADED_BY

# If the caller requests not reloading zeshy when previously loaded under the
# current shell and zeshy has indeed already been loaded, do not do so again.
if (( ZESHY_PID_LAST_LOADED_BY == $$ )) {
    # If zeshy has *NOT* been previously loaded under the current shell (as the
    # the lack of get_zeshy_version() implies), throw an exception.
    typeset -f get_zeshy_version &>/dev/null or
        die "get_zeshy_version() not defined, so zeshy not previously loaded"
# Otherwise, zeshy has not yet been loaded. Do so! Specifically:
#
# * If such shell is a login shell, establish sensible login shell settings.
#   See set_shell_login_defaults() for further details.
# * Source all zeshy configuration files.
# * If no zeshy digest file has been compiled or such file requires
#   recompilation (e.g., due to upgrading zeshy, editing zeshy configuration
#   files, or installing new command or uninstalling old commands from the
#   current ${PATH}), recompile such digest.
# * Prepend such digest to the current ${FPATH}, thus effectively loading all
#   zeshy functions. For efficiency, the zsh autoload system delays defining
#   these functions until the first call to such functions.
# * Perform all zeshy startup tasks, including:
#   * Defining all zeshy aliases and globals.
#   * Calling all user-defined startup hooks.
} else {
    # If the current shell is a login shell, set login-specific behavior.
    [[ -o login ]] && source -- "${ZESHY_HOME}/login"

    # Autoload zeshy's user digest file, recompiling such file if needed.
    source -- "${ZESHY_HOME}/digest"

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #Note: this *MUST* be performed from a global rather than function context.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #
    # Undefine all globals defined by such recompilation. The reasons are subtle but
    # the logic flows like butter. zeshy may (and often does) declare globals to be
    # read-only. Sadly, zsh fails on attempting to redefine read-only globals. Since
    # the subsequent call to startup_zeshy() and hence startup_zeshy_globals() does
    # just that, undefine zeshy-specific globals prior to such calls. Do so in the
    # root global context (i.e., in this component outside of functions) to
    # guarantee expected behavior. "'tis all a tad silly and worm-bitten, but such
    # is life in the tranche of code trenches."
    #
    # Since zsh never fails on redefining aliases or functions, do not bother
    # undefining either. We could, but there's little point (or profit) in it.
    #
    # Unfortunately, the above sourcing exposes function but *NOT* alias
    # declarations. Since undefine_variable_from<> is an alias, manually
    # implement the following:
    #
    #     >>> is_list_nonempty ZESHY_GLOBAL_NAMES and  # must be "*" rather than "@"
    #     ...     undefine_variable_from "${ZESHY_GLOBAL_NAMES[*]}"
    is_zeshy_verbose_and print_message 'zeshy: starting up...'
    if [[ -n "${ZESHY_GLOBAL_NAMES-}" ]] {
        typeset +r -- "${ZESHY_GLOBAL_NAMES[@]}"
        unset      -- "${ZESHY_GLOBAL_NAMES[@]}"
    }

    # Startup zeshy, having recompiled zeshy's user digest file above and hence
    # defined all autoloads applicable to such user.
    startup_zeshy
    is_zeshy_verbose_and print_message 'zeshy: started up.'

    # Ensure this conditional evaluates to true on the next attempt to load
    # zeshy under the current shell by setting such process ID to that of this
    # shell after successfully loading zeshy. (The "after" is key here!)
    ZESHY_PID_LAST_LOADED_BY=${$}
}

#FIXME: Unset such globals at the same place that we undefine the corresponding
#setter functions. Since the former *MUST* happen here, that suggests we should
#shift the latter here.

# Undefine documentation-specific maps defined at the top of this script. As the
# prior conditional calling load_zeshy() calling compile_zeshy() has already
# serialized such maps onto on-disk key value stores, such maps are no longer
# needed. As such maps consume non-trivial resources (typically 8MB to 16MB of
# memory), safely delete such maps here after their serialization to disk above.
unset --\
    ZESHY_ALIAS_NAME_TO_HELP_STRING\
    ZESHY_FUNCTION_NAME_TO_HELP_STRING\
    ZESHY_GLOBAL_NAME_TO_HELP_STRING

# ....................{ OPTIONS ~ last                     }....................
# If at least one command-line option was passed, handle all remaining options.
# *AFTER* loading Zeshy.
(( ${#arg_options} + ${#arg_shell_commands} + ${#arg_shell_options} )) and {
    # Handle help options *BEFORE* all other remaining options, which
    # immediately return if passed and hence assume priority. If passed, ignore
    # all other options and if:
    #
    # * The above option parsing failed as signified by option value "failed",
    #   print usage help to standard error and return with non-zero exit status.
    # * Else, print help to standard output and return with zero exit status.
    (( ${+arg_options[--help]} )) and {
        if [[ "${arg_options[--help]}" == 'failed' ]] {
            run_redirecting_to_standard_error print_zeshy_help_usage
            die 'passed invalid or unknown options'
        } else {
            print_zeshy_help_usage
            return_true
        }
    }

    # If passed a version option, behave similarly to above.
    (( ${+arg_options[--version]} )) and {
        print_zeshy_version
        return_true
    }

    # Run all passed shell commands. Since every other element parsed into
    # ${arg_shell_commands} is either "-c" or "--command" and hence ignorable,
    # iterate elements in pairs ignoring the first such element.
    for placeholder arg_shell_command ("${arg_shell_commands[@]}") {
    #   print "zeshy: passed command \"${arg_shell_command}\""
        run "${arg_shell_command}"
    }

    # Enable all passed shell options *AFTER* running passed shell commands, to
    # ensure such commands run under the default Zeshy environment. Iterate list
    # elements in pairs ignoring the first such element, as above.
    for placeholder arg_shell_option ("${arg_shell_options[@]}") {
    #   print "zeshy: passed option \"${arg_shell_option}\""
        enable_shell_option "${arg_shell_option}"
    }
}

# ....................{ PROFILING ~ end                    }....................
# If debugging Zeshy, print a human-readable synopsis of Zeshy startup time. For
# accuracy, minimize shell overhead by:
#
# * Printing such synopsis as a single statement.
# * Avoiding calling Zeshy-specific functions to do so.
is_zeshy_verbose_and printf\
    "zeshy: startup in %.4f seconds (wall clock)\n"\
    $(( EPOCHREALTIME - ZESHY_STARTUP_TIME_SECONDS ))

# ....................{ ARGUMENTS                          }....................
# If the caller passed at least one non-option, non-empty argument (i.e.,
# neither prefixed by "-" or expanding to the empty string), source the first
# such argument as the path of a Zeshy script and pass such script all remaining
# such arguments. To avoid unfairly budgeting the time spent sourcing such
# script to Zeshy startup, do so *AFTER* printing Zeshy's startup time.
is_string_nonempty "${*}" and {
#   is_zeshy_verbose_and print "zeshy: sourcing \"${@}\"..."
    source -- "${@}"
}

# ....................{ MAIN                               }....................
# Avoid implicitly returning with non-zero exit status, as occurs when the prior
# statement is a conditional evaluating to false.
#print 'returning zsh!'
return_true

# --------------------( WASTELANDS                         )--------------------
# Explicitly load only the subset of requisite zsh modules (i.e., C-based shared
# libraries bundled with zsh) for which no appropriate autoloadable function
# exists. Since all other requisite zsh modules supply autoloadable functions
# implicitly loading their parent module on the first call to such function, we
# explicitly load no other modules.

#FUXME: Oh. Wait. But then we can't define any other user paths, *INCLUDING
#THOSE IN CONFIG FILES*. Right. That doesn't work.
#FUXME: Wait. This exposes a fatal flaw with the current approach: passing
#"--no-zeshy-dot-dir" will permanently compile Zeshy (until the next
#compilation without such option, anyway) without *SOME* dot directory files,
#as such files are compiled from "if_config/zeshy". That, in turn, suggests
#that we need to shift such globals from such configuration file *BACK* here.
#No choice, really; they depend on passed command line options and hence cannot
#be baked into Zeshy's user digest.
#system-wide directory containing the 
# See declare_alias(),
# declare_function(), and declare_global() for further details.
#FUXME: Nice, but a bit belated... I finally discovered how to reliably use curly braces for all
#conditional blocks. It's astonishingly simple: delimit the test in curly braces, too!
#
#    # Hence, this...
#    if true; then
#       print ok
#    fi
#
#    # ...is always reliably reducible to this.
#    if { true } {
#       print ok
#    }
#
#This extends to while, case, etc. statements. *sigh*

#setopt extended_history  # save timestamps in history
# Ignore duplicate history items during <Ctrl-[rs]>-style history searches.
#setopt hist_find_no_dups

# Prefer expiring duplicate to non-duplicate history items, when required due to
# reaching the maximum history size. Avoid also setting "hist_ignore_all_dups",
# which conflicts with this option.
#setopt hist_expire_dups_first

                # Note that although zsh "info"
                # documentation is section "Exception Handling" explicitly
                # states the catch glob expression to *NOT* require quoting
                # (e.g., "catch *"), doing so silently fails without actually
                # catching anything!

#Since this path may be the empty string, no Zeshy functionality may assume such
#path to be non-empty. Test this global for non-emptiness before reading from or
#writing to this directory or files or subdirectories of this directory.

#FUXME: Either the documentation or implementation is wrong. In any case, I'm
#not convinced *EITHER* is right. We really want to implicitly throw exceptions
#on triggering TRAPZERR(), don't we? As stated below, throwing exceptions
#interacts sanely with "always" blocks -- this doesn't. It's still a sane
#implementation, but one wonders if we can't do better.
            # If an exception was thrown, print such exception.
#           if (( ${+EXCEPTION} ))
#           then print "zeshy: exception handler threw exception \"${EXCEPTION}\""
            # Else, a command returned non-zero exit status.
#           else print "zeshy: exception handler failed with non-zero exit status"
#           fi
            # While zsh should set global ${CAUGHT} to the name of the uncaught
            # exception, it infrequently appears not to. Handle this.
#Handle the exception resulting from the passed presumably non-zero exit status,
#typically by printing such exception to standard error if desired by the current
#user.

#return non-zero exit
#status, effectively throwing an exception as discussed under TRAPZERR().
#set_function_documentation handle_exception '
#string handle_exception(integer exit_status)
#
#Handle the exception resulting from the passed presumably non-zero exit status,
#typically by printing such exception to standard error if desired by the current
#user.
#'
#function handle_exception() {

# This placeholder implementation called only when
# bootstrapping Zeshy will be replaced when loading Zeshy''s digest file.
    # Before calling *ANY* functions throwing exceptions on failure, 

    #FUXME: Is this overkill? What happens if we return 1 instead? Forcefully
    #trigger this... and see!
    #FUXME: Uhm; we already validate this below. Hmm.
    # Validate passed arguments. Avoid returning non-zero exit status on fatal
    # errors, as such status triggers an exception and hence infinite recursion.
#   (( # == 1 )) || {
#       print 'zeshy: handle_exception() expected one exit status' 1>&2
#       return 0
#   }

    # See is_integer_nonnegative() for implementation details.
#   local exit_status="${1}"
#   [[ "${exit_status}" == <-> ]] || {
#       print "zeshy: handle_exception() exit status \"${exit_status}\" not a positive integer" 1>&2
#       return 0
#   }

    #FUXME: Consider catching exceptions thrown by Zeshy startup and responding
    #appropriately...somehow.
#   }
#${#} -ge 1 and
#(( ${#} )) and is_string_nonempty "${@}"

#FUXME: Option parsing has become sufficiently long to warrant extrication into
#a new top-level component "options". Since sourcing files is moderately
#expensive and since we don't need to source such file unless passed at least
#one option, consider the following efficient conditional:
#
#(( ${#arg_options} + ${#arg_shell_commands} + ${#arg_shell_options} )) &&
#    source options
#
#Assuming no options to be passed (as will be the typical case under release
#builds), this should actually be faster than the current method (as we manually
#test whether each option is enabled or not).

    #FUXME: Extract into a new throw_exception() function for use in the
    #new die() function.
# ....................{ PRINTERS                           }....................
# Declare placeholder functions to be overridden after loading the Zeshy digest.

#set_function_documentation say '
#void say(string message = "")
#
#Print the passed message suffixed by a trailing newline to standard output.
#This placeholder implementation called only when bootstrapping Zeshy will be
#replaced when loading Zeshy''s digest file.
#'
#function say() {
    #FUXME: Quite certain we want to replace all "[[ -o interactive ]] && say"
    #and "interactively say" with merely "say". (The former are patently silly
    #and, let's be honest, dangerous, by duplicating logic *EVERYWHERE*.) That
    #said, I'm not convinced that the solution here is to simply prepend this
    #statement with "[[ -o interactive ]] && "; the problem, of course, are
    #pipes. We want functions like the following to work:
    #    function testem() { say 'Oh, hello!'; }
    #    testem | cat
#    print "zeshy: ${@}"
#}
#
#set_function_documentation cry '
#void cry(string message = "")
#
#Print the passed message suffixed by a trailing newline to standard error.
#This placeholder implementation called only when bootstrapping Zeshy will be
#replaced when loading Zeshy''s digest file.
#'
#function cry() {
    # Print this message. Do *NOT* call print() as "print -u2 -- "${message}".
    # While that appears superficially identical to the following call, passing
    # the desired file descriptor as an argument fails to preserve interleaving
    # with prior commands printing to file descriptor 1 (i.e., standard out).
#    print "zeshy: ${@}" 1>&2
#}

#FUXME: Add ANSI coloring to sayed messages if on an ANSI-capable terminal.
#Also, consider prefixing messages under cron with: "["$(date +'%F %T')"].

#FUXME: *WAIT*. We only need to define a placeholder say() and cry() here
#prefixing *ALL* passed messages with "zeshy: ".
#The real say() and cry() implementations should be subsequently defined by
#the currently enabled theme. Make it so with a sprinkle of ANSI excellence.
#(( ${#arg_options} + ${#arg_shell_commands} + ${#arg_shell_options} )) and {
#           print 'printing usage!'
#           print 'exiting zsh!'
            #FUXME: Revert to return_true() after correcting startup regression.
#           exit_zsh
# While is_zeshy_verbose_and<> is expanded frequently enough to warrant such
# alias, this boolean is expanded only once elsewhere. Avoid alias overkill.
# If Zeshy's codebase resides in a directory with basename "src", implicitly
# enable all options below. Such options are generally desirable when debugging
# Zeshy's developer-specific codebase, naturally residing under directory "src".
# In other words, this is a special case facilitating developer torpitude.
# (Hopefully, the cost of such test for non-developers is negligible......)
#[[ "${ZESHY_HOME}" == *'/src' ]] && {
#if (( ${+arg_options[--verbose]} ))
#then alias is_zeshy_verbose_and=''
#else alias is_zeshy_verbose_and='true ||'
#fi
#FUXME: This is terrible. I've since stumbled on the obvious solution: restore
#global boolean ${ZESHY_IS_DEBUGGING}, but do so *AT THE TOP OF THIS FILE*
#rather than in the configuration file. Default such global as follows:
#
#    ZESHY_IS_DEBUGGING=${ZESHY_IS_DEBUGGING-'@ZESHY_IS_DEBUGGING@'}
#
#So, the caller can override such global which defaults to non-empty. On
#installation, Zeshy's install script should (obviously) delete the hard-coded
#'@ZESHY_IS_DEBUGGING@' (i.e., replace such string with the empty string).
#Perfectimo.
#detecting an upgrade to new versions of Zeshy.
# Absolute paths for Zeshy-specific directories and files. See commentary below.
#   ZESHY_DOT_DIR\
#   ZESHY_DOT_DIR_BASENAME\
#   ZESHY_USER_CACHE_DIR\
#   ZESHY_USER_CONFIG_DIR\
#   ZESHY_USER_OVERLAY_DIR\
#   ZESHY_USER_DIGEST_FILE\
#   ZESHY_USER_VERSION_FILE

# In either case, such alias
# eliminates the non-negligible cost of testing option
# "--verbose" each debug statement, thus simulating conventional
# debug statements.
#
# While zsh implements no conventional debug-specific builtins (e.g., assert()),
# it does offer a sufficiently general-purpose, language-level device for
# simulating such builtins: aliases.
#
# Conventional high-level language compilers and interpreters reduce debug
# statements to noops when targeting release builds, eliminating the otherwise
# non-negligible cost of such statements. While zsh provides no conventional
# debug-specific builtins (e.g., assert), it does offer a general-purpose,
# language-level mechanism for simulating such builtins: aliases.
#
# Default such alias to ignore the passed command. If Zeshy's user configuration
# files enable debugging, redefine such alias after sourcing such files to run
# the passed command instead.

# If such scripts enable Zeshy debugging, redefine is_zeshy_verbose_and<>
# defined at the top of this component to run the passed command instead.
#FUXME: Rename to ZESHY_USER_CACHE_DIGEST_FILE.
#FUXME: Rename to ZESHY_USER_CACHE_VERSION_FILE.
#is -n "${ZESHY_IS_DEBUGGING-}" si and printf\
#FUXME: Parse ${arg_options} and ${arg_shell_commands} here. Test a bit, of course.

#   typeset -p ZESHY_COLOR
#   typeset -gAx ZESHY_COLOR
#   typeset -p ZESHY_COLOR
    #   print -l "===ZESHY_GLOBAL_NAMES===" "${ZESHY_GLOBAL_NAMES[@]}"
    #   print "glob: ${ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY}"
# Unfortunately, at least the sourcing of Zeshy component "autoload" must be
# performed from a global rather than function context. The reason is, of course, subtle:
# zsh fails
# to to properly unset globals declared from a function transitively called
    # Do so.
#   load_zeshy
#   typeset -p ZESHY_COLOR

#set_function_documentation load_zeshy '
#void load_zeshy(void)
#
#Load Zeshy into the current zsh shell. '
#function load_zeshy() {
#    # Validate passed arguments.
#    (( # == 0 )) || die 'expected no arguments'

#FUXME: O.K.; interesting. This *CAN'T* be a function. Fair and simple enough.
#typeset -gAx ZESHY_COLOR
    #FUXME: Kill this. Kill this soon. (You know you want to...)
#   setup_zeshy
    # Delay validating passed arguments aside from the number of such arguments
    # to subsequent serialization of such arguments to disk following digest
    # recompilation. This permits an intuitive calling style of calling this
    # function before declaring the function name passed to this function.
# Declare set_function_documentation() before defining the other two, as
# the latter depend on the former.
# Consider calling document_function() instead.
#To subsequently print such
#documentation, call print_function_documentation().
    # Validate passed arguments.
#   local function_name="${1}"
#typeset -Agx ZESHY_FUNCTION_NAME_TO_DOCUMENTATION
#    ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${1}]="${2}"
#typeset -Agx ZESHY_FUNCTION_NAME_TO_HELP_STRING
#    ZESHY_FUNCTION_NAME_TO_HELP_STRING[${1}]="${2}"
#typeset -Agx ZESHY_FUNCTION_NAME_TO_DOC_STRING
#    ZESHY_FUNCTION_NAME_TO_DOC_STRING[${1}]="${2}"

#is_boolean_true ZESHY_IS_DEBUGGING and printf\
#FUXME: Source all remaining arguments via source_shell_script().
# Source such arguments *AFTER* printing Zeshy's startup time to avoid
# incrementing such time by the time required to source such arguments.
#FUXME: If ${ZESHY_IS_DEBUGGING}, print out a brief line printing timing statistics:
#namely, how quickly Zeshy started up. *ALWAYS* start timing as the first line
#of this file, since we won't have access to ${ZESHY_IS_DEBUGGING} for a bit of
#time. (What's the best way to perform shell profiling? Google us up.) Hmm;
#don't adopt the "zprof" solution, which imposes a bit too much overhead. We
#want a no-overhead -- the "times" command looks particularly helpful. Is there
#any way to reset the "times" timer? Alternatively, if we could somehow run this
#entire script prefixed by "time"... Heavy-weight, though. "times" would be
#preferable, really. Perhaps an initial implementation should just do:
#
#local ZESHY_TIME_STARTUP
#[[ -x "${${:-lsb_release}:c}" ]] &&
#  ZESHY_TIME_STARTUP="$(date "+%s%N)"
#
#Only trouble there is that the default profile may not have been established.
#Ah-ha! Knew it. zsh helpfully provides a builtin module circumventing such
#difficulties: "zsh/datetime". So, at the very top of this script:
#
## Load module "datetime", providing global list ${epochtime} expanded below.
#zmodload zsh/datetime
#
## Time in seconds and nanoseconds since the Unix epoch at which Zeshy was first
## loaded (i.e., at which the current script was first sourced).
#export -i ZESHY_STARTUP_TIME_SECONDS ZESHY_STARTUP_TIME_NANOSECONDS
#
## Get such times from global list ${epochtime}, whose:
##
## * First shell word has the current time in seconds since the Unix epoch.
## * Second shell word has the current time in nanoseconds since the epoch.
##
## For reliability, expand such shell words at the same time.
#for ZESHY_STARTUP_TIME_SECONDS ZESHY_STARTUP_TIME_NANOSECONDS in ${epochtime}
#do; done
#
#Brilliant! Make it so.
# accuracy, avoid calling Zeshy-specific functions to do so.
    # Time in seconds and nanoseconds since the Unix epoch at which Zeshy
    # startup completed.
#   float ZESHY_STARTUP_TIME_SECONDS="${EPOCHREALTIME}"

    # Print such synopsis as a single statement to minimize shell overhead.
# Time in seconds and nanoseconds since the Unix epoch at which Zeshy was first
# loaded (i.e., at which the current script was first sourced).
#integer ZESHY_STARTUP_TIME_SECONDS ZESHY_STARTUP_TIME_NANOSECONDS

# Set such times from global list ${epochtime}, whose:
#
# * First shell word has the current time in seconds since the Unix epoch.
# * Second shell word has the current time in nanoseconds since the epoch.
#
# For reliability, expand such shell words at the same time.
#for ZESHY_STARTUP_TIME_SECONDS ZESHY_STARTUP_TIME_NANOSECONDS in ${epochtime}
#do; done
    # Time in seconds and nanoseconds since the Unix epoch at which Zeshy
    # startup completed.
#   integer ZESHY_STARTUP_END_TIME_SECONDS ZESHY_STARTUP_END_TIME_NANOSECONDS

    # Set such times. See the top of this script for further details.
#   for ZESHY_STARTUP_END_TIME_SECONDS ZESHY_STARTUP_END_TIME_NANOSECONDS in\
#       ${epochtime}; do; done

#FUXME: Rename "curse_" to "print_" here and below, and reform handle_exception()
#to simply redirect output of such functions to standard error. Simple: centralize
#such redirection in one place rather than in every print statement in such
#functions.

#       print 1>&2  # print a blank line to standard error
#if (( #arg_options ))
#then for key ("${(k)arg_options}") print "arg_options[${key}]=${arg_options[${key}]}"
#else print "arg_options empty; args: ${*}"
#fi
#FUXME: Rename "print_" back to "print_" *EVERYWHERE*.
#FUXME: Rename "curse_" to "admit_" (?) *EVERYWHERE*. To search for applicable alternatives,
#search synonyms of "complain" and "confess". Ah! Right. Why not "curse". I
#still quite like it after all these years. It's readily replaceable, anyway, if
#we elect for something else. O.K.; go "curse" it!
#zeshy_alias_cli_substitution_names_for_gui_commands
#zeshy_alias_clies_substituting_gui_commands
#zeshy_alias_clies_for_gui_commands
#zeshy_alias_clies_for_cli_commands
#zeshy_alias_cli_substitutions_graphical
#zeshy_interactive_selfaliases_graphical
#zeshy_alias_cli_substitution_names_run_disowned
#zeshy_command_names

#zeshy_alias_cli_substitution_names_run_disowned
#zeshy_alias_cli_substitution_names

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #FUXME: This isn't right at all. *IT'S FAIRLY IMPORTANT WE FIX THIS PRIOR
    #TO RELEASE*. Basically, shouldn't we *ALWAYS* throw an exception? That
    #ensures expected behavior in Zeshy scripts with respect to "always"
    #blocks, whereas the current implementation completely falls down. I have
    #no idea why we adopted the current implementation, in fact. It seems
    #blatantly brain-dead...and not in the kitsch Peter Jackson way, either.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # If called under an interactive shell, unwind the call stack to return the
    # current user to an interactive prompt; otherwise, exit this shell script.
    #
    # Note that the simpler command "return ${exit_status}" implicitly invokes
    # the "err_return" and TRAPZERR() handlers and hence (ultimately) performs
    # the same logic, but that such invocation produces less readable stack
    # traces. Consequently, we prefer the present implementation.
#   if [[ -o interactive ]]
#   then throw ZeshyException
#   else exit ${exit_status}
#   fi

#       print 1>&2  # print a blank line to standard error
#       print_exception_exit_status "${1}"
#then ZESHY_IS_LOADING=
#print "zeshy: ZESHY_IS_LOADING=${ZESHY_IS_LOADING}"

# Load Zeshy and grace the saffron skies with fullsome zest! All shell commands
# following this conditional may safely access all Zeshy aliases, globals, and
# functions. Specifically:
#
# * If loading Zeshy, do so.
# * Else if Zeshy has not been previously loaded under the current shell (as
#   implied by the lack of get_zeshy_version()), throw an exception.
#if [[ -n "${ZESHY_IS_LOADING}" ]]
#then load_zeshy
#elif ! typeset -f -- get_zeshy_version &>/dev/null
#then die "get_zeshy_version() not defined and hence Zeshy not loaded"
#fi

#FUXME: O.K.; the whole "--no-zeshy-reload-by-same-process" thing doesn't work,
#since zsh oddly executes the passed script *BEFORE* performing startup
#behavior. Extremely unexpected, but there you are. I see no sane way around
#this without the general rule: Zeshy prohibits reloading itself from the same
#process. Period. That's it. Sorry, but them's the unfortunate breaks.

# If non-empty, make and use the user-specific Zeshy directory ${ZESHY_DOT_DIR}
# and all subdirectories and files of such directory; else, load Zeshy with
# default configuration and shell settings and no digest file. Unlike the
# similar boolean ${ZESHY_IS_LOADING}, publish this boolean globally; numerous
# Zeshy functions called after startup need to know about the "situation."
#export ZESHY_DOT_DIR=1

# ....................{ LOCALS                             }....................
# If non-empty, load Zeshy; else, only handle arguments passed to this script.
#local ZESHY_IS_LOADING=1

#FUXME: If ignoring the Zeshy user directory, disable the corresponding boolean.
#(( ${+arg_options[--no-zeshy-dot-dir]} )) && ZESHY_DOT_DIR=

#FUXME: Consider renaming "ZESHY_USER_" to "ZESHY_USER_" everywhere. Much more
#explanatory and slightly conciser.

#   -no-zeshy-dot-dir -no-zeshy-reload-by-same-process ||
#print "zeshy: funcstack[1]=${funcstack[1]}"
#sleep 2
#exit
#, but Zeshy has been at least partially previously loaded"
    # Bootstrap Zeshy by loading core aliases, globals, and autoloads, the minimal
    # clique of Zeshy components. All subsequent Zeshy functions are implicitly
    # loaded on the first call to such functions by the autoload system.
    # Specifically, set global string ${PATH} and a sane umask and source the
    # expected startup scripts (e.g., under "/etc/profile.d/").
#FUXME: We really need such boolean? Hmmm. Probably. But let's make sure.
#FUXME: Woops. This is pretty much completely wrong for actual Zeshy
#installations (e.g., into "/usr/share/zeshy", containing the current contents
#of "~/zsh/zeshy/src"). ZESHY_HOME and ZESHY_HOME should *ALWAYS* be the
#same exact thing. Hence, remove the latter and set the former as follows:
#
#[[ -n "${ZESHY_HOME-}" ]] || export ZESHY_HOME="${0:h}"(:A)
#
#We should probably remove all setting of such variable from
#"etc/{zlogin,zprofile,zshrc}", perhaps suggesting "etc/{zlogin,zshrc}" should
#be removed entirely and "etc/zprofile" reduced to just running "zeshy". (Or
#perhaps just "etc/zshrc" reduced to running "zeshy" and the others removed?)

# as the latter establishes the global ${PATH} required by the former. To avoid
# reduplication,
#
# (e.g., for
# finding commands in the global ${PATH} with word modifier ":c").
#    # See "compile" for further details on clever expressions like this.
#   [[ -x "${${:-lsb_release}:c}" ]] &&
#FUXME: This conditional needs testing, clearly.
#FUXME: Damn. It's broken. zsh doesn't set it as I expected; hence, we need to
#manually parse an option "--no-reload". Do so above and test for
#"(( ${+arg_options[--no-reload]} ))" here. I'm fairly sure we can just replace
#the "false &&" with the above test... and everything (might) just work. Ah;
#well, yes. *TECHNICALLY*, the logic below would work -- but it's overkill.
#Wait...no, it's not. It's the option name that's wrong: it's too succinct.
#Rename such option to "--no-reload-by-same-process". Bit if a mouthful, but
#that accurately describes what we *REALLY* want. And given that crazy name,
#I'm happy to leave this option undocumented, you know?

# Parse passed options *AFTER* performing login-specific logic, as the latter
# establishes the global ${PATH} required by the former (e.g., for finding
# commands in the global ${PATH} with word modifier ":c").
#
# Parse passed options *BEFORE* operating on any additional Zeshy files or operating
# on user-specific Zeshy files, as the
# former could modify the behavior of the latter (e.g., by preventing Zeshy from
# recompiling and loading its digest file).
    #FUXME: Do we need test against *BOTH* $$ and ${PPID}? It can't hurt, of
    #course... but it would be nice to ascertain which we require.
#   if [[ "${ZESHY_PID_IF_ZSH_STARTUP}" == ($$|${PPID}) ]]

#[[ "${funcstack[1]}" == */(.|)(zshrc|zprofile|zlogin) ]] && {
#* If [[ "${ZESHY_PID_IF_ZSH_STARTUP-}" -eq "${PPID}" ]], then:
#  * Zeshy has already been loaded by the parent process and hence (hopefully)
#    inherited by the current process. Return immediately.
#* If [[ "${funcstack[1]}" == "*/(.|)(zprofile|zshrc)" ]], then:
#  * Set ${ZESHY_PID_IF_ZSH_STARTUP} as a global export in "src/main" ala:
#    typeset -igx ZESHY_PID_IF_ZSH_STARTUP="${PID}"

# Due to portability
# concerns, avoid exporting globals via "export" prior to enabling
    # If interactive, immediately return back to zsh; otherwise, exit the
    # current script.
#   if [[ -o interactive ]]
#   then return 1
#   else   exit 1
#   fi

#   print "defaulting \"ZESHY_HOME\" to \"${ZESHY_HOME}\"" 1>&2
#   print "consider running \"zeshy\" rather than sourcing \"${0}\"" 1>&2

# Absolute directory of the Zeshy library.
#ZESHY_HOME="${ZESHY_HOME}/src"

# * Incorporate ZSH-lovers fixes, including:
#   * Use suffix aliases.
# * The new trap support obsoletes an astonishing quantity of prior
#   functionality (e.g., try()). Such functionality should be retained (???...
#   perhaps not), but exported out of this component into a new component: say,
#   "zeshy/shell/job".
# * zimport() can profitably be renamed require(). The latter captures the
#   intent and implementation much more succinctly and without the awkward
#   prefixing 'z'.
# * We only call a match_*() function once in this file. It's absurd to maintain
#   such complexity here; offload all match_*() functionality to
#   "zeshy/type/regex" and, if still required here, simply inline. I believe we
#   can use simple glob-style matching, instead.
# * Ultimately, Zeshy should auto-compile the recursive entirety of all Zeshy
#   function definitions into a single so-called "digest" file at, say,
#   "~/.zeshy/digest.zwc". Such a file is autoloadable by:
#
#       # ...implicitly autoloading such digest.
#       fpath=( "~/.zeshy/digest.zwc" "${fpath[@]}" )
#
#       # ...explicitly autoloading such digest.
#       autoload -Uw "~/.zeshy/digest.zwc"
#
#   I'm unsure if the former supercedes the latter. (Probably not, no.) Both
#   required, perhaps.
#
#   What's nice about this is that such a digest file appears to come prepended
#   with a list of all functions defined by such digest, thus rendering
#   autoloading of digest files terrifically fast. Auto-generating such a digest
#   on any change to any Zeshy file or directory is, unfortunately, not quite so
#   easy. We'll need to write something resembling:
#
#       if is "$(get_path_mtime "~/.zeshy/digest.zwc") equals SOMETHING si; then
#           zcompile "~/.zeshy/digest.zwc" "${ZESHY_HOME}/src/"**/*(.)
#       fi
#
#   However, it's unclear just how aggregating multiple files into one handles
#   initialization code. Clearly, it either doesn't or does but simply lumps all
#   initialization together. Either case is bad. We'll need to rewrite Zeshy to:
#
#   * Perform all non-costly initialization up-front in Zeshy .main or core.
#   * Perform all costly initialization in the functions requiring such
#     initialization as the first line of such functions. You know that grind...
#'zeshy: zsh 4.0.3 < 5.0.0'
#'zeshy: zsh 4.0.3 < 5.0.0'
#'zeshy: installed zsh 4.0.3 < required zsh 5.0.0'
#'zeshy: zsh 4.0.3 < required zsh 5.0.0'
#'zeshy: installed zsh version 4.0.3 < required zsh version 5.0.0'

#   print "zeshy: requires zsh ${ZESHY_ZSH_VERSION_REQUIRED} but running zsh ${ZSH_VERSION}" 1>&2
# Since zsh 
# Indeed, zsh has no corresponding option
# "no_rm_recursive_silent" for interactively confirming option "-r" when passed
# to command "rm". Zeshy, on the other hand, confirms both star-globbed and
# recursive removal. Since recursive removal is (arguably) less safe than even
# star-globbed removal, Zeshy's behavior may be (arguably) safer than the
# default zsh behavior. Indeed, Zeshy interactively confirms all attempted path
# removal -- regardless of the number of such paths.
#FUXME: Doesn't appear to work as advertised, sadly.
#setopt no_global_export   # prevent "typeset -x" from implying "typeset -xg"

# List of all Zeshy-specific globals defined while sourcing Zeshy, if
# recompiling the Zeshy digest file. Defining such list globally permits us to
# undefine such globals in a global context, below.
#typeset -a ZESHY_GLOBAL_NAMES

# If recompiling the Zeshy digest file and hence sourcing Zeshy scripts
# defining globals, undefine such globals prior to initializing Zeshy. Why?
# The reason may be subtle, but the logic flows like butter. Zeshy may and
# typically does declare globals to be read-only. Understandably, zsh fails on
# attempting to redefine such globals. The subsequent call to startup_zeshy()
# and hence startup_zeshy_globals() does just that, requiring such globals be
# undefined prior to such calls. Oh, 'tis all a tad silly and worm-bitten, but
# so goes life in the tranche of code trenches.
#(( #ZESHY_GLOBAL_NAMES )) and {
#    unfreeze_variable "${ZESHY_GLOBAL_NAMES[@]}"
#    undefine_variable "${ZESHY_GLOBAL_NAMES[@]}"
#    undefine_variable ZESHY_GLOBAL_NAMES
#}

# Delete all Zeshy-specific globals defined by and imported from the parent
# shell, locally preserving global ${ZESHY_HOME} for subsequent use. Failure to
# delete such globals results in a subtle issue when compiling the Zeshy digest
# file, which persists such globals to startup_zeshy_globals() by differencing
# the lists of globals defined before and after such compilation. Failing to
# delete such globals ensures the two lists to be effectively identical, thus
# preventing persistence of Zeshy globals into the Zeshy digest file.
#
# See undefine_variable_matching() for details on variable deletion.
#local zeshy_home="${ZESHY_HOME-}"
#typeset +r -m 'ZESHY_*'
#unset      -m 'ZESHY_*'
#typeset -p -m 'ZESHY_*'

# Restore ${ZESHY_HOME}, deleting the temporary ${zeshy_home}. We're good to go.
#typeset +gx ZESHY_HOME="${zeshy_home}"
#unset zeshy_home

#[[ -n "${ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY+x}" ]] and {
#    print 'Eh??!?!?'
#    typeset -p ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY
#}
#       [[ -f "${filename}" ]] || die "\"${filename}\" not a zeshy script"
# ....................{ TRAPS ~ errors                     }....................
# void source_zeshy_component(
#   string component_name1, string component_name2, ...)
#
# Source the passed Zeshy components (i.e., zsh scripts in this directory).
#function source_zeshy_component() {
#    (( # >= 1 )) || die 'expected at least one component name'
#    for filename ("${@}") {
#       say "sourcing \"${ZESHY_HOME}/${filename}\"..."
#        source "${ZESHY_HOME}/${filename}"
#    }
#}

#source_zeshy_component alias global autoload
    # Omit the current function call by starting from the second stack frame.
    # If there exists no such frame, return with failure.
#   (( funcstack_size >= 2 )) || die 'call stack empty'
#   (( ++funcstack_size ))

#   for (( i = 2; i <= funcstack_size; i++ )) {
#   [[ "${funcstack[-1]}" == TRAPZERR ]] && return $(( 128 + ${1} ))
#   print "TRAP! oldest caller: ${funcstack[-1]}"
#   integer signal_number=${1}
#   return $(( 128 + ${signal_number} ))
#   return ${exit_status}
#   print "zeshy: ${caller_name} failed with exit status ${exit_status}" 1>&2
#   cry "\"${caller_name}\" failed with exit status ${exit_status}"
        #FUXME: I have no idea why we were doing this. It doesn't seem
        #particularly intelligent, however... So stop.
        # If this is the most recent stack frame, recall the name of the second-
        # most recent stack frame that called that frame and line number of that
        # call for subsequent pretty printing.
#       (( i == 2 )) && caller_line_first="${caller_line}"
#       (( i == 3 )) && caller_name_first="${caller_name}"

        # If this frame is the handle_exception() function typically calling
        # this function, avoid meaninglessly printing such frame.
#       [[ "${caller_name}" == handle_exception ]] && continue

#       [[ "${funcname}" == '(eval)' ]] || funcname="${funcname}()"
        # Temporarily redefine cry() in a manner consistent with exception handling.
#       function cry() { print -- "zeshy: ${*}" 1>&2; }

# Depending
# on the current user's Zeshy configuration, such function prints stack traces,
# documentation, and source code.
# according to the current user's Zeshy
# configuration of the
# current user (e.g., by printing a stack trace).
#
# Unlike "setopt ERR_RETURN", this handler calls handle_exception(). Depending
# on the current user's Zeshy configuration, such function prints stack traces,
# documentation, and source code.
#
# and hence implicitly throws an exception unwinding the
# call stack of the current shell on *ANY* command returning non-zero exit
# status, as if such command had instead thrown an exception.
#
# If such shell fails to
# handle such exception, zsh implicitly rethrows such exception to the shell
# calling the calling shell. This process proceeds until either some calling
# shell handles such exception, in which case no further shells are unwound,
# or no shell handles such exception, in which case the current user receives an
# uncaught exception. In the
# Specifically, print a
# complete stack trace and . Such unwind exits all intermediate subshells
# (e.g., non-interactive Zeshy functions or scripts) to the originating shell
# (e.g., the interactive Zeshy or zsh shell transitively responsible for running
# the failed command), but not necessarily any other active shell.
#   integer signal_number=${1} exit_status=${?}
    # Print a complete stack trace. If some function called this function (i.e.,
    # this function was not called directly from the prompt), prefix such trace
    # with that function's name and exit status; otherwise, no such prefix.
#   if (( ${#funcstack} >= 2 ))
#   then handle_exception\
#       "\"${funcstack[2]}\" failed with exit status ${exit_status}."
#   else handle_exception
#   fi

    # Omit the current function call by starting from the second stack frame.
    # If there exists no such frame, return with failure.
#   (( funcstack_size >= 2 )) || {
#       cry 'call stack empty'
#       return_false
#   }

    # Print a prefixing header with the passed message.
#   cry "${1:-}" 1>&2

# Do not return non-zero
        # exit status, as that recursively triggers TRAPZERR().
#           cry 'exception not found'
#           return 0
#       }
    #FUXME: Clearly not right if calling from within a trap handler, as this
    #would trigger another trap calling this function, and so on. For the
    #duration of all functions called by handle_current_exception(), we need to
    #temporarily replace exception throwing with just printing to standard
    #error and returning immediately. That said, I wonder if zsh doesn't already
    #somehow handle this? Specifically, what happens if we *DO* just throw an
    #exception here? Perhaps everything magically works out. Test up. Ah! I get
    #it.

# For safety, trap functions and functions transitively called by such functions
# require only zsh functionality (i.e., no Zeshy-specific syntactic sugar). This
# comprises all functions defined up to and including the "TRAPS" section.

# the notice stream
# of the cron logging facility if a cron-job and to the standard output stream
# otherwise.
#say 'finalizing aliases...'
#source "${ZESHY_HOME}/alias"
#say 'finalizing globals...'
#source "${ZESHY_HOME}/global"
#say 'finalizing autoloads...'
#source "${ZESHY_HOME}/import"
#say 'finalizing startup...'
#   [[ -f  "${filename}" ]] || die "\"${filename}\" not found"
#   source "${filename}"
# * I've been operating under the assumption zsh variables require quoting to
#   preserve spaces. It appears that is *NOT* the case, under default zsh shell
#   options. It doesn't hurt anything as is, but we could probably stand to
#   remove most if not all existing quoting. Ah; I see, somewhat. Lists must
#   always be quoted, but scalars need never be. Still, 'tis a confusing
#   distinction. We're better off persisting with the current method, I reckon.

# zeshy: consider upgrading zsh to ${ZESHY_ZSH_VERSION_REQUIRED}" 2>&1

#FUXME: *BRILLIANT IDEA*. Stack traces are great. But, with longer function
#implementations, output like:
#
#   curse_call_stack: make_and_install_kernel() failed with exit status 1
#        \_ TRAPZERR() { /root/.zeshy/digest.zwc/make_and_install_kernel: 34 }
#         \_ make_and_install_kernel() { /bin/zsh: 130 }
#
#...isn't really helpful. What is the 34th line of that function excluding
#comments? Right. There's no easy way to peruse that function's commented
#implementation and discern just where the fault lies. Hence, a solution:
#
#* Add a new "ZESHY_DEBUG" config global. (Think we might have one already, yes?)
#* If enabled, curse_call_stack() should implicitly with no external effort
#  append something resembling "which ${funcname[2]}" to its output. That's
#  closer to what we want, but still incomplete: "which" has no option for
#  prefixing each line of output with its line number, which is what we need.
#  I guarantee there's an "awk" script to do it, though. Search us up the fix!

#       (( i == 3 )) && {
#           funcname_first="${funcname}"
#           fileline_first="${fileline}"
#       }
    # Message to print. (Yes, its declaration and definition must be separate.)
    # Message to print. (Yes, its declaration and definition *MUST* be separate.
    # I'm not entirely clear why, but declaring and defining the message in the
    # same command induces inexplicably, undebuggably subtle errors.)
#   print "script name: $(get_script_name)"
#   [[ -n "${ZESHY_IS_CRONJOB}" ]] && logger -p cron.notice -- "${message}"
#   [[ -n "${ZESHY_IS_CRONJOB}" ]] && logger -p cron.err -- "${message}"
#   elif [[ "${#funcstack}" -gt 0 &&
#            "${funcstack[-1]}" != (get_script_name|say|msay|cry) ]]; then

#       if "${funcstack[${i}]}" == "${funcfiletrace[${i}]}"
#       print "${frame_prefix} ${funcname}() {${filename}:${fileline}}"

# This
# Each such frame signifies a previously called function, sourced file, or evaluated "eval". Each call
# stack of such frames signifies a stack trace of the complete code path from
# the most to least recently called function, source file, or evaluated "eval".

    # Continue the default trap handler, as under TRAPZERR(). 

# After any command returns non-zero exit status but prior to executing the next
# such command, instruct zsh to:
#
# * Execute the TRAPZERR() trap function.
# * Unwind the call stack, exiting all intermediate shells, back to the
#   originating shell -- typically, the interactive shell from which the failing
#   command was transitively run.
# * If the failing command was run directly by some zsh function:
#   * Return from that function with that command's non-zero exit status.
# Terminate the current shell, returning the non-zero exit status of the prior
# command.
#
# The combination of enabling this option and defining TRAPZERR() as below
# offers a robust alternative to the customary command "set -e", whose
# default implementation dangerously terminates the current shell on failure.
#setopt err_return

# * Execute the ZERR trap, if set.
# * Execute the TRAPZERR trap function, if defined.
# * If the failing command or function was itself called from a function:
#   * Return from that function with that command or function e return value .
# Terminate the current shell, returning the non-zero exit status of the prior
# command.
#
# The combination of enabling this option and defining TRAPZERR() as below
# offers a robust alternative to the customary command "set -e", whose
# default implementation dangerously terminates the current shell on failure.
#setopt err_return

    #FUXME: Hmm. If called from a pipe (e.g., "false or die "false!"), we really
    #want to use "${pipestatus[-2]}" here rather than "${?}".
#   if (( # == 0 ))
#   then say
#   else say "${1:-}"
#   fi

    #FUXME: Truncate.
    # Arcane bit-munging. Exit codes are of size "char" (i.e., a single byte).
    # Non-zero exit statuss with high bit set signify signal-driven fatal errors
    # and with high bit unset signify command-specific fatal errors. In the
    # former case, all bits excluding the high bit signify the signal number.
    # Hence, signal-driven exit statuss are constructable by adding 128 to the
    # signal number.
    #
    # SIGINT signifies fatal error of signal number 2. Rather than hard-code
    # that constant, we note:
    #
    # * zsh passes the signal number as the first argument to trap functions.
    # * zsh continues handling trap function-trapped signals as if untrapped
    #   when receiving non-zero exit statuss from such functions. In such cases,
    #   zsh returns this exit status as the signal result to calling processes.
    # 
    # Since we prefer zsh handle the actual interrupt as such with the same
    # exit status as it would customarily return, the result follows.
#   return ${exit_status}
#   return $(( ${exit_status} + 128 + ${signal_number} ))

    # Die with the prior return code.
#   die_with_exit_status ${exit_status}

# void die_with_exit_status(int exit_status = 1)
#
# Exit the currently executed script or function with the passed return code.
#die_with_exit_status() {
#   for ((i = 1; i <= ${#funcstack}; i++)) { print "${i}: ${funcstack[${i}]}" }
#   if is_interactive; then
#   then print 'throwing exception'; throw ZeshyException

    # If the current context is a function called from an interactive and/or
    # login shell, unwind the call stack; otherwise, kill the current process.
#    if is_interactive
#    then throw ZeshyException
#    else exit ${1:-${ZESHY_EXIT_STATUS_FAILURE}}
#    fi
#    print 'still here!'
#}

#set -e

#FUXME: zsh fails to trigger ZERR traps from within the sourcing of zprofile and
#zshrc. I have no idea why. Since the following line does nothing to help,
#however, I can only assume this is somehow the intended behavior. Nonetheless,
#file a mailing list comment.
#trap TRAPZERR ZERR
#trap 'curse_call_stack; throw ZeshyException' ZERR

#   if is_interactive
#   then return $(( ${exit_status} + 128 + ${signal_number} ))
#   else exit       ${exit_status}
#   fi
 #   throw ZeshyException
#   print 'still here...'
#   for ((i = 1; i <= ${#funcstack}; i++)) { print "${i}: ${funcstack[${i}]}" }

    # Terminate the current shell, returning the non-zero exit status of the prior
    # command. This effectively enables "set -e" (i.e., the ERR_EXIT option,
    # terminating the current shell on SIGZERR signals).
#   eval 'throw ZeshyException'; return ${exit_status}
#   die_with_exit_status ${exit_status}

# * Uhm; how did I never see this? zsh supports loop syntax resembling:
#   for d (../**/*) {
#   }
#   No need for cumbersome "for d in (../**/*); do ... done" nonsense. 

#FUXME: This is likely a zsh bug, perhaps corrected in some subsequent version.
#But throwing uncaught exceptions from interactive functions appears to
#literally undefine the calling function. Yes, this makes no sense.

    #FUXME: Given the new stack trace facilities, this probably no longer applies.
    # Unset the script name, if set. This forces the get_script_name() function
    # to obtain the name of the most recently called non-trivial function, which
    # is of considerably more assistance when an error occurs.
#   local ZESHY_SCRIPT_NAME=

#   print
#   print     -- "${message} (stdout)"
#   print -u2 -- "${message} (stderr)"

#   elif is_interactive; then
        #FUXME: This is actually the reverse of what one might want. We should
        #select the *LAST* function on the function stack. 
#       typeset -i i
#       for (( i = ${#funcstack}; i >= 1; i-- )); do
#           print "${i}th function: ${funcstack[${i}]}"
#           [[ "${funcstack[${i}]}" == /* ]] && 
#
#           case "${funcstack[${i}]}" in
#               run*|die*|say*|msay*|cry*|ask_*) continue ;;
#               *) break ;;
#           esac
#       done
 
        # Ignore all intermediary I/O- and error handling-specific function
        # calls. Skip the first stack frame corresponding to the current
        # function by starting at the second stack frame.
#       typeset -i funcstack_size=${#funcstack}
#       for (( i = 2; i <= funcstack_size; i++ )); do
#           print "${i}th function: ${funcstack[${i}]}"
            # Order ignorable function names by likelihood, for "efficiency."
#           case "${funcstack[${i}]}" in
#               run*|die*|say*|msay*|cry*|ask_*) continue ;;
#               *) break ;;
#           esac
#       done
         
        # If after ignoring non-relevant functions there still exists at least
        # one function on the callstack, return that function's name.
#       if (( i <= funcstack_size )); then
            # If this name is an absolute path, return that path's basename.
#           if [[ "${funcstack[${i}]}" == /* ]]
#           then print "${funcstack[${i}]:t}"
            # Otherwise, return this name as is.
#           else print "${funcstack[${i}]}"
#           fi
        # Otherwise, return the default name.
#       else print 'zeshy'
#       fi
    # Otherwise, return the default name.
#   else print 'zeshy'
#   fi

# Math module supplementing zsh's rudimentary math functionality with essential
# math operations (e.g., exponentiation).
#zmodload zsh/mathfunc

# Load broadly applicable zsh modules.
#load_default_modules

# ....................{ DEFAULTS                           }....................
# void load_default_modules()
#
# Load broadly applicable zsh modules.
#load_default_modules() {
    # Stat module wrapping the stat() system call with the zstat() zsh function. Do
    # not load this module via "zmodload zsh/stat", as that wraps the stat() system
    # call with a stat() zsh function, conflicting with the "stat" command.
#   zmodload -F zsh/stat b:zstat

    # Math module. While zsh provides rudimentary math functionality out of the box,
    # some pivotal functions (e.g., exponentiation) are only provided by this.
#   zmodload zsh/mathfunc

    # Module exposing zsh's C-based internal dictionaries as zsh-based associative
    # arrays, including:
    #
    # * "$funcstack", having the current function call stack for user inspection.
    # * "$functions", having the current set of all functions for redefinition and
    #   later restoration of differing function definitions.
#   zmodload zsh/parameter

    # Perl-Compatible Regular Expression (PCRE) module. Note that, although
    # enabling the "rematch_pcre" option below implicitly loads this module on the
    # first use of the "=~" operator in a test, all code prior to that will not
    # have access to methods exposed by this module. Thus, simply import it
    # explicitly.
    #
    # See "String matching" below for use notes.
#   zmodload zsh/pcre

    # Utility module adding additional built-ins, including the commonly called
    # "zformat", "zparseopts", and "zstyle" functions.
#   zmodload zsh/zutil

# void _zeshy_bootstrap(string filename1, string filename2, ...)
#
# Source the passed Zeshy components in the passed order.
#_zeshy_bootstrap() {
#    for script_file in "${@}"; do
#        if [[ ! -f "${script_file}" ]]; then
#            print "zeshy: \"${script_file}\" not found or not a file" 1>&2
#            exit 1
#        fi
#        
#        source "${script_file}"
#    done
#}

#   _zeshy_init_bootstrap "${ZESHY_HOME}/src/init/if_shell_interactive/"*
## void _zeshy_init(void)
#_zeshy_init() {
#}
#
## Call and then immediately unset (i.e., delete) _zeshy_main().
#_zeshy_init
#unfunction _zeshy_init

# Import Zeshy Core defining import() prior to importing other dependencies.
#[[ $(whence -w zimport) =~ ': function' ]] ||
#    source "${ZESHY_HOME}/src/init/core"

# in a
# "system-sensitive" manner: i.e., importing only specific dependencies
# relevant to the current system.
    # Add Zeshy's "site-functions/" to the function path, if that directory exists.
#   is_dir "${ZESHY_HOME}/site-functions" and
#       fpath=( "${ZESHY_HOME}/site-functions" "${fpath[@]}" )

    #FUXME: Old.
    # Match all non-dotfiles in the current directory via the "(^D)" modifier:
    # i.e., all files and directories except this one. Since Zeshy components 
    # explicitly import dependencies, importation order is *NOT* important.
#   string import_script_path
#   for import_script_path in "${ZESHY_HOME}/src/zeshy"/*(^D); do
#       zimport "${import_script_path}"
#   done
#       [[ $(basename "${import_script_path}") =~\
#           "^(\..*|${ZESHY_MAIN_SCRIPT_BASENAME})$" ]] ||

# ....................{ PATHS                              }....................
# Absolute path to the current script.
#local zeshy_core_path=$(readlink --canonicalize-existing "${0}")

# Directory having the current script. This environment variable should have
# been permanently added to the current system on Zeshy installation. If it was
# not, however, ensure that it at least temporarily exists now.
#[[ -n "${ZESHY_HOME-}" ]] ||
#    export ZESHY_HOME=$(readlink --canonicalize-existing $(dirname "${zeshy_core_path}")"/../..")

    # Import all non-dotfiles in this directory with the "(^D)" modifier (i.e.,
    # all files and directories *NOT* prefixed by a "."). Since Zeshy scripts
    # explicitly import dependencies, order of import is mostly insignificant.

#   if is -z\
#       "${ZESHY_IMPORTED_PATH_TO_MTIME[(I)"${zeshy_script_path}"]}" or
#       "${ZESHY_IMPORTED_PATH_TO_MTIME["${zeshy_script_path}"]}" -ne\
#       "${zeshy_script_mtime}" si; then

# This glob expression matches the basename of all non-executable readable
# files residing under every path in the function path list, "${fpath}". Via
# zsh mandate, every such file basename corresponds to the autoloadable
# function name defined in the file. Thus, matching these basenames also
# matches all autoloadable function names.
#
# * "-.x" ignores non-executable files. While not strictly necessary, forum
# posters suggest this beneficially permits you to ignore undesirable autoloads
# by chmodding away their executable bit.  * "-.r" ignores non-readable files.
# This is strictly necessary.  * ":t" extracts the "tail" (i.e., basename) of
# the current file. This is a history modifier extracting each file's filename
# sans absolute path.
# 
#for autoload_function_name in ${^fpath}/*(N-.r:t); do

#FUXME: I suppose I don't quite understand why we can't simply implement this as
#some variant of '"${@}" 1>/dev/null 2>&1'. Doesn't that work as is?
#run_quietly() { run "${(q)@}" 1>/dev/null 2>&1 }

#   is "${#command}" exceeds 0 si or die 'expected exactly one command'
#
#global_alias to='|'

    # Decompacted:
    # 
    # * "1", the passed name.
    # * "(P)", the variable the passed name refers to.
    # * "-", the value to expand this variable to if unset:
    #   in this case, simply the empty string.
    # * "-z", true only if this variable is the empty string and hence unset.
#    is -z "${(P)1-}" si

# ....................{ COMMANDS ~ return codes            }....................
# void try_as_superuser(string command)
#
# Run the passed command as the superuser and, if it fails with error,
# terminate the current execution environment with the same error.
#try_as_superuser() {
#    run_as_superuser "${@}" or die
#}

# int get_last_exit_status(void)
# 
# Return the return code returned by the previous command.
#alias get_last_exit_status='is_ok'

# bool is_ok(void)
#
# Return success if the previous command succeeded. Otherwise, return failure.
#is_ok() {
#    # Cache the prior command's return code, as our initial sanity check on
#    # arguments replaces this code with its own.
#    integer prior_command_exit_status=${?}
#    die_unless_no_args
#    return ${prior_command_exit_status}
#}

# bool is_error(void)
#
# Return success if the previous command failed. Otherwise, return failure.
#is_error() {
#    # Cache the prior command's return code, as our initial sanity check on
#    # arguments replaces this code with its own.
#    integer prior_command_exit_status=${?}
#    die_unless_no_args
#    is ${prior_command_exit_status} -ne ${ZESHY_EXIT_STATUS_SUCCESS} si
#}

# string canonicalize_path_nonfatal(string pathname)
#
# Get the canonicalized form of the passed absolute path. Unlike the
# canonicalize_path() function, this function does not raise an exception when
# the passed path does not exist; it simply canonicalizes as much of this path
# as exists.
#canonicalize_path_nonfatal() {
#    die_unless_one_arg 'expected exactly one pathname'
#    readlink --canonicalize-missing "${1}"
#}

#FUXME: This and try() now obsolete by TRAPZERR(). Excise everywhere.
# void try_run_quietly_as(string username, string command)
#
# Run the passed command as the passed user run_quietly and, if it fails with error,
# terminate the current execution environment with the same error.
#try_as() {
#    die_unless_at_least_two_args\
#        'expected exactly one username and one command'
#
#    # Locally set "${ZESHY_RUN_AS}". The run() function notes this variable as
#    # set and behaves accordingly...
#    string ZESHY_RUN_AS="${1}"; shift
#
#    # Call try() with all remaining arguments: the command to be run.
#    try "${(q)@}"
#}

# void try(string command)
#
# Run the passed command and, if it fails with error, terminate the current
# execution environment with the same error.
#try() {
#    run "${(q)@}" or die "\"${@}\" returned error code ${?}"
#}

# void try_run_quietly(string command)
#
# Run the passed command run_quietly and, if it fails with error, terminate the
# current execution environment with the same error.
#try_run_quietly() {
#    run_quietly try "${@}" or die "\"${@}\" returned error code ${?}"
#}

# void try_run_quietly_as(string username, string command)
#
# Run the passed command as the passed user run_quietly and, if it fails with error,
# terminate the current execution environment with the same error.
#try_run_quietly_as() {
#    run_quietly try_as "${@}" or die "\"${@}\" returned error code ${?}"
#}

# bool or(...)
#
# Return true if at least one of the passed command's returned successfully.
#global_alias or='||'

# bool and(...)
#
# Return true if both of the passed command's returned successfully.
#global_alias and='&&'

# bool not(...)
#
# Negate the passed command's return code.
#alias not='!'

#FUXME: This function appears to be functionally obsolete now. If so, kill and
#rename which_command() to this.
# Aliases.
#alias which_binary="which_command"
#alias which_binary_nonfatal="which_command"

# string which_command(string command)
#
# Print the absolute path to the passed command: e.g.,
#
#     >>> which_command zsh /bin/zsh
#
# If the passed command is a string, all but the first whitespace-delimited word
# of the string is ignored: e.g.,
#
#     >>> which_command "zsh -x -o shwordsplit scr" /bin/zsh
#
# If the passed command is not found, if multiple binaries are passed, or if no
# command is passed, prints an error and dies.
#which_command() {
#Call the whence() built-in outside of "local" so as to retain the return
    # code. (ZSH == FAIL on that one.) 
#    string command_path; command_path="$(which_command "${@}")"
#    die_unless_ok "\"${1}\" not found"
#    print "${command_path}"
#}
#
# Identical to the which_command() function except that, if the passed command
# does not exist, returns nothing rather than dies.

#FUXME: No longer meaningful under TRAPZERR(); excise.
# void die_unless_ok(string error_message)
#
# Die with the passed error message unless the previous command succeeded.
#die_unless_ok() {
#    # Cache the prior command's return code, as our initial sanity check on
#    # arguments replaces this code with its own.
#    integer prior_command_exit_status=${?}
#    die_unless_one_arg 'expected exactly one error message'
#    is ${prior_command_exit_status} -eq ${ZESHY_EXIT_STATUS_SUCCESS} si or die "${1}"
#}

# void say_import(string script_name)
#
# Echo a message informing the user that the passed script name is being
# imported. This function should be called prior to actually importing that
# script if feasible.
#say_import() {
#    die_unless_one_arg 'expected exactly one script name'
#
#    say "loading \"${1}\"..."
#}

    # If the caller has supplied no explicit "${ZESHY_SCRIPT_NAME}", supply a
    # default.  Failing to do this encourages the say() function to use the
    # name of this function as its script name, producing unaesthetic results.
#   "${ZESHY_SCRIPT_NAME:=zeshy}"

        # Print the passed error message followed by a complete backtrace.
#   cry "${@}"
#   curse_call_stack
 #
    # Shells differentiate
    # fatal from non-fatal errors by setting the high bit (i.e., 2^7 = 128).
    # According to "zshbuiltins", this forces zsh to continue handling the
    # signal as if untrapped and hence returning the same exit status. Having no
    # arcanely carnal knowledge of the Linux signal implementation, it's unclear
    # why setting the high bit 

    #FUXME: Old.
    # If the passed path is a directory, only import filename
    # "${ZESHY_MAIN_SCRIPT_BASENAME}" in this directory.
#   is -d "${zeshy_script_path}" si and
#       zeshy_script_path="${zeshy_script_path}/${ZESHY_MAIN_SCRIPT_BASENAME}"
    
    # If this path does not exist, die.
#   is -f "${zeshy_script_path}" si or die "\"${zeshy_script_path}\" not found"
 #
#FUXME: Impossible to remember, I'm afraid. Perhaps "fail_if_error", instead?
# int fail_if_previous_command_failed(void)
# 
# Return from the current function with failure if the previous command or
# function also returned with failure.
#alias fail_if_previous_command_failed="is_ok || return ${ZESHY_EXIT_STATUS_FAILURE}"

#; ZESHY_IMPORTED_PATH_TO_MTIME=( )
#   typeset -Ax ZESHY_IMPORTED_PATH_TO_MTIME; ZESHY_IMPORTED_PATH_TO_MTIME=( )
 # The "-Ax" option to the "typeset" commands defines each such variable as an
# [A]ssociative array (i.e., a dictionary) and e[x]ported to the global
# environment for later access.

# Ascertain whether we are running as a cronjob and, if so, alter output
# appropriately. In particular, print the current date as a timestamp prior to
# printing all other output.

#   die_unless_at_least_one_arg 'expected at least one string'

#   # If no string was passed, attempt to read "stdin" for piped input.
#   if is_one_arg; then
#       set -- "${1}" "$(< /dev/stdin)"
#   fi

#   pcre_compile "${1}" || die "\"${1}\" not a valid regular expression"
#   pcre_match "${2}" || return ${?}
#   return ${ZESHY_EXIT_STATUS_SUCCESS}

# This function returns success 
# If this regular expression matched at least one group, this function returns
# this group as a string for caller convenience... Else, this function returns
# nothing. In the former case, callers may retrieve the set of all groups via
# the global "${match}" array. (See above.)

    # When the whence() built-in fails, it prints the name of the passed command
    # followed by "not found". Thus, if it prints such a message, the passed
    # command does not exist. Note that testing the return code is problematic
    # here, since setting a local variable always forces the return code to 0
    # (i.e., success). 
#   if [[ "${command_path}" == *" not found" ]]; then
#       return ${ZESHY_EXIT_STATUS_FAILURE}
#   else
#       echo "${command_path}"
#       return ${ZESHY_EXIT_STATUS_SUCCESS}
#   fi

    # O.K., this is tricksy: if the eventual caller explicitly quote-protected
    # the passed command name, there exists another "layer" of quote-protection
    # to unravel. Do so, alas.
#   if ! is_installed "${command_name}" && is_installed "${(Q)command[1]}"; then
#       command_name="${(Q)command[1]}"
#   fi

    #echo "PID: $$"
    #echo "current_process_basename:"
    #get_current_process_basename
    #echo "current_process_command_line:"
    #get_current_process_command_line

# ....................{ GLOB EXPRESSIONS                   }....................
# string *glob_non_dotfiles_in(string dirname)
#
# Glob all non-dotfiles (i.e., all files and directories whose first character
# is not a '.' dot) in the passed directory.
#glob_non_dotfiles_in() {
#    [[ ${#} -eq 1 ]] || die "expected exactly one directory name"
#    local dirname="${1}"
#    [[ -d "${dirname}" ]] || "\"${dirname}\" not a directory"
#
#    # Glob all non-dotfiles via the "(^D)" modifier.
#    echo "${dirname}"/*(^D)
#}

 # Enable variable substitution in prompt expansions in a "synchronous" fashion.
# Enabling this re-evaluates each prompt expansion after perform each
# interactive command with the current values of those variables without
# having to manually recreate the prompt each time.
#setopt promptsubst

#The existence of this variable also
# serves to inform callers as to whether or not this script has been imported
# yet and, when it has, to avoid reimporting it.

# Directory above the directory having the current script. This environment
# variable should have been permanently added to the current system as well.
#[[ -n "${ZESHY_ROOT}" ]] ||  
#    export ZESHY_ROOT=$(readlink --canonicalize-existing "${ZESHY_HOME}/..")

#FUXME: Harvest comments from the now-dead portion of zimport_file().
#
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#O.K.; the game plan:
#* Separate each function into a separate file. No symlinks. I know; I know.
#  This is awful. But zsh is as it is on this score. There's no fixing that.
#* Initialization needs to be centralized into a set of core files. Here's
#  what I'm thinking, now: cleave the "src/" directory into:
#  * "src/root", containing "zprofile", "zlogin", and "zshrc".
#  * "src/main", containing this file, "core", and all other initialization as
#    perhaps another file or two ("globals"? bah!). All global variable
#    declarations need to be shifted here.
#  * "src/auto/generic", containing the bulk of Zeshy as such autoloadable function
#    files. All such functions are safely applicable to all systems.
#  * "src/auto/command", allowing for conditionally autoloaded command-specific
#    function directories (e.g., "src/auto/command/ssh").
# * We need one digest for all of "generic" and one digest for each immediate
#   subdirectory of "src/auto/command", the latter conditionally autoloaded if
#   such command exists.
# * This scheme clearly allows for things like "src/auto/os", should we require
#   it. I'm currently considering trashing that... just assume GNU/Linux, for
#   the moment. (Time!)
# * Hmm; perhaps?:
#   "src/catabolize/".
#   "src/initialize/".
#   "src/bootstrap/".
#   "src/framework/".
#   "src/profile/".
#   "src/context/".
# * Ah; O.K.; how about just:
#   "src/construct/".
#   "src/bootstrap/".
#   "src/autoload/always".
#   "src/autoload/if_installed".
# * Or mayhap:
#   "src/boot/".
#   "src/init/".
#   "src/auto/always".
#   "src/auto/if_installed".
#
#Yes, it's lame. But our hands are really constrained, here.
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!
