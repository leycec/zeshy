#!/usr/bin/env zsh
# ====================[ main                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Bootstrap Zeshy into the current Zsh shell environment.
#
# --------------------( SEE ALSO                           )--------------------
# http://zsh.sourceforge.net/Doc/Release/Functions.html
#   Detailed description of trap functions.
# http://www.bash2zsh.com/essays/essay1_file_manager.html
#   Concise introduction to suffix aliases, mime types, and file magic.
#
# --------------------( TODO                               )--------------------
# * Zeshy's complexity and hence fragility is beginning to enter the caustic
#   zone. We *REEEALLY* need to add unit tests, post-haste. This will entail a
#   massive effort, but be well worthwhile. It's nigh impossible to keep up with
#   the current pace of new regressions without installing at least:
#
#   * One unit test per function intended to execute successfully.
#   * One unit test per function intended to execute unsuccessfully.
#
#   Thanks to our dependency on exception handling, it *SHOULD* be exceedingly
#   simple to doctor up a small unit test framework. When we expect unsuccessful
#   execution and hence a thrown exception, such framework will need a function
#   accepting the name of the expected thrown exception; on catching an
#   exception, such function must dynamically inspect the call stack for such
#   function. Alternatively, it'd be great if the exception thrown by both die()
#   and our TRAPZERR() function itself performed such inspection and *SET THE
#   NAME OF THE FUNCTION TO BE THE RESPONSIBLE die_*() FUNCTION NAME*. Pretty
#   sweet! We currently use a useless exception name (e.g., "ZeshyException");
#   so, this would be quite a welcome change.
# * Pretty sweet snippet adding a Vim-style modeline in vi-keys mode showing
#   whether currently in INSERT or NORMAL mode. I reckon we could ably integrate
#   this into the default theme, which would go a long way to converting me to
#   the vi-keys ZLE. See:
#   http://www.zsh.org/mla/users/2006/msg01180.html
#   http://www.gott-gehabt.de/800_wer_wir_sind/thomas/Homepage/Computer/zsh/vi-showmode
#   Perhaps there's a more recent working solution, as well?
# * Zsh helpfully provides a "DVORAK" setopt option, only of interest if
#   interactive. It'd be quite nice to dynamically determine whether a dvorak
#   keymap is currently in use and, if so, implicitly enable such option.
#   However, this fails to account for hardware-based keymapping (e.g.,
#   Kinesis). Perhaps a "config" global -- say, ZESHY_IS_KEYMAP_DVORAK" -- would
#   be of assistance here.
# * Use the "vcs_info" Zsh module for displaying VCS-specific metadata in a VCS-
#   agnostic fashion.
# * Incorporate grml-zshrc functionality where helpful, currently available at:
#   http://git.grml.org/f/grml-etc-core/etc/zsh/zshrc

# ....................{ PROFILING                          }....................
# Set the current time since the Unix epoch *BEFORE* all subsequent operations
# to ensure reasonable profiling results.

# Load module "datetime", providing timing-related globals expanded below.
zmodload zsh/datetime

# Time in partial seconds since the Unix epoch at which Zeshy was first loaded
# (i.e., at which the current script was first sourced).
float ZESHY_STARTUP_TIME_SECONDS="${EPOCHREALTIME}"

# ....................{ DOCUMENTATION                      }....................
# Map from Zeshy-specific alias name to documentation for such alias.
local -A ZESHY_ALIAS_NAME_TO_DOCUMENTATION

# Map from Zeshy-specific function name to documentation for such function.
local -A ZESHY_FUNCTION_NAME_TO_DOCUMENTATION

# Map from Zeshy-specific global name to documentation for such global.
local -A ZESHY_GLOBAL_NAME_TO_DOCUMENTATION

function set_function_documentation() {
    # Delay validating passed arguments aside from the number of such arguments
    # to subsequent serialization of such arguments to disk following digest
    # recompilation. This permits an intuitive calling style of calling this
    # function before declaring the function name passed to this function.
    (( # == 2 )) || die 'expected one function name and one help string'
    ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${1}]="${2}"
}
set_function_documentation set_function_documentation '
void set_function_documentation(string function_name, string documentation)

Document the passed function with the passed string. For convenience, consider
calling the higher-level document_function() rather than this function.
'

# ....................{ GLOBALS                            }....................
# Oldest Zsh version under which Zeshy runs without error.
export ZESHY_ZSH_VERSION_REQUIRED=5.0.0

# Absolute paths for Zeshy-specific directories and files. See commentary below.
export\
    ZESHY_HOME\
    ZESHY_DOT_DIR\
    ZESHY_DOT_DIR_BASENAME\
    ZESHY_DOT_CONFIG_DIR\
    ZESHY_DOT_OVERLAY_DIR\
    ZESHY_DOT_DIGEST_FILE\
    ZESHY_DOT_VERSION_FILE

# Process ID of the last zsh process to previously source this script.
export -i ZESHY_PID_LAST_LOADED_BY

# ....................{ SANITY                             }....................
# If *NOT* running under such version, print an error message to standard error
# and return rather than exiting to avoid exiting interactive shells with non-
# zero exit status.
autoload -U is-at-least
is-at-least ${ZESHY_ZSH_VERSION_REQUIRED} || {
    print "zeshy: installed zsh ${ZSH_VERSION} < required zsh ${ZESHY_ZSH_VERSION_REQUIRED}" 1>&2
    return 1
}

# Prohibit duplicate paths from being added to canonical global lists, removing
# any such duplicates that may already have been added. Since ${path} in
# particular is central to sane shell operation, do so before subsequent logic.
#
# Unlike *SOME* typeset options (e.g., "-r"), typeset option "-U" does not
# entirely destroy the contents of such lists. Rather helpful, that.
typeset -U path cdpath fpath manpath

# ....................{ OPTIONS                            }....................
# Enforce strictness, as under conventional high-level languages.
setopt no_unset           # exception on attempting to expand unset parameters
setopt warn_create_global # warning on attempting to set undeclared parameters
setopt no_err_exit        # Zeshy implements more robust error handling
setopt no_err_return      # Zeshy implements more robust error handling

# Variable assignment.
setopt no_global_export   # prevent "typeset -x" from implying "typeset -xg"
setopt no_ksh_typeset     # perform word splitting on variable assignment

# Avoid printing previously assigned variables when calling typeset() with
# variables with no new assignments (e.g., "typeset specular_reflection").
setopt typeset_silent

# Variable expansion.
setopt c_bases           # print non-base 10 integers in C format (e.g., "0x33")

# Shell parsing.
setopt no_ksh_arrays      # enable 1-based lists subscriptable without braces
setopt no_ksh_autoload    # treat autoloaded files as function definitions
setopt magic_equal_subst  # enable filename expansion on "="-prefixed strings
setopt short_loops        # enable "for ... (...) { ... }"-style shell constructs

# Shell quoting.
setopt no_csh_junkie_quotes  # allow unescaped newlines in quotes
setopt no_sh_word_split  # do not field split unquoted parameters
setopt rc_quotes         # parse '' as ' in single quotes (e.g., '''' == "'")

# Command execution.
setopt no_print_exit_value  # do not print "zsh: exit $?" on command failure

# Command history.
setopt append_history    # share history between multiple ZSH sessions
setopt inc_append_history  # incrementally add items to history
setopt extended_history  # save timestamps in history
setopt hist_ignore_all_dups # do not ignore dups in history
setopt hist_ignore_dups  # ignore consecutive dups in history
setopt hist_ignore_dups  # ignore consecutive dups in history
setopt hist_lex_words    # ensure accurate parsing of commands saved to disk
setopt hist_no_store     # do not store history-related functions

# Path changing.
setopt auto_cd           # automatically "cd" to directories in command position
setopt auto_pushd        # automatically "pushd" directories onto the dirstack
setopt pushd_ignore_dups # do not push duplicate directories onto the dirstack
setopt pushd_silent      # run "pushd" and "popd" silently

# File globbing.
setopt no_case_glob      # glob case-insensitively
setopt no_glob_assign    # do not glob variable assignments (use lists instead)
setopt no_ignore_braces  # enable "{...}"-style brace expansion
setopt no_ignore_close_braces  # render ";" optional for single-line functions
setopt extended_glob     # enable extended globbing (e.g., "#", "~", "^")
setopt glob              # enable globbing
setopt glob_dots         # permit "*" to match "."-prefixed pathnames

# Avoid interactively confirming star-style path removal (e.g., "rm *"). While
# nice, Zeshy already interactively confirms *ALL* attempted path removals.
# Since Zeshy's default behavior is arguably safer than Zsh's, avoid redudantly
# confirming star-style path removal twice.
setopt rm_star_silent

# Silently reduce non-matching globs to the empty string rather than printing an
# error message. While the latter appears preferable, Zsh fails to also:
#
# * Signal ZERR and hence call TRAPZERR() on non-matching globs, thus failing to
#   throw exceptions or print stack traces on glob failure.
# * Permit the printed error message to be customized. The error messages Zsh
#   prints are largely unhelpful for non-interactive scripts (e.g.,
#   "zsh: no matches found: Tomoe(:A)"), offering no human-readable context for
#   script debugging or development.
#
# Hence, we reluctantly disable errors on non-matching globs. Zeshy scripts and
# functions must test for glob failure by testing list emptiness. With practice,
# this should (!) become second nature: e.g.,
#
#     >>> list glob_match; glob_match=( "PiKHAL/TiKHAL"(:A) )
#     >>> is_nonempty "${glob_match}" or die "\"PiKHAL/TiKHAL\" not found"
setopt null_glob

# File writing.
setopt no_clobber        # forbid ">" from truncating existing files

# PCRE matching.
#
# This enables Perl-Compatible Regular Expression (PCRE) matching via the "=~"
# test operator, by implicitly loading the "zsh/pcre" module when requested.
# This module matches the entire match into "${MATCH}" and each group match
# into array elements of "${match[@]}" where the first match is "${match[1]}".
# For additional documentation on the "zsh/pcre" module, see:
# http://zsh.sourceforge.net/Doc/Release/Zsh-Modules.html#SEC192
#
# Note that traditional glob matching is always available via the "==" test
# operator: e.g.,
#     [[ $(whence -cp fahey) == *" not found" ]] && echo "Farewell."
setopt rematch_pcre      # prefer Perl-Compatible Regular Expression matching

# Process control.
setopt long_list_jobs    # list jobs in long format
setopt no_notify         # report job status only before prompt printing

# Shell I/O.
setopt no_flow_control   # disable interactive flow control (e.g., ^S, ^Q)
setopt ignore_eof        # do not treat ^D as "exit", interactively
setopt interactive_comments  # enable "#" comments in interactive commands
setopt print_eight_bit   # enable 8-bit output for completion lists

# Shell prompt.
#
# Enable variable substitution in prompt definitions. This dynamically re-
# expands each prompt definition and variables referenced in that definition
# immediately prior to displaying that prompt; by default, on the other hand,
# Zsh statically caches the expansion of each prompt definition for quick re-
# use when displaying those prompts. (While marginally faster, the latter is
# remarkably less useful as it requires redefining and exporting a prompt to
# alter the display of that prompt.)
setopt prompt_subst

# Tab completion.
setopt auto_menu         # use menu completion after two tabs
setopt complete_in_word  # complete inside words
setopt no_list_ambiguous # only list matches if ambiguous

# ....................{ MODULES                            }....................
# Explicitly load only the subset of requisite Zsh modules (i.e., C-based shared
# libraries bundled with Zsh) for which no appropriate autoloadable function
# exists. Since all other requisite Zsh modules supply autoloadable functions
# implicitly loading their parent module on the first call to such function, we
# explicitly load no other modules.

# Wrap system call stat() with Zsh function zstat(). Do not load this module
# with "zmodload zsh/stat", as that wraps such call with Zsh function stat()
# conflicting with external POSIX command "stat".
zmodload -F zsh/stat b:zstat

# Expose several of Zsh's internal C-based dictionaries as external Zsh-based
# associative arrays, including:
#
# * ${funcstack}, the stack of functions, scripts, and "eval" statements on the
#   current call path.
# * ${functions}, the set of all currently defined functions, permitting
#   redefinition and subsequent restoration of new function implementations.
zmodload zsh/parameter

#FIXME: Add ANSI coloring to sayed messages if on an ANSI-capable terminal.
#Also, consider prefixing messages under cron with: "["$(date +'%F %T')"].

#FIXME: *WAIT*. We only need to define a placeholder say() and cry() here
#prefixing *ALL* passed messages with "zeshy: ".
#The real say() and cry() implementations should be subsequently defined by
#the currently enabled theme. Make it so with a sprinkle of ANSI excellence.

# ....................{ PRINTERS                           }....................
# Declare placeholder functions to be overridden after loading the Zeshy digest.

set_function_documentation say '
void say(string message = "")

Print the passed message suffixed by a trailing newline to standard output.
This placeholder implementation called only when bootstrapping Zeshy will be
replaced when loading Zeshy''s digest file.
'
function say() {
    #FIXME: Quite certain we want to replace all "[[ -o interactive ]] && say"
    #and "interactively say" with merely "say". (The former are patently silly
    #and, let's be honest, dangerous, by duplicating logic *EVERYWHERE*.) That
    #said, I'm not convinced that the solution here is to simply prepend this
    #statement with "[[ -o interactive ]] && "; the problem, of course, are
    #pipes. We want functions like the following to work:
    #    function testem() { say 'Oh, hello!'; }
    #    testem | cat
    print "zeshy: ${@}"
}

set_function_documentation cry '
void cry(string message = "")

Print the passed message suffixed by a trailing newline to standard error.
This placeholder implementation called only when bootstrapping Zeshy will be
replaced when loading Zeshy''s digest file.
'
function cry() {
    # Print this message. Do *NOT* call print() as "print -u2 -- "${message}".
    # While that appears superficially identical to the following call, passing
    # the desired file descriptor as an argument fails to preserve interleaving
    # with prior commands printing to file descriptor 1 (i.e., standard out).
    print "zeshy: ${@}" 1>&2
}

# ....................{ EXCEPTIONS                         }....................
#FIXME: Either the documentation or implementation is wrong. In any case, I'm
#not convinced *EITHER* is right. We really want to implicitly throw exceptions
#on triggering TRAPZERR(), don't we? As stated below, throwing exceptions
#interacts sanely with "always" blocks -- this doesn't. It's still a sane
#implementation, but one wonders if we can't do better.

set_function_documentation TRAPZERR '
integer TRAPZERR(integer signal_number = SIGZERR)

Trap SIGZERR, a Zsh-specific signal on non-zero exit status from Zsh builtins
and functions and external commands. Doing so effectively globally enables
"setopt ERR_RETURN". On any command returning non-zero exit status:

* If the current shell is interactive:
* Implicitly throw an exception unwinding the call stack of such shell.
* If such exception is uncaught, return the current user to the prompt.
* If the current shell is non-interactive:
* Immediately exit such shell with non-zero exit status.
* If the calling shell fails to handle such exit status (e.g., by using
  "or true") and is also running Zeshy, repeat the above logic until either
  exiting all non-interactive shells or returning to an interactive shell.

In either case, handle such error according to the current user''s Zeshy
configuration (e.g., by printing a stack trace, documentation, and/or source
code related to such error). See handle_exception() for further details.

Unlike "setopt ERR_EXIT", this handler explicitly unwinds the call stack of
only the current shell rather than all parent shells.
'
function TRAPZERR() {
    # Save the exit status of the prior command prior to overwriting this status
    # by handling such error.
    integer exit_status=${?}

    # Handle such exception and return such command's exit status, mimicing the
    # action of "setopt ERR_RETURN". (See "man zshoptions" for further details.)
    handle_exception ${exit_status}
    return ${exit_status}
}

set_function_documentation die '
string die(string error_message1, string error_message2, ...)

Print the passed error messages to standard error and return non-zero exit
status, effectively throwing an exception as discussed under TRAPZERR().
'
function die() {
    # Exit status of the prior command. Zsh defines "pipestatus" to be a global
    # list with elements the return values of each subcommand of the prior pipe
    # command or of the prior command if not a pipe command. Conversely, Zsh
    # defines "?" to be a global integer with the return value of the prior
    # command. Since the former subsumes the latter *AND* the latter fails to
    # provide the return value of the prior command when a subcommand of a pipe
    # command, we defer to the former. For example, consider:
    #
    #     # Define helper functions.
    #     >>> pipe_status() { print ${pipestatus[-1]} }
    #     >>> exit_status() { print $? }
    #
    #     # Show "pipestatus" to return the required values.
    #     >>> true; pipe_status  # this works...
    #     0
    #     >>> true; true | false || pipe_status  # ...and so does this.
    #     1
    #
    #     # Show "?" to *NOT* return the required values.
    #     >>> true; exit_status  # this works...
    #     0
    #     >>> true; true | false || exit_status  # ...but this doesn't.
    #     0
    integer exit_status=${pipestatus[-1]}

    # If the prior command succeeded, coerce such exit status into an error.
    (( ${exit_status} == 0 )) && exit_status=1

    # Print the passed error message and handle such exception.
    cry "${@}"
    handle_exception ${exit_status}

    #FIXME: Suffix the exception name by the name of the function directly
    #responsible for throwing this exception. See curse_exception_exit_status()
    #for simple logic getting this function name.

    # Unwind the current call stack, thus returning the current user to an
    # interactive prompt if the current shell is interactive or exiting the
    # current Zeshy script otherwise.
    throw ZeshyException
}

#FIXME: Interestingly, we don't actually want all exceptions to be handled. We
#always want *UNEXPECTED* exceptions to be handled. Expected exceptions,
#however, should only be handled if the current user's Zeshy configuration
#requests such handling, which should be disabled by default. The canonical
#example of an expected exception is an external command wrapped by a Zeshy
#function returning non-zero exit status on failing to find a match (e.g.,
#"command grep" wrapped by grep_path()). Note that even in this case, of course,
#not all errors emitted by "command grep" are expected: only on failing to find
#a match, which must be explicitly tested for. This suggests a new helper
#function die_unhandled(), which (as expected) does everything die() does but
#excludes only the call to handle_exception(). Since this reduplicates a great
#deal of intricate code, perhaps die() and die_unhandled() can simply delegate
#to an internal utility function with prototype:
#
# string die_handled_if(
#   string error_message = '', boolean is_handling_exception)
#
#Obviously, such functions should be shifted to a new component in the proper
#Zeshy codebase: say, "shell/exception".
#FIXME: While such functionality is essential for oddball corner-cases (e.g.,
#"grep"), what we generally want is a simple way of squelching exceptions when
#the current shell is interactive *AND* the current call stack ends with a
#particular function that was called by some other particular function earlier
#in such stack. This could possibly be implemented as a global map from the
#former to latter, which function die() and associates would need to respect.
#Consider the following definition:
#
#map_global_export\
#    ZESHY_EXCEPTION_HIDE_IF_INTERACTIVELY_THROWN_BY_FUNCTION_NAMES
#
#Ah; wait. The "_INTERACTIVELY" is redundant, since such code paths can only
#come about as interactive alias expansions. Also, it's not specifically
#function names -- it's runnable names. Reduce to:
#
#map_global_export\
#    ZESHY_EXCEPTION_HIDE_IF_THROWN_BY_RUNNABLE_NAMES
#
#Define such global as follows:
#
#ZESHY_EXCEPTION_HIDE_IF_THROWN_BY_RUNNABLE_NAMES=(
#    'ls' 'l'
#    'ls' 'ls'
#    'grep' 'g'
#    'grep' 'grep'
#    'grep' 'gr'
#    ...
#)
#
#Now, that's in a great format for consumption by die_*() functions. But it's
#not really the greatest for definition; given the tenuous nature of interactive
#aliases, we really want to automate definition of such global. This should,
#naturally, be done by the interactive_abbreviation() and
#interactive_substitution() functions. (O.K.; I suppose interactive_alias()
#applies as well.) Under interactive_substitution(), it's easy to set two such
#entries: for both, the key is the command name being substituted; for the
#first, the value is the same name; for the second, the value is such
#substitution's abbreviation (if any!). Under interactive_abbreviation(),
#thing's are a bit less automated: we'll need to improve
#interactive_abbreviation() to accept an optional second argument specifying the
#name of the core underlying external command that such abbreviation eventually
#runs. Hence, this:
#
#    interactive_abbreviation {cal}endar{q}uarter='print_calendar_quarter'
#
#...would need to be expanded to this:
#
#    interactive_abbreviation {cal}endar{q}uarter='print_calendar_quarter' cal
#
#This then adds a single entry to the above global resembling this:
#
#    ZESHY_EXCEPTION_HIDE_IF_THROWN_BY_RUNNABLE_NAMES+='cal' 'calq'
#
#There's really no other sensible way to handle abbreviations. This works, it's
#only a minor nuisance; let's go-goggogogogo-go!
#
#The first steps, clearly, will be automating interactive_substitution() to
#perform such definition and die() to respect such definition (possibly subject
#to a user-configurable boolean enabling or disabling such functionality). After
#getting that to work, then contemplate the extension of such logic to
#interactive_abbreviation(). Such global could (possibly) be called:
#
#    boolean_global_export ZESHY_IS_HANDLING_ERROR_IF_THROWN_BY_NONHANDLING_RUNNABLES
#
#Hmm; what about:
#
#    boolean_global_export ZESHY_IS_ERROR_HANDLED_IF_HIDDEN
#    ZESHY_IS_ERROR_HANDLED_IF_HIDDEN=${ZESHY_BOOLEAN_FALSE}
#
#Much better. >)

# string die_unhandled(string error_message = '')
function die_unhandled() {
    #FIXME: Implement such function. Unsure this is the best name, to be honest.
    die_handled_if "${@}" ${ZESHY_BOOLEAN_FALSE}
}

set_function_documentation handle_exception '
string handle_exception(integer exit_status)

Handle the exception resulting from the passed (presumably) non-zero exit
status, typically by printing such exception to standard error if requested
by the current user. This placeholder implementation called only when
bootstrapping Zeshy will be replaced when loading Zeshy''s digest file.
'
function handle_exception() {
    # Redirect all output printed below to standard error. Yes, a single
    # suffixing "} 1>&2" actually suffices. You rock, Zsh! (Sometimes.)
    {
        # If called directly from the command-line, no such exception exists.
        (( # == 1 )) || die 'expected one positive integer'
        (( #funcstack >= 2 )) || die 'exception not thrown'

        # Print a blank line.
        print

        # Print a description of the passed non-zero exit status.
        print_exception_exit_status "${1}"

        # If the current user's Zeshy configuration requests printing stack
        # traces on exceptions, do so.
        [[ -n "${ZESHY_IS_ERROR_HANDLER_PRINTING_CALL_STACK-}" ]] &&
            print_call_stack
    # If such handling itself throws an exception, catch such exception here to
    # prevent uncaught exceptions from recursively triggering TRAPZERR(). Since
    # Zeshy functions may sadly be the source of such exception, avoid calling
    # Zeshy functions in catch logic.
    } always {
        # While Zsh *SHOULD* always set the ${CAUGHT} global to the name of the
        # uncaught exception, it (occassionally) appears not to. *sigh*
        catch * && if [[ -n "${CAUGHT-}" ]]
        then print "zeshy: exception handler threw uncaught exception \"${CAUGHT}\"" 1>&2
        else print "zeshy: exception handler failed with non-zero exit status" 1>&2
        fi
    } 1>&2
}

set_function_documentation print_exception_exit_status '
string print_exception_exit_status(integer exit_status)

Print a description of the passed non-zero exit status to standard error.
'
function print_exception_exit_status() {
    # Validate passed arguments.
    local exit_status="${1}"
    [[ "${exit_status}" == <-> ]] ||  # see is_integer()
        die "\"${exit_status}\" not a positive integer"

    # Decide the name of the caller script or function. Since the prior test
    # succeeded, the call stack consists of at least two (and typically
    # three) stack frames:
    #
    # * ${funcstack[1]}, this function.
    # * ${funcstack[2]}, the handle_exception() function.
    # * ${funcstack[3]}, the caller. This is typically either the
    #   intermediate Zeshy-specific TRAPZERR() or die() functions.
    # * ${funcstack[4]}, the caller's caller. Assuming ${funcstack[2]} to be
    #   either TRAPZERR() or die(), this is the actual "caller."
    local caller_name
    if [[ "${#funcstack}" -ge 4 && "${funcstack[3]}" == (TRAPZERR|die) ]]
    then caller_name="${funcstack[4]}"
    else caller_name="${funcstack[3]}"
    fi

    #FIXME: Quite nice, though we don't currently use it. Perhaps extract into a
    #new function convert_runnable_name_to_printable_string() in "runnable/runnable". This
    #suggests a new series of functions inspired by Java's toString() approach,
    #all intended for use as human-readable strings. There are a number of existing
    #functions which, arguably, should be renamed in such fashion -- including:
    #
    #* convert_string_integer_to_comma_delimited_string(). This function appears to
    #  use awk's printf() and hence implicitly locale globals to perform such
    #  delimitation, suggesting in fact the result to not necessarily be comma-
    #  delimited. Hence, convert_string_integer_to_printable_string() seems much
    #  more sensible.
    # If this frame signifies a function, append "()" to such function name.
#   if typeset -f -- "${caller_name}" &>/dev/null
#   then caller_name="${caller_name}()"
    # If this frame signifies no "eval" statement and hence signifies a script,
    # double quote such filename.
#   elif [[ "${caller_name}" != '(eval)' ]]
#   then caller_name="\"${caller_name}\""
#   fi

    # Describe such exit status.
    print "${caller_name}: failed with exit status ${exit_status}"
}

#FIXME: There appears to be a very curious oddity in Zsh; sourcing a Zsh script
#containing the line "return 1" produces the expected call stack, resembling:
#
#./tmpy.zsh: failed with exit status 1
#    \_ curse_call_stack() { /home/leycec/zsh/zeshy/src/main: 418 }
#     \_ handle_exception() { /home/leycec/zsh/zeshy/src/main: 8458093679346917924 }
#      \_ TRAPZERR() { ./tmpy.zsh: 2 }
#       \_ ./tmpy.zsh { zsh: 32 }
#
#Running a Zsh script containing the line "exit 1" as a command, however,
#produces call stacks resembling:
#
#TRAPZERR: failed with exit status 20
#    \_ curse_call_stack() { /home/leycec/zsh/zeshy/src/main: 418 }
#     \_ handle_exception() { /home/leycec/zsh/zeshy/src/main: 7955925549229362501 }
#      \_ TRAPZERR() { /bin/zsh: 31 }
#
#In the latter case, Zsh reports the call stack to contain no such command. But
#it gets worse! Zsh fails to include commands in *ALL* call stacks; try
#"command ls zzmmmm", for example. This tends to produce inherently senseless
#error output. I suggest one of two solutions:
#
#* If "TRAPZERR" is the top of the call stack, print no call stack. (It's
#  meaningless, so don't even bother.) This is most certainly the simplest
#  solution. (Actually, I tried this. It blatantly sucks.)
#* Forcefully add the expected command to the top of the call stack. This is
#  much better, since the prior solution still crudely reports
#  "TRAPZERR: failed with exit status 20" when in fact we expect
#  "./tmpy.zsh: failed with exit status 1". Just not sure how to *GET* the
#  expected command name or exit status.

set_function_documentation print_call_stack '
string print_call_stack(void)

Print a trace of the current call stack consisting of all previously called
functions, sourced files, and "eval" statements in the current call path to
standard error, excluding only the stack frame of the caller''s call to this
function. Printing to standard error rather than output ensures that calling
this function from command substitutions (e.g., "$(get_zsh_version)") prints
to the terminal device attached to the current shell, without requiring the
caller to explicitly perform such printing: e.g.,

  # Assuming neither "/spider" or "/murphy" exist, the following command
  # substitution throws an exception printing a call stack trace to
  # standard error without effort on our behalf.
  >>> string first_file; first_file="$(get_first_file /spider /murphy)"
'
function print_call_stack() {
    # Validate passed arguments.
    (( # == 0 )) || die 'expected no arguments'
    integer funcstack_size=${#funcstack} i caller_line
    local frame_prefix='    \\_' filename caller_name

    # Print the current call stack.
    for (( i = 1; i <= funcstack_size; i++ )) {
        # Split the current stack frame's funcfiletrace entry on the last colon
        # in that entry into this frame's filename and line number, thus
        # accounting for possible colons in filenames (e.g., from "colon:blow:7"
        # to filename "colon:blow" and line number 7).
        caller_name="${funcstack[${i}]}"
        caller_line="${funcfiletrace[${i}]##*:}"
           filename="${funcfiletrace[${i}]%:*}"

        # If this frame signifies a function, append "()" to such name. Sadly,
        # if a script with the same name exists (which is technically feasible,
        # given Zsh support for double-quoted function names), there appears to
        # be no simple way of discerning between the two. *shrug*
        #
        # Note that, when called due to an exception thrown from an interactive
        # alias, such alias will be disabled here and hence not be recognized as
        # a function. Since such alias signifies an alias and not a function,
        # this is (arguably) not a bug. (Nothin' to see here, folks.)
        typeset -f -- "${caller_name}" &>/dev/null &&
            caller_name="${caller_name}()"

        # Print the current stack frame to standard error.
        print --\
            "${frame_prefix} ${caller_name} { ${filename}: ${caller_line} }"

        # Indent the next stack frame one space to the right.
        frame_prefix=" ${frame_prefix}"
    }
}

# ....................{ INTERRUPTION                       }....................
#FIXME: It appears this may encourage non-halting interrupts, which is bad. I
#have no idea why, but strongly suspect calling curse_call_stack() in this
#context to be the culprit. Disable for now.
# integer TRAPINT(integer signal_number = SIGINT)
#
# Trap SIGINT (i.e., signal interrupt, as after a user-driven <Ctrl-C> event).
#function TRAPINT() {
#    integer signal_number=${1}

    # Print the current call stack to indicate the point of interruption.
#    curse_call_stack

    # Store the interrupted line in the history. By default, Zsh omits such
    # lines -- somewhat unhelpfully. Dismantled, this is:
    #
    # * "zle", true only if the history is currently active.
    # * "-s", output the interrupted line to the history rather than stdout.
    # * "-r", preserve escapes from "echo" command manipulation.
    # * "--", prevent dash prefixes in the interrupted line from being
    #   misinterpreted as "print" command options.
    # * "${BUFFER}", the interrupted line.
#    zle && print -sr -- "${BUFFER}"

    # Arcanely uncanny bit-munging. Exit status is always a 1-byte integer.
    # Non-zero exit status with:
    #
    # * The high bit unset signifies a command or function-specific error.
    # * The high bit set signifies a signal-specific error. All bits excluding
    #   the high bit signify the signal number.
    #
    # Hence, constructing a signal-specific exit status requires merely adding
    # 128 to the desired signal number. Moreover, Zsh interprets non-zero trap
    # function return values as the exit status to be returned from running the
    # default handler for the trap. Since we would like to continue running the
    # default handler for the trap (SIGINT, in this case), this function returns
    # a non-zero value. Rather than hard-coding the desired signal number, reuse
    # the number Zsh passed as the first argument to this function.
#    return $(( 128 + ${signal_number} ))
#}

# ....................{ OPTIONS                            }....................
# Map from parsed option name to optional value. As expected, unparsed options
# remain preserved in the current argument list.
local -A arg_options

# List of shell commands to be run parsed from options "-c" and "--command".
local -a arg_shell_commands

# List of shell options to be enabled parsed from options "-o" and "--option".
local -a arg_shell_options

#FIXME: I'm fairly assured that passing multiple commands and options with
#long-form options works as advertised. I strongly doubt, however, that passing
#multiple commands and options with short-form options works as advertised. If
#not, we'll probably want to drop the "-M" and manually map short- to long-form
#arguments following option parsing. (Simple, if a tad tedious.)
#FIXME: Add an option for profiling Zsh startup. Yes, Zsh supports this.
#Exceptionally cool; I had no idea! See Dennis' great answer here:
#
#http://stackoverflow.com/questions/4351244/can-i-profile-my-zshrc-zshenv
#http://stackoverflow.com/questions/6693515/zsh-how-to-time-a-block-of-code
#
#We should most certainly add a run_profiled() function for printing a timing
#profile after running the passed command. There appear to be several ways of
#doing this: the "setopt xtrace" approach of the first URL above; the
#"time ( ... )" approach of the second URL above; and the "zprof" module. I'm
#unclear which is better but am currently leaning towards the latter. Regardless
#of which approach we choose, output to standard error by default, so as to
#ensure expected behavior under process substitution. (Naturally, a secondary
#function could be implemented to log to a passed file, instead.)
#FIXME: Hmm; yes, the "zprof" approach appears superior. Its output rocks, as
#expected. Mimics "gprof", so there you go. It's a bit wieldy to use, requiring
#unload of the module to disable profiling, but... no problems, given a
#run_profiled() helper.

# Parse passed options *BEFORE* operating on any Zeshy files, as the former
# could modify the behavior of the latter (e.g., by preventing Zeshy from
# recompiling and loading its digest file). If such parsing fails, set option
# "-h" to non-zero exit status, instructing the end of this script to print help
# to standard error and return with such status. See parse_arg_options().
#
# For readability, map short- to long-form options. Map option
# "--no-zeshy-dot-dir" to "--zeshy-dot-dir", thus implicitly setting the latter
# option with the option string on parsing the former option.
zparseopts -M -D -E -A arg_options --\
    h=-help -help \
    v=-version -version\
    c+:=arg_shell_commands -command+:=arg_shell_commands\
    o+:=arg_shell_options -option+:=arg_shell_options\
    -zeshy-dot-dir:: -no-zeshy-dot-dir=-zeshy-dot-dir ||
    arg_options[--help]=1
#print -- "passed option names (${#arg_options}): ${(k)arg_options}"

# ....................{ OPTIONS ~ paths                    }....................
# Absolute directory of the Zeshy codebase. See "bin/zeshy" for commentary.
[[ -n "${ZESHY_HOME}" ]] || ZESHY_HOME="$(print -- "${0:h}"(:A))" || {
    print "zeshy: main script \"${0}\" not found" 1>&2
    return 1
}

# User-specific Zeshy dot directory basename.
ZESHY_DOT_DIR_BASENAME='.zeshy'

#FIXME: Actually test this. Shouldn't be terribly difficult: just temporarily
#move "~leycec/.zeshy" aside and pass "--no-zeshy-dot-dir" to an interactively
#run "zeshy" process. If "~leycec/.zeshy" doesn't appear, we've done something
#spectacularly right. Huzza!

# User-specific Zeshy dot directory. While typically non-empty, callers passing
# options "--zeshy-dot-dir=" or "--no-zeshy-dot-dir" forces option parsing
# performed below to set this directory to the empty string. Hence:
#
# *NO ZESHY FUNCTIONALITY MAY ASSUME USE OF SUCH DIRECTORY*.
#
# All Zeshy functionality must explicitly test this global for non-emptiness
# before reading from or writing to this directory or files or subdirectories of
# this directory. In particular, if empty, Zeshy must load with default settings
# and no digest file.
#
# If the caller passed option "--zeshy-dot-dir", set this directory to the value
# of such option.
if (( ${+arg_options[--zeshy-dot-dir]} ))
then ZESHY_DOT_DIR="${arg_options[--zeshy-dot-dir]}"
# If the current user's ${HOME} is the root directory, the current user is
# either "cron" or a subsidiary thereof. In such case, default this directory to
# under "/var/".
elif [[ "${HOME}" == '/' ]]
then ZESHY_DOT_DIR='/var/cache/zeshy'
# Otherwise, default this directory to "~/.zeshy".
else ZESHY_DOT_DIR="${HOME}/${ZESHY_DOT_DIR_BASENAME}"
fi

# Directory from which Zeshy reads user configuration files.
ZESHY_DOT_CONFIG_DIR="${ZESHY_DOT_DIR}/config"

# Directory from which Zeshy reads user themes, plugins, etc.
ZESHY_DOT_OVERLAY_DIR="${ZESHY_DOT_DIR}/src"

# Digest file to which Zeshy compiles its codebase. Since such compilation
# assumes user-specific state (e.g., Zeshy theme, installed commands), such
# file is user-specific.
ZESHY_DOT_DIGEST_FILE="${ZESHY_DOT_DIR}/digest.zwc"

# File to which Zeshy caches its version specifier (e.g., to detect upgrades).
ZESHY_DOT_VERSION_FILE="${ZESHY_DOT_DIR}/current_version"

# ....................{ LOAD                               }....................
set_function_documentation source_zeshy_script '
void source_zeshy_script(string filename1, string filename2, ...)

Source the passed Zeshy scripts with no arguments in the passed order.
'
function source_zeshy_script() {
    # Validate passed arguments.
    (( # >= 1 )) || die 'expected at least one filename'

    for filename ("${@}") {
        # If such filename is prefixed with no dirname and hence is only a
        # basename,  prefix such basename with Zeshy's top-level directory.
        [[ "${filename}" == *'/'* ]] ||
            filename="${ZESHY_HOME}/${filename}"

        # Source such Zeshy script.
        source -- "${filename}"
    }
}

set_function_documentation load_zeshy '
void load_zeshy(void)

Load Zeshy into the current zsh shell. Specifically:

* If such shell is a login shell, establish sensible login shell settings.
  See set_shell_login_defaults() for further details.
* Source all Zeshy configuration files.
* If no Zeshy digest file has been compiled or such file requires
  recompilation (e.g., due to upgrading Zeshy, editing Zeshy configuration
  files, or installing new command or uninstalling old commands from the
  current ${PATH}), recompile such digest.
* Prepend such digest to the current ${FPATH}, thus effectively loading all
  Zeshy functions. For efficiency, the Zsh autoload system delays defining
  these functions until the first call to such functions.
* Perform all Zeshy startup tasks, including:
  * Defining all Zeshy aliases and globals.
  * Calling all user-defined startup hooks.
'
function load_zeshy() {
    # Validate passed arguments.
    (( # == 0 )) || die 'expected no arguments'

    # If the current shell is a login shell, set login-specific behavior.
    [[ -o login ]] && source_zeshy_script login

    # Source all Zeshy configuration files and compile and load Zeshy's digest.
    source_zeshy_script config autoload
    #print "glob: ${ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY}"

    # Undefine all globals defined by such recompilation. The reasons are subtle but
    # the logic flows like butter. Zeshy may (and often does) declare globals to be
    # read-only. Sadly, Zsh fails on attempting to redefine read-only globals. Since
    # the subsequent call to startup_zeshy() and hence startup_zeshy_globals() does
    # just that, undefine Zeshy-specific globals prior to such calls. Do so in the
    # root global context (i.e., in this component outside of functions) to
    # guarantee expected behavior. "'tis all a tad silly and worm-bitten, but such
    # is life in the tranche of code trenches."
    #
    # Since Zsh never fails on redefining aliases or functions, do not bother
    # undefining either. We could, but there's little point (or profit) in it.
    [[ -n "${ZESHY_GLOBAL_NAMES-}" ]] && {
    #   print -l "===ZESHY_GLOBAL_NAMES===" "${ZESHY_GLOBAL_NAMES[@]}"
        typeset +r -- "${ZESHY_GLOBAL_NAMES[@]}"
        unset      -- "${ZESHY_GLOBAL_NAMES[@]}"
    #   print "glob: ${ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY}"
    }

    # Initialize Zeshy, having recompiled the Zeshy digest file above and hence
    # defined all autoloads applicable to the current user.
    startup_zeshy

    #FIXME: Kill this. Kill this soon. (You know you want to...)
    setup_zeshy
}

# ....................{ LOAD ~ reload                      }....................
# If sourcing the current script under Zsh startup logic (e.g., from a Zsh
# script with basename matching either ".zlogin", ".zprofile", or ".zshrc"),
# prevent Zsh from reloading Zeshy if already loaded earlier during such logic.
#
# Ideally, the current script should only ever be sourced by the "zeshy" script
# installed with Zeshy. Ideally, Zsh startup logic should avoid sourcing the
# current script. Since Zeshy is valid Zsh, however, this script is sourceable
# as is by any Zsh script or shell -- including Zsh startup scripts. In such a
# case, failing to prevent Zsh from reloading Zeshy induces the following:
#
# * Some process runs the "zeshy" script as a new child process.
# * This process runs under "zsh" due to such script's shebang line.
# * This process sources at least ".zshrc" and possibly also ".zlogin" and
#   ".zprofile", depending on runtime context.
# * Sourcing such script could source the current script, loading Zeshy.
# * After sourcing the current script, control returns to the "zeshy" script,
#   which either:
#   * Sources the current script, reloading Zeshy.
#   * Replaces this process with a new process running "zsh" passed the current
#     script as its first argument and hence reloading Zeshy twice:
#     * Once by Zsh startup logic, as above.
#     * Once by the first argument passed to such script.
#
# In either case, Zsh loads Zeshy at least twice and possibly more. Avoid this!
#print "zeshy: argv[0]=$0}"
#print "zeshy: command line=$(< /proc/$$/cmdline)"
#print "zeshy: process ID (current)=$$"
#print "zeshy: process ID (parent!)=${PPID}"
#print "zeshy: process ID (cached.)=${ZESHY_PID_LAST_LOADED_BY-}"
#print "zeshy: passed option names=${(k)arg_options}"

# If the caller requests we not reload Zeshy if previously loaded by the current
# shell and (indeed!) Zeshy was loaded by such shell, avoid doing so again.
if (( ZESHY_PID_LAST_LOADED_BY == $$ )); then
    # If Zeshy has *NOT* been previously loaded under the current shell (as the
    # the lack of get_zeshy_version() implies), throw an exception.
    typeset -f get_zeshy_version &>/dev/null or
        die "get_zeshy_version() not defined, so Zeshy not previously loaded"
# Otherwise, Zeshy has not yet been loaded.
else
    # Do so.
    load_zeshy

    # To test the prior conditional on the next attempt to load Zeshy under the
    # current shell, set the process ID to that of this shell *AFTER*
    # successfully loading Zeshy.
    ZESHY_PID_LAST_LOADED_BY=$$
fi

# Undefine documentation-specific maps defined at the top of this script. As the
# prior conditional calling load_zeshy() calling compile_zeshy() has already
# serialized such maps onto on-disk key value stores, such maps are no longer
# needed. As such maps consume non-trivial resources (typically 8MB to 16MB of
# memory), safely delete such maps here after their serialization to disk above.
undefine_variable\
    ZESHY_ALIAS_NAME_TO_HELP_STRING\
    ZESHY_FUNCTION_NAME_TO_HELP_STRING\
    ZESHY_GLOBAL_NAME_TO_HELP_STRING

# ....................{ OPTIONS ~ help                     }....................
# Handle passed help options *AFTER* loading Zeshy.

# If passed a help option, ignore all other options and if:
#
# * The above option parsing failed as signified by (( arg_options[-h] == 1 )),
#   print usage help to standard error and return with non-zero exit status.
# * Else, print help to standard output and return with zero exit status.
(( ${+arg_options[--help]} )) and {
    if (( arg_options[--help] == 1 )); then
        run_redirecting_to_standard_error print_zeshy_help_usage
        die 'passed invalid or unknown options'
    else
        print_zeshy_help_usage
        return_true
    fi
}

# If passed a version option, behave similarly to above.
(( ${+arg_options[--version]} )) and {
    print_zeshy_version
    return_true
}

# ....................{ OPTIONS ~ shell                    }....................
# Handle passed shell options *AFTER* handling help options, which immediately
# return if passed and hence assume priority.

#FIXME: Parse ${arg_options} and ${arg_shell_commands} here. Test a bit, of course.

# Run all passed shell commands. Since every other element parsed into
# ${arg_shell_commands} is either "-c" or "--command" and hence ignorable, iterate
# elements in pairs ignoring the first such element.
for placeholder arg_shell_command ("${arg_shell_commands[@]}") {
#   print "zeshy: passed command \"${arg_shell_command}\""
    run "${arg_shell_command}"
}

# Enable all passed shell options *AFTER* running passed shell commands, to
# ensure such commands run under the default Zeshy environment. Iterate list
# elements in pairs ignoring the first such element, as above.
for placeholder arg_shell_option ("${arg_shell_options[@]}") {
#   print "zeshy: passed option \"${arg_shell_option}\""
    enable_shell_option "${arg_shell_option}"
}

# ....................{ PROFILING ~ end                    }....................
# If debugging Zeshy, print a human-readable synopsis of Zeshy startup time. For
# accuracy, minimize shell overhead by:
#
# * Printing such synopsis as a single statement.
# * Avoiding calling Zeshy-specific functions to do so.
is -n "${ZESHY_IS_DEBUG-}" si and printf\
    "zeshy: startup in %.4f seconds (wall clock)\n"\
    $(( EPOCHREALTIME - ZESHY_STARTUP_TIME_SECONDS ))

#FIXME: It'd be nice to profile Zeshy a bit to see what's consuming the most
#time. (I suspect the single "autoload -w" statement loading the digest, but
#one never knows, really.) Perhaps add a new "--profile-zeshy-startup" option.

# ....................{ ARGUMENTS                          }....................
# If the caller passed at least one argument *NOT* prefixed by "-", source
# Prior option parsing removed all recognized options from the current argument
# list. Interpret the first remaining argument as the path of a Zeshy script to
# be sourced and subsequent remaining arguments as arguments to be passed to
# such script. Since this is the same argument order accepted by builtin
# source(), source all remaining arguments as is *AFTER* printing Zeshy's
# startup time to avoid increasing such time by the time spent sourcing.
(( # )) && source -- "${@}"

# ....................{ MAIN                               }....................
# Avoid implicitly returning with non-zero exit status, as occurs when the prior
# statement is a conditional evaluating to false.
return_true

# --------------------( WASTELANDS                         )--------------------
#To subsequently print such
#documentation, call print_function_documentation().
    # Validate passed arguments.
#   local function_name="${1}"
#typeset -Agx ZESHY_FUNCTION_NAME_TO_DOCUMENTATION
#    ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${1}]="${2}"
#typeset -Agx ZESHY_FUNCTION_NAME_TO_HELP_STRING
#    ZESHY_FUNCTION_NAME_TO_HELP_STRING[${1}]="${2}"
#typeset -Agx ZESHY_FUNCTION_NAME_TO_DOC_STRING
#    ZESHY_FUNCTION_NAME_TO_DOC_STRING[${1}]="${2}"

#is_boolean_true ZESHY_IS_DEBUG and printf\
#FUXME: Source all remaining arguments via source_shell_script().
# Source such arguments *AFTER* printing Zeshy's startup time to avoid
# incrementing such time by the time required to source such arguments.
#FUXME: If ${ZESHY_IS_DEBUG}, print out a brief line printing timing statistics:
#namely, how quickly Zeshy started up. *ALWAYS* start timing as the first line
#of this file, since we won't have access to ${ZESHY_IS_DEBUG} for a bit of
#time. (What's the best way to perform shell profiling? Google us up.) Hmm;
#don't adopt the "zprof" solution, which imposes a bit too much overhead. We
#want a no-overhead -- the "times" command looks particularly helpful. Is there
#any way to reset the "times" timer? Alternatively, if we could somehow run this
#entire script prefixed by "time"... Heavy-weight, though. "times" would be
#preferable, really. Perhaps an initial implementation should just do:
#
#local ZESHY_TIME_STARTUP
#[[ -x "${${:-lsb_release}:c}" ]] &&
#  ZESHY_TIME_STARTUP="$(date "+%s%N)"
#
#Only trouble there is that the default profile may not have been established.
#Ah-ha! Knew it. Zsh helpfully provides a builtin module circumventing such
#difficulties: "zsh/datetime". So, at the very top of this script:
#
## Load module "datetime", providing global list ${epochtime} expanded below.
#zmodload zsh/datetime
#
## Time in seconds and nanoseconds since the Unix epoch at which Zeshy was first
## loaded (i.e., at which the current script was first sourced).
#export -i ZESHY_STARTUP_TIME_SECONDS ZESHY_STARTUP_TIME_NANOSECONDS
#
## Get such times from global list ${epochtime}, whose:
##
## * First shell word has the current time in seconds since the Unix epoch.
## * Second shell word has the current time in nanoseconds since the epoch.
##
## For reliability, expand such shell words at the same time.
#for ZESHY_STARTUP_TIME_SECONDS ZESHY_STARTUP_TIME_NANOSECONDS in ${epochtime}
#do; done
#
#Brilliant! Make it so.
# accuracy, avoid calling Zeshy-specific functions to do so.
    # Time in seconds and nanoseconds since the Unix epoch at which Zeshy
    # startup completed.
#   float ZESHY_STARTUP_TIME_SECONDS="${EPOCHREALTIME}"

    # Print such synopsis as a single statement to minimize shell overhead.
# Time in seconds and nanoseconds since the Unix epoch at which Zeshy was first
# loaded (i.e., at which the current script was first sourced).
#integer ZESHY_STARTUP_TIME_SECONDS ZESHY_STARTUP_TIME_NANOSECONDS

# Set such times from global list ${epochtime}, whose:
#
# * First shell word has the current time in seconds since the Unix epoch.
# * Second shell word has the current time in nanoseconds since the epoch.
#
# For reliability, expand such shell words at the same time.
#for ZESHY_STARTUP_TIME_SECONDS ZESHY_STARTUP_TIME_NANOSECONDS in ${epochtime}
#do; done
    # Time in seconds and nanoseconds since the Unix epoch at which Zeshy
    # startup completed.
#   integer ZESHY_STARTUP_END_TIME_SECONDS ZESHY_STARTUP_END_TIME_NANOSECONDS

    # Set such times. See the top of this script for further details.
#   for ZESHY_STARTUP_END_TIME_SECONDS ZESHY_STARTUP_END_TIME_NANOSECONDS in\
#       ${epochtime}; do; done

#FUXME: Rename "curse_" to "print_" here and below, and reform handle_exception()
#to simply redirect output of such functions to standard error. Simple: centralize
#such redirection in one place rather than in every print statement in such
#functions.

#       print 1>&2  # print a blank line to standard error
#if (( #arg_options ))
#then for key ("${(k)arg_options}") print "arg_options[${key}]=${arg_options[${key}]}"
#else print "arg_options empty; args: ${*}"
#fi
#FUXME: Rename "print_" back to "print_" *EVERYWHERE*.
#FUXME: Rename "curse_" to "admit_" (?) *EVERYWHERE*. To search for applicable alternatives,
#search synonyms of "complain" and "confess". Ah! Right. Why not "curse". I
#still quite like it after all these years. It's readily replaceable, anyway, if
#we elect for something else. O.K.; go "curse" it!
#zeshy_interactive_substitution_names_for_gui_commands
#zeshy_interactive_aliases_substituting_gui_commands
#zeshy_interactive_aliases_for_gui_commands
#zeshy_interactive_aliases_for_cli_commands
#zeshy_interactive_substitutions_graphical
#zeshy_interactive_selfaliases_graphical
#zeshy_interactive_substitution_names_run_disowned
#zeshy_command_names

#zeshy_interactive_substitution_names_run_disowned
#zeshy_interactive_substitution_names

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #FUXME: This isn't right at all. *IT'S FAIRLY IMPORTANT WE FIX THIS PRIOR
    #TO RELEASE*. Basically, shouldn't we *ALWAYS* throw an exception? That
    #ensures expected behavior in Zeshy scripts with respect to "always"
    #blocks, whereas the current implementation completely falls down. I have
    #no idea why we adopted the current implementation, in fact. It seems
    #blatantly brain-dead...and not in the kitsch Peter Jackson way, either.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # If called under an interactive shell, unwind the call stack to return the
    # current user to an interactive prompt; otherwise, exit this shell script.
    #
    # Note that the simpler command "return ${exit_status}" implicitly invokes
    # the "err_return" and TRAPZERR() handlers and hence (ultimately) performs
    # the same logic, but that such invocation produces less readable stack
    # traces. Consequently, we prefer the present implementation.
#   if [[ -o interactive ]]
#   then throw ZeshyException
#   else exit ${exit_status}
#   fi

#       print 1>&2  # print a blank line to standard error
#       print_exception_exit_status "${1}"
#then ZESHY_IS_LOADING=
#print "zeshy: ZESHY_IS_LOADING=${ZESHY_IS_LOADING}"

# Load Zeshy and grace the saffron skies with fullsome zest! All shell commands
# following this conditional may safely access all Zeshy aliases, globals, and
# functions. Specifically:
#
# * If loading Zeshy, do so.
# * Else if Zeshy has not been previously loaded under the current shell (as
#   implied by the lack of get_zeshy_version()), throw an exception.
#if [[ -n "${ZESHY_IS_LOADING}" ]]
#then load_zeshy
#elif ! typeset -f -- get_zeshy_version &>/dev/null
#then die "get_zeshy_version() not defined and hence Zeshy not loaded"
#fi

#FUXME: O.K.; the whole "--no-zeshy-reload-by-same-process" thing doesn't work,
#since Zsh oddly executes the passed script *BEFORE* performing startup
#behavior. Extremely unexpected, but there you are. I see no sane way around
#this without the general rule: Zeshy prohibits reloading itself from the same
#process. Period. That's it. Sorry, but them's the unfortunate breaks.

# If non-empty, make and use the user-specific Zeshy directory ${ZESHY_DOT_DIR}
# and all subdirectories and files of such directory; else, load Zeshy with
# default configuration and shell settings and no digest file. Unlike the
# similar boolean ${ZESHY_IS_LOADING}, publish this boolean globally; numerous
# Zeshy functions called after startup need to know about the "situation."
#export ZESHY_DOT_DIR=1

# ....................{ LOCALS                             }....................
# If non-empty, load Zeshy; else, only handle arguments passed to this script.
#local ZESHY_IS_LOADING=1

#FUXME: If ignoring the Zeshy user directory, disable the corresponding boolean.
#(( ${+arg_options[--no-zeshy-dot-dir]} )) && ZESHY_DOT_DIR=

#FUXME: Consider renaming "ZESHY_DOT_" to "ZESHY_DOT_" everywhere. Much more
#explanatory and slightly conciser.

#   -no-zeshy-dot-dir -no-zeshy-reload-by-same-process ||
#print "zeshy: funcstack[1]=${funcstack[1]}"
#sleep 2
#exit
#, but Zeshy has been at least partially previously loaded"
    # Bootstrap Zeshy by loading core aliases, globals, and autoloads, the minimal
    # clique of Zeshy components. All subsequent Zeshy functions are implicitly
    # loaded on the first call to such functions by the autoload system.
    # Specifically, set global string ${PATH} and a sane umask and source the
    # expected startup scripts (e.g., under "/etc/profile.d/").
#FUXME: We really need such boolean? Hmmm. Probably. But let's make sure.
#FUXME: Woops. This is pretty much completely wrong for actual Zeshy
#installations (e.g., into "/usr/share/zeshy", containing the current contents
#of "~/zsh/zeshy/src"). ZESHY_HOME and ZESHY_HOME should *ALWAYS* be the
#same exact thing. Hence, remove the latter and set the former as follows:
#
#[[ -n "${ZESHY_HOME-}" ]] || export ZESHY_HOME="${0:h}"(:A)
#
#We should probably remove all setting of such variable from
#"etc/{zlogin,zprofile,zshrc}", perhaps suggesting "etc/{zlogin,zshrc}" should
#be removed entirely and "etc/zprofile" reduced to just running "zeshy". (Or
#perhaps just "etc/zshrc" reduced to running "zeshy" and the others removed?)

# as the latter establishes the global ${PATH} required by the former. To avoid
# reduplication,
#
# (e.g., for
# finding commands in the global ${PATH} with word modifier ":c").
#    # See "compile" for further details on clever expressions like this.
#   [[ -x "${${:-lsb_release}:c}" ]] &&
#FUXME: This conditional needs testing, clearly.
#FUXME: Damn. It's broken. Zsh doesn't set it as I expected; hence, we need to
#manually parse an option "--no-reload". Do so above and test for
#"(( ${+arg_options[--no-reload]} ))" here. I'm fairly sure we can just replace
#the "false &&" with the above test... and everything (might) just work. Ah;
#well, yes. *TECHNICALLY*, the logic below would work -- but it's overkill.
#Wait...no, it's not. It's the option name that's wrong: it's too succinct.
#Rename such option to "--no-reload-by-same-process". Bit if a mouthful, but
#that accurately describes what we *REALLY* want. And given that crazy name,
#I'm happy to leave this option undocumented, you know?

# Parse passed options *AFTER* performing login-specific logic, as the latter
# establishes the global ${PATH} required by the former (e.g., for finding
# commands in the global ${PATH} with word modifier ":c").
#
# Parse passed options *BEFORE* operating on any additional Zeshy files or operating
# on user-specific Zeshy files, as the
# former could modify the behavior of the latter (e.g., by preventing Zeshy from
# recompiling and loading its digest file).
    #FUXME: Do we need test against *BOTH* $$ and ${PPID}? It can't hurt, of
    #course... but it would be nice to ascertain which we require.
#   if [[ "${ZESHY_PID_IF_ZSH_STARTUP}" == ($$|${PPID}) ]]

#[[ "${funcstack[1]}" == */(.|)(zshrc|zprofile|zlogin) ]] && {
#* If [[ "${ZESHY_PID_IF_ZSH_STARTUP-}" -eq "${PPID}" ]], then:
#  * Zeshy has already been loaded by the parent process and hence (hopefully)
#    inherited by the current process. Return immediately.
#* If [[ "${funcstack[1]}" == "*/(.|)(zprofile|zshrc)" ]], then:
#  * Set ${ZESHY_PID_IF_ZSH_STARTUP} as a global export in "src/main" ala:
#    typeset -igx ZESHY_PID_IF_ZSH_STARTUP="${PID}"

# Due to portability
# concerns, avoid exporting globals via "export" prior to enabling
    # If interactive, immediately return back to Zsh; otherwise, exit the
    # current script.
#   if [[ -o interactive ]]
#   then return 1
#   else   exit 1
#   fi

#   print "defaulting \"ZESHY_HOME\" to \"${ZESHY_HOME}\"" 1>&2
#   print "consider running \"zeshy\" rather than sourcing \"${0}\"" 1>&2

# Absolute directory of the Zeshy library.
#ZESHY_HOME="${ZESHY_HOME}/src"

# * Incorporate ZSH-lovers fixes, including:
#   * Use suffix aliases.
# * The new trap support obsoletes an astonishing quantity of prior
#   functionality (e.g., try()). Such functionality should be retained (???...
#   perhaps not), but exported out of this component into a new component: say,
#   "zeshy/shell/job".
# * zimport() can profitably be renamed require(). The latter captures the
#   intent and implementation much more succinctly and without the awkward
#   prefixing 'z'.
# * We only call a match_*() function once in this file. It's absurd to maintain
#   such complexity here; offload all match_*() functionality to
#   "zeshy/type/regex" and, if still required here, simply inline. I believe we
#   can use simple glob-style matching, instead.
# * Ultimately, Zeshy should auto-compile the recursive entirety of all Zeshy
#   function definitions into a single so-called "digest" file at, say,
#   "~/.zeshy/digest.zwc". Such a file is autoloadable by:
#
#       # ...implicitly autoloading such digest.
#       fpath=( "~/.zeshy/digest.zwc" "${fpath[@]}" )
#
#       # ...explicitly autoloading such digest.
#       autoload -Uw "~/.zeshy/digest.zwc"
#
#   I'm unsure if the former supercedes the latter. (Probably not, no.) Both
#   required, perhaps.
#
#   What's nice about this is that such a digest file appears to come prepended
#   with a list of all functions defined by such digest, thus rendering
#   autoloading of digest files terrifically fast. Auto-generating such a digest
#   on any change to any Zeshy file or directory is, unfortunately, not quite so
#   easy. We'll need to write something resembling:
#
#       if is "$(get_path_mtime "~/.zeshy/digest.zwc") equals SOMETHING si; then
#           zcompile "~/.zeshy/digest.zwc" "${ZESHY_HOME}/src/"**/*(.)
#       fi
#
#   However, it's unclear just how aggregating multiple files into one handles
#   initialization code. Clearly, it either doesn't or does but simply lumps all
#   initialization together. Either case is bad. We'll need to rewrite Zeshy to:
#
#   * Perform all non-costly initialization up-front in Zeshy .main or core.
#   * Perform all costly initialization in the functions requiring such
#     initialization as the first line of such functions. You know that grind...
#'zeshy: zsh 4.0.3 < 5.0.0'
#'zeshy: zsh 4.0.3 < 5.0.0'
#'zeshy: installed zsh 4.0.3 < required zsh 5.0.0'
#'zeshy: zsh 4.0.3 < required zsh 5.0.0'
#'zeshy: installed zsh version 4.0.3 < required zsh version 5.0.0'

#   print "zeshy: requires zsh ${ZESHY_ZSH_VERSION_REQUIRED} but running zsh ${ZSH_VERSION}" 1>&2
# Since Zsh 
# Indeed, Zsh has no corresponding option
# "no_rm_recursive_silent" for interactively confirming option "-r" when passed
# to command "rm". Zeshy, on the other hand, confirms both star-globbed and
# recursive removal. Since recursive removal is (arguably) less safe than even
# star-globbed removal, Zeshy's behavior may be (arguably) safer than the
# default Zsh behavior. Indeed, Zeshy interactively confirms all attempted path
# removal -- regardless of the number of such paths.
#FUXME: Doesn't appear to work as advertised, sadly.
#setopt no_global_export   # prevent "typeset -x" from implying "typeset -xg"

# List of all Zeshy-specific globals defined while sourcing Zeshy, if
# recompiling the Zeshy digest file. Defining such list globally permits us to
# undefine such globals in a global context, below.
#typeset -a ZESHY_GLOBAL_NAMES

# If recompiling the Zeshy digest file and hence sourcing Zeshy scripts
# defining globals, undefine such globals prior to initializing Zeshy. Why?
# The reason may be subtle, but the logic flows like butter. Zeshy may and
# typically does declare globals to be read-only. Understandably, Zsh fails on
# attempting to redefine such globals. The subsequent call to startup_zeshy()
# and hence startup_zeshy_globals() does just that, requiring such globals be
# undefined prior to such calls. Oh, 'tis all a tad silly and worm-bitten, but
# so goes life in the tranche of code trenches.
#(( #ZESHY_GLOBAL_NAMES )) and {
#    unfreeze_variable "${ZESHY_GLOBAL_NAMES[@]}"
#    undefine_variable "${ZESHY_GLOBAL_NAMES[@]}"
#    undefine_variable ZESHY_GLOBAL_NAMES
#}

# Delete all Zeshy-specific globals defined by and imported from the parent
# shell, locally preserving global ${ZESHY_HOME} for subsequent use. Failure to
# delete such globals results in a subtle issue when compiling the Zeshy digest
# file, which persists such globals to startup_zeshy_globals() by differencing
# the lists of globals defined before and after such compilation. Failing to
# delete such globals ensures the two lists to be effectively identical, thus
# preventing persistence of Zeshy globals into the Zeshy digest file.
#
# See undefine_variable_matching() for details on variable deletion.
#local zeshy_home="${ZESHY_HOME-}"
#typeset +r -m 'ZESHY_*'
#unset      -m 'ZESHY_*'
#typeset -p -m 'ZESHY_*'

# Restore ${ZESHY_HOME}, deleting the temporary ${zeshy_home}. We're good to go.
#typeset +gx ZESHY_HOME="${zeshy_home}"
#unset zeshy_home

#[[ -n "${ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY+x}" ]] and {
#    print 'Eh??!?!?'
#    typeset -p ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY
#}
#       [[ -f "${filename}" ]] || die "\"${filename}\" not a zeshy script"
# ....................{ TRAPS ~ errors                     }....................
# void source_zeshy_component(
#   string component_name1, string component_name2, ...)
#
# Source the passed Zeshy components (i.e., Zsh scripts in this directory).
#function source_zeshy_component() {
#    (( # >= 1 )) || die 'expected at least one component name'
#    for filename ("${@}") {
#       say "sourcing \"${ZESHY_HOME}/${filename}\"..."
#        source "${ZESHY_HOME}/${filename}"
#    }
#}

#source_zeshy_component alias global autoload
    # Omit the current function call by starting from the second stack frame.
    # If there exists no such frame, return with failure.
#   (( funcstack_size >= 2 )) || die 'call stack empty'
#   (( ++funcstack_size ))

#   for (( i = 2; i <= funcstack_size; i++ )) {
#   [[ "${funcstack[-1]}" == TRAPZERR ]] && return $(( 128 + ${1} ))
#   print "TRAP! oldest caller: ${funcstack[-1]}"
#   integer signal_number=${1}
#   return $(( 128 + ${signal_number} ))
#   return ${exit_status}
#   print "zeshy: ${caller_name} failed with exit status ${exit_status}" 1>&2
#   cry "\"${caller_name}\" failed with exit status ${exit_status}"
        #FUXME: I have no idea why we were doing this. It doesn't seem
        #particularly intelligent, however... So stop.
        # If this is the most recent stack frame, recall the name of the second-
        # most recent stack frame that called that frame and line number of that
        # call for subsequent pretty printing.
#       (( i == 2 )) && caller_line_first="${caller_line}"
#       (( i == 3 )) && caller_name_first="${caller_name}"

        # If this frame is the handle_exception() function typically calling
        # this function, avoid meaninglessly printing such frame.
#       [[ "${caller_name}" == handle_exception ]] && continue

#       [[ "${funcname}" == '(eval)' ]] || funcname="${funcname}()"
        # Temporarily redefine cry() in a manner consistent with exception handling.
#       function cry() { print -- "zeshy: ${*}" 1>&2; }

# Depending
# on the current user's Zeshy configuration, such function prints stack traces,
# documentation, and source code.
# according to the current user's Zeshy
# configuration of the
# current user (e.g., by printing a stack trace).
#
# Unlike "setopt ERR_RETURN", this handler calls handle_exception(). Depending
# on the current user's Zeshy configuration, such function prints stack traces,
# documentation, and source code.
#
# and hence implicitly throws an exception unwinding the
# call stack of the current shell on *ANY* command returning non-zero exit
# status, as if such command had instead thrown an exception.
#
# If such shell fails to
# handle such exception, Zsh implicitly rethrows such exception to the shell
# calling the calling shell. This process proceeds until either some calling
# shell handles such exception, in which case no further shells are unwound,
# or no shell handles such exception, in which case the current user receives an
# uncaught exception. In the
# Specifically, print a
# complete stack trace and . Such unwind exits all intermediate subshells
# (e.g., non-interactive Zeshy functions or scripts) to the originating shell
# (e.g., the interactive Zeshy or Zsh shell transitively responsible for running
# the failed command), but not necessarily any other active shell.
#   integer signal_number=${1} exit_status=${?}
    # Print a complete stack trace. If some function called this function (i.e.,
    # this function was not called directly from the prompt), prefix such trace
    # with that function's name and exit status; otherwise, no such prefix.
#   if (( ${#funcstack} >= 2 ))
#   then handle_exception\
#       "\"${funcstack[2]}\" failed with exit status ${exit_status}."
#   else handle_exception
#   fi

    # Omit the current function call by starting from the second stack frame.
    # If there exists no such frame, return with failure.
#   (( funcstack_size >= 2 )) || {
#       cry 'call stack empty'
#       return_false
#   }

    # Print a prefixing header with the passed message.
#   cry "${1:-}" 1>&2

# Do not return non-zero
        # exit status, as that recursively triggers TRAPZERR().
#           cry 'exception not found'
#           return 0
#       }
    #FUXME: Clearly not right if calling from within a trap handler, as this
    #would trigger another trap calling this function, and so on. For the
    #duration of all functions called by handle_current_exception(), we need to
    #temporarily replace exception throwing with just printing to standard
    #error and returning immediately. That said, I wonder if Zsh doesn't already
    #somehow handle this? Specifically, what happens if we *DO* just throw an
    #exception here? Perhaps everything magically works out. Test up. Ah! I get
    #it.

# For safety, trap functions and functions transitively called by such functions
# require only Zsh functionality (i.e., no Zeshy-specific syntactic sugar). This
# comprises all functions defined up to and including the "TRAPS" section.

# the notice stream
# of the cron logging facility if a cron-job and to the standard output stream
# otherwise.
#say 'finalizing aliases...'
#source "${ZESHY_HOME}/alias"
#say 'finalizing globals...'
#source "${ZESHY_HOME}/global"
#say 'finalizing autoloads...'
#source "${ZESHY_HOME}/import"
#say 'finalizing startup...'
#   [[ -f  "${filename}" ]] || die "\"${filename}\" not found"
#   source "${filename}"
# * I've been operating under the assumption Zsh variables require quoting to
#   preserve spaces. It appears that is *NOT* the case, under default Zsh shell
#   options. It doesn't hurt anything as is, but we could probably stand to
#   remove most if not all existing quoting. Ah; I see, somewhat. Lists must
#   always be quoted, but scalars need never be. Still, 'tis a confusing
#   distinction. We're better off persisting with the current method, I reckon.

# zeshy: consider upgrading zsh to ${ZESHY_ZSH_VERSION_REQUIRED}" 2>&1

#FUXME: *BRILLIANT IDEA*. Stack traces are great. But, with longer function
#implementations, output like:
#
#   curse_call_stack: make_and_install_kernel() failed with exit status 1
#        \_ TRAPZERR() { /root/.zeshy/digest.zwc/make_and_install_kernel: 34 }
#         \_ make_and_install_kernel() { /bin/zsh: 130 }
#
#...isn't really helpful. What is the 34th line of that function excluding
#comments? Right. There's no easy way to peruse that function's commented
#implementation and discern just where the fault lies. Hence, a solution:
#
#* Add a new "ZESHY_DEBUG" config global. (Think we might have one already, yes?)
#* If enabled, curse_call_stack() should implicitly with no external effort
#  append something resembling "which ${funcname[2]}" to its output. That's
#  closer to what we want, but still incomplete: "which" has no option for
#  prefixing each line of output with its line number, which is what we need.
#  I guarantee there's an "awk" script to do it, though. Search us up the fix!

#       (( i == 3 )) && {
#           funcname_first="${funcname}"
#           fileline_first="${fileline}"
#       }
    # Message to print. (Yes, its declaration and definition must be separate.)
    # Message to print. (Yes, its declaration and definition *MUST* be separate.
    # I'm not entirely clear why, but declaring and defining the message in the
    # same command induces inexplicably, undebuggably subtle errors.)
#   print "script name: $(get_script_name)"
#   [[ -n "${ZESHY_IS_CRONJOB}" ]] && logger -p cron.notice -- "${message}"
#   [[ -n "${ZESHY_IS_CRONJOB}" ]] && logger -p cron.err -- "${message}"
#   elif [[ "${#funcstack}" -gt 0 &&
#            "${funcstack[-1]}" != (get_script_name|say|msay|cry) ]]; then

#       if "${funcstack[${i}]}" == "${funcfiletrace[${i}]}"
#       print "${frame_prefix} ${funcname}() {${filename}:${fileline}}"

# This
# Each such frame signifies a previously called function, sourced file, or evaluated "eval". Each call
# stack of such frames signifies a stack trace of the complete code path from
# the most to least recently called function, source file, or evaluated "eval".

    # Continue the default trap handler, as under TRAPZERR(). 

# After any command returns non-zero exit status but prior to executing the next
# such command, instruct Zsh to:
#
# * Execute the TRAPZERR() trap function.
# * Unwind the call stack, exiting all intermediate shells, back to the
#   originating shell -- typically, the interactive shell from which the failing
#   command was transitively run.
# * If the failing command was run directly by some Zsh function:
#   * Return from that function with that command's non-zero exit status.
# Terminate the current shell, returning the non-zero exit status of the prior
# command.
#
# The combination of enabling this option and defining TRAPZERR() as below
# offers a robust alternative to the customary command "set -e", whose
# default implementation dangerously terminates the current shell on failure.
#setopt err_return

# * Execute the ZERR trap, if set.
# * Execute the TRAPZERR trap function, if defined.
# * If the failing command or function was itself called from a function:
#   * Return from that function with that command or function e return value .
# Terminate the current shell, returning the non-zero exit status of the prior
# command.
#
# The combination of enabling this option and defining TRAPZERR() as below
# offers a robust alternative to the customary command "set -e", whose
# default implementation dangerously terminates the current shell on failure.
#setopt err_return

    #FUXME: Hmm. If called from a pipe (e.g., "false or die "false!"), we really
    #want to use "${pipestatus[-2]}" here rather than "${?}".
#   if (( # == 0 ))
#   then say
#   else say "${1:-}"
#   fi

    #FUXME: Truncate.
    # Arcane bit-munging. Exit codes are of size "char" (i.e., a single byte).
    # Non-zero exit statuss with high bit set signify signal-driven fatal errors
    # and with high bit unset signify command-specific fatal errors. In the
    # former case, all bits excluding the high bit signify the signal number.
    # Hence, signal-driven exit statuss are constructable by adding 128 to the
    # signal number.
    #
    # SIGINT signifies fatal error of signal number 2. Rather than hard-code
    # that constant, we note:
    #
    # * Zsh passes the signal number as the first argument to trap functions.
    # * Zsh continues handling trap function-trapped signals as if untrapped
    #   when receiving non-zero exit statuss from such functions. In such cases,
    #   Zsh returns this exit status as the signal result to calling processes.
    # 
    # Since we prefer Zsh handle the actual interrupt as such with the same
    # exit status as it would customarily return, the result follows.
#   return ${exit_status}
#   return $(( ${exit_status} + 128 + ${signal_number} ))

    # Die with the prior return code.
#   die_with_exit_status ${exit_status}

# void die_with_exit_status(int exit_status = 1)
#
# Exit the currently executed script or function with the passed return code.
#die_with_exit_status() {
#   for ((i = 1; i <= ${#funcstack}; i++)) { print "${i}: ${funcstack[${i}]}" }
#   if is_interactive; then
#   then print 'throwing exception'; throw ZeshyException

    # If the current context is a function called from an interactive and/or
    # login shell, unwind the call stack; otherwise, kill the current process.
#    if is_interactive
#    then throw ZeshyException
#    else exit ${1:-${ZESHY_EXIT_STATUS_FAILURE}}
#    fi
#    print 'still here!'
#}

#set -e

#FUXME: Zsh fails to trigger ZERR traps from within the sourcing of zprofile and
#zshrc. I have no idea why. Since the following line does nothing to help,
#however, I can only assume this is somehow the intended behavior. Nonetheless,
#file a mailing list comment.
#trap TRAPZERR ZERR
#trap 'curse_call_stack; throw ZeshyException' ZERR

#   if is_interactive
#   then return $(( ${exit_status} + 128 + ${signal_number} ))
#   else exit       ${exit_status}
#   fi
 #   throw ZeshyException
#   print 'still here...'
#   for ((i = 1; i <= ${#funcstack}; i++)) { print "${i}: ${funcstack[${i}]}" }

    # Terminate the current shell, returning the non-zero exit status of the prior
    # command. This effectively enables "set -e" (i.e., the ERR_EXIT option,
    # terminating the current shell on SIGZERR signals).
#   eval 'throw ZeshyException'; return ${exit_status}
#   die_with_exit_status ${exit_status}

# * Uhm; how did I never see this? Zsh supports loop syntax resembling:
#   for d (../**/*) {
#   }
#   No need for cumbersome "for d in (../**/*); do ... done" nonsense. 

#FUXME: This is likely a Zsh bug, perhaps corrected in some subsequent version.
#But throwing uncaught exceptions from interactive functions appears to
#literally undefine the calling function. Yes, this makes no sense.

    #FUXME: Given the new stack trace facilities, this probably no longer applies.
    # Unset the script name, if set. This forces the get_script_name() function
    # to obtain the name of the most recently called non-trivial function, which
    # is of considerably more assistance when an error occurs.
#   local ZESHY_SCRIPT_NAME=

#   print
#   print     -- "${message} (stdout)"
#   print -u2 -- "${message} (stderr)"

#   elif is_interactive; then
        #FUXME: This is actually the reverse of what one might want. We should
        #select the *LAST* function on the function stack. 
#       typeset -i i
#       for (( i = ${#funcstack}; i >= 1; i-- )); do
#           print "${i}th function: ${funcstack[${i}]}"
#           [[ "${funcstack[${i}]}" == /* ]] && 
#
#           case "${funcstack[${i}]}" in
#               run*|die*|say*|msay*|cry*|ask_*) continue ;;
#               *) break ;;
#           esac
#       done
 
        # Ignore all intermediary I/O- and error handling-specific function
        # calls. Skip the first stack frame corresponding to the current
        # function by starting at the second stack frame.
#       typeset -i funcstack_size=${#funcstack}
#       for (( i = 2; i <= funcstack_size; i++ )); do
#           print "${i}th function: ${funcstack[${i}]}"
            # Order ignorable function names by likelihood, for "efficiency."
#           case "${funcstack[${i}]}" in
#               run*|die*|say*|msay*|cry*|ask_*) continue ;;
#               *) break ;;
#           esac
#       done
         
        # If after ignoring non-relevant functions there still exists at least
        # one function on the callstack, return that function's name.
#       if (( i <= funcstack_size )); then
            # If this name is an absolute path, return that path's basename.
#           if [[ "${funcstack[${i}]}" == /* ]]
#           then print "${funcstack[${i}]:t}"
            # Otherwise, return this name as is.
#           else print "${funcstack[${i}]}"
#           fi
        # Otherwise, return the default name.
#       else print 'zeshy'
#       fi
    # Otherwise, return the default name.
#   else print 'zeshy'
#   fi

# Math module supplementing Zsh's rudimentary math functionality with essential
# math operations (e.g., exponentiation).
#zmodload zsh/mathfunc

# Load broadly applicable Zsh modules.
#load_default_modules

# ....................{ DEFAULTS                           }....................
# void load_default_modules()
#
# Load broadly applicable Zsh modules.
#load_default_modules() {
    # Stat module wrapping the stat() system call with the zstat() Zsh function. Do
    # not load this module via "zmodload zsh/stat", as that wraps the stat() system
    # call with a stat() Zsh function, conflicting with the "stat" command.
#   zmodload -F zsh/stat b:zstat

    # Math module. While Zsh provides rudimentary math functionality out of the box,
    # some pivotal functions (e.g., exponentiation) are only provided by this.
#   zmodload zsh/mathfunc

    # Module exposing Zsh's C-based internal dictionaries as Zsh-based associative
    # arrays, including:
    #
    # * "$funcstack", having the current function call stack for user inspection.
    # * "$functions", having the current set of all functions for redefinition and
    #   later restoration of differing function definitions.
#   zmodload zsh/parameter

    # Perl-Compatible Regular Expression (PCRE) module. Note that, although
    # enabling the "rematch_pcre" option below implicitly loads this module on the
    # first use of the "=~" operator in a test, all code prior to that will not
    # have access to methods exposed by this module. Thus, simply import it
    # explicitly.
    #
    # See "String matching" below for use notes.
#   zmodload zsh/pcre

    # Utility module adding additional built-ins, including the commonly called
    # "zformat", "zparseopts", and "zstyle" functions.
#   zmodload zsh/zutil

# void _zeshy_bootstrap(string filename1, string filename2, ...)
#
# Source the passed Zeshy components in the passed order.
#_zeshy_bootstrap() {
#    for script_file in "${@}"; do
#        if [[ ! -f "${script_file}" ]]; then
#            print "zeshy: \"${script_file}\" not found or not a file" 1>&2
#            exit 1
#        fi
#        
#        source "${script_file}"
#    done
#}

#   _zeshy_init_bootstrap "${ZESHY_HOME}/src/init/if_shell_interactive/"*
## void _zeshy_init(void)
#_zeshy_init() {
#}
#
## Call and then immediately unset (i.e., delete) _zeshy_main().
#_zeshy_init
#unfunction _zeshy_init

# Import Zeshy Core defining import() prior to importing other dependencies.
#[[ $(whence -w zimport) =~ ': function' ]] ||
#    source "${ZESHY_HOME}/src/init/core"

# in a
# "system-sensitive" manner: i.e., importing only specific dependencies
# relevant to the current system.
    # Add Zeshy's "site-functions/" to the function path, if that directory exists.
#   is_dir "${ZESHY_HOME}/site-functions" and
#       fpath=( "${ZESHY_HOME}/site-functions" "${fpath[@]}" )

    #FUXME: Old.
    # Match all non-dotfiles in the current directory via the "(^D)" modifier:
    # i.e., all files and directories except this one. Since Zeshy components 
    # explicitly import dependencies, importation order is *NOT* important.
#   string import_script_path
#   for import_script_path in "${ZESHY_HOME}/src/zeshy"/*(^D); do
#       zimport "${import_script_path}"
#   done
#       [[ $(basename "${import_script_path}") =~\
#           "^(\..*|${ZESHY_MAIN_SCRIPT_BASENAME})$" ]] ||

# ....................{ PATHS                              }....................
# Absolute path to the current script.
#local zeshy_core_path=$(readlink --canonicalize-existing "${0}")

# Directory having the current script. This environment variable should have
# been permanently added to the current system on Zeshy installation. If it was
# not, however, ensure that it at least temporarily exists now.
#[[ -n "${ZESHY_HOME-}" ]] ||
#    export ZESHY_HOME=$(readlink --canonicalize-existing $(dirname "${zeshy_core_path}")"/../..")

    # Import all non-dotfiles in this directory with the "(^D)" modifier (i.e.,
    # all files and directories *NOT* prefixed by a "."). Since Zeshy scripts
    # explicitly import dependencies, order of import is mostly insignificant.

#   if is -z\
#       "${ZESHY_IMPORTED_PATH_TO_MTIME[(I)"${zeshy_script_path}"]}" or
#       "${ZESHY_IMPORTED_PATH_TO_MTIME["${zeshy_script_path}"]}" -ne\
#       "${zeshy_script_mtime}" si; then

# This glob expression matches the basename of all non-executable readable
# files residing under every path in the function path list, "${fpath}". Via
# Zsh mandate, every such file basename corresponds to the autoloadable
# function name defined in the file. Thus, matching these basenames also
# matches all autoloadable function names.
#
# * "-.x" ignores non-executable files. While not strictly necessary, forum
# posters suggest this beneficially permits you to ignore undesirable autoloads
# by chmodding away their executable bit.  * "-.r" ignores non-readable files.
# This is strictly necessary.  * ":t" extracts the "tail" (i.e., basename) of
# the current file. This is a history modifier extracting each file's filename
# sans absolute path.
# 
#for autoload_function_name in ${^fpath}/*(N-.r:t); do

#FUXME: I suppose I don't quite understand why we can't simply implement this as
#some variant of '"${@}" 1>/dev/null 2>&1'. Doesn't that work as is?
#run_quietly() { run "${(q)@}" 1>/dev/null 2>&1 }

#   is "${#command}" exceeds 0 si or die 'expected exactly one command'
#
#global_alias to='|'

    # Decompacted:
    # 
    # * "1", the passed name.
    # * "(P)", the variable the passed name refers to.
    # * "-", the value to expand this variable to if unset:
    #   in this case, simply the empty string.
    # * "-z", true only if this variable is the empty string and hence unset.
#    is -z "${(P)1-}" si

# ....................{ COMMANDS ~ return codes            }....................
# void try_as_superuser(string command)
#
# Run the passed command as the superuser and, if it fails with error,
# terminate the current execution environment with the same error.
#try_as_superuser() {
#    run_as_superuser "${@}" or die
#}

# int get_last_exit_status(void)
# 
# Return the return code returned by the previous command.
#alias get_last_exit_status='is_ok'

# bool is_ok(void)
#
# Return success if the previous command succeeded. Otherwise, return failure.
#is_ok() {
#    # Cache the prior command's return code, as our initial sanity check on
#    # arguments replaces this code with its own.
#    integer prior_command_exit_status=${?}
#    die_unless_no_args
#    return ${prior_command_exit_status}
#}

# bool is_error(void)
#
# Return success if the previous command failed. Otherwise, return failure.
#is_error() {
#    # Cache the prior command's return code, as our initial sanity check on
#    # arguments replaces this code with its own.
#    integer prior_command_exit_status=${?}
#    die_unless_no_args
#    is ${prior_command_exit_status} -ne ${ZESHY_EXIT_STATUS_SUCCESS} si
#}

# string canonicalize_path_nonfatal(string pathname)
#
# Get the canonicalized form of the passed absolute path. Unlike the
# canonicalize_path() function, this function does not raise an exception when
# the passed path does not exist; it simply canonicalizes as much of this path
# as exists.
#canonicalize_path_nonfatal() {
#    die_unless_one_arg 'expected exactly one pathname'
#    readlink --canonicalize-missing "${1}"
#}

#FUXME: This and try() now obsolete by TRAPZERR(). Excise everywhere.
# void try_run_quietly_as(string username, string command)
#
# Run the passed command as the passed user run_quietly and, if it fails with error,
# terminate the current execution environment with the same error.
#try_as() {
#    die_unless_at_least_two_args\
#        'expected exactly one username and one command'
#
#    # Locally set "${ZESHY_RUN_AS}". The run() function notes this variable as
#    # set and behaves accordingly...
#    string ZESHY_RUN_AS="${1}"; shift
#
#    # Call try() with all remaining arguments: the command to be run.
#    try "${(q)@}"
#}

# void try(string command)
#
# Run the passed command and, if it fails with error, terminate the current
# execution environment with the same error.
#try() {
#    run "${(q)@}" or die "\"${@}\" returned error code ${?}"
#}

# void try_run_quietly(string command)
#
# Run the passed command run_quietly and, if it fails with error, terminate the
# current execution environment with the same error.
#try_run_quietly() {
#    run_quietly try "${@}" or die "\"${@}\" returned error code ${?}"
#}

# void try_run_quietly_as(string username, string command)
#
# Run the passed command as the passed user run_quietly and, if it fails with error,
# terminate the current execution environment with the same error.
#try_run_quietly_as() {
#    run_quietly try_as "${@}" or die "\"${@}\" returned error code ${?}"
#}

# bool or(...)
#
# Return true if at least one of the passed command's returned successfully.
#global_alias or='||'

# bool and(...)
#
# Return true if both of the passed command's returned successfully.
#global_alias and='&&'

# bool not(...)
#
# Negate the passed command's return code.
#alias not='!'

#FUXME: This function appears to be functionally obsolete now. If so, kill and
#rename which_command() to this.
# Aliases.
#alias which_binary="which_command"
#alias which_binary_nonfatal="which_command"

# string which_command(string command)
#
# Print the absolute path to the passed command: e.g.,
#
#     >>> which_command zsh /bin/zsh
#
# If the passed command is a string, all but the first whitespace-delimited word
# of the string is ignored: e.g.,
#
#     >>> which_command "zsh -x -o shwordsplit scr" /bin/zsh
#
# If the passed command is not found, if multiple binaries are passed, or if no
# command is passed, prints an error and dies.
#which_command() {
#Call the whence() built-in outside of "local" so as to retain the return
    # code. (ZSH == FAIL on that one.) 
#    string command_path; command_path="$(which_command "${@}")"
#    die_unless_ok "\"${1}\" not found"
#    print "${command_path}"
#}
#
# Identical to the which_command() function except that, if the passed command
# does not exist, returns nothing rather than dies.

#FUXME: No longer meaningful under TRAPZERR(); excise.
# void die_unless_ok(string error_message)
#
# Die with the passed error message unless the previous command succeeded.
#die_unless_ok() {
#    # Cache the prior command's return code, as our initial sanity check on
#    # arguments replaces this code with its own.
#    integer prior_command_exit_status=${?}
#    die_unless_one_arg 'expected exactly one error message'
#    is ${prior_command_exit_status} -eq ${ZESHY_EXIT_STATUS_SUCCESS} si or die "${1}"
#}

# void say_import(string script_name)
#
# Echo a message informing the user that the passed script name is being
# imported. This function should be called prior to actually importing that
# script if feasible.
#say_import() {
#    die_unless_one_arg 'expected exactly one script name'
#
#    say "loading \"${1}\"..."
#}

    # If the caller has supplied no explicit "${ZESHY_SCRIPT_NAME}", supply a
    # default.  Failing to do this encourages the say() function to use the
    # name of this function as its script name, producing unaesthetic results.
#   "${ZESHY_SCRIPT_NAME:=zeshy}"

        # Print the passed error message followed by a complete backtrace.
#   cry "${@}"
#   curse_call_stack
 #
    # Shells differentiate
    # fatal from non-fatal errors by setting the high bit (i.e., 2^7 = 128).
    # According to "zshbuiltins", this forces Zsh to continue handling the
    # signal as if untrapped and hence returning the same exit status. Having no
    # arcanely carnal knowledge of the Linux signal implementation, it's unclear
    # why setting the high bit 

    #FUXME: Old.
    # If the passed path is a directory, only import filename
    # "${ZESHY_MAIN_SCRIPT_BASENAME}" in this directory.
#   is -d "${zeshy_script_path}" si and
#       zeshy_script_path="${zeshy_script_path}/${ZESHY_MAIN_SCRIPT_BASENAME}"
    
    # If this path does not exist, die.
#   is -f "${zeshy_script_path}" si or die "\"${zeshy_script_path}\" not found"
 #
#FUXME: Impossible to remember, I'm afraid. Perhaps "fail_if_error", instead?
# int fail_if_previous_command_failed(void)
# 
# Return from the current function with failure if the previous command or
# function also returned with failure.
#alias fail_if_previous_command_failed="is_ok || return ${ZESHY_EXIT_STATUS_FAILURE}"

#; ZESHY_IMPORTED_PATH_TO_MTIME=( )
#   typeset -Ax ZESHY_IMPORTED_PATH_TO_MTIME; ZESHY_IMPORTED_PATH_TO_MTIME=( )
 # The "-Ax" option to the "typeset" commands defines each such variable as an
# [A]ssociative array (i.e., a dictionary) and e[x]ported to the global
# environment for later access.

# Ascertain whether we are running as a cronjob and, if so, alter output
# appropriately. In particular, print the current date as a timestamp prior to
# printing all other output.

#   die_unless_at_least_one_arg 'expected at least one string'

#   # If no string was passed, attempt to read "stdin" for piped input.
#   if is_one_arg; then
#       set -- "${1}" "$(< /dev/stdin)"
#   fi

#   pcre_compile "${1}" || die "\"${1}\" not a valid regular expression"
#   pcre_match "${2}" || return ${?}
#   return ${ZESHY_EXIT_STATUS_SUCCESS}

# This function returns success 
# If this regular expression matched at least one group, this function returns
# this group as a string for caller convenience... Else, this function returns
# nothing. In the former case, callers may retrieve the set of all groups via
# the global "${match}" array. (See above.)

    # When the whence() built-in fails, it prints the name of the passed command
    # followed by "not found". Thus, if it prints such a message, the passed
    # command does not exist. Note that testing the return code is problematic
    # here, since setting a local variable always forces the return code to 0
    # (i.e., success). 
#   if [[ "${command_path}" == *" not found" ]]; then
#       return ${ZESHY_EXIT_STATUS_FAILURE}
#   else
#       echo "${command_path}"
#       return ${ZESHY_EXIT_STATUS_SUCCESS}
#   fi

    # O.K., this is tricksy: if the eventual caller explicitly quote-protected
    # the passed command name, there exists another "layer" of quote-protection
    # to unravel. Do so, alas.
#   if ! is_installed "${command_name}" && is_installed "${(Q)command[1]}"; then
#       command_name="${(Q)command[1]}"
#   fi

    #echo "PID: $$"
    #echo "current_process_basename:"
    #get_current_process_basename
    #echo "current_process_command_line:"
    #get_current_process_command_line

# ....................{ GLOB EXPRESSIONS                   }....................
# string *glob_non_dotfiles_in(string dirname)
#
# Glob all non-dotfiles (i.e., all files and directories whose first character
# is not a '.' dot) in the passed directory.
#glob_non_dotfiles_in() {
#    [[ ${#} -eq 1 ]] || die "expected exactly one directory name"
#    local dirname="${1}"
#    [[ -d "${dirname}" ]] || "\"${dirname}\" not a directory"
#
#    # Glob all non-dotfiles via the "(^D)" modifier.
#    echo "${dirname}"/*(^D)
#}

 # Enable variable substitution in prompt expansions in a "synchronous" fashion.
# Enabling this re-evaluates each prompt expansion after perform each
# interactive command with the current values of those variables without
# having to manually recreate the prompt each time.
#setopt promptsubst

#The existence of this variable also
# serves to inform callers as to whether or not this script has been imported
# yet and, when it has, to avoid reimporting it.

# Directory above the directory having the current script. This environment
# variable should have been permanently added to the current system as well.
#[[ -n "${ZESHY_ROOT}" ]] ||  
#    export ZESHY_ROOT=$(readlink --canonicalize-existing "${ZESHY_HOME}/..")

#FUXME: Harvest comments from the now-dead portion of zimport_file().
#
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#O.K.; the game plan:
#* Separate each function into a separate file. No symlinks. I know; I know.
#  This is awful. But Zsh is as it is on this score. There's no fixing that.
#* Initialization needs to be centralized into a set of core files. Here's
#  what I'm thinking, now: cleave the "src/" directory into:
#  * "src/root", containing "zprofile", "zlogin", and "zshrc".
#  * "src/main", containing this file, "core", and all other initialization as
#    perhaps another file or two ("globals"? bah!). All global variable
#    declarations need to be shifted here.
#  * "src/auto/generic", containing the bulk of Zeshy as such autoloadable function
#    files. All such functions are safely applicable to all systems.
#  * "src/auto/command", allowing for conditionally autoloaded command-specific
#    function directories (e.g., "src/auto/command/ssh").
# * We need one digest for all of "generic" and one digest for each immediate
#   subdirectory of "src/auto/command", the latter conditionally autoloaded if
#   such command exists.
# * This scheme clearly allows for things like "src/auto/os", should we require
#   it. I'm currently considering trashing that... just assume GNU/Linux, for
#   the moment. (Time!)
# * Hmm; perhaps?:
#   "src/catabolize/".
#   "src/initialize/".
#   "src/bootstrap/".
#   "src/framework/".
#   "src/profile/".
#   "src/context/".
# * Ah; O.K.; how about just:
#   "src/construct/".
#   "src/bootstrap/".
#   "src/autoload/always".
#   "src/autoload/if_installed".
# * Or mayhap:
#   "src/boot/".
#   "src/init/".
#   "src/auto/always".
#   "src/auto/if_installed".
#
#Yes, it's lame. But our hands are really constrained, here.
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!
