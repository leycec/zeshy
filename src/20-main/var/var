#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle core variable functionality.
/---

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void :die_unless_var(
    string variable_name,
    string error_message = "Variable \$\{${variable_name}\} undefined.")

Throw an exception with the passed message unless the passed variable exists.
See :is_var() for further details.
/---
function :die_unless_var() {
    die_unless_args_1_to_2\
        'Expected one variable name and optional error message.'
    :string variable_name__duv="${1}"
    :is_var "${variable_name__duv}" or
        die "${2-Variable \$\{${variable_name__duv}\} undefined.}"
}

declare_function_with_stdin <<'/---'
void :die_unless_vars(string variable_name1, ...)

Throw an exception with a stock message unless all passed variables exist. See
:is_var() for further details.
/---
function :die_unless_vars() {
    # Validate sanity.
    die_unless_args 'Expected one or more variable names.'

    #FIXME: The following hackery should yield a significantly more efficient
    #implementation. Nice! Actually, it's nearly bloody brilliant:
    #
    #   eval "(( ${@//(#m)*/\${+${MATCH}\} +} 0 == ${#} ))"
    #
    #Such optimization is reasonably helpful, as this function is called
    #frequently in core functionality (e.g., is_exception()). Test us up,
    #naturally. (Looks good from the command line, though.)
    #FIXME: Right. We've implemented a working variant on the above idea for the
    #is_pathable() function, so see such function first.

    # Test such variables.
    :string variable_name__duvs
    for     variable_name__duvs ("${@}") {
        :is_var "${variable_name__duvs}" or
            die "Variable \$\{${variable_name__duvs}\} undefined."
    }
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_var(string variable_name)

Report success if the passed variable exists.
/---
function :is_var() {
    # Interestingly, such test is also efficiently implementable as follows:
    #
    #    is -n "${(P)1+x}" si
    #
    # Dismantled, this is:
    #
    # * "(P)1", referencing the variable with passed name.
    # * "+x", expanding to "x" if such variable is set or to the empty string
    #   otherwise. Since any arbitrary non-empty value will do, use "x". (zsh
    #   precedent, and all.)
    #
    # While it would be preferable to use parameter expansion flag "+", such
    # flag unfortunately fails to respect parameter expansion flag "P": e.g.,
    #
    #    # Fails with error "zsh: error in flags".
    #    (( ${(+P)1} ))
    #
    #    # Fails with error "zsh: bad substitution".
    #    (( ${+(P)1} ))
    #
    # While this could be corrected by embedding such test in an "eval"
    # statement, the above remains more efficient.
    #
    # All that said, map lookup is likely to prove slightly more efficient than
    # parameter expansion (especially for variables expanding to long strings.
    # Hence, we retain the current implementation.
    die_unless_arg 'Expected one variable name.'
    (( ${+parameters[${1}]} ))
}

# ....................{ TESTERS ~ empty                    }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_var_empty(string variable_name)

Report success if the passed variable is *empty* (i.e., set to the value
specific to such variable's type signifying emptiness). Specifically, report
success if such variable is of type:

* Float and set to *real zero* (i.e., `0.0`).
* Integer and set to *integer zero* (i.e., `0`).
* List and set to the *empty list* (i.e., `()`).
* Map and set to the *empty map* (i.e., `()`).
* String and set to the *empty string* (i.e., `""`).
/---
function :is_var_empty() {
    not  :is_var_nonempty "${@}"
}

declare_function_with_stdin <<'/---'
[status: bool] :is_var_nonempty(string variable_name)

Report success if the passed variable is set to a nonempty value. See
:is_var_empty() for further details.
/---
function :is_var_nonempty() {
    # Validate sanity.
    die_unless_arg 'Expected one variable name.'
    :string variable_name__ivn="${1}"

    # Test such variable. Since :is_var_number() calls
    # :die_unless_var(), avoid doing so above.
    if { :is_var_numeric "${variable_name__ivn}" } {
            (( ${(P)variable_name__ivn} ))  and report_status
    } else {
        is -n "${(P)variable_name__ivn}" si and report_status
    }
}

# ....................{ GETTERS                            }....................
#FIXME: Convert to setters, naturally renaming "_variable" to "_var" everywhere.

declare_function_with_stdin <<'/---'
string get_variable_first(
    string variable_name1, variable_name2, ...)

Get the name of the first passed defined variable expanding to a nonempty string
or throw an exception if all such variables are either undefined or expand to the
empty string: e.g.,

.get_variable_first()
==========================================
[source]
------------------------------------------
>>> string on_growth=\
...    "Unfortunately, once an economy is geared to expansion, the means rapidly
...     turn into an end and \"the going becomes the goal.\" Even more
...     unfortunately, the industries that are favored by such expansion must,
...     to maintain their output, be devoted to goods that are readily
...     consumable either by their nature, or because they are so shoddily
...     fabricated that they must soon be replaced. By fashion and built-in
...     obsolescence the economies of machine production, instead of producing
...     leisure and durable wealth, are duly cancelled out by the mandatory
...     consumption on an even larger scale."
>>> get_variable_first on_sustenance on_decline on_growth
on_growth
------------------------------------------
==========================================
/---
function get_variable_first() {
    get_variable_first_if_found "${@}" or
        die "Variables $(join_strings_readable: "${@}") undefined."
}

declare_function_with_stdin <<'/---'
[stdout: string, status: bool] get_variable_first_if_found(
    string variable_name1, variable_name2, ...)

Get the name of the first passed variable with non-empty value or return failure
if no such variable has a non-empty value: e.g.,

.get_variable_first_if_found()
==========================================
[source]
------------------------------------------
>>> string on_modernity=\
...    "[The processes of the paleotechnic period are] doubly ruinous: they
...     impoverish the earth by hastily removing, for the benefit of a few
...     generations, the common resources which, once expended and dissipated,
...     can never be restored; and second, in its technique, its habits, its
...     processes, the paleotechnic period is equally inimical to the earth
...     considered as a human habitat, by its destruction of the beauty of the
...     landscape, its ruining of streams, its pollution of drinking water, its
...     filling the air with a finely divided carboniferous deposit, which
...     chokes both life and vegetation."
>>> get_variable_first_if_found on_ruination on_rusticity on_modernity
on_modernity
------------------------------------------
==========================================
/---
function get_variable_first_if_found() {
    # Validate sanity.
    die_unless_args 'Expected one or more variable names.'

    # Get such variable. For efficiency, inline such implementation. See
    # :is_var() for further details.
    string variable_name__gvnfif
    for    variable_name__gvnfif ("${@}") {
        if { is -n     "${(P)variable_name__gvnfif+x}" si } {
            return_string "${variable_name__gvnfif}"
        }
    }
    report_failure
}

# ....................{ GETTERS ~ value                    }....................
declare_function_with_stdin <<'/---'
string get_variable_value_first(
    string variable_name1, variable_name2, ...)

Get the value of the first passed variable with non-empty value or throw an
exception if no such variables have a non-empty value: e.g.,

.get_variable_value_first()
==========================================
[source]
------------------------------------------
>>> string on_obsolescence=\
...    "But what would become of mass production and its system of financial
...     expansion if technical perfection, durability, social efficiency, and
...     human satisfaction were the guiding aims? The very conditions for
...     current financial success — constantly expanding production and
...     replacement — works against these ends. To ensure the rapid absorption
...     of its immense productivity, megatechnics resort to a score of different
...     devices: consumer credit, installment buying, multiple packaging, non-
...     functional designs, meretricious novelties, shoddy materials, defective
...     workmanship, built-in fragility, or forced obsolescence through frequent
...     arbitrary changes of fashion. Without constant enticement and
...     inveiglement by advertising, production would slow down and level off to
...     normal replacement demand. Otherwise many products could reach a plateau
...     of efficient design which would call for only minimal changes from year
...     to year."
>>> get_string_line "$(get_variable_value_first\
...     on_durability on_efficiency on_obsolescence)" 1
But what would become of mass production and its system of financial
------------------------------------------
==========================================
/---
function get_variable_value_first() {
    get_variable_value_first_if_found "${@}" or
        die "Variables $(join_strings_readable: "${@}") undefined."
}

declare_function_with_stdin <<'/---'
[stdout: string, status: bool] get_variable_value_first_if_found(
    string variable_name1, variable_name2, ...)

Get the value of the first passed variable with non-empty value or return
failure if no such variables has a non-empty value: e.g.,

.get_variable_value_first_if_found()
==========================================
[source]
------------------------------------------
>>> string on_suburbia=\
...    "In the mass movement into the suburban areas a new kind of community was
...     produced, which caricatured both the historic city and the archetypal
...     suburban refuge: a multitude of uniform, unidentifiable houses, lined up
...     inflexibly, at uniform distances, on uniform roads, in a treeless
...     communal waste, inhabited by people of the same class, the same income,
...     the same age group, witnessing the same television performances, eating
...     the same tasteless prefabricated foods, from the same freezers,
...     conforming in every outward and inward respect to a common mold,
...     manufactured in the central metropolis. Thus the ultimate effect of the
...     suburban escape in our time is, ironically, a low-grade uniform
...     environment from which escape is impossible."
>>> get_string_line "$(get_variable_value_first_if_found\
...     on_usurpation on_conurbations on_suburbia)" -1
environment from which escape is impossible.
------------------------------------------
==========================================
/---
function get_variable_value_first_if_found() {
    # Validate sanity.
    die_unless_args 'Expected one or more variable names.'

    # Get such variable's value. For efficiency, inline such implementation. See
    # :is_var() for further details.
    string variable_name__gvnvfif
    for    variable_name__gvnvfif ("${@}") {
        if { is -n        "${(P)variable_name__gvnvfif+x}" si } {
            return_string "${(P)variable_name__gvnvfif}"
        }
    }
    report_failure
}

# ....................{ GETTERS ~ binding                  }....................
#FIXME: Rename to :get_var_binding().
declare_function_with_stdin <<'/---'
string get_variable_binding(string var_name1, ...)

Get *variable bindings* for all passed variables in the passed order.
See :set_string_to_var_binding() for further details.
------------------------------------------
==========================================
/---
function get_variable_binding() {
    # Validate sanity.
    die_unless_args 'Expected one or more variable names.'

    # For each such variable, both declare and define such variable.
    # Ideally, the following command would suffice to do so:
    #
    # >>> typeset -p -- "${@}"
    #
    # Unfortunately, such command suffers numerous deficiencies (arguably,
    # reportable zsh bugs):
    #
    # * It fails to annotate global variables with option "-g", thus localizing
    #   variable declarations to the current context.
    # * It fails to quote nonscalar variable elements when such elements are
    #   single shell words: e.g.,
    #
    # >>> list l; l=( and or is )
    # zsh: parse error near `&&'
    #
    # Typically, quoting single shell words is safe. As the prior example
    # demonstrates, however, if such words are equal to global alias names,
    # then the result is typically a fatal parse error.
    #
    # Only manually iterating such variables suffices to amend such issues.

    # Type string for the current variable (e.g., "string-local").
    :string var_type__sstvb

    # Options to be passed to "typeset" for the current variable.
    :string typeset_options__sstvb

    # Append all such variable bindings to such strings.
    :string var_name__sstvb
    for     var_name__sstvb ("${@}") {
        # Type string for such variable.
        :set_string_to_var_type var_type__sstvb "${var_name__sstvb}"
        # output_string "binding: ${var_name__sstvb} (${var_type__sstvb})"
        # Reset "typeset" options for such variable.
        typeset_options__sstvb=''

        # If such variable is *NOT* local and hence is global, pass appropriate
        # options. (If such variable is local, no "typeset" options need be
        # passed, as "typeset" defaults to local scope.)
        if is "${var_type__sstvb}" != ${~ZESHY_VARIABLE_TYPE_GLOB_LOCAL} si {
            # Globalize such variable.
            typeset_options__sstvb+='-g '

            # If such variable is exported, also pass such option.
            if is "${var_type__sstvb}" ==\
                ${~ZESHY_VARIABLE_TYPE_GLOB_EXPORTED} si {
                typeset_options__sstvb+='-x '
            }
        }

        #FIXME: While the scalar logic suffices (due to deferring to "typeset -p"),
        #the nonscalar logic is necessarily implemented manually and hence
        #insufficient. In particular, such logic fails to currently detect and
        #set "typeset" options "-U" and possibly others.

        # If such variable is a list, escape all reserved characters in list
        # elements. While parameter expansion flag "q" also suffices for such
        # purposes, such flag needlessly increases the length of such string and
        # hence serialization and deserialization time -- especially on large
        # lists and maps, the principle use case for serializing variables: e.g.,
        #
        # >>> output_string "${(q):-Laissez-faire was planned; planning was not.}"
        # Laissez-faire\ was\ planned\;\ planning\ was\ not.
        # >>> output_string "${(qq):-Laissez-faire was planned; planning was not.}"
        # 'Laissez-faire was planned; planning was not.'
        #
        # See :is_var_list() for further details.
        if is "${var_type__sstvb}" == ${~ZESHY_VARIABLE_TYPE_GLOB_LIST} si {
            output_string\
                "typeset ${typeset_options__sstvb}-a ${var_name__sstvb}
${var_name__sstvb}=( ${(qq@P)var_name__sstvb} )"
        # Else if such variable is a map, escape all reserved characters in map
        # keys and values.  See :is_var_map() for further details.
        } elif is "${var_type__sstvb}" ==\
            ${~ZESHY_VARIABLE_TYPE_GLOB_MAP} si {
            output_string\
                "typeset ${typeset_options__sstvb}-A ${var_name__sstvb}
${var_name__sstvb}=( ${(qqkv@P)var_name__sstvb} )"
        # Else, such variable is scalar. If passing at least one "typeset"
        # option (e.g., if such variable is global), "typeset -p" output must
        # be modified to do so. Dismantled, this is:
        #
        # * "/", performing such replacement at most once.
        # * "(#s)", anchoring such match to the start of such output.
        } elif { is_string_nonempty "${typeset_options__sstvb}" } {
            output_string\
                "${$(typeset -p -- "${var_name__sstvb}")/(#s)typeset /typeset ${typeset_options__sstvb}}"
        # Else, such variable is scalar and "typeset" output suffices.
        } else {
            typeset -p -- "${var_name__sstvb}"
        }
    }
}

# ....................{ SETTERS                            }....................
#FIXME: Intense example. Fantastic, of course, but excessive; split at least
#half elsewhere.

declare_function_with_stdin <<'/---'
void :set_string_to_var_binding(
    string string_name,
    string var_name1, ...)

Set the passed string to the set of all *variable bindings* for the passed
variables in the passed order. For each such variable, the corresponding
binding is exactly one or two evaluable commands declaring _and_ defining such
variable: e.g.,

.:set_string_to_var_binding()
==========================================
[source]
------------------------------------------
>>> :string_constant_global on_world3=\
...    "Our world model was built specifically to investigate five major trends
...     of global concern -- accelerating industrialization, rapid population
...     growth, widespread malnutrition, depletion of nonrenewable resources,
...     and a deteriorating environment. These trends are all interconnected in
...     many ways, and their development is measured in decades or centuries,
...     rather than in months or years. With the model we are seeking to
...     understand the causes of these trends, their interrelationships, and
...     their implications as much as one hundred years in the future."
>>> :map_global on_conclusions; on_conclusions=(
...     "Our" "conclusions are:" )
>>> :list on_conclusion_1; on_conclusion_1=(
...     "1. If the present growth trends in world population,"
...     "industrialization, pollution, food production, and resource depletion"
...     "continue unchanged, the limits to growth on this planet will be"
...     "reached sometime within the next one hundred years. The most probable"
...     "result will be a rather sudden and uncontrollable decline in both"
...     "population and industrial capacity." )
>>> :string var_bindings
>>> :set_string_to_var_binding var_bindings\
...     on_world3 on_conclusions on_conclusion_1
>>> output_string "${var_bindings}"
typeset -g -r on_world3='Our world model was built specifically to investigate five major trends
of global concern -- accelerating industrialization, rapid population
growth, widespread malnutrition, depletion of nonrenewable resources,
and a deteriorating environment. These trends are all interconnected in
many ways, and their development is measured in decades or centuries,
rather than in months or years. With the model we are seeking to
understand the causes of these trends, their interrelationships, and
their implications as much as one hundred years in the future.'
typeset -g -A on_conclusions
on_conclusions=( Our conclusions\ are: )
typeset -a on_conclusion_1
on_conclusion_1=( 1.\ If\ the\ present\ growth\ trends\ in\ world\ population, industrialization,\ pollution,\ food\ production,\ and\ resource\ depletion continue\ unchanged,\ the\ limits\ to\ growth\ on\ this\ planet\ will\ be reached\ sometime\ within\ the\ next\ one\ hundred\ years.\ The\ most\ probable result\ will\ be\ a\ rather\ sudden\ and\ uncontrollable\ decline\ in\ both population\ and\ industrial\ capacity. )
------------------------------------------
==========================================
/---
function :set_string_to_var_binding() {
    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected one string name and one or more variable names.'
    :string string_name__sstvb="${1}"
    shift_arg

    # Set such string to all such bindings, captured from the output of the
    # following subshell. In this obscure case, capturing subshell output
    # performs both more reliably *AND* efficiently (contrary to customary zeshy
    # doctrine). Why? As:
    #
    # * Each such binding is produced as either a string literal *OR* the
    #   output of running "typeset -p". While the former is efficiently
    #   appendable to the passed string, attempting to append the latter to
    #   such string would require forking one subshell for each passed variable
    #   satisfying the corresponding conditions (i.e., local scalars).
    #   Since at least one subshell is required in either case, forking only
    #   one exterior subshell is dramatically (!!!!) more preferable to forking
    #   one interior subshell each iteration.
    # * Perhaps more importantly, list and map items are *NOT* quote-escapable
    #   in scalar assignments (e.g., when appending to the passed string).
    #   Curiously, list and map items are quote-escapable in both list
    #   assignments and output commands. While this arguably constitutes a zsh
    #   bug, the only alternative is to output rather than append such items:
    #   e.g.,
    #
    #    # Test list.
    #    :list de_te_spellemenn=( "Trollskau, skrømt" "og kølabrenning" )
    #    :string quoted_list
    #
    #    # This is terrible. zsh concatenates such list items!
    #    >>> quoted_list="${(qq@)de_te_spellemenn}"
    #    >>> output_string "${quoted_list}"
    #    'Trollskau, skrømt og kølabrenning'
    #
    #    # This isn't. zsh actually separates such list items.
    #    >>> output_string "${(qq@)de_te_spellemenn}"
    #    'Trollskau, skrømt' 'og kølabrenning'
    #
    # Given the requirement for such subshell, we implement the core logic to
    # be performed by such subshell as a distinct getter function. This has the
    # demonstrable benefit of expanding all aliases in such function at
    # function definition time rather than at function call time, as would
    # otherwise be the case if such function were inlined in such subshell here.
    :set_string_to_string\
        "${string_name__sstvb}" "$(get_variable_binding "${@}")"
}

#FIXME: In lieu of unit tests...
function varo() {
    string_global YIL
    :string yil binding
    :set_string_to_var_binding binding yil YIL
    output_string "bindings: ${binding}"
}

# ....................{ PRINTERS                           }....................
declare_function_with_stdin <<'/---'
string print_variable(string variable_name1, ...)

Print a human-readable synopsis of the passed variables. Such synopsis describes
both the type and value of such variables.
/---
function print_variable() {
    # Validate sanity.
    die_unless_args 'Expected one or more variable names.'

    #FIXME: While fine, such output is rather bland and difficult to read. For
    #readability, lightly parse and colorify such output. See
    #print_aliases_cli() for similar code.

    # Print such variables.
    {
        print_message_heading 'Variable Definitions'
        typeset -p -- "${@}"
    } | page_stdin
}

# --------------------( WASTELANDS                         )--------------------
# function get_variable_binding() {
#     # Validate sanity.
#     die_unless_args 'Expected one or more variable names.'
# 
#     # For each such variable, both declare and define such variable.
#     # Ideally, the following command would suffice to do so:
#     #
#     # >>> typeset -p -- "${@}"
#     #
#     # Unfortunately, such command suffers numerous deficiencies (arguably,
#     # reportable zsh bugs):
#     #
#     # * It fails to annotate global variables with option "-g", thus localizing
#     #   variable declarations to the current context.
#     # * It fails to quote nonscalar variable elements when such elements are
#     #   single shell words: e.g.,
#     #
#     # >>> list l; l=( and or is )
#     # zsh: parse error near `&&'
#     #
#     # Typically, quoting single shell words is safe. As the prior example
#     # demonstrates, however, if such words are equal to global alias names,
#     # then the result is typically a fatal parse error.
#     #
#     # Only manually iterating such variables suffices to amend such issues.
# 
#     # Type string of the current variable (e.g., "string-local").
#     :string variable_type__gvb
# 
#     # Options to be passed to "typeset" for the current variable.
#     :string typeset_options__gvb
# 
#     #FIXME: The implementation is *HORRIBLE*. No, really. It works, yes.
#     #Unfortunately, we inlined in the implementations of a variety of functions
#     #that we needn't have (presumably prior to realizing that the efficiency
#     #bottleneck was entirely in command substitutions rather than all function
#     #calls). Undo such nonsense *IMMEDIATELY*. (Ugh.)
# 
#     # Print each such variable's binding. For efficiency, inline all zeshy
#     # functions referenced below into such implementation.
#     :string variable_name__gvb
#     for     variable_name__gvb ("${@}") {
#         # If such variable does *NOT* exist, throw an exception. See
#         # :is_var() for further details.
#         is -n "${(P)variable_name__gvb+x}" si or die\
#             "variable \"${variable_name__gvb}\" not found"
# 
#         # Get such variable's type string. See get_variable_type() for further
#         # details.
#         variable_type__gvb="${(tP)variable_name__gvb}"
# 
#         # If such variable is local, pass no further options to "typeset". See
#         # :is_var_local() for further details.
#         if is "${variable_type__gvb}" == ${~ZESHY_VARIABLE_TYPE_GLOB_LOCAL} si {
#             typeset_options__gvb=''
#         # Else, such variable is global. Pass option "-g" to "typeset".
#         } else {
#             typeset_options__gvb='-g '
#         }
# 
#         # If such variable is a list, escape all reserved characters in list
#         # elements. While parameter expansion flag "q" also suffices for such
#         # purposes, such flag needlessly increases the length of such string and
#         # hence serialization and deserialization time -- especially on large
#         # lists and maps, the principle use case for serializing variables: e.g.,
#         #
#         # >>> output_string "${(q):-Laissez-faire was planned; planning was not.}"
#         # Laissez-faire\ was\ planned\;\ planning\ was\ not.
#         # >>> output_string "${(qq):-Laissez-faire was planned; planning was not.}"
#         # 'Laissez-faire was planned; planning was not.'
#         #
#         # See :is_var_list() for further details.
#         if is "${variable_type__gvb}" == ${~ZESHY_VARIABLE_TYPE_GLOB_LIST} si {
#             # Sadly, a more readable implementation expanding output_stdin()
#             # rather than output_string() fails to properly quote list elements.
#             # Yes, the space preceding the "\" is necessary.
#             output_string\
#                 "typeset ${typeset_options__gvb}-a ${variable_name__gvb}
# ${variable_name__gvb}=( ${(qq@P)variable_name__gvb} )"
#         # Else if such variable is a map, escape all reserved characters in map
#         # keys and values.  See :is_var_map() for further details.
#         } elif is "${variable_type__gvb}" ==\
#             ${~ZESHY_VARIABLE_TYPE_GLOB_MAP} si {
#             output_string\
#                 "typeset ${typeset_options__gvb}-A ${variable_name__gvb}
# ${variable_name__gvb}=( ${(qqkv@P)variable_name__gvb} )"
#         # Else, such variable is scalar. If passing at least one option to
#         # "typeset", "typeset -p" output must be modified to do so.
#         # Dismantled, this is:
#         #
#         # * "/", performing such replacement at most once.
#         # * "(#s)", matching only at the start of such output.
#         } elif is -n "${typeset_options__gvb}" si {
#             output_string "${"$(typeset -p -- "${variable_name__gvb}"\
#                 )"/(#s)typeset /typeset ${typeset_options__gvb}}"
#         # Else, such variable is scalar and "typeset" output suffices.
#         } else {
#             typeset -p -- "${variable_name__gvb}"
#         }
#     }
# }

        # If such variable is local, pass no further options to "typeset". See
        # :is_var_local() for further details.
        # if is "${var_type__sstvb}" == ${~ZESHY_VARIABLE_TYPE_GLOB_LOCAL} si {
        #     typeset_options__sstvb=''

    # output_string "bindings: ${var_bindings__sstvb}"
        # Delimit such binding by a newline.
        # var_bindings__sstvb+=$'\n'
    # Set such string to such variable bindings.
    # :set_string_to_string "${string_name__sstvb}" "${var_bindings__sstvb}"

    # Temporary string of all variable bindings. While the iteration below
    # could instead append such bindings directly to the passed string
    # variable, directly appending to this string local is more efficient.
    # :string var_bindings__sstvb

    # Set such string to all such variable bindings, captured from the output of
    # the following subshell. Since such subshell prints both raw strings *AND*
    # the output of running "typeset -p", 
    #
    # The natural question arises: why not
    # :set_string_to_string string_name__sstvb "$(

    #FUXME: The implementation is *HORRIBLE*. No, really. It works, yes.
    #Unfortunately, we inlined in the implementations of a variety of functions
    #that we needn't have (presumably prior to realizing that the efficiency
    #bottleneck was entirely in command substitutions rather than all function
    #calls). Undo such nonsense *IMMEDIATELY*. (Ugh.)

            # Sadly, a more readable implementation expanding output_stdin()
            # rather than output_string() fails to properly quote list elements.
            # Yes, the space preceding the "\" is necessary.
    # Set such string to such variable bindings.
    # :set_string_to_string string_name__sstvb "${var_bindings__sstvb}"

#         # If such variable does *NOT* exist, throw an exception. See
#         # :is_var() for further details.
#         is -n "${(P)var_name__sstvb+x}" si or die\
#             "variable \"${var_name__sstvb}\" not found"
# 
#         # Get such variable's type string. See get_var_type() for further
#         # details.
#         var_type__sstvb="${(tP)var_name__sstvb}"
# 
#         # If such variable is local, pass no further options to "typeset". See
#         # :is_var_local() for further details.
#         if is "${var_type__sstvb}" == ${~ZESHY_VARIABLE_TYPE_GLOB_LOCAL} si {
#             typeset_options__sstvb=''
#         # Else, such variable is global. Pass option "-g" to "typeset".
#         } else {
#             typeset_options__sstvb='-g '
#         }
# 
#         # If such variable is a list, escape all reserved characters in list
#         # elements. While parameter expansion flag "q" also suffices for such
#         # purposes, such flag needlessly increases the length of such string and
#         # hence serialization and deserialization time -- especially on large
#         # lists and maps, the principle use case for serializing variables: e.g.,
#         #
#         # >>> output_string "${(q):-Laissez-faire was planned; planning was not.}"
#         # Laissez-faire\ was\ planned\;\ planning\ was\ not.
#         # >>> output_string "${(qq):-Laissez-faire was planned; planning was not.}"
#         # 'Laissez-faire was planned; planning was not.'
#         #
#         # See :is_var_list() for further details.
#         if is "${var_type__sstvb}" == ${~ZESHY_VARIABLE_TYPE_GLOB_LIST} si {
#             # Sadly, a more readable implementation expanding output_stdin()
#             # rather than output_string() fails to properly quote list elements.
#             # Yes, the space preceding the "\" is necessary.
#             output_string\
#                 "typeset ${typeset_options__sstvb}-a ${var_name__sstvb}
# ${var_name__sstvb}=( ${(qq@P)var_name__sstvb} )"
#         # Else if such variable is a map, escape all reserved characters in map
#         # keys and values.  See :is_var_map() for further details.
#         } elif is "${var_type__sstvb}" ==\
#             ${~ZESHY_VARIABLE_TYPE_GLOB_MAP} si {
#             output_string\
#                 "typeset ${typeset_options__sstvb}-A ${var_name__sstvb}
# ${var_name__sstvb}=( ${(qqkv@P)var_name__sstvb} )"
#         # Else, such variable is scalar. If passing at least one option to
#         # "typeset", "typeset -p" output must be modified to do so.
#         # Dismantled, this is:
#         #
#         # * "/", performing such replacement at most once.
#         # * "(#s)", matching only at the start of such output.
#         } elif is -n "${typeset_options__sstvb}" si {
#             output_string "${"$(typeset -p -- "${var_name__sstvb}"\
#                 )"/(#s)typeset /typeset ${typeset_options__sstvb}}"
#         # Else, such variable is scalar and "typeset" output suffices.
#         } else {
#             typeset -p -- "${var_name__sstvb}"
#         }

 # For efficiency, inline all zeshy
    # functions referenced below into such implementation.
# depends on variable type in the typical way. 

# ....................{ PRINTERS                           }....................
#declare_function_with_stdin <<'/---'
#string print_variables(string variable_name1, string variable_name2, ...)
#
#Print a human-readable synopsis of the passed variables (e.g., printing the
#current type and value of such variables).
#/---
#function print_variables() {
#    #FUXME: While fine, this output is rather bland and difficult to read. For
#    #readability, lightly parse and colorify such output. See
#    #print_aliases_cli() for similar code.
#
#    # Validate sanity.
#    die_unless_args 'Expected one or more variable names.'
#
#    # Print such variables.
#    typeset -p -- "${@}"
#}

#       is_string_nonempty "${variable_name__gvnfif}" and
#           return_string  "${variable_name__gvnfif}"

    # Write such variables. Dismantled, this is:
    #
    # * "-p", printing the current definitions of such variables.
    # * ">!", forcefully overwriting such file if already extant.
#   typeset -p -- "${@}"

    #FUXME: Shift the following block to a separate function to permits its
    #calling in append_file_with_variable() as well.
            # In this case, "typeset -p" output
            # safely declares and defines such variable.
#           :die_unless_var 

            # See :is_var_list() for further details.
#           if { :is_var_list "${variable_name__wfwv}" "${}" ${~ZESHY_VARIABLE_TYPE_GLOB_SCALAR si}

    # * "+g +", listing newline-delimited global names, each such line prefixed
    #   by zero or more space-delimited attributes (e.g., "ZSH_VERSION",
    #   "integer 10 readonly ZESHY_AND_THE_BLOOD_DIMMED_TIDE").
    # * "(f)", splitting such list on newlines.
    # * "##* ", removing the space-delimited attributes from each line.
#   case "$(get_variable_type "${variable_name__ivn}")" {
#, defined
#depending on variable type as follows:
#
#* For string variables, `""`.
#* For integer variables, `0`.
#* For float variables, `0.0`.
#* For list and map variables, `()`.

#   ${~ZESHY_VARIABLE_TYPE_GLOB_NUMBER})
#           (( ${(P)variable_name__ivn} ))  and report_status;;
#   *)
#       is -n "${(P)variable_name__ivn}" si and report_status;;
#   }

#   :die_unless_var "${variable_name__ivn}"
    # See get_variable_type() for further details.
#   die_unless_arg 'expected one variable name'
#   string variable_type="${(tP)1}"
#   is_string_nonempty "${variable_type}" and
#       is_string_suffix "${variable_type}" '-local'

    # See get_variable_type() for further details.
#   string variable_type="${(tP)1}"
#   is "${variable_type}" == '-global' si
#   is_string_nonempty "${variable_type}" and
#       "${variable_type}" '-global'

#       :is_var "${variable_name}" or :die_unless_var
#           die "${2:-variable \"${variable_name}\" undefined}"
#   case "${variable_type}" {
#   integer*|float*) (( ${(P)variable_name} )) and report_status_silent;;
#   *)          is -n "${(P)variable_name}" si and report_status_silent;;
#   }

#Serialize the passed variables to the passed file, appending the contents
#of such file with the current definitions of such variables. Subsequently call
#:source_script() to deserialize such variables from such file.

#FUXME: Silly function. Replace everywhere with a call to
#die_unless_string_nonempty(). (The reason? For safety, the passed variable name
#is usually suffixed by something resembling "__duvn", which is hardly human-
#readable. This function promotes bad output and hence bad behavior. Excise!)
#declare_function '
#void :die_unless_var_nonempty(
#    string variable_name,
#    string error_message = "\"${variable_name}\" not set or empty")
#
#Throw an exception unless the passed variable is set to a non-empty value.
#See :is_var_empty() for the definition of "empty value."
#'
#function :die_unless_var_nonempty() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string variable_name="${1}"
#    :is_var_nonempty "${variable_name}" or
#        die "${2:-\"${variable_name}\" not set or empty}"
#}

#FUXME: No longer fond of such nomenclature. The script is the dominant object
#to which the action "write" is applied -- not the variable. Hence, rename to
#write_file_with_variable().
        #FUXME: Implement new get_zsh_path() and get_zsh_shebang_line()
        #functions. The latter function should first test if either "env" is a
        #pathable and, if so, print a shebang line to such command; otherwise,
        #default to get_zsh_path(), as implemented below.

        # For safety, ensure the first line of such script is a zsh shebang.
#       string zsh_path; zsh_path="$(get_pathable_path zsh)"
#       print_string "#!${zsh_path}"

# -- particularly, names, types, values, and related metadata
# (e.g., globality, writability)
#       variable_type="$(get_variable_type "${variable_name}")"
#       print_string "variable type: ${variable_type}\nglob: ${glob}"
#       is_string_matches_glob "${variable_type}" "${glob}" # do not quote such glob!
    # * "is -n ... si", true if such expansion is non-empty and thus the passed
    #   valiable is set.
#FUXME: I'm somewhat unhappy with the nomenclature of the current write_*() and
#append_*() methods. Reconsider. (These function names, however, are great.)

# ....................{ FREEZERS                           }....................
#FUXME: Fairly certain all of the freeze_*() and unfreeze_*() functions below
#are fundamentally dangerous. The reason, unfortunately, is that each call of
#typeset() on a variable replaces all prior attributes of such variable rather
#than merely supplementing them. The result? Unhappy chaos. This is
#astonishingly hard to do, actually. I suspect the best will be to first
#print out the current definitions of all passed variables with
#'typeset -p -- "${@}"', string munge such definitions to remove all "-r" flags,
#and then embed the munged definitions in an "eval" statement. Ugly and rather
#inefficient, but I don't see why it wouldn't work. That said, I don't currently
#require such functionality, so... cut 'em!

# void freeze_variable(string variable_name1, string variable_name2, ...)
#
# Make the passed variables read-only (e.g., "const", "final").
#function freeze_variable() {
#    die_unless_args 'expected at least one variable name'
#    :die_unless_vars "${@}"
#    die 'implement me'
#}

# void unfreeze_variable(string variable_name1, string variable_name2, ...)
#
# Make passed variables writable (i.e., non-read-only).
#function unfreeze_variable() {
#    die_unless_args 'expected at least one variable name'
#    :die_unless_vars "${@}"
#    die 'implement me'
#}

# ....................{ FREEZERS ~ glob                    }....................
# void freeze_variables_matching(string glob)
#
# Make all variabless matching the passed glob read-only (e.g., "const").
#function freeze_variables_matching() {
#    die_unless_arg 'expected one glob'
#    die 'implement me'
#   typeset -mr -- "${1}"
#}

# void unfreeze_variables_matching(string glob)
#
# Make all variabless matching the passed glob writable (i.e., non-read-only).
#function unfreeze_variables_matching() {
#    die_unless_arg 'expected one glob'
#    die 'implement me'
#   typeset -m +r -- "${1}"
#}

# ....................{ UNDEFINERS                         }....................
#FUXME: Define corresponding undefine_local() *ALIASES*. It's critical they not
#be functions to guarantee correct scope. *WAIT.* These functions are
#practically useless; there appears to be no coherent means of undefining
#global variables from a function context. At least, I couldn't do it!
#Unsetting just unsets locally, which seems miserably stupid. *sigh*
#We'd need to define these as aliases; but then, of course, there's no means of
#adding in the essential "typeset +r". In any case, the resulting aliases
#*STILL* wouldn't work globally - just in the local function context.

# void undefine_global(string global_name1, string global_name2, ...)
#
# Undefine the passed global variables.
#function undefine_global() {
    # Validate sanity.
#    die_unless_args 'expected at least one global name'

    # zsh refuses to unset read-only globals. But zsh didn't count on us. Mark
    # such globals writable before undefining such globals. Haha!
#   unfreeze_global_export "${@}"
#   typeset +r ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY\
#       ZESHY_MAP_SHELL_NAME_TO_EMULATABLE_SHELL_NAME
#   typeset -p -- "${@}"
#    typeset +r -- "${@}"
#   for variable_name ("${@}") {
#       env --unset="${variable_name}" &>/dev/null
#   }
#    unset -- "${@}"
#   typeset +r ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY=2
#   typeset -p -- "${@}"
#   print_string "unset: "
#   print_strings_newlined "${@}"
#   [[ -n "${ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY+x}" ]] and print 'hmmmmm'
#}

# void undefine_globals_matching(string glob)
#
# Undefine all global variables matching the passed glob.
#function undefine_globals_matching() {
    # See undefine_global() for discussion.
#    die_unless_arg 'expected one glob'
#    string glob="${1}"
#    typeset -m +rg -- "${@}"
#    unset -m -- "${glob}"
#}

#   unfreeze_variables_matching "${glob}"
#FUXME: Improve to accept multiple variable names. Requires a loop, amusingly,
#to manually ensure each such variable exists.

#   for variable_name ("${@}"
#   string variable_name="${1}"
#   :die_unless_var "${variable_name}"
#   string variable_name="${1}" filename="${2}"
#   :die_unless_var "${variable_name}"

    # Write such variable. Dismantled, this is:
    #
    # * "-p", printing the current definition of such variable.
    # * ">!", forcefully overwriting such file if already extant.
#   typeset -p "${variable_name}" >! "${filename}"
# read_variables_from_file() to deserialize such variable from such file.
# ....................{ READERS                            }....................
# void read_variable_from_file(string variable_name, string filename)
#
# Deserialize the passed variable from the passed file, presumably written by a
# prior call to write_variable_to_file().
# :set_var_to_file_contents() to deserialize such variable from such file.
#function read_variable_from_file() {

#, concatenated into a single string.
        # If this word defines a global variable, continue to the next; else,
        # break with this word. Dismantled, this is:
        # * "[a-zA-Z_]", matching the first character of a variable name.
        # * "[a-zA-Z0-9_]#", matching all remaining characters of such name.
        # * '=', a "=" delimiter.
        # * "*", matching zero or more characters as the variable value.
#       is "${word}" == [a-zA-Z_][a-zA-Z0-9_]#'='* si or break
# Clearly, these
#functions should all be shifted to the same component.
#FUXME: Fails to account for prefixing temporary globals: e.g.,
#   LD_PATH="oeu=oeu" ssh -o hmm
#       is "${word}" == *?'='* si or break
# This function currently fails to return the expected name for exotic command
# lines containing pathological, but technically valid, syntax (e.g.,
# '"{!! This is a sadistic variable name !!}"="===" ls').
#   list words; words=( "${(z)*}" )
#   for word ("${words[@]}") {
#   string args; args="$(get_args)"
    # Exclude prefixing temporary global variable definitions.
    # Return the first shell word of remaining arguments.
#   get_word "${args}" 1
        # If such variable's type is numeric, emptiness is equality with zero;
        # otherwise, emptiness is equality with the empty string.
#FUXME: Remove at least two of the following functions. I'm thinking
#get_variable_first_or() and get_variable_value_first_or().
#FUXME: Rename "_if_found" back to "_if_found" *EVERYWHERE*. Much more readable.

    # Validate sanity.
#   die_unless_arg 'expected one variable name'
#   string variable_name; variable_name="${1}"

    # If such variable exists, test such variable's value for emptiness
    # depending on its type.
#   :is_var "${variable_name}" and {
#       string variable_type; variable_type="$(get_variable_type)"

#       case "${variable_type}" in
        # If such variable's type is numeric, emptiness is equality with zero.
#       integer*|float*) (( "${(P)variable_name}" == 0 )) and report_status;;
        # Otherwise, emptiness is equality with the empty string.
#       *) is -z "${(P)variable_name}" si and report_status;;
#       esac
#   }

#FUXME: Such functions only return string values; rename to
#get_variable_first_expansion_if_found().
    # If the passed variable is unset, expand to the empty string; otherwise,
    # expand as is. Return true if such expansion is non-empty.
#   is -n "${${(P)1-}#0}" si

# string get_variable_first_or(
#   string default_value,
#   string variable_name1, variable_name2, ...)
#
# Get the name of the first passed variable with non-empty value or the passed
# default value if no such variable has a non-empty value: e.g.,
#
#     >>> unset_variable PEGANUM HARMALA
#     >>> get_variable_first_or('Thank you, Iran.' PEGANUM HARMALA)
#     Thank you, Iran.
#function get_variable_first_or() {
#    die_unless_args_2_or_more\
#        'expected one default value and at least one variable name'
#    get_variable_first_if_found "${@[2,-1]}" or print_string "${@[1]}"
#}

# string get_variable_value_first_or(
#   string default_value,
#   string variable_name1, variable_name2, ...)
#
# Get the value of the first passed variable with non-empty value or the passed
# default value if no such variable has a non-empty value: e.g.,
#
#     >>> unset_variable PEGANUM
#     >>> string HARMALA='Esfand svanta'
#     >>> get_variable_value_first_or('Thank you.' PEGANUM HARMALA)
#     Esfand svanta
#function get_variable_value_first_or() {
#    die_unless_args_2_or_more\
#        'expected one default value and at least one variable name'
#    get_variable_value_first_if_found "${@[2,-1]}" or print_string "${@[1]}"
#}

    # If the passed variable is unset, expand to "x"; otherwise, expand as is.
    # Return true if such expansion is empty. Dismantled, this is:
    #
    # * "#0", removing a prefixing "0" if present and hence treating "0" as
    #   empty. By default, zsh only treats the empty string as empty. Since
    #   integers are scalars that are *ALWAYS* some integer and hence never the
    #   empty string, integers would never be treated as empty without such fix.
#   is -z "${${(P)1-x}#0}" si

#       string*)
#       array*|association*) (( "${(P)variable_name}" == 0 ));;
# or throw an
# exception if no such object exists# void die_unless_unset(string variable_name, string error_message = 'already set')
#
# Throw an exception unless the variable with the passed name is unset.
#function die_unless_unset() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string variable_name="${1}"
#    is_undeclared "${variable_name}" or die "${2:-\"${variable_name}\" already set}"
#}

    # Validate sanity.
    # Iterate sanity for the first non-empty variable or return false.
# boolean :is_var(string text)
#
# Return true if the variable with the passed name is unset (i.e., undeclared).
#function :is_var() {
    # Negate the condition :is_var_declared() tests for.
#    die_unless_arg 'expected one variable name'
#    is -z "${(P)1+x}" si
#}

#FUXME: I'm no longer enamoured with our use of "set" in this context, which
#conflicts with our use of "set" when referring to list and map sets. Rather,
#let's rename the former uses of "set" with "defined": e.g.,
# string get_first_defined_nonempty_variable(...)

#FUXME: Uhm... what? I'm fairly certain we never call this. Doesn't is_declared()
#suffice? We probably want to replace this with a new is_global() function.
# boolean :is_var(string variable_name)
#
# Return true if there exists a variable with the passed name.
#:is_var() {
#    die_unless_arg 'expected one name'
#    is_string_nonempty "${(tP)1}"  # see get_type() for details
#}

#FUXME: Rename is_local().
#       string object_type
#       object_type="$(whence -w -- "${object_name}")" or true  # ignore errors

# * Reflection functionality for dynamically inspecting functions and aliases
#   like first-class constructs.
#FUXME: Uhm; shouldn't "_runnable" be "_callable" everywhere below? Do we really
#need a distinction between the two? Arguably, functions aren't runnable and
#commands and builtins aren't callable. Perhaps

# ....................{ DEPENDENCIES                       }....................
#FUXME: This is generic functionality which should probably be provided by
#"core". Shift us up the genericity!
# void _zeshy_type(void)
#
# Import Zeshy components specific to the current OS.
#_zeshy_type() {
#    string current_dir="$(dirname "${zeshy_script_path}")"
#    is_dir "${current_dir}" and zimport "${current_dir}"
#}

# ....................{ MAIN                               }....................
# Call and then immediately unset (i.e., delete) _zeshy_os().
#_zeshy_os
#unset _zeshy_os
