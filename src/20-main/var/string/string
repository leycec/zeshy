#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle core string functionality.
/---

#FIXME: O.K.; I've had a *MAJOR* rethink on nomenclature here. Any string
#function *NOT* prefixed by "get_" should accept the name of a string *VARIABLE*
#rather than string value as its first argument and set such variable in-place.
#All existing string functions *NOT* prefixed by "get_" should be renamed in
#such a way as to be prefixed by "get_": e.g.,
#
#* Rename reverse_string() to :get_string_reversed().
#* Rename capitalize_string() to :get_string_capitalized().
#
#This is *ABSOLUTELY* essential for our continued sanity and that of our user's.
#Currently, some similarly named functions (e.g.,
#:replace_scalar_text_matching_pcre_by_text(),
#:remove_list_items_matching_glob()) replace in-place, while others don't. The
#former is the only sane nomenclature, however, by virtue of the fact that if we
#abandon such nomenclature, then *ALL* operations on maps and lists (which by
#definition only operation on variables rather than values) must be renamed to
#explicitly specify the fact they operate on variables (e.g., from
#:remove_list_items_matching_glob() to
#:remove_list_variable_items_matching_glob()). But even the denotation
#"_variable" isn't quite right, as the "_scalar" family of functions merely
#operate on general LHSs rather than simple variable names, meaning we'd have to
#embed "_lhs" (or some such) in such families (e.g., from
#:replace_scalar_text_matching_pcre_by_text() to
#:replace_scalar_lhs_text_matching_pcre_by_text()). In other words, we have to
#render function names across a wide variety of classes (namely, list, map, and
#scalar) even *MORE* unreadably verbose than they previously were. Which really
#isn't on the map (...get it? GET IT?) at all.
#
#That said, renaming all functions behaving like getters as getters simply makes
#fundamental sense. It eliminates ambiguity, improves precision, and should
#(hopefully) reduce the inevitable load of repetitous FAQ queries.

# ....................{ REVERSERS                          }....................
declare_function_with_stdin <<'/---'
string reverse_string(string text1, ...)

Reverse the concatenation of the passed strings: e.g.,

.reverse_string()
==========================================
[source]
------------------------------------------
>>> reverse_string "Satan, oscillate my metallic sonatas!"
!satanos cillatem ym etallicso ,nataS
>>> reverse_string Mr. Owl ate my metal worm...
...mrow latem ym eta lwO .rM
>>> reverse_string Rats live on no evil star.
.rats live on no evil staR
------------------------------------------
==========================================
/---
function reverse_string() {
    # While external command "rev" implements such operation as well, a pure zsh
    # implementation is likely to be faster on small strings. It's also more
    # amusing, and that surely counts for... well, not much.
    #
    # Validate sanity.
    die_unless_args 'Expected one or more strings.'
    :list chars chars_reversed

    # Split such strings on characters.
    set_list_to_string_characters chars "${*}"

    # Reverse such list.
    set_list_to_list_reversed chars_reversed chars

    # Concatenate such list elements.
    join_list chars_reversed
}

# ....................{ MUNGERS ~ case                     }....................
declare_function_with_stdin <<'/---'
void :capitalize_string(string string_name)

Capitalize the first character of each word in the value of the passed string
variable: e.g.,

.:capitalize_string()
==========================================
[source]
------------------------------------------
>>> :string on_modernity=\
...    "Why are we sad and miserable?  Because our modern culture has failed.
...     We are all failures. The world around us has failed to sustain our
...     humanity, our spirituality. The deep woe inside black metal is about
...     fear, that we can never return to the mythic pastoral world that we
...     crave on a deep subconscious level... for modernity has transformed us –
...     our minds, bodies and spirit – into an alien life form, one not suited
...     to life on Earth without the mediating forces of technology, culture,
...     and organized religion. We are weak and pitiful in our strength over the
...     Earth. In conquering, we have destroyed ourselves."
>>> :capitalize_string "${on_modernity}"
>>> get_string_line "${on_modernity}" 1
Why Are We Sad And Miserable? Because Our Modern Culture Has Failed.
------------------------------------------
==========================================
/---
function :capitalize_string() {
    # Validate sanity.
    die_unless_arg 'Expected one string name.'
    :string string_name__cs="${1}"
    die_unless_string "${string_name__cs}"

    # Capitalize such string.
    set_string_to_string "${string_name__cs}" "${(CP)string_name__cs}"
}

declare_function_with_stdin <<'/---'
void :lowercase_string(string string_name)

Lowercase all characters in the value of the passed string variable: e.g.,

.lowercase_string()
==========================================
[source]
------------------------------------------
>>> :string on_warnings=\
...    "Awakened in the morning
...     To more air pollution warnings.
...     Still we sleepwalk off to work
...     While our nervous systems jerk."
>>> :lowercase_string "${on_warnings}"
>>> get_string_line "${on_warnings}" 3
still we sleepwalk off to work
------------------------------------------
==========================================
/---
function :lowercase_string() {
    # Validate sanity.
    die_unless_arg 'Expected one string name.'
    :string string_name__ls="${1}"
    die_unless_string "${string_name__ls}"

    # Lowercase such string.
    set_string_to_string "${string_name__ls}" "${(LP)string_name__ls}"
}

declare_function_with_stdin <<'/---'
void :uppercase_string(string string_name)

Uppercase all characters in the value of the passed string variable: e.g.,

.:uppercase_string()
==========================================
[source]
------------------------------------------
>>> :string on_body_parts=\
...    "We know how to and sure as shit we'll win.
...     War is peace. (Sure, man.)
...     A retreat for the damned;
...     A playground for the demented;
...     A haven for those who walk this world
...     Bereft of heart and soul.
...     Love and war – they say all is fair.
...     Take his life
...     But won't take his hair.
...     Your body has parts your
...     Country can spare.
...     By the way, son,
...     Here's your wheelchair."
>>> :uppercase_string "${on_body_parts}"
>>> get_string_line "${on_body_parts}" 1
WE KNOW HOW TO AND SURE AS SHIT WE'LL WIN.
------------------------------------------
==========================================
/---
function :uppercase_string() {
    # Validate sanity.
    die_unless_arg 'Expected one string name.'
    :string string_name__us="${1}"
    die_unless_string "${string_name__us}"

    # Uppercase such string.
    set_string_to_string "${string_name__us}" "${(UP)string_name__us}"
}

# ....................{ (PRE|SUF)FIXERS                    }....................
#FIXME: Refactor into :prefix_string() operating directly on string variables
#and shift to @{substring}.
declare_function_with_stdin <<'/---'
string prefix_string(string text, string prefix)

Prefix the passed string with the passed prefix, if not already: e.g.,

.prefix_string()
==========================================
[source]
------------------------------------------
>>> string on_soldiers=\
...    "You don't hate! Only the unloved hate — the unloved and the unnatural."
>>> prefix_string "${on_soldiers}"\
...    "Soldiers! Don't give yourselves to brutes — men who despise you! Enslave
...     you! Who regiment your lives, tell you what to do, what to think or what
...     to feel! Who drill you, diet you, treat you like cattle, use you as
...     cannon fodder! Don't give yourselves to these unnatural men — machine
...     men with machine minds and machine hearts! You are not machines! You are
...     not cattle! You are men! You have the love of humanity in your hearts."
Soldiers! Don't give yourselves to brutes — men who despise you! Enslave
you! Who regiment your lives, tell you what to do, what to think or what
to feel! Who drill you, diet you, treat you like cattle, use you as
cannon fodder! Don't give yourselves to these unnatural men — machine
men with machine minds and machine hearts! You are not machines! You are
not cattle! You are men! You have the love of humanity in your hearts.
You don't hate! Only the unloved hate — the unloved and the unnatural.
------------------------------------------
==========================================
/---
function prefix_string() {
    die_unless_args_2 'Expected one string and one prefix.'
    output_string "${2}${1#${2}}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Excise, replacing with :suffix_string_if_needed() everewhere.
# declare_function_with_stdin <<'/---'
# string suffix_string(string text, string suffix)
# 
# Suffix the passed string with the passed suffix, if not already: e.g.,
# 
# .suffix_string()
# ==========================================
# [source]
# ------------------------------------------
# >>> string on_ashcans_and_unobtainable_dollars=\
# ...    "Moloch the incomprehensible prison! Moloch the crossbone soulless jail-
# ...     house and Congress of sorrows! Moloch whose buildings are judg-
# ...     ment! Moloch the vast stone of war! Moloch the stunned govern-
# ...     ments!"
# >>> suffix_string "${on_ashcans_and_unobtainable_dollars}"\
# ...    "Moloch whose mind is pure machinery! Moloch whose blood is running
# ...     money! Moloch whose fingers are ten armies! Moloch whose breast
# ...     is a cannibal dynamo!  Moloch whose ear is a smoking tomb!"
# Moloch the incomprehensible prison! Moloch the crossbone soulless jail-
#  house and Congress of sorrows! Moloch whose buildings are judg-
#  ment! Moloch the vast stone of war! Moloch the stunned govern-
#  ments!
# Moloch whose mind is pure machinery! Moloch whose blood is running
#  money! Moloch whose fingers are ten armies! Moloch whose breast
#  is a cannibal dynamo!  Moloch whose ear is a smoking tomb!
# ------------------------------------------
# ==========================================
# /---
# function suffix_string() {
#     die_unless_args_2 'Expected one string and one suffix.'
#     output_string "${1%${2}}${2}"
# }

#FUXME: The dichotomy between is_string_matches_glob()- and
#get_string_text_matching_glob()-style nomenclature seems increasingly
#nonsensical. Since the lion's share of functionality uses "ing"-suffixed rather
#than "es"-suffixed verbs, rename all:
#is_string_matches_glob()- to
#is_string_matching_glob()-style nomenclature across the board. I know, it's
#slightly awkward and one character longer. But the cognitive load in trying to
#remember whether it was an "es" or "ing" suffix for the verb in the current
#context is real, awkward, and ultimately of the same order as the cognitive
#load in Perl for sigils. So, contemplate it strongly.

#However sensible such expansions may
    # seem, they all obstinately return the number of sanity. *sigh*
    # (Don't get us wrong: we know why such reductions fail. They gall, though.)
#   die_unless_stdin_readable_sans_blocking

#...    "As for politics, I'm an anarchist. I hate governments and rules and
#...     fetters. Can't stand caged animals. People must be free."

#...     \"Military intelligence\": two words combined that can't make sense."
#FUXME: Rename to truncate_string_to_length().
#FUXME: Optional arguments are terrible. Split a new
#truncate_string_to_length_and_append_suffix() from this. (To be honest, pretty much
#*EVERY* call to this function should be passing a suffix, so renaming this to
#such function should fix us up tidely.)
#FUXME: You know what -- shouldn't pretty *EVERY* call to this function be
#replaced with the above truncate_string_readable:(), in which case this function
#can simply (and happily!) be deleted?

#declare_function_with_stdin <<'/---'
#string truncate_string(
#    string text, integer maximum_length, string text_suffix_if_truncated = "")
#
#Truncate the passed string to the passed length, replacing the end of such
#string with the passed suffix (defaulting to the empty string) if the passed
#string exceeds such length: e.g.,
#
#.truncate_string()
#==========================================
#[source]
#------------------------------------------
#>>> truncate_string "Fallujah" 7
#Falluja
#>>> truncate_string "Fallujah" 7 "..."
#Fall...
#------------------------------------------
#==========================================
#/---
#function truncate_string() {
#    # Validate sanity.
#    die_unless_args_2_to_3\
#        'expected one string, one length, and optional suffix'
#    string text="${1}" max_length="${2}" text_suffix_if_truncated="${3:-}"
#    die_unless_integer_positive "${max_length}"
#
#    # If the passed string requires no truncation, return the same string.
#    (( ${#text} <= max_length )) and return_string "${text}"
#
#    # If a suffix was passed and the passed string is at least as long as such
#    # suffix, truncate by replacing the end of the string with such suffix.
#    if (( ${#text_suffix_if_truncated} &&
#          ${#text} > ${#text_suffix_if_truncated} )) {
#        (( max_length -= ${#text_suffix_if_truncated} ))
##       print "max_length: ${max_length}"
#        return_string "${text[1,${max_length}]}${text_suffix_if_truncated}"
#    # Otherwise, truncate without suffix replacement.
#    } else {
#        return_string "${text[1,${max_length}]}"
#    }
#}

# likely to produce aesthetic or human-readable output
# (Truncating after punctuation rather than indiscriminately improves aesthetics.)
#[^.,;!?]##
    #FUXME: Close, but not quite right. Ideally, we want to preserve human-
    #readable list output when truncating. Humans expect output resembling:
    #     "I mrethil", "p...", ...
    #Rather than:
    #     "I mrethil", "peliar"...
    #Not terribly easy or readibly internationalizable, so I suppose I'm content
    #with this as is. For now...

    # zsh implements string repetition in one of two ways:
    #
    # * With the "l" parameter expansion flag, as below.
    # * With the printf() builtin, as below.
    #
    # While the former fails in the unlikely event such text contains all
    # possible parameter expansion tokens, the 
    # avoids the multiplication of the former, it also
    # expands the expression "{1..${count}}" to all integers in such range and
    # hence fails to efficiently scale to large counts. On the other hand, the
    # latter . Prefer the  We reconcile these differences as follows:
    #
    # * If such text does *NOT* contain at least one such token, perform the
    #   latter with such token.
    # * Else, perform the former.
#FUXME: Contemplate renaming back to is_string_contains(), which reads much more
#naturally than this. Search for other instances of "_substring" in function
#names; perhaps we had a respectable reason for adopting such nomenclature?
#FUXME: Yeah. This is great. Rename back to is_string_contains(), in keeping
#with the existing is_string_equals() nomenclature. But the *REAL* reason is
#much more compelling: because we have numerous other functions elsewhere testing
#containment, each currently with their own domain-specific nomenclature
#(e.g., is_list_contains()). *THIS IS NONSENSE.* All containment testers should
#share the same nomenclature: _contains(). Why? Because anything else induces
#thinking on trying to remember the domain-specific noun for testing that
#particular type of containment, which ends up being just horrible. (Even I
#can't keep it straight.) Hence, rename is_list_contains() to is_list_contains()
#as well.
    #FUXME: This can be dramatically improved upon by recalling that
    #set_list_to_string_split_on_string() currently concocts an impressive
    #algorithm for efficiently finding the first available free token (e.g.,
    #":", ".", "'", '"', and so on). Generalize such algorithm into a new
    #function accepting only a single string and:
    #
    #* If an available free token exists for such string, returning non-zero
    #  exit status and printing such token;
    #* Otherwise, returning zero exit status and printing nothing.
    #
    #Assuming such function to be sensibly named
    #get_string_parameter_expansion_token(), call such function as follows:
    #
    #    string token
    #    if token="$(get_string_parameter_expansion_token "${text}")"
    #    then # ...do something with the token!
    #    else # ...otherwise try to find another way to do it or just die.
    #    fi
    #
    #Awesomeness!

    # zsh implements string repetition in one of two ways:
    #
    # * With the printf() builtin, as below.
    # * With the "l" parameter expansion flag, as below.
    #
    # While the former avoids the multiplication of the latter, it also
    # expands the expression "{1..${count}}" to all integers in such range.
    # When repeating characters, this often creates excessively many arguments,
    # impeding efficiency. Unfortunately, the latter fails when the passed text
    # contains a colon. We reconcile these differences as follows:
    #
    # * If the passed text contains a colon, run the former slower command.
    # * Otherwise, run the latter faster command.
#   if { is_string_contains "${text}" ':' } {
        # Since printf() appends no newline by default, do so.
#       printf -- "${text}%.0s" {1..${count}}
#       return_string "${ZESHY_ASCII_NEWLINE}"
#   } else {
        # Total length of the repeated result, below.
#       integer result_length
#       (( result_length = count * $(get_string_length "${text}") ))

        # Print such result.
#       eval "return_string \${(l:\${result_length}::${text}:):-}"
#   }

#   die_unless_string_nonempty "${text}" 'string to be repeated empty'
    # While external command "rev" implements such operation as well, a pure zsh
    # implementation is likely to be faster on small strings. It's also more
    # amusing, and that surely counts for... something.
#declare_function_with_stdin <<'/---'
#string get_string_text_count(string string, string substring)
#
#Get the number of instances of the passed substring in the passed string: e.g.,
#
#.get_string_text_count()
#==========================================
#[source]
#------------------------------------------
#>>> get_string_text_count "cult of radical consumerism" "c"
#3
#------------------------------------------
#==========================================
#/---
#function get_string_text_count() {
    # The difference between the passed string and such string excluding all
    # instances of the passed substring divided by the length of such substring
    # gives the number of such instances. Math for the obscene win!
#   die_unless_args_2 'expected one string and one substring'
#   string text="${1}" substring="${2}" string_sans_substring
#   string_sans_substring="${text//${substring}}"
#   return_string $(( (${#string} - ${#string_sans_substring}) / ${#substring} ))
#}

#FUXME: Rename to set_string_if_unset_to_string().
#declare_function '
#void set_string_if_unset(string string_name, string text)
#
#Set the passed variable if unset to the passed string: e.g.,
#
#    >>> string gnomes_say="hooray" hooray
#    >>> set_string_if_unset "${gnomes_say}" "lesser lights of the Bardo"
#    >>> print_string "${hooray}"
#    lesser lights of the Bardo
#'
#function set_string_if_unset() {
#    die_unless_args_2 'expected one variable name and one string'
#    noop ${(P)1=${2}}
#}

#declare_function '
#integer get_string_ansiless_length_printable(string text)
#
#Get the number of  length of the passed string in multibyte characters.
#'
#function get_string_ansiless_length_printable() {
#    # While parameter flag "(mm)" counts multibyte characters, parameter flag
#    # "(m)" counts only printable multibyte characters, thus ignoring control
#    # characters (e.g., newline). See get_string_length() for further caveats.
#    die_unless_args 'expected at least one string'
#    print_string "${(mm)#${*}}"
#}

#       print "result length: ${result_length}"
#   else eval "print -- ${(l:$((${#text} * ${count}))::\\${text}:):-}"
#FUXME: Rename to remove_string_text(). The current nomenclature implies
#removal of only one such substring, which is not the case.
#FUXME: For consistency, the following functions should be renamed
#:die_unless_var_string(), die_unless_character(), and so on.
#Naturally, that implies similar renamings of list *TYPE TESTING* functions to
#:die_unless_var_list(), :die_unless_var_map(), :is_var_list(), and
#so on. *BUT STOP THERE.* Rename only functions testing variable types in this
#manner; all other existing functions (in particular, non-type testing list and
#map functions such as join_list_on_newline() and get_list_size()) *RETAIN THEIR
#EXISTING FUNCTION NAMES*. This gives us the best of all worlds: consistent
#naming for functions testing variable type, concise and consistent naming for
#list and map functions, and concise and consistent naming for string functions.
#
#This is good. It's a simple patch, so make it so.

#       integer suffix_length
#       suffix_length="$(get_string_length "${suffix_if_exceeding_max_length}")"
#       (( max_length >  suffix_length )) && {
#           (( max_length -= suffix_length ))
#           print "max_length: ${max_length}"
#           print_string "${text[1,${max_length}]}${suffix_if_exceeding_max_length}"
#           report_success
#       }
#   }

    # Otherwise, truncate without suffix replacement.
#   print_string "${text[1,${max_length}]}"

#FUXME: Bad. Remove entirely, replacing existing calls with
#:die_unless_var_nonempty().
# void :die_unless_var_nonempty(
#   string string_name,
#   string error_message = "\"${string_name}\" not a string or empty")
#
# Throw an exception unless the passed variable is a non-empty string.
#function :die_unless_var_nonempty() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    :is_var_nonempty "${1}" or
#        die "${2:-\"${1}\" not a string or empty}"
#}

#FUXME: Bad. Remove entirely, replacing existing calls with
#:is_var_nonempty().
# boolean :is_var_nonempty(string string_name)
#
# Return true if the passed variable is a nonempty string.
#function :is_var_nonempty() {
#    die_unless_arg 'expected one variable name'
#    string string_name="${1}"
#    :is_var_string "${string_name}" and (( ${#${(P)string_name}} ))
#}

#   integer text_length; text_length="$(get_string_length "${text}")"

#FUXME: I'm beginning to wonder if all string functions shouldn't accept a
#variable *NAME* rather than type. Hmm; no, actually. It's rather dangerous,
#though it appears somewhat more elegant, due to the risk of variable name
#shadowing. Safest to copy all parameters rather than try the reference
#approach, yes?

    #FUXME: It might be nice to create a family of string functions for testing
    #string content: e.g.,
    #
    #* string is_string_contains(string text, string substring)
    #* string is_string_prefix(string text, string prefix)
    #* string is_string_suffix(string text, string suffix)
    #
    #For example, the first simply implements:
    #    is "${1}" == *"${2}"* si

#   eval\
#       "${prefix_name}=\"${text%%${delimiter}*}\"; "\
#       "${suffix_name}=\"${text#*${delimiter}}\""

# string get_first_word(string text, string text2, ...)
#
# Get the first word from the passed string.
#get_first_word() {
#    die_unless_args 'expected at least one string'
#    print_string "${*[(w)1]}"
#}

#       print_message "piped_input: $(get_stdin_piped)"
#       text="$(get_stdin_piped)"
    # Validate sanity.
#   print -lr -- "${(uf)@}"
#   print_strings_newlined ${(uf)@}
#   map unique_lines
    #list lines; lines=( )

#   foreach line (${(f)@}) {
#       is_map_key unique_lines "${line}" or {
#           print_string ${line}
#           unique_lines[${line}]=
#       }
#   }
# Also, suffix
#with "_string" for safety (i.e., we might someday want a capitalize_string_list()
#function, in which case a capitalize_string() function sows confusion).
#FUXME: I'm fairly sure that, as with the "(f)" flag above, the "(w)" flag
#erroneously operates on characters if there exists only one such word. Fix.
#Hmm. Perhaps not. It appears to operate completely differently, actually, being
#an index rather than parameter expansion. Also, do we really need a
#get_first_word() function? Seems a tad superfulous.

# string number_string_lines_highlighting_line(
#   int highlight_line_index,
#   string text1, string text2, ...)
#
# Prefix each line of the passed string with that line's number and highlight
# the passed line number. Since "nl" supports no highlighting, this function
# accepts no "nl"-specific options.
#number_string_lines_highlighting_line() {
#    # Localize sanity.
#    die_unless_args_2_or_more\
#        'expected one line number and one or more strings'
#    die_unless_integer "${1}"
#    integer highlight_line_index="${1}" line_length
#    shift_arg
#    string text="${@}"

#FUXME: By definition, you only join a list to a string and split a list to a
#string. Hence, these function names are overly verbose. Rename
#join_join_list() to join_list_on() and
#join_join_list_prefixing_last_with() to join_list_prefixing_last_element_with().
#This produces much more legible code.

#FUXME: Right. join_list() is simply too brief. join_join_list() reads
#better.

    # Localize sanity.
#   die_unless_args\
#       'expected zero or more "nl" options and one string'
#   string text="${@[-1]}"
#   pop_arg

    # Prefix.
#   list nl; nl=( nl "${ZESHY_OPTIONS_NL[@]}" )
#   print_string "${text}" | {
#       if is_shell_interactive
#       then "${nl[@]}" "${ZESHY_OPTIONS_NL_IF_SHELL_INTERACTIVE[@]}"     "${@}"
#       else "${nl[@]}" "${ZESHY_OPTIONS_NL_IF_SHELL_NONINTERACTIVE[@]}" "${@}"
#       fi
#   }

    #FUXME: Implementable with pure-zsh.
#   print_string "${1}" | head --lines="${2:-1}"

#   list newline_split; newline_split=( "${(s:\n:)1}" )
#   print "first line: ${newline_split[1]}"

# string get_first_line(string text)
#
# Get the first line from the passed string.
#get_first_line() {
#    die_unless_arg 'expected one string'
#   print_string "${1[(f)1]}"
#}

#   # Localize sanity.
#   (( # >= 1 && # <= 2 )) ||
#       die 'expected one string and optional first line number'
#   local text="${1}"
#   integer first_line_index="${2}"

    # Prefix.
#   nl -v${first_line_index} "${text}"

    # Bizarrely, the "(f)" no longer appears to behave as advertised on my
    # install. In fact, it no longer does anything at all. Consequently, we
    # perform a brute-force split on newlines. Ideally, this should be:
    #
    #     print "${#${(f)1}}"
    # 
    # Unfortunately, we can't even expand this to:
    # 
    #     print "${#${(s:\n:)1}}"
    # 
    # Doing so behaves correctly for all input *EXCEPT* that without newlines.
    # Consequently, we perform an even more brute-force split into a list.
#     >>> set_list_to_string_split_on '"Contumely Hard" Climaxes' array
#     >>> print "${array[1]}"
#     Contumely Hard
#    # If the caller passed no separator, default to word splitting.
#   if is_string_empty "${separator}"
#   then eval ${list_name}'=( ${(z)text} )'

#   :is_var "${target_name_prefix}" or string ${target_name_prefix}
#   :is_var "${target_name_suffix}" or string ${target_name_suffix}
#   :is_var "${list_name}" or list "${list_name}"

#   :die_unless_var_string "${target_name_prefix}"
#   :die_unless_var_string "${target_name_suffix}"

#Compare the lengths of the original and resulting strings.
#   local string_matches_deleted="${string//${~glob}/}"
#   local glob_characters="${#glob//}"
#   print $(((${#string} - ${#string_matches_deleted}) / ${#glob}))
#   print "string_newlined: ${string_newlined}"
