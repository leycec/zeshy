#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *string getters* (i.e., functions getting string properties).
/---

# ....................{ GETTERS                            }....................
#FIXME: Overly verbose example, though delightful. Shift half of it elsewhere.
declare_function_with_stdin <<'/---'
integer get_string_length(string text1, ...)

Get the total length of the passed strings in single-byte characters. Consider
calling get_string_ansiless_length_printable() instead if any such string contains
multibyte characters (e.g., UTF-8-encoded Unicode): e.g.,

.get_string_length()
==========================================
[source]
------------------------------------------
>>> string on_worrisome_rides=\
...    "The world is like a ride in an amusement park, and when you choose to go
...     on it you think it's real because that's how powerful our minds are. The
...     ride goes up and down, around and around, it has thrills and chills, and
...     it's very brightly colored, and it's very loud, and it's fun for a
...     while. Many people have been on the ride a long time, and they begin to
...     wonder, \"Hey, is this real, or is this just a ride?\" And other people
...     have remembered, and they come back to us and say, \"Hey, don't worry;
...     don't be afraid, ever, because this is just a ride.\" And we kill those
...     people. \"Shut him up! I've got a lot invested in this ride, shut him
...     up! Look at my furrows of worry, look at my big bank account, and my
...     family. This has to be real.\""
>>> string on_better_rides=\
...    "It's just a ride. But we always kill the good guys who try and tell us
...     that, you ever notice that? And let the demons run amok. But it doesn't
...     matter, because it's just a ride. And we can change it any time we want.
...     It's only a choice. No effort, no work, no job, no savings of money.
...     Just a simple choice, right now, between fear and love. The eyes of fear
...     want you to put bigger locks on your doors, buy guns, close yourself
...     off. The eyes of love instead see all of us as one. Here's what we can
...     do to change the world, right now, to a better ride. Take all that money
...     we spend on weapons and defenses each year and instead spend it feeding
...     and clothing and educating the poor of the world, which it would pay for
...     many times over, not one human being excluded, and we could explore
...     space, together, both inner and outer, forever, in peace."
>>> get_string_length "${on_worrisome_rides}" "${on_better_rides}"
1578
------------------------------------------
/---
function get_string_length() {
    # Due to zsh eccentricity, this expansion *CANNOT* be reduced to either
    # "${#*}", "${#@}", "${#${*}}", or "${#${@}}". Reducing this expansion to
    # "${#${*}}" successfully returns the expected string length in all cases
    # *EXCEPT* when the empty string is passed, in which case such expansion
    # erroneously returns 1 rather than 0. Strangely, assigning passed arguments
    # to a local variable before testing the length of such variable corrects
    # this edge case (and probable zsh bug).
    die_unless_args 'Expected one or more strings.'
    string text="${*}"
    output_string ${#text}
}

declare_function_with_stdin <<'/---'
integer get_string_length_printable(string text1, ...)

Get the total length in printable multibyte characters of the passed strings
excluding ANSI escape sequences in such strings. See
:set_int_to_string_length_printable() for a setter analogue and
get_string_ansiless_length_printable() for further details: e.g.,

.get_string_length_printable()
==========================================
[source]
------------------------------------------
>>> string on_flag_and_wind=\
...    "A temple flag flapped in the wind. Two monks stood watching. One said to
...     the other, \"The flag is moving.\" The other replied, \"The wind is
...     moving.\" The sixth patriarch, Eno, overheard this and said, \"It is not
...     the wind or the flag. The mind is moving.\""
>>> get_string_length_printable "${on_flag_and_wind}"
248
>>> get_string_length_printable\
...     "${ZESHY_STYLE_TO_COLOR[color.reset]}${on_flag_and_wind}"
248
------------------------------------------
==========================================
/---
function get_string_length_printable() {
    # See get_string_length() for further details.
    die_unless_args 'Expected one or more strings.'
    string text="${*}"
    output_string "${(m)#${text//${~ZESHY_ANSI_GLOB}}}"
}

#FIXME: We strongly suspect all existing calls of this function to be erroneous.
#Consider changing such calls to get_string_length_printable() instead.
declare_function_with_stdin <<'/---'
integer get_string_ansiless_length_printable(string text1, ...)

Get the length of the passed string in printable multibyte characters, thus
treating *control characters* (e.g., newline, tab) as 0 characters for counting
purposes. Unfortunately, `zsh` currently provides no builtin means for counting
such characters as 1 character: e.g.,

.get_string_ansiless_length_printable()
==========================================
[source]
------------------------------------------
>>> string on_informed_decisions=\
...     "Wouldn't you like to see a positive LSD story on the news? To base your
...      decision on information rather than scare tactics and superstition?
...      Perhaps? Wouldn't that be interesting? Just for once?"
>>> string on_the_holographic_principle=\
...     "\"Today, a young man on acid realized that all matter is merely energy
...      condensed to a slow vibration â€“ that we are all one consciousness
...      experiencing itself subjectively. There's no such thing as death, life
...      is only a dream, and we're the imagination of ourselves. Here's Tom
...      with the weather.\""
>>> get_string_ansiless_length_printable\
...     "${on_informed_decisions}" "${on_the_holographic_principle}"
481
>>> get_string_ansiless_length_printable "${ZESHY_ASCII_NEWLINE}"
0
>>> get_string_ansiless_length_printable "${ZESHY_ASCII_NEWLINE}Gnosis"
6
------------------------------------------
==========================================
/---
function get_string_ansiless_length_printable() {
    # See get_string_length() for further details.
    die_unless_args 'Expected one or more strings.'
    string text="${*}"
    output_string ${(m)#text}
}

# ....................{ GETTERS ~ count                    }....................
#FIXME: "Count" is a verb as well as noun. Hence, rename this function to
#count_string_text() *AND* rename all other function names matching
#*"_count"* similarly.

declare_function_with_stdin <<'/---'
integer get_string_text_count(string text, string substring)

Get the number of instances of the passed substring in the passed string: e.g.,

.get_string_text_count()
==========================================
[source]
------------------------------------------
>>> string on_war_as_peace=\
...    "Launch the Polaris.
...     The end doesn't scare us.
...     The warheads will all rust in peace.
...     Eradication of
...     Earth's population loves
...     Polaris."
>>> get_string_text_count "${on_war_as_peace}" 'ar'
3
------------------------------------------
==========================================
/---
function get_string_text_count() {
    # Validate sanity.
    die_unless_args_2 'Expected one string and one substring.'
    string text="${1}" substring="${2}" text_with_substrings_removed

    #FIXME: Inefficient. Call set_string_to_string_text_removed(): e.g.,
    #set_string_to_string_text_removed\
    #    text_with_substrings_removed text substring
    #FIXME: Actually, there should be an even more efficient mechanism:
    #
    #    eval 'output_string $(( '${(S)text//*${substring}/1+}'0 ))'
    #
    #Reasonably clever, eh? The "(S)" enables non-greedy matching. The
    #replacement portion *SHOULD* (untested, of course!) replace each matching
    #substring with "1+". The outer evaluation thus gets the number of such
    #substrings. Niiiice.

    # Remove such substrings from such string.
    text_with_substrings_removed="$(remove_string_text\
        "${text}" "${substring}")"

    # Get the number of such substrings by differencing the lengths of such
    # string and such string with all such substrings removed, divided by the
    # length of such substring. For efficiency, avoid calling
    # get_string_length().
    output_string\
        $(( (${#text} - ${#text_with_substrings_removed}) / ${#substring} ))
}

# --------------------( WASTELANDS                         )--------------------
