#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *string length setters* (i.e., functions setting integer variables to
the lengths of passed strings).
/---

# ....................{ SETTERS                            }....................
# Such functions are transitively called by print_exception() via
# output_call_stack_lists_in_style() and hence subject to the same
# constraints: namely, to avoid calling other functions from such functions
# unless explicitly preceding such calls with tests of whether such functions
# are still defined or not.

#FIXME: Rename to :set_int_to_string_length_printable().
declare_function_with_stdin <<'/---'
void :set_int_to_string_length_printable(
    string int_name,
    string text1, ...)

Set the passed integer variable to the total length in printable multibyte
characters of all passed strings excluding ANSI escape sequences in such
strings. See get_string_ansiless_length_printable() for further details. e.g.,

.:set_int_to_string_length_printable()
==========================================
[source]
------------------------------------------
>>> :int length
>>> :string on_theology=\
...    'Nobushige, a respected samurai, came to Hakuin and asked, "Is there
...     really a heaven and hell?"
...     "Who are you?" inquired Hakuin.
...     "A samurai," Nobushige replied.
...     "You, a samurai!" exclaimed Hakuin. "What kind of ruler would have
...     you as his guard? Your face is like that of a beggar."
...     In anger, Nobushige drew his sword. Hakuin continued, "So, you have a
...     sword? Your weapon is probably too dull to even cut off my head."
...     As Nobushige raised his sword, Hakuin intoned, "Here open the gates of
...     hell." As Nobushige lowered his sword, Hakuin intoned, "Here open the
...     gates of heaven."'
>>> :set_int_to_string_length_printable length "${on_theology}"
>>> output_string "${length}"
568
>>> :set_int_to_string_length_printable length\
...     "${ZESHY_STYLE_TO_COLOR[color.black]}${on_theology}"
>>> output_string "${length}"
568
------------------------------------------
==========================================
/---
function :set_int_to_string_length_printable() {
    # Validate sanity. Yes, capturing such string to a local variable is
    # necessary due to a probable zsh bug. See below for further details.
    die_unless_args_2_or_more\
        'Expected one integer name and one or more strings.'
    :string int_name__sitslp="${1}" text__sitslp="${*[2,-1]}"
#   print "text__sitslp: \"${text__sitslp}\"; length: ${#text__sitslp}; length (multi): ${(m)#text__sitslp}; length (multi sans ansi): ${(m)#${text__sitslp//${~ZESHY_ANSI_GLOB}}}"

    # Remove all ANSI escape sequences from such string. Such sequences are
    # inherently non-printable (in the sense of printable characters).
    :remove_string_ansi text__sitslp

    # Set such length. See get_string_length_printable() for further details.
    :set_int_to_int "${int_name__sitslp}" "${(m)#text__sitslp}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: This probably no longer needs to be here, now that we've relegated
#exception handling to late in zeshy startup.

    # Set such length. For efficiency, inline such implementation. See
    # set_string_to_string() and get_string_length_printable() for further details.
    # noop "${(P)int_name__sitslp::=${(m)#text__sitslp}}"

    # # If any such variable is undefined or not of the expected type, throw an
    # # exception. See is_string() and is_list for further details.
    # is "${(tP)int_name__sitslp-}" == 'integer'* si or die\
    #     "\${${int_name__sitslp}} undefined or not an integer variable."
    # is "${(t)ZESHY_ANSI_GLOB}" == 'scalar'* si or die\
    #      "\${ZESHY_ANSI_GLOB} undefined or not a string variable."

    # # Remove all ANSI escape sequences from such string. For efficiency, it
    # # would be preferable to inline such removal below: e.g.,
    # #
    # #     noop "${(P)int_name__sitslp::=${(m)#${text__sitslp//${~ZESHY_ANSI_GLOB}}}}"
    # #
    # # Unfortunately, doing so improperly sets such integer to 1 if such string
    # # is the empty string. Consequently, separate the two operations.
    # text__sitslp="${text__sitslp//${~ZESHY_ANSI_GLOB}}"

# Handle *string repeaters* (i.e., functions repeating strings, typically for
# ensuring padded, aligned, and/or otherwise structured output).

# get_string_length_printable() for a getter analogue and

    # necessary due to a probable zsh bug. See get_string_length() for further
    # details.

    # For efficiency, inline the equivalent of:
    # 
    #     >>> get_string_ansiless_length_printable "$(remove_string_ansi "${@}")"
#FUXME: Remove entirely. Existing calls to this function should be changed to
#call get_string_length_printable() instead. The whole "_sans_ansi"
#concept is fundamentally flawed, as discussed below.
#FUXME: Bad nomenclature, I'm afraid. :set_int_to_string_length_printable()
#should be a general-purpose function and hence exclude the length of non-
#printable ANSI escape sequences. Hence, this function should be renamed to
#:set_int_to_string_length_printable() and shifted to a more appropriate
#parcel (e.g., @{variable/string/set}). Naturally, the existing
#get_string_ansiless_length_printable() function should internally defer to
#:set_int_to_string_length_printable().

#    integer\
#        padding_length__sstsartl\
#        repetition_count__sstsartl\
#        remainder_length__sstsartl
    # Padding length. See get_string_ansiless_length_printable() for further details.
#    padding_length__sstsartl=${(m)#padding__sstsartl}
#
#    # Number of times to completely repeat the passed padding. If such padding's
#    # length evenly divides the passed length, such repetition suffices to
#    # produce the requested string; else, a leftmost substring of such padding
#    # must be appended to such repetition to produce the requested string.
#    repetition_count__sstsartl=$((\
#        string_length__sstsartl / padding_length__sstsartl ))
#
#    # Length of the longest leftmost substring of such padding needed to produce
#    # a string of exactly the passed length. If such padding's length evenly
#    # divides the passed length, this is 0; else, this is a positive integer.
#    remainder_length__sstsartl=$((\
#        string_length__sstsartl % padding_length__sstsartl ))
#
#    # If such length is a positive integer, then by the prior discussion such
#    # padding's length does *NOT* evenly divide the passed length. In such case,
#    # get the leftmost substring of such padding of such length.
#    if (( remainder_length__sstsartl != 0 )) {
#        remainder__sstsartl="${padding__sstsartl[1,${remainder_length__sstsartl}]}"
#    }

    # Set such string to the required repetition of such padding followed by the
    # leftmost substring of such padding. See set_string_to_string() and
    # repeat_string() for further details.

    #FUXME: Implement me. Copy from repeat_string(), yes?
