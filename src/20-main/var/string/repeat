#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *string repeaters* (i.e., functions repeating strings, typically for
ensuring padded, aligned, and/or otherwise structured output).
/---

# ....................{ SETTERS                            }....................
#FIXME: If any function begged for examples, this would be it.
#FIXME: It's possible to create a generalized version of this function named
#:set_string_to_string_repeated_to_length() accepting any padding regardless of
#whether such padding contains ANSI escape sequences. Doing so requires code
#similar to that shifted to the wastelands (grep for
#"repetition_count__sstsartl"): namely, manually calculating whether the length
#of such padding excluding ANSI escape sequences evenly divides the passed
#length and, if not, appending the leftmost subset of such padding (again
#excluding ANSI escape sequences, which may be easier said than done). In such
#case, repetition must use the generalized printf() technique rather than the
#parameter expansion flag "(r...)" technique below. In other words, such
#function will have a completely different and considerably more complex and
#less efficient implementation. It'll probably be important at some point -- but
#it certainly isn't now!

declare_function_with_stdin <<'/---'
void :set_string_to_string_ansiless_repeated_to_length(
    string string_name,
    string padding,
    int length)

Set the passed string variable to the passed padding _not_ containing ANSI
escape sequences repeated until producing a string of exactly the passed length.
If such length is _not_ evenly divided by the length of such padding, the last
repetition of such padding will be truncated on the right by as many characters
as needed to guarantee producing a string of exactly the passed length.

== Caveats ==

*Avoid embedding ANSI escape sequences in such padding.* Doing so over-reports
such padding's length, producing a string of insufficient length.
/---
function :set_string_to_string_ansiless_repeated_to_length() {
    # Validate sanity.
    die_unless_args_3\
        'Expected one string name, one padding string, and one length.'
    :string\
        string_name__sstsartl="${1}"\
        padding__sstsartl="${2}"\
        length__sstsartl="${3}"\
        remainder__sstsartl
    character token__sstsartl

    #FIXME: Horrible. Just horrible. Call actual zeshy functions here.

    # If any such variable is undefined or not of the expected type, throw an
    # exception. See is_string() and :var.is_type_list for further details.
    is "${(tP)string_name__sstsartl-}" == 'scalar'* si or die\
        "\${${string_name__sstsartl}} undefined or not a string variable."

    # Validate remaining arguments. See die_unless_string_nonempty() and
    # :die_unless_int_nonnegative() for further details.
    is -n "${padding__sstsartl}" si or die 'Expected nonempty padding.'
    is "${length__sstsartl}" == <-> si or die\
        "Length \"${length__sstsartl}\" less than zero or not an integer."

    # Parameter expansion token suitable for repeating such padding. If no such
    # token exists, an exception will be thrown. While this would typically be
    # problematic, padding strings are typically succinct and hence unlikely to
    # contain all possible parameter expansion tokens. Moreover, the general-
    # purpose solution (avoiding such tokens) is substantially more complex,
    # more error prone, and less efficient than the token-based solution
    # implemented below.
    :set_char_to_string_expansion_token\
        token__sstsartl "${padding__sstsartl}"

    # Repeat such string. While the length of such padding is not guaranteed to
    # divide the passed length, parameter expansion flag "(r...)" guarantees
    # that in such case the last repetition of such padding only expands to the
    # leftmost substring of such padding producing a string of exactly the
    # passed length: e.g.,
    #
    #     >>> print ${(r:6::=~-:):-}
    #     =~-=~-
    #     >>> print ${(r:8::=~-:):-}
    #     =~-=~-=~
    #
    # Parameter expansion flag "(l...)" behaves similarly except that in such
    # case the first repetition of such padding only expands to the rightmost
    # substring of such padding producing a string of exactly the passed length.
    # Since this does *NOT* produce the expected result, the implementation
    # below leverages flag "(r...)" instead: e.g.,
    #
    #     >>> print ${(l:6::=~-:):-}
    #     =~-=~-
    #     >>> print ${(l:8::=~-:):-}
    #     ~-=~-=~-
    eval ${string_name__sstsartl}'="${(r'${token__sstsartl}${length__sstsartl}${token__sstsartl}${token__sstsartl}${padding__sstsartl}${token__sstsartl}'):-}"'
}

#FIXME: In lieu of unit tests...
#function biso() {
#    string text padding="=>/{"
#    :set_string_to_string_ansiless_repeated_to_length text "${padding}" 9
#    :string.output "padding: ${padding}; result length: 9; result: ${text}"
#}

# ....................{ REPEATERS                          }....................
declare_function_with_stdin <<'/---'
string repeat_string(string text, int count)

Repeat the passed string the passed number of times: e.g.,

.repeat_string()
==========================================
[source]
------------------------------------------
>>> repeat_string "Slavoj Žižek" 6
Slavoj ŽižekSlavoj ŽižekSlavoj ŽižekSlavoj ŽižekSlavoj ŽižekSlavoj Žižek
------------------------------------------
==========================================
/---
function repeat_string() {
    # Validate sanity.
    die_unless_args_2 'Expected one string and one integer.'
    :string text="${1}" count="${2}" token
    :die_unless_int_nonnegative "${count}"

    # If such count is 0, return the empty string. This isn't simply a trivial
    # edge-case optimization; the technique below assumes a strictly positive
    # count, actually repeating such string twice rather than printing the empty
    # string when passed a count of 0.
    (( count )) or report_success

    # Technically, there exist a multitude of techniques for repeating strings.
    # The technique implemented here is _not_ necessarily the most efficient for
    # edge-case strings but has the distinct benefit of behaving as expected for
    # all strings regardless of content. The (arguably) more popular alternative
    # to this technique leverages parameter expansion flags "(l...)" or "(r...)"
    # as follows:
    #
    #    # If such text does *NOT* contain at least one parameter expansion token,
    #    # prefer token- to printf()-based repetition. The latter expands the
    #    # expression "{1..${count}}" to ${count} number of integer arguments and
    #    # hence fails to efficiently scale to large counts.
    #    if { :set_char_to_string_expansion_token_if_found\
    #            token "${text}" } {
    #        # Desired length *AFTER* repeating such string below. See
    #        # get_string_ansiless_length_printable() for further details.
    #        integer length=$(( count * ${(m)#text} ))
    #
    #        # Repeat such string. Since such string's length is guaranteed to divide
    #        # the total length computed above, repeating such string in either a
    #        # rightmost (i.e., ${(r...):-}) or leftmost (i.e., ${(l...):-}) manner
    #        # produces the same result. For orthogonality with related functionality
    #        # (e.g., :set_string_to_string_padded_to_length()), repeat in a
    #        # rightmost manner.
    #        eval ':string.output ${(r'${token}${length}${token}${token}${text}${token}'):-}'
    #    }
    #
    # Unfortunately, such parameter expansion flags fail to account for non-
    # printable ANSI escape sequences when calculating such length, rendering
    # such technique erroneous for strings containing such sequences. While the
    # prior conditional *COULD* be improved to detect such strings and avoid
    # applying such technique to such strings, the cost of such detection and
    # the necessity of finding a suitable parameter expansion token quickly
    # overwhelms any efficiency gains of the technique itself.
    #
    # Instead, implement printf()-based repetition.

    # For safety, escape printf()-reserved percent signs in such string. For
    # efficiency, inline such implementation. See escape_string_for_printf() for
    # further details.
    printf -- "${text//\%/%%}%.0s" {1..${count}}

    # Since printf() appends no newline by default, do so.
    :output_newline
}

#FIXME: In lieu of unit tests...
#function baso() {
#    repeat_string "${ZESHY_STYLE_TO_COLOR[color.red]}bo${ZESHY_STYLE_TO_COLOR[color.white]}lo" 7
#}

# --------------------( WASTELANDS                         )--------------------
    # If such count is 0, return the empty string. This isn't simply a trivial
    # edge-case optimization; all of the implementations below assume a
    # positive count. The printf()-based implementation, for example, actually
    # repeats the desired string twice rather than printing the empty string
    # when passed a count of 0.
#   (( count )) or report_success

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with :set_string_to_string_padded_to_length().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # If such text does *NOT* contain at least one parameter expansion token,
    # prefer token- to printf()-based repetition. The latter expands the
    # expression "{1..${count}}" to ${count} number of integer arguments as
    # well as requiring command substitution and hence fails to efficiently
    # scale to large counts.
#    if { :set_char_to_string_expansion_token_if_found\
#            token "${text}" } {
#        integer text_length result_length
#
#        # Length of such string excluding ANSI escape sequences.
#        :set_int_to_string_length_printable text_length "${text}"
#        
#        # Desired length *AFTER* repeating such string below.
#        result_length=$(( count * text_length ))
#        print "text: ${text}; text length: ${text_length}; result length: ${result_length}"
#
#        # Repeat such string. Since such string's length is guaranteed to divide
#        # the total length computed above, repeating such string in either a
#        # rightmost (i.e., ${(r...):-}) or leftmost (i.e., ${(l...):-}) manner
#        # produces the same result. For orthogonality with related functionality
#        # (e.g., :set_string_to_string_padded_to_length()), repeat in a
#        # rightmost manner.
#        eval ':string.output ${(r'${token}${result_length}${token}${token}${text}${token}'):-}'

#       return_string "${ZESHY_ASCII_NEWLINE}"

# ....................{ SETTERS                            }....................
#FUXME: If any function begged for examples, this would be it.
#declare_function_with_stdin <<'/---'
#void :set_string_to_string_padded_to_length(
#    string string_name,
#    string padding,
#    integer length)
#
#Set the passed string variable to the passed padding repeated until producing a
#string of exactly the passed length. If such length is _not_ evenly divided by
#the length of such padding, the last repetition of such padding will be
#truncated on the right by as many characters as needed to guarantee producing a
#string of exactly the passed length.
#/---
#function :set_string_to_string_padded_to_length() {
#    # Validate sanity.
#    die_unless_args_3\
#        'Expected one string name, one padding string, and one length.'
#    string\
#        string_name__sstsptl="${1}"\
#        padding__sstsptl="${2}"\
#        length__sstsptl="${3}"
#    die_unless_string_nonempty\
#        "${padding__sstsptl}" 'Expected nonempty padding.'
#    :die_unless_int_nonnegative "${length__sstsptl}"
#
#    # If such padding's length evenly divides such length, life is simple.
#    if (( length__sstsptl )) {
#    }
#}
