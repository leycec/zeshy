#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle newline-delimited strings.
/---

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: bool] is_string_line(string text, string line)

Report success if the passed string contains the passed line: e.g.,

.is_string_line()
==========================================
[source]
------------------------------------------
>>> :string on_right_causes=\
...    "Don't look for media-approved ideologically sound Right Causes where
...     there are none. Look out of the window instead, and do something about
...     what you see there."
>>> is_string_line "${on_right_causes}" "what you see there." or output_string\
...     "Never trust anything that bleeds for four days but doesn't die."
Never trust anything that bleeds for four days but doesn't die.
------------------------------------------
==========================================
/---
function is_string_line() {
    # Validate sanity.
    die_unless_args_2 'Expected one string and one line.'

    # Test such string. Dismantled, this is:
    #
    # * "(|*...)", matching either the start of the string or a newline.
    # * "(|...*)", matching either the end of the string or a newline.
    #
    # To avoid string copies, inline such test.
    is "${1}" == (*${ZESHY_ASCII_NEWLINE}|)"${2}"(${ZESHY_ASCII_NEWLINE}*|) si
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_string_line(string text, int line_number)

Get the line with the passed (possibly negative) 1-based line number from the
passed string: e.g.,

.get_string_line()
==========================================
[source]
------------------------------------------
>>> :string on_forced_labor=\
...    "When I say I want to abolish work, I mean just what I say, but I want to
...     say what I mean by defining my terms in non-idiosyncratic ways. My
...     minimum definition of work is forced labor, that is, compulsory
...     production. Both elements are essential. Work is production enforced by
...     economic or political means, by the carrot or the stick. (The carrot is
...     just the stick by other means.) But not all creation is work. Work is
...     never done for its own sake, it's done on account of some product or
...     output that the worker (or, more often, somebody else) gets out of it.
...     This is what work necessarily is. To define it is to despise it. But
...     work is usually even worse than its definition decrees. The dynamic of
...     domination intrinsic to work tends over time toward elaboration. In
...     advanced work-riddled societies, including all industrial societies
...     whether capitalist or \"Communist,\" work invariably acquires other
...     attributes which accentuate its obnoxiousness."
>>> get_string_line "${on_forced_labor}" 1
When I say I want to abolish work, I mean just what I say, but I want to
------------------------------------------
==========================================
/---
function get_string_line() {
    # Validate sanity.
    die_unless_args_2 'Expected one string and one line number.'
    :string text="${1}" line_number=${2} glob_line
    :die_unless_int_nonzero "${line_number}"

    # If such line number is positive, get such line by matching without
    # capturing the required number of prior newlines and then capturing the
    # next line into ${match[1]}. (This is more efficient than list splitting.)
    if (( line_number > 0 )) {
        # Glob matching a single line.
        glob_line="[^$'\n']#"

        # Match the desired line or throw an exception if no such line exists.
        :is_string_matches_glob\
            (${glob_line}${ZESHY_ASCII_NEWLINE})(#c${line_number})${ZESHY_GLOB_ENABLE_CAPTURING_GROUPED}(${glob_line})* or
            die 'String "'$(truncate_string_readable: "${text}")'" contains no line '${line_number}'.'

        # Get such line.
        return_string "${match[1]}"
    # Else, such line number is negative. Applying the prior technique would
    # require first counting the number of lines in such string and then
    # converting the passed line number from negative to positive, reducing the
    # efficiency of such technique. Instead, just split such list.
    } else {
        # Split such string into lines.
        list lines; set_list_to_string_lines lines "${1}"
        die_unless_list_index lines "${line_number}"\
            "string \"$(truncate_string_readable: "${text}")\" contains no line ${line_number}"

        # Get such line.
        return_string "${lines[${line_number}]}"
    }
}

declare_function_with_stdin <<'/---'
string get_string_lines(
    string text, integer start_line_number, integer end_line_number)

Get all lines inclusively between the passed (possibly negative) 1-based line
numbers from the passed string: e.g.,

.get_string_lines()
==========================================
[source]
------------------------------------------
>>> string on_monoculture=\
...    "That's what a monoculture is. It's everywhere, and it's all the same.
...     And it takes up alien cultures and digests them and shits them out in a
...     homogenous building-block shape that fits seamlessly into the vast blank
...     wall of the monoculture. This is the future. This is what we built. This
...     is what we wanted. It must have been. Because we all had the fucking
...     choice, didn't we? It is only our money that allows commercial culture
...     to flower. If we didn't want to live like this, we could have changed it
...     any time, by not paying for it. So let's celebrate by all going out and
...     buying the same burger."
>>> get_string_lines "${on_monoculture}" -8 -7
homogenous building-block shape that fits seamlessly into the vast blank
wall of the monoculture. This is the future. This is what we built.
------------------------------------------
==========================================
/---
function get_string_lines() {
    # Validate sanity.
    die_unless_args_3\
        'Expected one string, one start line number, and one end line number.'
    string line_number_start="${2}" line_number_end="${3}"
    list lines

    # Split such string into lines. While this certainly could be implemented by
    # glob matching as under get_string_line(), it's uncertain whether that
    # would actually be any faster than this.
    set_list_to_string_lines lines "${1}"
    die_unless_list_range lines "${line_number_start}" "${line_number_end}"

    # Join the desired lines back into a string. Do *NOT* quote such expansion.
    join_strings_on_newline ${lines[${line_number_start},${line_number_end}]}
}

# ....................{ GETTERS ~ count                    }....................
declare_function_with_stdin <<'/---'
integer get_string_line_count(string text1, string text2, ...)

Get the total number of lines in the passed strings: e.g.,

.get_string_line_count()
==========================================
[source]
------------------------------------------
>>> :string on_candidates=\
...    "I always thought people were essentially bright. Distracted, sure, and
...     weak, and beaten, but never stupid. And then you show them, here's the
...     two people who want to be president. One is evil, but you can deal with
...     him, because he actually harbors beliefs. The other one will tell any
...     lie, wear any mask, to become president, and not only that, he fucking
...     hates you, and he's doing this just so he can make your lives hell. And
...     who do you think they vote for? Stupid."
>>> get_string_line_count "${on_candidates}"
7
------------------------------------------
==========================================
/---
function get_string_line_count() {
    # Validate sanity.
    die_unless_args 'Expected one or more strings.'
    :list lines
    :int line_count

    # List of all lines split from such string(s).
    set_list_to_string_lines lines "${*}"

    # Number of such lines.
    :set_int_to_list_size line_count lines

    # Get such number.
    output_string "${line_count}"
}

# ....................{ NUMBERERS                          }....................
#FIXME: Poor nomenclature. Such functions will be rarely called and hence
#should be accessible as either getters or converters -- say,
#get_string_lines_numbered() (which coincides fairly nicely with existing
#get_string_line() nomenclature.
declare_function_with_stdin <<'/---'
string number_string_lines(string text1, ...)

Prefix each line of the passed strings with such line's number.
/---
function number_string_lines() {
    die_unless_args 'Expected one or more strings.'
    output_string "${@}" |
        run_code_with_options 'run_code_paged command nl' ZESHY_OPTIONS_NL
}

#FIXME: Rename to number_string_lines_highlighting_line().
declare_function_with_stdin <<'/---'
string number_string_lines_highlighting(
    string text, integer highlight_line_index)

Prefix each line of the passed string with that line's number and highlight
the passed line number. Since `nl` supports no highlighting, this function
accepts no `nl`-specific options.
/---
function number_string_lines_highlighting() {
    # Validate sanity.
    die_unless_args_2 'Expected one string and one line number.'
    string text="${1}" line_index="${2}"
    integer line_count
    :die_unless_int_positive "${line_index}"

    #FIXME: Actually, it's trivial to convert negative to positive line numbers.
    # Validate sanity. Negative line numbers are impermissible.
    line_count="$(get_string_line_count "${text}")"
#   print_message "line length: ${line_count}"
    (( 1 <= line_index && line_index <= line_count )) or
        die "line number ${line_index} not in [1, ${line_count}]"

    #FIXME: Convert to zeshy. "awk" dependencies are simply awkward.
    # Number lines.
    output_string "${text}" | awk -vNRHI=${line_index} '
# If any line other than the highlight line, print the current line number
# followed by the line.
NR != NRHI { printf("%6d%7s%s\n", NR, "", $0) }
# If the highlight line, print the current line number prefixed and suffixed by
# pleasing ASCII arrows. (See curse_call_stack() for similar logic.)
NR == NRHI {
    # Number of digits in the current line number.
    NRLEN = length(NR);
         if (NRLEN==1) {NRNOW = " <-~ " NR}
    else if (NRLEN==2) {NRNOW = "<-~ " NR}
    else if (NRLEN==3) {NRNOW = "<- " NR}
    else               {NRNOW = NR}       # if true, your string is horrid.
    printf("%s ~->   %s\n", NRNOW, $0)
}'
}

# ....................{ REMOVERS                           }....................
declare_function_with_stdin <<'/---'
string remove_string_line_duplicates(string text1, string text2, ...)

Remove all duplicate lines from the concatenation of the passed strings.
Unlike conventional solutions (e.g., `sort -u`, `sort | uniq -u`), this
function preserves the line order of returned lines: e.g.,

.remove_string_line_duplicates()
==========================================
[source]
------------------------------------------
>>> remove_string_line_duplicates\
...    "the Perfect
...     and
...     the Perfect
...     are one Perfect
...     and not two;
...     nay, are none!"
the Perfect
and
are one Perfect
and not two;
nay, are none!
------------------------------------------
==========================================
/---
function remove_string_line_duplicates() {
    # Split passed strings into lines, remove duplicate lines, and join all
    # remaining lines back into a newline-delimited string. Dismantled, this is:
    #
    # * "f", splitting passed strings into lines.
    # * "u", excluding duplicate lines.
    die_unless_args 'Expected one or more strings.'
    join_strings_on_newline "${(uf)*}"   # this... this is ridiculous
}

# ....................{ ITERATORS                          }....................
declare_function_with_stdin <<'/---'
string for_string_lines(
    string text,
    string line_string_name = 'LINE',
    string command)

Run the passed command for each line of the passed string, capturing such line
into the passed local string variable (defaulting to ${LINE}): e.g.,

.for_string_lines()
==========================================
[source]
------------------------------------------
>>> string on_little_men=\
...    "Because you have no memory for things that happened ten or twenty years
...     ago, you're still mouthing the same nonsense as two thousand years ago.
...     Worse, you cling with might and main to such absurdities as 'race,'
...     'class,' 'nation,' and the obligation to observe a religion and repress
...     your love."
>>> for_string_lines "${on_little_men}"\
...     ':is_string_matches_glob "${LINE}" *"you "* and output_string "${LINE}"'
Because you have no memory for things that happened ten or twenty years
Worse, you cling with might and main to such absurdities as 'race,'
------------------------------------------
==========================================
/---
function for_string_lines() {
    # Validate sanity.
    die_unless_args_2_to_3\
        'Expected one string, optional line string name, and one command.'
    :string text__fsl="${1}" string_name_line__fsl='LINE' command__fsl="${@[-1]}"
    :int length__fsl
    die_unless_string_nonempty "${command__fsl}" 'Expected nonempty command.'

    # If such variable name was passed, localize such name.
    if { is_args_3 } {
        string_name_line__fsl="${2}"
    }
    :die_unless_var_name "${string_name_line__fsl}"

    # Currently matched line.
    :string ${string_name_line__fsl}

    # Byte length of such string.
    :set_int_to_string_byte_count length__fsl "${text__fsl}"

    # If the string is sufficiently short, splitting such string on newlines
    # into a list of string lines *BEFORE* iterating such lines more
    # efficient than dynamically iterating PCRE line matches. While the latter
    # avoids both the space and time costs of splitting a string into a list,
    # the cost of PCRE line matching overwhelms such costs on "short" strings.
    #
    # Pending further tests, consider strings under 16KB to be short.
    if (( length__fsl <= 16000 )) {
        # List of all lines split from such string.
        :list lines__fsl
        :set_list_to_string_lines lines__fsl

        # Iterate such list and hence such lines.
        eval 'for '${string_name_line__fsl}' ("${lines__fsl[@]}") {
            '${command__fsl}'
        }'
    # Else, dynamically iterate PCRE line matches.
    } else {
        # PCRE matching implicitly captures each match (i.e., line) to ${MATCH}.
        for_string_text_matching_pcre_multiline: "${text__fsl}" '^.*$'\
            ${string_name_line__fsl}'="${MATCH}"
        '${command__fsl}
    }
}

# --------------------( WASTELANDS                         )--------------------
#       output_string "for_string_lines (short text):${ZESHY_ASCII_NEWLINE}${eval__fsl}"
        # eval "${eval__fsl}"
#       output_call_stack
        # :string eval__fsl=${line_string_name__fsl}'="${MATCH}"
        # '${command__fsl}
#       output_string "for_string_lines (long text):${ZESHY_ASCII_NEWLINE}${eval__fsl}"

 # For efficiency,
        # inline such splitting, evaluate the loop once rather than
        # on each loop iteration, and capture each line to ${MATCH}.
        # Split such string into lines and iterate such lines. For efficiency,
        # inline such splitting, evaluate the loop once rather than
        # on each loop iteration, and capture each line to ${MATCH}.

#FUXME: O.K.; this is really a general comment on "eval" statements, but this is
#the function in which the issue first arose. When zsh encounters a parse error
#in such statements, it simply prints a context-less line to stderr resembling:
#
#    for_string_lines:19: bad math expression: illegal character: "
#
#Unsurprisingly, this is pretty much useless. Hence, we pretty much need to call
#run_code() rather than "eval". Then, we need to substantially improve the
#run_code() implementation to instead tee stderr to a string local and,
#after executing such command, test such local. If such local is nonempty and
#matches the following glob pattern:
#
#    ($'\n'|)"$(get_caller):"(#b)(<->##)': '([^$'\n']##)"($'\n'|)
#
#Then ${match[1]} supplies the failing line number and ${match[2]} the error
#message. Since such line number is relative to the caller function rather than
#"eval" statement by default under zsh, run_code() needs to locally disable
#shell option "EVAL_LINENO" for the duration of such "eval" statement, ensuring
#such line number is relative to the "eval" statement instead. Naturally,
#replace $'\n' with ${ZESHY_ASCII_NEWLINE}.
#
#If such glob matches, throw a well-formatted exception, calling
#number_string_lines_highlighting(). (Not the best nomenclature, incidentally.)
#FUXME: Hmm. If the zsh parser behaves sensibly, any syntax error should be
#caught... Interesting. O.K.; I tested this. As expected, zsh reports top-level
#syntax errors before executing anything: e.g.,
#
#    >>> eval '
#    ...     print ko 1>&2
#    ...     [[ "ohoh" == "hoho" ]] or print "okok" 1>&2'
#    (eval):3: condition expected: ===
#    TRAPZERR() failed with exit status 1
#     TRAPZERR() { /bin/zsh: 22 }
#
#Note the "ko" is *NOT* printed. However, zsh reports sub-level syntax errors
#(e.g., glob errors) at the actual point of execution: e.g.,
#
#    >>> eval '
#    ...     print ko 1>&2
#    ...     [[ "ohoh" == (#zzz)"hoho" ]] or print "okok" 1>&2'
#    ko
#    (eval):3: (eval):3: bad pattern: (#zzz)hoho
#    TRAPZERR() failed with exit status 1
#     TRAPZERR() { /bin/zsh: 22 }
#
#Hence, the prior regular expression is substantially correct: an invalid syntax
#error may be raised at any point.
#FUXME: When implementing the above approach, it'd be nice to get the
#redirection right. First, I'll note that we should redirect the eval() call
#rather than the evaluated code to stderr. But that doesn't quite get us there.
#Ideally, ... oh, heck. It's probably the best we can do without going into the
#coprocess zone though, isn't it?
#FUXME: O.K.; we probably don't want to impose such logic on *EVERY* run_code()
#call. While such logic is demonstrably great, it's somewhat inefficient as well
#as (more importantly) requiring capturing stderr from a command executed in the
#current shell -- which, as we well know, requires the coprocess. Hence, we want
#a new function run_code_validated() (or some such) itself calling
#run_code_and_set_string_to_stderr() and then matching on the contents of such
#string variable.
#FUXME: run_code_validated() is decent, but how about...
#FUXME: Interesting. While I still admit the prior idea to be relevant, it's not
#quite as relevant as it otherwise could be. Why? Because zsh *ALREADY* signals
#SIGZERR() for pretty much every syntax error I tested with only one exception.
#Guess the exception! That's right, the very cause of this entire line of
#reasoning: double-quotes in math expressions. Given the heavyweight nature of
#this idea, it hardly seems reasonable to implement such logic merely to catch
#such errors, particularly when zsh guaranteeably catches everything else. Pass
#for now, I should think.

#...    "This is what we wanted. It must have been. Because we all had the
#...     fucking choice, didn't we? It is only our money that allows commercial
#...     culture to flower. If we didn't want to live like this, we could have
#...     changed it any time, by not paying for it. So let's celebrate by all
#...     going out and buying the same burger."
#>>> get_string_line "${on_commerce}" -1
#going out and buying the same burger

        #FUXME: We replicate the above truncate_string() behavior on numerous
        #exceptions. Replace with calls to a new
        #function truncate_string_for_exception_message().
    # While splitting such string into a list of lines and then indexing such
    # list by such number is certainly feasible, it's also rather inefficient.
    # Instead, get such line by matching without capturing the required number
    # of prior newlines and then capturing the next line into ${match[1]}.
#   get_string_lines "${1}" ${line_index} ${line_index}
#If positive, this is the nth line from the beginning starting at 1. Conversely
#if negative, this is the nth line from the end starting at -1.
#, such that:
#
#* Such line is preceded either by a newline or the start of such string.
#* Such line is followed either by a newline or the end of such string

#...     You had your choice between soaring to superhuman heights with Nietzsche
#...     and sinking into subhuman depths with Hitler. You shouted Heil! Heil!
#...     and chose the subhuman. You had the choice between Lenin's truly
#...     democratic constitution and Stalin's dictatorship. You chose Stalin's
#...     dictatorship... You had your choice between Marx's insight into the
#...     productivity of your living labor power, which alone creates the value
#...     of commodities and the idea of the State. You forgot the living energy
#...     of your labor and chose the idea of the State. In the French Revolution,
#...     you had your choice between the cruel Robespierre and the great Danton.
#...     You chose cruelty and sent greatness and goodness to the guillotine. In
#...     Germany you had your choice between Goring and Himmler on the one hand
#...     and Liebknecht, Landau, and Muhsam on the other. You made Himmler your
#...     police chief and murdered your great friends. You had your choice
#...     between Julius Streicher and Walter Rathenau. You murdered Rathenau. You
#...     had your choice between Lodge and Wilson. You murdered Wilson. You had
#...     your choice between the cruel Inquisition and Galileo's truth. You
#...     tortured and humiliated the great Galileo, from whose inventions you are
#...     still benefiting, and now, in the twentieth century, you have brought
#...     the methods of the Inquisition to a new flowering."
# for use by such command
#   append_stdin_piped_to_args
    # Validate sanity. treating piped input as the passed string.
#   string __error_message__='expected one list name and one string'\
#       __text__ list_name
#   if :is_stdin_pipe; then
#       die_unless_arg "${__error_message__}"
#       set_string_to_stdin_piped __text__
#       list_name="${1}"
#   else
#       die_unless_args_2 "${__error_message__}"
#       list_name="${1}"
#       __text__="${2}"
#   fi

    # Split such string.
#   set_list_to_evaluation ${list_name} '${(f)__text__}'
#   string text="${1}" line="${2}"
#   is "${text}" == (|*$'\n')"${line}"(|$'\n'*) si
    # Validate sanity. treating piped input as the passed string.
#   string text line error_message='expected one string and one line'
#   if :is_stdin_pipe; then
#       die_unless_arg "${error_message}"
#       set_string_to_stdin_piped text
#       line="${1}"
#   else
#       die_unless_args_2 "${error_message}"
#       text="${1}"
#       line="${2}"
#   fi

#   die_unless_args_2_to_3\
#       'expected one string, one first glob, and optional next glob'
    # Avoid naming the local string "lines" to avoid dynamic scope conflicts
    # with caller lists also named "lines". (O, how this hath bitten me hard.)
#       __text__="$(get_stdin_piped)"
    #FUXME: Can we use a "noop ${(P)list_name::=( ${(f)text} )}"-style
    #technique here? I suspect not, but it does beg the question...
#   die_unless_list "${list_name}"
#   print_string "text: ${text}"
#   eval "${list_name}:always( \${(f)__lines__} )"

# string get_first_lines(string text, int last_line_index = 1)
#
# Get the first n lines (defaulting to the first line) from the passed string.
#function get_first_lines() {
#    die_unless_args_1_to_2\
#        'expected one string and optional last line number'
#    get_string_lines "${1}" 1 ${2:-1}
#}

# string get_last_lines(
#   string text, int last_line_index = $(get_string_line_count string))
#
# Get the last n lines (defaulting to the last line) from the passed string.
#function get_last_lines() {
#    die_unless_args_1_to_2\
#        'expected one string and optional last line number'
#    string text="${1}" line_length
#    line_length="$(get_string_line_count "${text}")"
#    get_string_lines "${text}" ${2:-${line_length}} ${line_length}
#}
