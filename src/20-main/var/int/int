#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

#FIXME: Copy the integer-specific caveats in "doc/README.dev" here, to be
#incorporated into zeshy's formal documentation.

declare_parcel_as_script_with_stdin <<'/---'
Handle core integer functionality.

== Caveats ==

As `doc/README.dev` discusses, integer variables suffer numerous deficiencies,
including forced casting of non-integer types to 0 _and_ forced rounding down
of float types without error or warning. Since string variables suffer no such
deficiencies and implicitly support integer values, consider declaring integers
to be of type string instead. In either case, this component seemlessly handles
integer values and hence both types.
/---

# ....................{ GETTERS                            }....................
#FIXME: Refactor into setters.

declare_function_with_stdin <<'/---'
void get_integer_maximum(integer number1, ...)

Get the largest of the passed integers: e.g.,

.get_integer_maximum()
==========================================
[source]
------------------------------------------
>>> get_integer_maximum 4 8 15 16 23 42
42
------------------------------------------
==========================================
/---
function get_integer_maximum() {
    # Validate sanity.
    die_unless_args 'Expected one or more integers.'
    :die_unless_ints "${@}"

    # Dismantled, this is:
    #
    # * "(On)", sorting such integers in descending order.
    # * "[1]", returning the first such integer.
    :output_string "${${(On)@}[1]}"
}

declare_function_with_stdin <<'/---'
void get_integer_minimum(integer number1, ...)

Get the largest of the passed integers: e.g.,

.get_integer_minimum()
==========================================
[source]
------------------------------------------
>>> get_integer_minimum 4 6 8 10 12 14 16 18 20 22 24 26 28 30 36 38 42
4
------------------------------------------
==========================================
/---
function get_integer_minimum() {
    # Validate sanity.
    die_unless_args 'Expected one or more integers.'
    :die_unless_ints "${@}"

    # Dismantled, this is:
    #
    # * "(on)", sorting such integers in ascending order.
    # * "[1]", returning the first such integer.
    :output_string "${${(on)@}[1]}"
}

# ....................{ CONVERTERS                         }....................
#FIXME: Rename to :localize_int(). This is reasonably important, as we'll be
#adding different forms of integer localization (e.g.,
#:localize_currency()).
#FIXME: Refactor such function to operate on a passed integer variable in-place.

# If:
#
# * GNU printf() is available, defer to such command, efficiently implementing
#   such conversion with proper localization. ("Solid gold, mate.")
# * Else, implement such conversion in pure zsh.
:declare_func_if_or_noop\
    'string convert_integer_to_string_localized(int number)'\
    'die_unless_arg "Expected one integer."
     :string number="${1}"
     :die_unless_int "${number}"'\
    'is_pathable_gnu printf' 'command printf "%''d\n" "${number}"'\
    ':else' '
        # Thousandths separator specific to the current locale.
        :string separator
        separator="$(get_locale_delimiter_thousands)"

        # Reverse such integer as a string.
        number="$(reverse_string "${number}")"

        # Suffix every set of three digits with such separator.
        number="${x//(#b)([0-9](#c3))/${match[1]}${separator}}"

        # If the number of digits in such integer is a multiple of three, the
        # prior replacement appended an superfluous separator. Excise it.
        remove_string_suffix number "${separator}"

        # Reverse such string back into an integer.
        reverse_string "${number}"' <<'/---'
Localize the passed integer into a human-readable string specific to the current
locale. For English locales, this comma-separates thousandths places: e.g.,

.convert_integer_to_string_localized()
==========================================
[source]
------------------------------------------
>>> convert_integer_to_string_localized $(round_float $((4.54 * 10**9)))
4,540,000,000
------------------------------------------
==========================================
/---

# --------------------( WASTELANDS                         )--------------------
# Such functions are either not required at the top-level or call functions
# unavailable at such level and hence do not reside in the prior parcel of the
# same name.

    # the first such integer.
    # If the passed number of arguments is sufficiently small, explicitly
    # searching such integers for the maximum is more efficient than forking a
    # "sort" process sorting such integers in descending order and and returning
    # the first such integer.
    #
    # Ideally, zsh itself would offer some means of 
    # While sorting such integers and returning the first
    # such integer would offer an optimal implementation, zsh currently only
    # supports sorting of nonnegative integers.
    #
    # Since the passed integers may
    # contain negative integers, fall back to an explicit search.

#FUXME: Incorrect. *ALL* such functions should die unless the passed integer is
#actually an integer, as only that accords with caller expectations. Note
#interestingly that that also induces correct behavior when called by a
#die_unless_*() function (i.e., an exception is thrown, and in fact a more
#appropriately named exception). See "parity" below for what such
#implementations should resemble.

#FUXME: Rename to convert_integer_to_string_separated_by_commas().
#FUXME: Actually, this should be localized and hence renamed to
#convert_integer_to_string_localized(). Not all locales delimit with commas, as
#we well know. Come to think, this might *ALREADY* be localized in such fashion.
#Research what "awk" actually does with the "'" in "%'d".
    #FUXME: Localize this. Not terribly hard, since zsh module "localeinfo"
    #provides map value "${localeinfo[THOUSEP]}" providing such string.
#       print "${integer}" | awk "{ printf \"%'d\n\", \$1 }"
#   die_unless_arg 'expected one string'
#   is "${1}" == '-'<-> si   # mildly clever optimization
#   string integer_min="${1:-0}" integer_max="${2:-32767}"
#FUXME: Rename "_integer" to "_integer" everywhere.
# ....................{ TESTERS ~ value                    }....................
#FUXME: Bad. Accept string values rather than variable names, as is the standard
#for scalar types. Of course, in that case, we'd might as well just shift all
#"string/integer" functionality here, renaming "string_integer" to simply
#"integer" everywhere. *ACTUALLY, THAT SOUNDS LIKE A BLOODY BRILLIANT IDEA.*
#Make it so, ensign.
#declare_function '
#boolean :is_int_positive(string variable_name)
#
#Report true if the passed variable is an integer > 0.
#'
#function :is_int_positive() {
#    die_unless_arg 'expected one string'
#    string variable_name__iip="${1}"
#    :is_var_integer "${variable_name__iip}" and (( ${(P)variable_name__iip} > 0 ))
#}

#declare_function '
#boolean :is_int_nonnegative(string variable_name)
#
#Report true if the passed variable is an integer >= 0.
#'
#function :is_int_nonnegative() {
#    die_unless_arg 'expected one string'
#    string variable_name__iin="${1}"
#    :is_var_integer "${variable_name_iin}" and (( ${(P)variable_name__iin} >= 0 ))
#}

#FUXME: Excise.
#declare_function '
#void :die_unless_int_positive(
#  string variable_name,
##  string error_message = "\"${variable_name}\" not a positive integer")
#
#Throw an exception unless the passed variable is an integer > 0.
#'
#function :die_unless_int_positive() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string variable_name__duip="${1}"
#    :is_int_positive "${variable_name__duip}" or
#        die "${2:-\"${variable_name__duip}\" not a positive integer}"
#}

#FUXME: Excise.
#declare_function '
#void :die_unless_int_nonnegative(
#  string variable_name,
#  string error_message = "\"${variable_name}\" not a nonnegative integer")
#
#Throw an exception unless the passed variable is an integer >= 0.
#'
#function :die_unless_int_nonnegative() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string variable_name__duin="${1}"
#    :is_int_nonnegative "${variable_name__duin}" or
#        die "${2:-\"${variable_name__duin}\" not a nonnegative integer}"
#}

#FUXME: This now strikes me as rather wrong. Lists and maps are a reasonable
#rule to nomenclature rules as they can only be accessed by named; integers,
#floats, and other scalar types however are always accessible by their expanded
#values. Consequently, it strikes me as *MUCH* more intuitive to rename
#:die_unless_int() and :is_int() to :die_unless_var_integer() and
#:is_var_integer(). Then excise the :is_int_*() functions; they're
#superfulous, really. Replace them with calls to similar :is_int_*()
#functions -- *WHICH BY THE WAY SHOULD THEMSELVES BE RENAMED BACK TO
#:is_int_*() BUT STILL OPERATE ON EXPANDED STRING SCALARS* and probably
#consequently shifted back into this component.
#
#O.K.; so, we have two nomenclature styles insofar as variables are concerned:
#
#* Scalar-specific functions accepting typeless scalar values.
#* Non-scalar-specific functions accepting typed variable names.
#
#This is perfectly fine and in fact necessary. But don't confuse the two. Stay
#consistent. Let's fix this up, eh? We should document this design decision
#somewhere -- it's rather core.
#FUXME: Actually, consistency *ABSOLUTELY* takes precedence. Ignore all of the
#above.

# (i.e., constrained to natural numbers and
# negatives of such numbers)
