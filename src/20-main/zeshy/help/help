#!/usr/bin/env zsh
# ====================[ help                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle `zeshy` help documentation.
/---

#FIXME: Naturally, AsciiDoc will be an only optional dependency for users
#attempting to build the documentation. If not installed, we'll just display
#function documentation as is when a user runs "help function". If installed,
#we'll probably want to pipe function documentation dynamically through either
#the ASCII or man page exporters. (Sweeeeeet, no?)
#FIXME: Source code highlighting is simple. Just write:
#
#    [source,bash]
#    ----
#    INSERT CODE HERE
#    ----
#
#Sadly, neither Pygments or other less popular alternatives support zsh yet.
#Hence, "bash" suffices. Then, we want to selectively prefer "pygments" where
#available. To do so, we'll need to output the following at the very top of each
#AsciiDoc document we send to "asciidoc":
#
#    8<---------------
#    = Title
#    :source-highlighter: pygments
#
#This is an AsciiDoc header instructing "asciidoc" to prefer the "pygments"
#backend for the [source] filter. For further details, see:
#    https://groups.google.com/forum/?fromgroups=#!topic/asciidoc/ReIM4z-zi9I
#FIXME: Avoid repetition. In particular, replace "[source,bash]" with simply
#"[source]" everywhere by setting the default "language" in the AsciiDoc
#document header, like so:
#
#    :language: bash
#
#The same style can be extended to set default table attributes as follows:
#
#    :grid:  none
#    :frame: topbot

#FIXME: See related comment containing the sentence
#"How does segregating such setters to such digest help us?" in
#@{00-declare/10-function}, providing an additional important optimization to
#the excellent technique documented above. (Basically, define *ALL* such
#functions as setters segregated to a documentation-specific digest file. Cool!
#Such digest then in effect becomes an on-disk, read-only map for documentation.)

#FIXME: O.K.; help strings should be documented in zsh's built-in run-help
#format, printed by typing <Esc-h>. This appears to involve "perl", but I can't
#quite be sure yet. See the preamble for "man zshcontrib." O.K.; there's a perl
#script at "/usr/share/zsh/5.0.0/Util/helpfiles" run like so:
#      man zshbuiltins | colcrt - | helpfiles
#That (somehow) splits apart the manpage subsection specific to each zsh builtin
#into a help file for such builtin subsequently accessed when typing <Esc-h>.
#Interestingly, <Esc-h> is bound by default in the ZLE to run a function
#run-help(). So, replacing such function with a Zeshy-specific function suffices
#to implement such help. The perl script above provides a helpful default
#implementation for such function. It'd be nice to redefine this script as
#pure-Zeshy, honestly. It's not terribly heavy-weight: only about 100 lines of
#genuine line parsing code, all readily Zeshifiable. Since speed is not an issue
#(we only need to slurp "man zshbuiltins" once on every zsh update -- right; so,
#we'll need a bit of caching, I suppose), it's !very doable.
#FIXME: Hmm; scratch that. For the moment, just rely on "helpfiles". We'll still
#need to implement caching ourselves, but that's no worry.
#FIXME: Woops! Obviously, <Esc-h> doesn't work under Vi[M] emulation. We can
#still test it as root, but... Hmm. We'll need to selectively redefine such
#binding under such emulation. *sigh*
#FIXME: O.K.; I'd love to implement this, but it's all a bit heavy for the
#moment. Just push on ahead with the current implementation, keeping in mind
#that it would be helpful to eventually support run-help().
#FIXME: However, I'll note that this is all a bit overkill, for the moment. We'd
#need to rewrite documentation in the "man" nroff format... hmm; wait. No; no
#documentation-rewriting required. The sample run-help() function above simply
#invokes "more" on individual files. Frankly, both "man" and "info" suck, so I'm
#disinclined to want to format documentation in their formats.  Fortunately, it
#looks like we won't need to!

# ....................{ PRINTERS                           }....................
#FIXME: Define print_alias_documentation() and print_global_documentation().
declare_function_with_stdin <<'/---'
string print_function_documentation(string function_name)

Print documentation for the passed function . If no previous call to
declare_function() defined such documentation, throw an exception.
/---
#FIXME: Actually implement me!
function print_function_documentation() {
    # O.K.; this works. I have no idea how fast it is, of course... but then, we
    # shouldn't really *NEED* this to be obscenely fast, because we only need this
    # when converting documentation to some human-readable format, which really
    # shouldn't happen terribly often.
    #
    # Note that the PCRE contains a placeholder empty match "()". This efficiently
    # works around a subtle PCRE or zsh bug: all optional capture groups except the
    # last are assigned an array value. The last such group if not matched, however,
    # is assigned no array value. Adding a placeholder match forces such group to
    # always be assigned an array value as well. *sigh*
    #
    # Note this is *OVERKILL* for every other list. For every other list, after
    # matching the entire list as a string simply compact delimiters down via
    #      string_list="${string_list//[[:space:]]#,[[:space:]]#/,}"
    # and then simply split such string on commas with
    #      list values; list=( "${(s:,:)string_list}" )
    # Very efficient. No need for manual iteration, unlike here. The above approach
    # doesn't work here, of course, due to the possibility of quote-embedded commas.
    #
    # Note also that we *MUST* segregate the parsing of documentation from the
    # handling of parsed data structures. We've accomplished this nicely here via
    # data structures; just make sure we do so elsewhere. The idea is to handle such
    # data structures after parsing in a manner corresponding to output requirements
    # (e.g., ANSI, PDF, HTML). Note that newlines must somehow be preserved when
    # outputting to terminals; this probably isn't *TOO* hard. Or...maybe it is. *sigh*
    # Hmm. We want to preserve *ALL* whitespace when outputting to terminals, actually.
    # That, or we need to handle wrapping manually (which might be a better idea, really).
    # The wrapping rules should be pretty deterministic, so, heck, why not? The alternative
    # (preserving whitespace) is a wicked problem, and I really can't be bothered.

    #local argstring='(integer siphon, character funnel, boolean testm)'
    #local argstring='(integer siphon="y,m", character funnel, boolean testm="ugh,)")'
    local regex_arg='([-_[:alnum:]]++)\s++([-_[:alnum:]]++)(?:\s*+=\s*+"([^"]*+)")?'
    local regex_comma='\s*+,\s*+'
    local regex_args='^\(((?:'${regex_arg}${regex_comma}')*)'${regex_arg}'(?:'${regex_comma}')?\)()$'

    # List of parsed arguments, each argument comprising three elements of such
    # list: the argument's type, name, and default value (or empty string if no
    # such value).
    local -a args

    # List of the last parsed argument.
    local -a args_last

    # Parse the last argument and capture the string of all arguments preceding
    # such argument, to be parsed iteratively below.
    [[ "${argstring}" =~ ${~regex_args} ]] && {
        for ((match_index=1; match_index <= ${#match}; ++match_index)) {
            print "match ${match_index}: ${match[${match_index}]}"
        }

        # Record the last parsed argument before overwriting ${match} below.
        args_last=( "${match[-4]}" "${match[-3]}" "${match[-2]}" )

    #   print "match: ${match[1]}"

        # Regex parsing a single argument followed by a similar placeholder group.
        pcre_compile "${regex_arg}${regex_comma}()"
        pcre_study

        # Iteratively parse all arguments preceding the last.
        local args_sans_last="${match[1]}"
        integer match_set_index=0
        local ZPCRE_OP='0 0'
        while { pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${args_sans_last}" } {
            print "match set ${match_set_index}:"
            for ((match_index=1; match_index <= ${#match}; ++match_index)) {
                print "match ${match_index}: ${match[${match_index}]}"
            }
            ((++match_set_index))

            # Record the current parsed argument before overwriting ${match} above.
            args+=( "${match[1]}" "${match[2]}" "${match[3]}" )
        }

        # At this point, ${args} and ${args_last} contain the desired strings.
        # Great!
        print "args: ${args[@]}"
        print "args (last): ${args_last[@]}"
        print "proof:"
        for ((match_index=1; match_index <= ${#args}; ++match_index)) {
            print "arg ${match_index}: ${args[${match_index}]}"
        }
    }
}

#FIXME: Actually, it'd be great to accept general object names: which is to say,
#*ALSO* accept global variable names. We document such variables and hence
#should expose such documentation via the same interface here. While runnables
#and variables occupy different zsh namespaces and hence could theoretically
#collide, no Zeshy runnables share the same name as a Zeshy variable; hence,
#searching for both is unambiguous here. That said, third-party Zeshy plugins
#could theoretically define poorly named runnables or variables contravening
#such standardization; so, conceivably we should search for and page both, much
#as we currently do for ebuild names and description.

declare_function '
string print_zeshy_help(string runnable_name)

Print help documentation for the passed Zeshy-specific runnable (i.e., Zeshy
alias or function).
'
function print_zeshy_help() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one runnable name'
    string\
        runnable_name="${1}" script_filename script_text\
        newline line_glob help_text
    die_unless_zeshy_runnable "${runnable_name}"

    # Get the absolute path of the Zeshy component defining such runnable.
    script_filename="$(get_zeshy_script_defining_runnable "${runnable_name}")"

    # Get the text contents of such component.
    script_text="$(get_file_text "${script_filename}")"

    # Newline character, abbreviated for ease of use.
    newline="${ZESHY_ASCII_NEWLINE}"

    # Glob matching any number of non-newline characters followed by a newline,
    # thus matching the rest of a line.
    line_glob="[^${newline}]#${newline}"

    # If such runnable is a function, collect such function's documentation.
    if :func.is "${runnable_name}"; then
        if is "${script_text}" ==\
            *${newline}${newline}('#'${~line_glob})#(#b)('# '[a-z_]##" ${runnable_name}("${~line_glob})(('#'${~line_glob})#)"function ${runnable_name}() {"* si
        #FIXME: It'd be *EXCEPTIONALLY* nice to colorize output.
        then help_text="${match[1]}${match[2]}"
        else die "${runnable_name}() undocumented, unfortunately"
        fi
    # Else such runnable is an alias; collect such alias' documentation.
    else
        #FIXME: Don't bother implementing me, yet; get function help working
        #first, please.
        noop
    fi

    #FIXME: Strip off substrings matching "^# " and "^#$" from each line. It'd
    #be great to define a new remove_string_line_prefix_matches() function, probably
    #leveraging a new remove_list_prefix_matches() function. Though, wouldn't a
    #slightly simpler remove_string_line_matches() function suffice?

    #FIXME: We should actually page such documentation normalized to the current
    #terminal width. "nroff" should help, no? Be nice to define a utility
    #function implementing repagination: perhaps called "paginate_string", yes?
    # Page such help documentation.
    page_string "${help_text}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: I somewhat of an epiphany concerning help documentation lookup recently.
#Previously, we'd intended to implement a filesystem-backed key-value store in
#pure zeshy. While such a construct would still be helpful, it's implementation
#will probably prove considerably more involved than originally expected.
#Moreover, such a construct turns out to be a bit of overkill in the case of
#documentation lookup, largely as such documentation *NEVER* changes after
#initial definition (although, of course, it would be helpful to support
#infrequent changes to documentation after initial definition).
#
#The epiphany is as follows: replace *ALL* existing help-centric map globals
#(e.g., ${ZESHY_FUNCTION_NAME_TO_HELP}) with dynamically constructed functions
#compiled to a *NEW* digest file "~/.zeshy/cache/digest/help.zwc" (or some
#such). For each prior key-value pair of such map, we construct exactly *ONE*
#such function "returning" that value on standard output. For example, if we had
#a prior key-value pair resembling:
#
#    ZESHY_FUNCTION_NAME_TO_HELP=(
#       ...
#       'wrap_string' 'Wrap passed strings to the width of the current terminal.'
#       ...
#    )
#
#...then such pair will be replaced with a new function as follows:
#
#    function :help:function:wrap_string() {
#       die_if_args
#       :output_string 'Wrap passed strings to the width of the current terminal.'
#    }
#
#So what's awesome about this? Innumerably many things. With a single stroke, we
#excise *ALL* such map globals and the need for overly error-prone key-value
#store support. Thanks to zsh's builtin support for efficient indexing of
#digest files *AND* for arbitrary characters in function names, we've
#effectively hijacked zsh digest files for use as highly efficient read-only
#*DATABASES*. We retain the on-disk nature of a key-value store and hence avoid
#the memory cost of needing to retain unaccessed help entries in memory, while
#dramatically simplifying the serialization of such entries to disk. Awesomely!
#
#Of course, since such files are read-only, extending such paradigm to writable
#keys basically falters. It can be done, of course, but both adding a new key
#and changing an existing key (signified by a function) in such digest requires
#deserializing all functions in such digest into memory, altering the effected
#function, and reserializing exactly such functions back to such digest. (All
#while ensuring such digest is locked to external writes, of course.)
#
#But writable help entries is neither a hard or soft requirement, here. It's
#just too sweet to pass up. Go, go, go-ooooo!

    #FUXME: Option printing is somewhat cumbersome and certainly repetitive. It
    #would be advantageous to abstract such printing into a series of arrays
    #iteractively parsed to dynamically construct such output. Probably easiest
    #to harvest the set of such options from actual output rather than the
    #implementation below, for obvious reasons!
    #FUXME: Actually, it'd be great to abstract this into a template callable by
    #third-party zeshy scripts for use in printing help usage. The great thing
    #about that is the consistency of output: all zeshy scripts including zeshy
    #itself would share the same help output format. In such case, perhaps
    #rename "print_zeshy_help_usage" everywhere to simply print_usage(), yes?
    #We'll have to contemplate the data structure format. It certainly won't be
    #simple, but should be as simple as possible.

# Define an interactive help system for publishing Zeshy documentation.
    #FUXME: Since we have the entirety of Zeshy at our disposal here, it would
    #be quite nice (not to mention appropriate) to colorify the output.
    # Colorize such usage.
#   string color_punctuation="${ZESHY_COLOR[grey_bold]}"
#   string\
#       color_help_title="${ZESHY_COLOR[grey_bold]}"\
#       color_help_colon="${ZESHY_COLOR[${ZESHY_COLOR_IGNORABLE}]}"\
#       color_help_description="${ZESHY_COLOR[white_bold_italic]}"\
#       color_command_name="${ZESHY_COLOR[cyan_bold]}"\
#       color_arg_brace="${ZESHY_COLOR[cyan]}"\
#       color_arg_name="${ZESHY_COLOR[cyan_bold]}"\
#       color_arg_ellipsis="${color_punctuation}"\
#       color_heading_title="${ZESHY_COLOR[magenta_bold]}"\
#       color_heading_colon="${color_punctuation}"\
#       color_option_dash="${ZESHY_COLOR[blue]}"\
#       color_option_name="${ZESHY_COLOR[blue_bold]}"\
#       color_option_equals="${ZESHY_COLOR[green]}"\
#       color_option_value="${ZESHY_COLOR[green_bold]}"\
#       color_option_comma="${color_punctuation}"\
#       color_option_description="${ZESHY_COLOR[white_italic]}"

#Consider renaming to simply print_zeshy_usage()
#FUXME: Woops. Turns out... this was all a bit of a c0ckup, including the
#current means with which we define alias, function, and global documentation.
#The core thrust of it is that Zeshy needs to formalize such documentation with
#one function call per Zeshy alias, function, and global to functions defined
#under "always/00-startup" associating the passed documentation with the passed
#alias, function, or global name: e.g.,
#
# string set_alias_documentation(string alias_name, string documentation)
# string set_function_documentation(string documentation)
# string set_global_documentation(string global_name, string documentation)
#
#Or ideally the more concise:
#
# string declare_alias(string alias_name, string documentation)
# string declare_function(string documentation) --OR--
# string declare_function(string function_name, string documentation)
# string declare_global(string global_name, string documentation)
#
#Note the function name needn't be passed, since it's readily parseable from
#the passed documentation.
#
#For alias and global names, we should *ADDITIONALLY* define convenience
#functions both defining and setting documentation for such aliases and globals
#in one fell swoop: e.g.,
#
# string list_global_export_documented(string documentation, string list_name)
# string string_global_export_documented(string documentation, string specifier)
#
#...where "specifier" is the typical "="-delimited variable typeset: e.g.,
#
#   string_global_export_documented 'Thisizniceglobal.' ZESHY_STRANG='Hmm.'
#
#We can't do this for functions, for obvious reasons. So, prefix all function
#definitions with a call to declare_function(), using a literal heredoc so as
#to avoid unwanted interpolation: e.g.,
#
#   declare_function <<'EOD'
#   string nice_function()
#
#   Oh.... what a nice function!
#   EOD
#   function nice_function() {
#       print 'This is all yer gettin'.'
#   }
#
#It's not quite Python's built-in support for docstrings, but, frankly, I've
#always felt such support to be extreme syntactic sugar anyway. The above
#method *ROCKS*: it's intuitive, it's concise, it's optional, and it still
#allows for conventional "#"-prefixed comments. Such comments won't be picked up
#as documentation, implying implementation-specific commentary can now be
#separated from function documentation without concern (e.g., "#FUXME" comments).
# * It seems fairly silly to reparse Zeshy scripts on each call to
#   print_zeshy_help(). Clearly, we should persist successfully parsed
#   documentation as a "map_global_export" to a script under "~/.zeshy/cache" --
#   perhaps entirely overwriting the map previously written to such script after
#   every successful parse? Hmm; actually, while that would probably work
#   perfectly fine as a first implementation, we would do considerably better to
#   simply append the newly parsed documentation as a new entry to such file.
#   That's actually quite straightforward... hmm; or is it? Yes! I think.
#   Using "${mapfile}", right? How about something resembling:
#   mapfile[${doc_cache_file}][-1]="\"${function_name}\" \"${(q)function_docs}\"
#)"
#   The idea here is to replace the suffixing ")" with the new entry. You know
#   what? This is overengineering. Probably more efficient and certainly
#   simpler to just overwrite such cache each time. *shrug* Let's ignore this
#   until it actually becomes a discernable bottleneck.
# * In any case, what's great about the cache idea is that we could (and *MUST*,
#   actually) seed such cache with initial values for synthesized functions
#   created during compilation that don't actually exist and hence can't be
#   tangibly parsed. See precompile_zeshy_functions() in "src/compile".
#   * *AH!* Wait. That would work, but it's terribly heavyweight; all we have to
#     do is define such functions with empty definitions in some placeholder
#     Zeshy script in the root overlay. Their only purpose is to provide
#     documentation; their empty definitions will be immediately overwritten by
#     precompile_zeshy_functions(). Yes... much cleaner.

#FUXME: The search algorithm for finding the exact documentation in a file
#corresponding to a function is actually not terribly hard:
#
#1. Find the function definition in such file. Assuming there exists only one
#   such definition, which there should, this is the first string matching
#   "^function ${function_name}\(\)$" in such file.
#2. If the line immediately preceding such definition matches "^# .*$", then:
#   a. Search backwards one line at a time, prepending each line to a list of
#      such lines *UNTIL* a line fails to match "^#( .*)?$".
#   b. Search forwards one line at a time starting at the line that fails to
#      match, shifting off each line that fails to match
#      "^# [a-z_]+ ${function_name}\(.*$" from such list *UNTIL* matching such
#      line.
#   c. Such list now contains the desired in-order documentation. Tad
#      complicated, but well within the scope of reasonable feasibility. Note
#      it's not safe to simply begin searching for the first line matching
#      "^# [a-z_]+ ${function_name}\(.*$" in the file, due to "#FUXME" comments,
#      "TODO" sections, and the fact that "# also that_function()." Also happens
#      to match.
#3. Otherwise, no documentation has been authored for such function yet. Throw
#   an exception.

#Open a Zeshy-fortified zsh shell with the passed OPTIONs. Source the optionally
#passed FILE as a Zeshy script passed the passed ARGUMENTs.
# ....................{ GETTERS                            }....................
#FUXME: Shift elsewhere -- perhaps a new "zeshy/script" component. Hmm;
#alternately, we could simply rename this to
#get_zeshy_runnable_script(). It's concise; I like it. (Not entirely sure a new
#component is warranted for merely one function... We're heavyweight enough!)

# string get_zeshy_script_defining_runnable(string runnable_name)
#
# Get the absolute path of the Zeshy component defining the passed runnable.
#function get_zeshy_script_defining_runnable() {
#    # Validate passed arguments.
#    die_unless_one_arg 'expected one runnable name'
#    string runnable_name="${1}"
#    die_unless_zeshy_runnable "${runnable_name}"
#
#    #FUXME: Implement map lookup here!
#    die 'implement me'
#}

#Even if zsh did, however, there exist no guarantees
#it is unclear whether requiring zsh be
#compiled with support for such store as an external Zeshy dependency
#Print the documentation previously associated with the passed function by a call
#to declare_function() call.

#Help options:
#  load zeshy by recursively sourcing the zeshy codebase
#                            rather than autoloading a (re)compiled digest file
    # Since we should never get here, throw an exception.
#   is_alias "${function_name}".
#   die "\"${runnable_name}\" neither an alias or function, unexpectedly"
