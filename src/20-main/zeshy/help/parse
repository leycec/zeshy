#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *documentation parsers* (i.e., functions parsing `zeshy`-specific help
strings).
/---

# ....................{ MAIN                               }....................
#FIXME: Nice PCRE, but we don't currently do anything with it. Perhaps
#globalize string local ${pcre_asciidoc} -- say, to ${ZESHY_ASCIIDOC_PCRE}.

() {
    # Function description. Ignore cross-references embedded in the following
    # AsciiDoc-specific passthrough syntactic constructs, which AsciiDoc and hence
    # zeshy ignores for parsing purposes:
    #
    # * "`"-delimited passthrough quotes.
    # * "pass:["- and "]"-delimited passthrough macros.
    # * "+++"-delimited passthrough macros.
    # * "$$"-delimited passthrough macros.
    # * "\n----"-delimited listing blocks.
    # * "\n...."-delimited literal blocks.
    # * "\n////"-delimited comment blocks.
    # * "\n++++"-delimited passthrough blocks.
    # * "\n[literal]"-prefixed literal paragraphs.
    # * "\n "- and "\n\t"-prefixed literal lines.
    #
    # Ignore cross-references embedded in the following AsciiDoc-specific anchored
    # syntactic constructs, which AsciiDoc anchors for subsequent cross-referencing
    # and hence should not themselves contain cross-references:
    #
    # * "\n."-prefixed block titles.
    local pcre_asciidoc_quote_backtick='\b`\N*?`\b'
    local pcre_asciidoc_macro_pass='pass:\[(?:\\\]|\N)*?\]'
    local pcre_asciidoc_macro_plus='\+\+\+\N*?\+\+\+'
    local pcre_asciidoc_macro_dollar='\$\$\N*?\$\$'
    local pcre_asciidoc_block_listing='-{4,}+\n.*?\n-{4,}+'
    local pcre_asciidoc_block_literal='\.{4,}+\n.*?\n\.{4,}+'
    local pcre_asciidoc_block_comment='/{4,}+\n.*?\n/{4,}+'
    local pcre_asciidoc_block_pass='\+{4,}+\n.*?\n\+{4,}+'
    local pcre_asciidoc_block_title_or_line_literal='(?:\.|[ \t]++)\N+'
    local pcre_asciidoc_paragraph_literal='^\[literal\]\n.*?(?:\n\n|\Z)'
    local pcre_asciidoc_cross_reference='((?:'${pcre_asciidoc_quote_backtick}'|\b(?:'${pcre_asciidoc_macro_pass}'|'${pcre_asciidoc_macro_plus}'|'${pcre_asciidoc_macro_dollar}')\b|^(?:'${pcre_asciidoc_block_listing}'|'${pcre_asciidoc_block_literal}'|'${pcre_asciidoc_block_comment}'|'${pcre_asciidoc_block_pass}'|'${pcre_asciidoc_block_title_or_line_literal}')$|'${pcre_asciidoc_paragraph_literal}'|.)*?)([$@]\{'${pcre_operable_name}'\}|(?:(alias|func):)?'${pcre_operable_name}'\(\))'
    local pcre_asciidoc_suffix='(.*)'
    local pcre_asciidoc='\s*+(.*)'
}

# ....................{ MAKERS                             }....................
:run_hook_on_zeshy_precompile precompile_zeshy_documentation

declare_function_with_stdin <<'/---'
void precompile_zeshy_documentation()

Compile help documentation before compiling `zeshy`\'s user digest file but
after sourcing the `zeshy` codebase and hence calling all relevant documentation
functions (e.g., declare_function()). For efficiency, serialize documentation
onto an on-disk key value store mapping alias, global, and function names to
previously declared documentation strings.
/---
function precompile_zeshy_documentation() {
    # Validate sanity.
    die_if_args
    string documentation

    # Make one key-value store for each type namespace.
#   make_key_value_store_dir "${ZESHY_USER_HELP_FUNCTION_DIR}"

    # Function attributes in both string and list format.
    string attrs_string
    list attrs

    # For each function documentation string, ...
    for documentation ("${ZESHY_CORE_HELP_FUNCTIONS[@]}") {
#       print "function_name: ${function_name}"
        # Strip prefixing and suffixing whitespace from such documentation.
        # Dismantled, this is:
        #
        # * "//", greedily removing all matched substrings.
        # * "(#s)", matching the start of such string.
        # * "(#e)", matching the end of such string.
        # * "[[:space:]]##", matching one or more whitespace characters.
        documentation="${documentation//((#s)[[:space:]]##|[[:space:]]##(#e))}"

        # If such documentation is prefixed by a function prototype, match the
        # relevant function name from such prototype. zsh permissively allows
        # function name declarations to be quoted and hence contain arbitrary
        # characters, necessitating a more lenient glob expression than liked.
        # Dismantled, this is:
        #
        # * "(#b)", capturing match groups into global list ${match}.
        # * "[[:space:]]#", matching optional whitespace.
        # * "([^'(']##)", matching function attributes into ${match[1]}.
        if [[ "${documentation}" ==\
            (#b)'{'[[:space:]]#([^'}']#)'}'* ]]; then

#        (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'(']##)'('* ]]; then
#        # Attempt to split such function name on " [or] " delimiters.
#        local    function_name__df="${match[1]}"
#        local -a function_names__df
#        function_names__df=( "${(s: [or] :)function_name__df}" )

            # Eliminate:
            #
            # * Optional whitespace surrounding commas (e.g., from " , " to ",").
            # * Optional trailing whitespace.
            attrs_string="${${match[1]//[[:space:]]#,[[:space:]]#/,}%%[[:space:]]##}"

            # Split the string of function attributes on commas.
            attrs=( "${(s:,:)attrs_string}" )

            # Apply each attribute to such function.
            for attr ("${attrs[@]}") {
                case "${attr}" {
                #FIXME: To set this, we clearly need to parse the list of function
                #names first. Do so above. This implies we really want one giant regular
                #expression *GLOBAL* matching everything in one go. Hopefully, we'll be
                #able to re-use such expression elsewhere (e.g., when producing output
                #documentation).

                # If "globbable", disable filename globbing for all arguments of
                # such function by defining an alias of the same name prefixing
                # such function by "noglob".
                globbable) ;;
#                   alias ${function_name}="noglob ${function_name}"
                *) print "function attribute \"${attr}\" unrecognized" 1>&2
                }
            }
        fi
    }
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Make key-value stores here. First, we'll need to add a new global
    #path to "src/if_config/zeshy"... O.K.; we've got the requisite globals. Now
    #we'll need a rudimentary working directory-based key-value store.
    #*ABSOLUTELY* create a new "always/zeshy/dot_dir" component handling such
    #operations. How about a function in such component entitled
    #remove_zeshy_dot_dir_subdir_files()? Such function should perform sanity
    #checks, including:
    #
    #* The passed subdirectory is *ACTUALLY* a subdirectory of the current
    #  user's Zeshy dot directory.
    #* Ah-ha! Here's the best check: we should forcefully change the mtime of
    #  both the subdirectory and all files in such subdirectory at the end of
    #  *THIS* function to the same mtime as the current Zeshy digest file.
    #  *ONLY* delete files with such mtime. Yes! That's great. Exceptionally
    #  safe. We'll probably want a corresponding function in
    #  "always/zeshy/dot_dir" to do so, perhaps named something like
    #  synchronize_zeshy_dot_dir_path_mtime() accepting only one
    #  argument -- the path whose mtime is to be synchronized. This function
    #  should, in turn, depend on a new "path/time" function accepting two
    #  paths -- a source path to get the mtime from and a target path whose
    #  mtime will be set to that of the former. Sweetness. How about
    #  :change_path_mtime_from_path()?
    #* Don't worry about matching only plain files -- just non-directory files
    #  suffices. The above checks are decently strong and should prevent all
    #  accidental mischief.
    #FUXME: O.K.; as I see it, there are a few means of accomplishing this:
    #
    #* The most reliable, but heavyweight, is to serialize to a separate file
    #  (say, "~/.zeshy/help/index") the set of all help-specific files and
    #  directories written to by the prior zeshy precompilation. Then, just
    #  iterate, remove all such files, and remove the "help/index" for safety.
    #** What's nice is that this generalizes to support *ANY* dot directory
    #   files. Ideally, we could create a global index... Hm. But that's a bit
    #   less helpful. With only a documentation-specific index, it's trivial to
    #   iterate and remove the set of all such files. Furthermore, it's also
    #   safer, as modifying such file has no effect on other such indices.
    #   Right. Keep them isolated. Simplicity is key, here.
    #FUXME: Ah; right. This whole discussion should be shifted to the key-value
    #store component.

#FUXME: We probably want to "gzip" each individual documentation string, to
#reduce both load times on shell startup and runtime memory consumption. Is
#"gzip" the ideal solution for short runs of English text? It's certainly the
#most widespread; but, perhaps LZMA-based compression can do substantially
#better.
#FUXME: That said, even gzipping is a temporary solution. Ideally, in the long
#run, we want to use an entirely disk-based zsh-fueled key-value store and just
#perform on-disk lookups on each call to print_zeshy_help(). That's a
#demonstrably superior solution, long-term. Research whether there exist
#key-value store implementations in bash and zsh. Even if there do, such
#solutions are unlikely to be optimal. Research the theory underlying efficient
#key-value stores. Perhaps take a look at Tokyo Cabinet and friends?
#FUXME: *OH*. There appears to be an optional zsh "db" interface to "gdbm".
#That would certainly be ideal. Unfortunately, my local installation doesn't
#appear to have compiled support for it despite having enabled USE flag "gdbm";
#research! Ah; nope. zsh only supports "gdbm" to the extent that it caches
#completions against GDBM; that's it. No front-facing module, I'm afraid. Bash
#also fails to provide built-in support for "gdbm".
#FUXME: O.K. I'm convinced. "bkvs" implements a rudimentary filesystem-based
#key-value store in pure-Bash. What do you think? It only consists of one file,
#so it's tremendously lightweight. See:
#https://code.google.com/p/bkvs/source/browse/bkvs
#It seems quite a fun idea; we could certainly devote three directories
#"~/.zeshy/cache/documentation/{alias,function,global}" to three different
#filesystem-based stores corresponding to the three fundamental zsh namespaces.
#Naturally, just initialize with "command rm -r" prior to sourcing during
#compilation. I'll be honest: this kicks the heck out of the above in-memory
#map idea.
#FUXME: Interesting. We could just "tar.gz" the whole thing rather than
#implement such store as a directory. (Perhaps provide both? They serve different
#purposes.) Nice! Yes. This is probably the way to go; tar supports extraction of
#the exact desired file: e.g.,
#  tar -xzf foo.tar.gz blah.txt
#There we go. Have each documentation string as an individual file in a
#compressed tarball. Bam! Sweeeeeeeet. We'll naturally need to construct such
#archive during compilation. Shouldn't be terribly difficult:
#
#* Create a new temporary directory "documentation" under "~/.zeshy/tmp".
#  * Yes, this path; don't bother with "/tmp" or "~/tmp", as the logic needs to
#    be simplified to work cleanly and concisely under the limited subset of Zeshy
#    we have available during compilation.
#* Have declare_function() write each documentation string as a new file to such
#  temporary directory.
#* Tarball the entire directory into
#  "~/.zeshy/cache/documentation/functions.tar.gz". It'd be nice to choose the
#  optimal format available under the current system for indexed text retrieval.
#  (Is any format optimal for such purposes?)
#
#FUXME: Ah-ha! Consideration of indexing led me to "dar", a substantially
#improved "tar" supporting implicit fast file retrieval via indexing. That said,
#just make "dar" an optional but recommended dependency: use "dar" if available;
#otherwise, default to "tar".
#FUXME: That said, the "zeshy" ebuild should force-install "dar" to ensure
#optimum behavior. There's a stable "dar" ebuild, so... there you go! Speaking
#of, perhaps we should get crackin' on that "zeshy" ebuild, eh?
