#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *text writers* (i.e., functions either writing or appending to file
contents).
/---

# ....................{ WRITERS                            }....................
declare_function_with_stdin <<'/---'
void write_file_with_string(string filename, string text)

Overwrite the contents of the passed text file with the passed string if such
file exists or create a new file containing such string otherwise. Since this
function does _not_ interactively confirm such append, call this function only
where guaranteed to be non-destructive.
/---
function write_file_with_string() {
    # Validate sanity.
    die_unless_args_2 'Expected one string and one filename.'
    :string filename="${1}"

    # If such file's parent directory does *NOT* exist, make such directory.
    :make_dir_parent_if_not_found "${filename}"

    # Write such string to such file. zeshy disables zsh option "clobber", thus
    # requiring operator ">!" to force truncation of such file if nonzero.
    output_string "${2}" >!"${filename}"
}

declare_function_with_stdin <<'/---'
void append_file_with_string(string filename, string text)

Append the passed string to the contents of the passed text file if such file
exists or create a new file containing such string otherwise. Since this
function does _not_ interactively confirm such append, call this function only
where guaranteed to be non-destructive.
/---
function append_file_with_string() {
    # Validate sanity.
    die_unless_args_2 'Expected one string and one filename.'
    :string filename="${1}"

    # If such file's parent directory does *NOT* exist, make such directory.
    :make_dir_parent_if_not_found "${filename}"

    # Append such string to such file. zeshy disables zsh option "clobber", thus
    # requiring operator ">>!" to force truncation of such file if nonzero.
    output_string "${2}" >>!"${filename}"
}

# ....................{ WRITERS ~ var                      }....................
#FIXME: Rename to :write_script_with_var_binding() and likewise below.
declare_function_with_stdin <<'/---'
void write_file_with_variable(
    string filename,
    string variable_name1, ...)

Overwrite the passed file with the passed *variable bindings* (i.e., exactly
one or two `zsh` commands declaring _and_ defining each such variable). Such
file will be prefixed by the `zsh` shebang line specific to the current system
(e.g., `#!/usr/bin/env zsh`) _and_ contain only low-level commands valid under
both `zsh` and `zeshy`; hence, such file will be a sourceable `zsh` _and_
`zeshy` script.

== Binding Deserialization ==

Consider calling :source_script() to *deserialize* such bindings (i.e., reverse
the serialization this function performs, by running such script and importing
the variables such script declares and defines back into the current shell).
/---
function write_file_with_variable() {
    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected one or more variable names and one filename.'
    :string filename="${1}" zsh_shebang_line var_binding
    shift_arg

    # Shebang line prefixing zsh scripts for the current system.
    :set_string_to_zsh_shebang_line zsh_shebang_line

    # Such variables' bindings.
    :set_string_to_var_binding var_binding "${@}"

    # Write such shebang and bindings to such script.
    write_file_with_string\
        "${filename}"\
        "${zsh_shebang_line}${ZESHY_ASCII_NEWLINE}${var_binding}"
}

#FIXME: Actually, we should just be calling write_file_with_string() here.
#(Likewise, in the appender function below.) To do so reasonably, however,
#we'll have to first refactor get_variable_binding() into a setter.

declare_function_with_stdin <<'/---'
void append_file_with_variable(
    string filename,
    string variable_name1, ...)

Append the passed file with the current definitions of the passed variables.
See write_file_with_variable() for further details.
/---
function append_file_with_variable() {
    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected one or more variable names and one filename.'
    :string filename="${1}"
    shift_arg

    # If such file already exists, append such variables.
    if { is_file "${filename}" } {
        # Print such variables' bindings (i.e., declarations and definitions).
        # Avoid operator ">>!" here; such operator creates such file if not
        # already extant, which in this case would create a shell script *NOT*
        # prefixed with a shebang line. Using operator ">>" instead ensures an
        # exception will be thrown in the unlikely event such file is moved or
        # removed in between the prior conditional succeeding and this command
        # running.
        get_variable_binding "${@}" >> "${filename}"
    # Else, such file does not exist. Call write_file_with_variable() to prefix
    # the contents of such file with a shebang line.
    } else {
        write_file_with_variable "${filename}" "${@}"
    }
}

# --------------------( WASTELANDS                         )--------------------
    # If such file's parent directory does *NOT* exist, make such directory.
    # :make_dir_parent_if_not_found "${filename}"

    # Overwrite such file. Dismantled, this is:
    #
    # * ">!", forcefully overwriting such file if already extant.
    # {
    #     # For safety, prefix such script with the canonical zsh shebang line.
    #     get_zsh_shebang_line

    #     # Print such variables' bindings (i.e., declarations and definitions).
    #     get_variable_binding "${@}"
    # } >! "${filename}"

    # For safety, prefix such script with the canonical zsh shebang line.
# Consider calling :source_script() to deserialize the bindings previously
# such script back into such variables.
