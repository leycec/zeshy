#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *path canonicalizers* (i.e., functions converting paths from non-
canonical to canonical form).
/---

# ....................{ SETTERS                            }....................
#FIXME: Whoops! Turns out canonicalize_path() is subtly dangerous. Here's why:
#if the passed path is a shell-specific path (e.g., "/proc/mounts"), then
#calling canonicalize_path() from a command substitution success *BUT* basically
#fails since the returned path ceases to exist when such substitution completes.
#Hence, we basically need to replace every call to canonicalize_path() to
#set_string_to_path_canonicalized() *AND* document why in this documentation.
#It's important, to avoid bugs both here and elsewhere.
#FIXME: Indeed, given the subtle bugs inherent to canonicalize_path(), excise
#such function completely and document why such function no longer exists.

declare_function_with_stdin <<'/---'
void set_string_to_path_canonical(string string_name, string pathname)

Set the passed string variable to the canonical form of the passed path. See
canonicalize_path() for further details.
/---
function set_string_to_path_canonical() {
    # Validate sanity.
    die_unless_args_2 'Expected one string name and one pathname.'
    string string_name__sstpc="${1}" pathname__sstpc="${2}"
    :die_unless_var_string "${string_name__sstpc}"
    die_unless_path "${pathname__sstpc}"

    # Set such string.
    :set_string_to_string "${string_name__sstpc}" "${pathname__sstpc}"(:A)
}

# ....................{ CANONICALIZERS                     }....................
declare_function_with_stdin <<'/---'
string canonicalize_path(string pathname)

Convert the passed path to *canonical form*. Specifically:

* If such path does not exist, throw an exception.
* If such path is *relative* (i.e., not prefixed by `/`), convert such path into
  an *absolute path* (i.e., prefixed by `/`).
* Expand all symbolic links in such path recursively to the corresponding
  *physical paths* (i.e., non-symbolic links).
* Expand all *pseudo-directories* (i.e., `./`, `../`) in such path to the
  corresponding directory names.

Two canonicalized paths are equal if and only if such paths refer to the same
file or directory (e.g., canonical paths `/etc/passwd` and `/etc/passwd` are
equal and hence refer to the same file), a constraint _not_ applicable to non-
canonicalized paths (e.g., non-canonical paths `/etc/./` and `/etc/../etc/./`
are unequal but still refer to the same directory): e.g.,

.canonicalize_path()
==========================================
[source]
------------------------------------------
>>> get_pid
5993
>>> canonicalize_path /proc/mounts
/proc/5993/mounts
>>> change_dir /proc/self/cwd/root
>>> canonicalize_path ./.././.././../
/
------------------------------------------
==========================================

== Caveats ==

This function is typically called as a getter function from command substitution
and hence subshell of the current shell. While typically safe, such substitution
is _inherently_ unsafe in the general case. Specifically, if the passed path is
a symbolic link managed by the underlying operating system in a shell-specific
manner (i.e., created on shell forks and deleted on shell termination), then the
canonical form of such path returned by calling this function from a command
substitution will _not_ exist in the caller's shell -- even though such symbolic
link _does_ exist in the caller's shell. In such case, consider calling
set_string_to_path_canonical() instead.

Consider `/proc/mounts`, a shell-specific path in the `/proc` pseudo-filesystem
managed by the Linux kernel. Such path symbolically links to
`/proc/self/mounts`, itself linking to `/proc/$(get_pid)/mounts`. While
`/proc/mounts` exists in all shells and subshells, its temporary target
`/proc/$(get_pid)/mounts` exists only in the current shell. Hence, call
set_string_to_path_canonical() rather than this function to canonicalize
`/proc/mounts`: e.g.,

.canonicalize_path() vs set_string_to_path_canonical()
==========================================
[source]
------------------------------------------
>>> string filename

>>> get_pid
6797
>>> set_string_to_path_canonical filename /proc/mounts
>>> print_string "${filename}"
/proc/6797/mounts
>>> is_file "${filename}" or print_string "\"${filename}\" not found"

>>> filename="$(canonicalize_path /proc/mounts; run_code_to_stderr get_pid)"
59117
>>> print_string "${filename}"
/proc/59117/mounts
>>> is_file "${filename}" or print_string "\"${filename}\" not found"
"/proc/59117/mounts" not found
------------------------------------------
==========================================
/---
function canonicalize_path() {
    # Validate sanity.
    die_unless_arg 'Expected one pathname.'
    string pathname="${1}"
    die_unless_path "${pathname}"

    # Canonicalize such path. Call output_string() rather than return_string().
    # While the two are typically synonymous when called as the final statement
    # of a function body, return_string() is implemented to accept herestring-
    # style standard input. Since zsh fails to perform history expansion on such
    # input and since "(:A)" is a history expansion modifier, only
    # output_string() suffices. Yes, this is laboriously inscrutable and
    # insufferably laborious.
    output_string "${pathname}"(:A)
}

# --------------------( WASTELANDS                         )--------------------
#See canonicalize_path() for further details.

#FUXME: Whoops! Turns out canonicalize_path() is subtly dangerous. Here's why:
#if the passed path is a shell-specific path (e.g., "/proc/mounts"), then
#calling canonicalize_path() from a command substitution success *BUT* basically
#fails since the returned path ceases to exist when such substitution completes.
#Hence, we basically need to replace every call to canonicalize_path() to
#set_string_to_path_canonicalized() *AND* document why in this documentation.
#It's important, to avoid bugs both here and elsewhere.

#Consider calling set_string_to_path_canonical() rather than this function when
#canonicalizing general-purpose paths possibly referring to shell-specific
#symbolic links.
#
#The passed path may symbolically
#refer to a temporary shell-specific path deleted after this function returns and
#such subshell terminates.
#
#and hence no longer exist after this function returns  subshell terminates
#
#Since paths may 
#
#is _inherently_ unsafe in the general case, in which 
#
#. Specifically, paths specific 
#
#*shell-specific
#symbolic links* (i.e., symbolic links  
#
#consider a symbolic
#link 
#silently fails (by successfully returning a nonextant path) if : e.g.,

# Under most Linux systems, "/proc/mounts" is a symbolic link to
# "/proc/self/mounts" is a symbolic link to "/proc/$(get_pid)/mounts". Hence,
# attempting to resolve 
