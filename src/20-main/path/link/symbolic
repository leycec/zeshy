#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle symbolic links.
/---

# For brevity, prefer "symlink" to "link_symbolic" nomenclature. Define function
# synonyms with the latter nomenclature for those functions overlapping with
# existing hard link functions (e.g., die_unless_link_hard(), is_link_hard()).

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void {die_unless_symlink,die_unless_link_symbolic}(
    string pathname,
    string error_message = "Path \"${pathname}\" not a symbolic link.")

Throw an exception with the passed message unless the passed symbolic link
exists. See is_link_symbolic() for further details.
/---
function die_unless_symlink die_unless_link_symbolic() {
    die_unless_args_1_to_2\
        'Expected one pathname and optional error message.'
    :string pathname="${1}"
    is_symlink "${pathname}" or
        die "${2-Path \"${pathname}\" not a symbolic link.}"
}

declare_function_with_stdin <<'/---'
void :die_unless_path_unbroken(
    string pathname,
    string error_message =
        "Path \"${pathname}\" not found or is a broken symbolic link.")

Throw an exception with the passed message unless the passed path is unbroken.
See :is_path_unbroken() for further details.
/---
function :die_unless_path_unbroken() {
    die_unless_args_1_to_2\
        'Expected one pathname and optional error message.'
    :string pathname="${1}"
    :is_path_unbroken "${pathname}" or
        die "${2-Path \"${pathname}\" not found or is a broken symbolic link.}"
}


# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: bool] {is_symlink,is_link_symbolic}(string pathname)

Report success if the passed path is an existing symbolic link.
/---
function is_symlink is_link_symbolic() {
    die_unless_arg 'Expected one pathname.'
    is -L "${1}" si
}

declare_function_with_stdin <<'/---'
[status: bool] is_symlink_broken(string pathname)

Report success if the passed path is an existing *broken symbolic link* (i.e.,
an existing symbolic link whose transitive link target no longer exists). If
such path is not an existing symbolic link, an exception is thrown.
/---
function is_symlink_broken() {
    # Validate sanity.
    die_unless_arg 'Expected one pathname.'
    :string pathname="${1}"
    die_unless_symlink "${pathname}"

    # Test such path. Dismantled, this is:
    #
    # * "-", transitively resolving the passed symbolic link to its final
    #   destination. If this is merely another symbolic link, the passed
    #   symbolic link is broken; else, this is a non-symbolic link (i.e.,
    #   physical file) and the passed symbolic link is unbroken.
    # * "@", excluding non-symbolic links. When combined with the prior
    #   "-", this filters unbroken symbolic links to the empty string. (zsh
    #   first resolves the passed symbolic link to its destination and then
    #   tests whether such destination is itself a symbolic link.)
    #
    # See http://www.zsh.org/mla/users/2005/msg00394.html for Peter Stephenson's
    # clever inspiration.
    :is_glob_qualified_path "${pathname}" '-@'
}

# ....................{ TESTERS ~ path                     }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_path_unbroken(string pathname)

Report success if the passed path is *unbroken* (i.e., exists and is _not_ a
broken symbolic link). See :is_symlink_broken() for further details.
/---
function :is_path_unbroken() {
    # Validate sanity.
    die_unless_arg 'Expected one pathname.'
    :string pathname="${1}"

    # Test such path.
    :is_path "${pathname}" and {
        is_symlink "${pathname}" and
            not is_symlink_broken "${pathname}" or
            report_success
    }
}

# ....................{ SETTERS                            }....................
#FIXME: Define a new :set_string_to_symlink_target_last() function as well. The
#implementation is sadly non-trivial and probably even platform-specific. Where
#"readlink" is pathable, such function is trivially implementable by running
#'readlink -f -- "${pathname}"'; else, a fallback implementation that would
#definitely work cross-platform-portably (but somewhat inefficiently) would be
#to iteratively call :set_string_to_symlink_target_first() until the resulting target
#either does not exist *OR* is not a symbolic link. Mildly clever, no?

declare_function_with_stdin <<'/---'
void :set_string_to_symlink_target_first(
    string string_name, string symlink_filename)

Set the passed string variable to the passed symbolic link's *direct target*
(i.e., absolute or relative path to which such link directly links). This
function does _not_ resolve intermediate symbolic links or guarantee such
target to either exist or be an absolute path. For such functionality, consider
calling :set_string_to_path_canonical() instead.
/---
function :set_string_to_symlink_target_first() {
    # Validate sanity.
    die_unless_args_2 'Expected one string name and filename.'
    :string string_name__sstst="${1}" filename__sstst="${2}"
    :list filename_stats__sstst
    die_unless_symlink "${filename__sstst}"

    # List of canonical statistics for such link. Such logic is somewhat
    # circuitous but remains both the most efficient and reliable. A common
    # alternative is to run external command "readlink" if installed as follows:
    #
    #     :set_string_to_string "${string_name__sstst}"\
    #         "$(command readlink -- "${filename__sstst}")"
    :set_list_to_path_stats filename_stats__sstst "${filename__sstst}"

    # Set such string to such symbolic link.
    :set_string_to_string\
        "${string_name__sstst}"\
        "${filename_stats__sstst[${ZESHY_STAT_INDEX_SYMLINK_TARGET}]}"
}

# ....................{ PRINTERS                           }....................
declare_function_with_stdin <<'/---'
[stderr: string] print_warning_if_symlink_broken(string pathname1, ...)

Print a warning to standard error for each passed broken symbolic link. See
is_symlink_broken() for further details.
/---
function print_warning_if_symlink_broken() {
    # Validate sanity.
    die_unless_args_1_or_more 'Expected one or more pathnames.'
    :string pathname_target

    # Print a warning for all shifted paths that are broken symbolic links.
    :string pathname
    for     pathname ("${@}") {
        if { is_symlink "${pathname}" and is_symlink_broken "${pathname}" } {
            :set_string_to_symlink_target_first pathname_target "${pathname}"
            print_warning "Symbolic link \"${pathname}\" target \"${pathname_target}\" not found."
        }
    }
}

declare_function_with_stdin <<'/---'
[stderr: string] print_warning_if_symlink_broken_by_path_change(
    string source_pathname1, ...,
    string target_pathname)

Print a warning to standard error for each passed broken symbolic link after
copying or moving paths. This utility function is intended to be called only by
copy_path*() and move_path*() functions.
/---
function print_warning_if_symlink_broken_by_path_change() {
    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected one or more source pathnames and one target pathname.'

    # List of target pathnames to be tested for broken symbolic links.
    list target_pathnames

    # If passed two arguments and...
    if { is_args_2 } {
        # The second passed argument is a directory, the target pathname is such
        # argument appended with the basename of the first passed argument.
        if { is_dir "${2}" } {
            target_pathnames=( "${2}/${1:t}" )
        # Else, the second passed argument is itself the target pathname.
        } else {
            target_pathnames=( "${2}" )
        }
    # If passed three or more arguments, the latter is the target dirname. Find
    # the target pathnames by appending the basename of each source pathname to
    # such dirname. Dismantled, this is:
    #
    # * "${@[-1]}", expanding to the target pathname. Since at least three paths
    #   were passed and the underlying copy or move command returned
    #   successfully, this is always a dirname.
    # * "${^@[1,-2]:t}", iteratively expanding to the basename for each passed
    #   target pathname.
    } else {
        target_pathnames=( "${@[-1]}/${^@[1,-2]:t}" )
    }

    # Print such warnings.
    print_warning_if_symlink_broken "${target_pathnames[@]}"
}

# --------------------( WASTELANDS                         )--------------------
# ....................{ GETTERS                            }....................
#FUXME: Horrible. Remove. We already have a corresponding setter, so just
#excise this completely.
#FUXME: Add examples.

# declare_function_with_stdin <<'/---'
# string get_symlink_target(string filename)
# 
# Get the immediate target of the passed symbolic link. This function does _not_
# resolve intermediate symbolic links or guarantee such target to be absolute or
# extant. Consider calling :canonicalize_path() for such resolution.
# /---
# function get_symlink_target() {
#     # Validate sanity.
#     die_unless_arg 'Expected one filename.'
#     string target
# 
#     # Get and output such target.
#     :set_string_to_symlink_target_first target "${1}"
#     output_string "${target}"
# }
#             pathname_target="$(get_symlink_target "${pathname}")"

    #FUXME: Can the inefficient command substitution here be avoided at all? Not
    #if we continue to use an external command, of course, suggesting a pure zsh
    #alternative to be strongly preferable (....if ever discovered, of course!).
    #FUXME: Ah-ha! Yes. We need to call:
    #
    #    list filename_stats__sstst
    #    zstat -L -A filename_stats__sstst "${filename__sstst}"
    #    :set_string_to_string "${string_name__sstst}"\
    #        "${filename_stats__sstst[14]}"
    #
    #Since magic numbers are horrid, however, let's concoct a new @{path/stat}.

    # Alas, but zsh itself appears to supply no means of printing the immediate
    # target of a symbolic link. Resort to core utilities instead.
#    :set_string_to_string "${string_name__sstst}"\
#        "$(command readlink -- "${filename__sstst}")"

    # Validate sanity.
#    die_unless_arg 'Expected one filename.'
#    string filename="${1}"
#    die_unless_link_symbolic "${filename}"
#
#    # Alas, but zsh itself appears to supply no means of printing the immediate
#    # target of a symbolic link. Resort to core utilities instead.
#    command readlink -- "${filename}"

#FUXME: It'd be great to supply synonyms for each such function, replacing
#"link_symbolic" with "symlink". The latter produces *MUCH* more readable
#function names, inarguably.

    # * "link_symbolic_broken", an empty list if the passed symbolic link is
    #   unbroken; else, a single-element list. Define such list with:
    #   * "${pathname}"(...), filtering the passed path with glob qualifiers:
    # If the last such path is not a broken symbolic link, the prior conditional
    # returns false. Avoid returning false from this function by forcefully
    # returning true, here.
#   report_success
#       list link_symbolic_broken; link_symbolic_broken=( "${pathname}"(-@) )
#       is_list_nonempty link_symbolic_broken
        #FUXME: We *REALLY* want a path glob helper. Don't we already have one?
        #Call such helper instead.
#FUXME: Take care when calling this function with "-"-prefixed arguments.
#FUXME: Generalize this function just to accept source pathnames -- exclude the
#final target pathname.
#FUXME: Rename to print_warning_if_symlink_broken() and shift to "path/link".

# Get the physical path to which the passed symbolic link directly links.
# (i.e., resolving all intermediate symbolic links). The resulting path is
# guaranteed to be neither absolute or extant. See :canonicalize_path() for an
# alternative guaranteeing absolute and extant return values.
    # Dismantled, this is:
    #
    # * "(:A)", expanding to the absolute path of such directory if relative and
    #   resolving symbolic links in such path to their non-symbolic targets.
#   print_string "${filename}"(:A)

    # See is_symlink_broken() for related discussion.
#   list link_symbolic_target; link_symbolic_target=( "${filename}"(-) )
#   print_string "${link_symbolic_target[1]}"

#   string source_pathname="${1}" target_filename="${2}"
#   die_unless_file "${source_pathname}"
#
#   if is_link_symbolic "${target_filename}"; then
#       ln -sf "${source_pathname}" "${target_filename}"
#   else
#       die_if_file "${target_filename}"
#       ln -s  "${source_pathname}" "${target_filename}"
#   fi
