#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "COPYING" for additional details.

:parcel <<'/---'
Handle *path permission changers* (i.e., functions changing path permissions).
/---

# ....................{ CHANGES                            }....................
#FIXME: Define the exact syntax of such permissions strings. "man chmod"
#provides a useful description, which we should distill to its terse essence.
declare_function_with_stdin <<'/---'
void change_path_permissions(
    string pathname1, ...,
    string permissions)

Change the permissions of all passed paths to the passed symbolic or octal
permissions with the currently configured `chmod`-specific options (e.g.,
${ZESHY_OPTIONS_CHMOD}).  If any such path does not exist, an exception is
thrown. See `man chmod` for further details: e.g.,

.change_path_permissions()
==========================================
[source]
------------------------------------------
# Change user, group, and other permissions with symbolic permissions.
>>> change_path_permissions "/ogallala/yucca" ugo-rwx
>>> cd /ogallala/yucca
cd: permission denied: /ogallala/yucca
# Change user, group, and other permissions with octal permissions.
>>> change_path_permissions "/ogallala/yucca" 0777
>>> cd /ogallala/yucca
>>> get_dir
/ogallala/yucca
------------------------------------------
==========================================

== Permissions Strings ==

As the prior example demonstrates, permissions strings are either:

* Human-readable symbolic strings (e.g., `ugo+rX`).
* Machine-readable octal integers (e.g., 0711).
/---
function change_path_permissions() {
    # Validate sanity.
    die_unless_args_2 'Expected one path and one permissions string.'
    string permissions="${@[-1]}"
    pop_arg

    # Change such permissions.
    change_path_permissions_with_options -- "${permissions}" "${@}"
}

declare_function_with_stdin <<'/---'
void change_path_permissions_with_options(
    string chmod_option1?, ...,
    string permissions,
    string pathname1 = "$(get_dir)/"{.,*}, ...)

Change the permissions of all passed paths (defaulting to the current directory
and all immediate paths in such directory, if called directly from the command
line) to the passed symbolic or octal permissions with both the passed and
currently configured `chmod`-specific options (e.g., ${ZESHY_OPTIONS_CHMOD}).
See change_path_permissions() for further details.
/---
function change_path_permissions_with_options() {
    # Validate sanity.
    if { is_context_cli_function } {
        die_unless_args_1_or_more\
            'Expected optional "chmod" options, one permissions string, and optional pathnames.'
        is_args_2_or_more or append_arg "$(get_dir)/"{.,*}
    } else {
        die_unless_args_2_or_more\
            'Expected optional "chmod" options, one permissions string, and one or more pathnames.'
    }

    # Change such permissions.
    run_code_with_options_configured\
        'command chmod' ZESHY_OPTIONS_CHMOD "${(q)@}"
}

# ....................{ CHANGES ~ recursive                }....................
declare_function_with_stdin <<'/---'
void change_path_permissions_recursive(
    string pathname1, ...,
    string permissions)

Recursively change the permissions of all passed paths to the passed symbolic or
octal permissions with the currently configured `chmod`-specific options (e.g.,
${ZESHY_OPTIONS_CHMOD}). See change_path_permissions() for further details.
/---
function change_path_permissions_recursive() {
    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected one or more paths and one permissions string.'
    string permissions="${@[-1]}"
    pop_arg

    # Change such permissions.
    change_path_permissions_recursive_with_options -- "${permissions}" "${@}"
}

declare_function_with_stdin <<'/---'
[status: boolean] change_path_permissions_recursive_with_options(
  string chmod_option1?, ...,
  string permissions,
  string pathname1 = "$(get_dir)", ...)

Recursively change the permissions of all passed paths (defaulting to the
current directory, if called directly from the command line) to the passed
symbolic or octal permissions with both the passed and currently configured
`chmod`-specific options (e.g., ${ZESHY_OPTIONS_CHMOD}). See
change_path_permissions() for further details.
/---
function change_path_permissions_recursive_with_options() {
    # Validate sanity.
    if { is_context_cli_function } {
        die_unless_args\
            'Expected optional "chown" options, one permissions string, and optional pathnames.'
        string permissions paths
        integer arg_nonoption_count arg_nonoption_index_first

        # Default such path to the current directory.
        is_args_2_or_more or append_arg "$(get_dir)"

        # Get the number of non-option arguments and index in the passed
        # arguments of the first such argument.
        set_integers_to_arg_nonoption_count_and_index_first\
            arg_nonoption_count arg_nonoption_index_first

        # Strings synopsizing such change for confirmation purposes.
        permissions="${@[${arg_nonoption_index_first}]}"
        paths="\"${@[$(( arg_nonoption_index_first + 1 ))]}\""
        if (( arg_nonoption_count > 2 )) {
            paths+=', ...'
        }

        # Confirm such change.
        is_query_character_yes\
            "Recursively change permissions of ${paths} to ${permissions}?" or
            report_failure
    } else {
        die_unless_args_2_or_more\
            'Expected optional "chown" options, one permissions string, and one or more pathnames.'
    }

    # Change such permissions.
    run_code_with_options_configured 'command chmod'\
        'ZESHY_OPTIONS_CHMOD ZESHY_OPTIONS_CHMOD_IF_RECURSIVE' "${(q)@}"
}

# --------------------( WASTELANDS                         )--------------------
#function change_path_permissions_recursive_with_options() {
#    # Validate sanity.
#    set_integers_to_arg_nonoption_count_and_index_first\
#        'arg_nonoption_count arg_nonoption_index_first'
#    if { is_context_cli_function } {
#        die_unless_args_1_or_more\
#            'Expected optional "chmod" options, one permissions string, and optional pathnames.'
#
#        # If passed no paths, default to the current directory. 
#        if (( arg_nonoption_count == 1 )) {
#            # Increment the number of passed arguments to ensure sanity below.
#            arg_nonoption_count+=1
#            append_arg "$(get_dir)"
#        }
#    } else {
#        die_unless_args_2_or_more\
#            'Expected optional "chmod" options, one permissions string, and one or more pathnames.'
#    }
#
#    # If the current shell is interactive, return non-zero exit status unless
#    # the current user interactively affirms such changes. Recursively changing
#    # permissions is often permanently harmful and hence deserves confirmation.
#    if { is_shell_interactive } {
#        string paths\
#            permissions="${@[${arg_nonoption_index_first}]}"\
#             first_path="${@[$(( arg_nonoption_index_first + 1 ))]}"
#
#        # Set the question to be asked depending on the number of passed paths.
#        paths="\"${first_path}\""
##       print "count: ${arg_nonoption_count}"
#        if (( arg_nonoption_count > 2 )) {
#            paths+=', ...'
#        }
#
#        # Confirm such change.
#        is_query_character_yes\
#            "Recursively change permissions of ${paths} to ${permissions}?" or
#            report_failure
#    }
#
#    # Change such permissions.
#    run_code_with_options_configured 'command chmod'\
#        'ZESHY_OPTIONS_CHMOD ZESHY_OPTIONS_CHMOD_IF_RECURSIVE' "${(q)@}"
#}

#    append_list_with_list_locally_from\
#        'ZESHY_OPTIONS_CHMOD ZESHY_OPTIONS_CHMOD_IF_RECURSIVE'
#    change_path_permissions "${@}"

        # If passed no paths, default to the current directory and paths in it.
#        set_integer_to_arg_nonoption_count arg_nonoption_count
#        (( arg_nonoption_count == 1 )) and append_arg "$(get_dir)/"{.,*}

#Specify such permissions in either machine-readable (e.g., 0711) or
#human-readable format (e.g., `ugo+rX`).
#       then  to ${permissions}?"
#       else question "recursively change permissions of \"${first_path}\", etc. to ${permissions}?"
#       fi

#FUXME: Recursive path changing can be dangerous. Interactively confirm such
#changes (but don't bother with non-recursive path changing).

    #FUXME: Replace with call to append_list_with_lists_locally(), as below.
    # Recursively change permissions by delegating to change_path_permissions(),
    # temporarily appending recursive options to ${ZESHY_OPTIONS_CHMOD}.
#   list options; options=(
#       "${ZESHY_OPTIONS_CHMOD[@]}"
#       "${ZESHY_OPTIONS_CHMOD_IF_RECURSIVE[@]}"
#   )
#   list ZESHY_OPTIONS_CHMOD; ZESHY_OPTIONS_CHMOD=( "${options[@]}" )
#       then paths="recursively change permissions of \"${first_path}\" to ${permissions}?"
#       else question "recursively change permissions of \"${first_path}\", etc. to ${permissions}?"
#
#function change_path_permissions_recursive_with_options() {
#    append_list_with_list_locally\
#        ZESHY_OPTIONS_CHMOD ZESHY_OPTIONS_CHMOD_IF_RECURSIVE
#    change_path_permissions_with_options "${@}"
#}

#declare_function '
#string change_path_permissions_with_options(
#  string option1, string option2, ...,
#  string permissions,
#  string path1 = "$(get_dir)", string path2, ...)
#
#Change the permissions of the passed paths (defaulting to the current
#directory) via the passed permission specifier and "chmod" options. See
#change_path_permissions() or "man chmod" for further details.
#'
#function change_path_permissions_with_options() {
#    # Validate passed arguments.
#    die_unless_args 'expected one permissions string and at least one path'
#
#    #FUXME: Insufficient. The user could have passed arguments "-R" and "go+X",
#    #in which case at least two arguments were passed but none of them a proper
#    #path. To test this properly, first temporarily remove all passed arguments
#    #prefixed with "-" and *THEN* test the number of arguments: if still only
#    #one, then, indeed, we do need to append the current directory.
#
#    # If passed one argument, default the path to the current working directory.
#    is_one_arg and append_arg "$(get_dir)"
#
#    # Change permissions.
#    run_code_with_options 'command chmod' ZESHY_OPTIONS_CHMOD "${(q)@}"
#}

# ....................{ CHANGERS                           }....................
#FUXME: Shift pertinent "../permission" functionality here.
#FUXME: Argument order is appropriate when called interactively but not non-
#interactively. Each such function should accept only two arguments.
