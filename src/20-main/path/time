#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle miscellaneous path access, change, and modification time functionality.
/---

# ....................{ GETTERS                            }....................
#FIXME: Refactor into a setter.
declare_function_with_stdin <<'/---'
float get_path_mtime_recursive(string pathname)

Get the *mtime* (i.e., modification time) of the passed path in Unix time,
recursively. If such path is a:

* File, this is the same time as returned by get_path_mtime().
* Directory, this is the most recent modification time of such directory and
  all files and subdirectories of such directory, recursively.
/---
function get_path_mtime_recursive() {
    # Validate sanity.
    die_unless_arg 'Expected one pathname.'
    string pathname="${1}"

    # Calculate such time. Dismantled, this is:
    #
    # * "${pathname}"/**/*, all files and subdirectories of this directory.
    # * "om", such files and subdirectories in ascending order by mtime.
    # * "[1]", the first and hence newest such file or subdirectory.
    if { is_dir "${pathname}" } {
        get_path_mtime "${pathname}"/**/*(om[1])
    } else {
        get_path_mtime "${pathname}"
    }
}

# ....................{ CHANGERS                           }....................
#FIXME: Rename to :change_path_mtime().
declare_function_with_stdin <<'/---'
void set_path_mtime(string pathname, float modification_time)

Set the *mtime* (i.e., modification time) of the passed path to the passed time
in high-resolution seconds since the Unix epoch. See get_time() for further
details.
/---
function set_path_mtime() {
    # Validate sanity.
    die_unless_args_2 'Expected one pathname and one modification time.'
    string pathname="${1}" mtime="${2}"
    die_unless_path "${pathname}"
    die_unless_integer_positive "${mtime}"

    #FIXME: Probably GNU-specific. *collective shrug*
    # Set modification time.
    command touch -m --date=@${mtime} -- "${pathname}"
}

# --------------------( WASTELANDS                         )--------------------
    # :set_list_to_dir_dirs_recursive_sorted_by_ctime_descending\
    #     dir_dirs "${dirname}"

# ....................{ SETTERS                            }....................
# declare_function_with_stdin <<'/---'
# void :set_list_to_dir_dirs_recursive_sorted_by_ctime_descending(
#     string list_name, string dirname)
# 
# Set the passed list (ideally, list set) to the set of all directories
# recursively found under the passed directory, sorted in descending order of
# *directory ctime* (i.e., the last time such directories were changed). See
# :get_path_ctime() for further details.
# /---
# function :set_list_to_dir_dirs_recursive_sorted_by_ctime_descending() {
#     # Validate sanity.
#     die_unless_args_2 'Expected one list name and one dirname.'
#     :string list_name__sltddrsbcd="${1}" dirname__sltddrsbcd="${2}"
#     die_unless_dir "${dirname__sltddrsbcd}"
#     die_unless_list "${list_name__sltddrsbcd}"
# 
#     # Set such list. Dismantled, this is:
#     #
#     # * "**/*", recursively expanding to all paths under such directory.
#     # * "(/oc)", filtering such paths for directories ("/") sorted in descending
#     #   order of ctime ("oc").
#     eval ${list_name__sltddrsbcd}='( "${dirname__sltddrsbcd}"/**/*(/oc) )'
# }

    # set_list_to_evaluation ${list_name__sltddrsbcd}\
    #     '"${dirname__sltddrsbcd}"/**/*(/oc)'

    # For readability, print such directories verbosely.
    # list_path_verbosely "${dir_dirs[@]}"

# void :set_list_to_dir_dirs_recursive_sorted_by_ctime_descending(
#     string list_name, string dirname="$(get_dir)")
# 
# Set the passed list (ideally, list set) to the set of all directories
# recursively found under the passed directory (defaulting to the current
# directory, if called directly from the command line), sorted in descending order
# of *directory ctime* (i.e., the last time such directories were changed). See
# :get_path_ctime() for further details.
# /---
# function :set_list_to_dir_dirs_recursive_sorted_by_ctime_descending() {
#     # Validate sanity.
#     if { is_context_cli_function } {
#         die_unless_args_1_to_2 'Expected one list name and optional dirname.'
#         is_args_2 or append_arg "$(get_dir)"
#     } else {
#         die_unless_args_2 'Expected one list name and one dirname.'
#     }
#     :string list_name__sltddrsbcd="${1}" dirname__sltddrsbcd="${2}"
#     die_unless_dir "${dirname__sltddrsbcd}"

# Such functions call functions unavailable at "00-startup" time and hence not
# shiftable to the prior parcel of the same name.

# _not_
#handled by the prior parcel of the same name

#   mtime="${2:-$(get_time)}"
# with optional fractional digits on
#systems recording high-resolution file times)
#, where
#the meaning of ``high-resolution'' depends on system-specific properties
#       zam=( "${(s:~~~:)"$(stat --dereference --printf '%y~~~%Y' "${pathname}")"}" )
        # For efficiency, inline such implementation. See set_list_to_string_split_on_string for further details.
#   if is_file "${pathname}"
#   else die "\"${pathname}\" not found or not a file or directory"
#     directory's file or subdirectory creation,
#     deletion, 
# * to file content or
# permissions. If such path is a directory, this time reflects file and
# subdirectory creation but not changes to file or subdirectory content or
# permissions.
