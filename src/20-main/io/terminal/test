#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *terminal testers* (i.e., functions testing attributes associated with
the current terminal, if any).

== Caveats ==

Most functions declared by subparcels in parcel @{terminal} operate on file
descriptors, including those declared by this subparcel. Since subshells do
_not_ inherit file descriptors attached to terminal devices, such functions
rarely behave as expected when called from subshells: e.g.,

.Terminal Functions under Subshells
==========================================
[source]
------------------------------------------
>>> is_stdout_terminal and print_string "Firefly Class"
Firefly Class
>>> $(is_stdout_terminal or print_string "Universal Alliance")
Universal Alliance
------------------------------------------
==========================================
/---

#FIXME: O.K.; I've definitively determined what went wrong when invoking the
#"Cataclysm: DDA" error (i.e., running "cataclysm-dda" with an existing "save"
#subdirectory corresponding to a prior version). For some reason,
#"cataclysm-dda" corrupts (err... "changes") the terminal line settings of the
#current shell on failing with an error. Restoring such settings turns out to be
#both remarkably fast and simple: just run "stty sane". "sane" is an "aggregate
#setting" combining multiple sane terminal line settings. We're unclear as to
#whether or not it's GNU-specific, but suspect it is. Under BSD, the simplest
#(but less functional) equivalent may be "stty echo -nl -cbreak". We probably
#want a new function reset_terminal() in "io/terminal/terminal" running such
#command. Since it is fast *AND* since terminal corruption when it occurs is
#horrible enough to make frequent resets worthwhile, I'm having trouble coming
#up with a compelling argument *AGAINST* resetting the terminal prior to
#printing every shell prompt. Hence, consider adding:
#
#   run_hook_before_prompt_printed reset_terminal
#
#For further details, see http://docstore.mik.ua/orelly/unix/upt/ch42_04.htm and
#http://www.unixguide.net/linux/faq/06.14.shtml.
#FIXME: Actually, having reset_terminal() run "stty sane" really isn't the most
#generally applicable solution, since that overwrites custom terminal line
#settings that the user actually intended. Instead, do the following:
#
#* On zeshy startup, run "stty -g >'${ZESHY_USER_CACHE_DIR}/stty'". Again, check
#  whether or not this is GNU-specific. If it is, just do *NOTHING* on BSD
#  systems, which is obviously better than doing something horrible. In any case,
#  this caches current terminal line settings to a zeshy-specific file.
#* Implement the following functions:
#
#   function reset_terminal_to_sane_defaults() {
#       stty sane
#   }
#   function reset_terminal_to_startup_defaults() {
#       stty "$(get_file_text "${ZESHY_USER_CACHE_DIR}/stty")"
#   }
#
#Ideally, we'd just save such settings to a global string, avoiding a file read
#for each shell prompt. Sadly, "stty" only supports printing machine-readable
#settings to a file. (I know.) We can circumvent this by:
#
#* Caching to such file as above, or perhaps simply a temporary file. Wait...
#  doesn't zsh support writing to and from variables as files? Check. If not:
#* Read such file into a string global.
#* Delete such file.
#
#Annoying, but certainly faster.
#FIXME: Serializing a file on each zeshy startup seems excessive. Honestly, such
#settings are unlikely to change between startup invocations and hence should
#probably be precompiled into zeshy's user digest file. We recompile it often
#enough that this is unlikely to prove too problematic.

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void :die_unless_terminal(
    string error_message =
        "Current shell headless (i.e., not running under terminal emulation).")

Throw an exception unless the current shell is running under a terminal
emulator. See :is_terminal() for further details.
/---
function :die_unless_terminal() {
    die_unless_args_0_to_1 'Expected optional error message.'
    :is_terminal or die\
        "${1-Current shell headless (i.e., not running under terminal emulation).}"
}

# ....................{ EXCEPTIONS ~ position              }....................
declare_function_with_stdin <<'/---'
void :die_unless_terminal_column(
    int terminal_column,
    string error_message =
        "Terminal column \"${terminal_column}\" invalid (i.e., not an integer in [1, ${COLUMNS}]).")

Throw an exception unless the passed integer is a valid terminal column. See
:is_terminal_column() for further details.
/---
function :die_unless_terminal_column() {
    die_unless_args_1_to_2 'Expected one terminal column and optional error message.'
    :is_terminal_column "${1}" or {
        :string terminal_column="${1}"
        die "${2-Terminal column \"${terminal_column}\" invalid (i.e., not an integer in [1, ${COLUMNS}]).}"
    }
}

declare_function_with_stdin <<'/---'
void :die_unless_terminal_row(
    int terminal_row,
    string error_message =
        "Terminal row \"${terminal_row}\" invalid (i.e., not an integer in [1, ${COLUMNS}]).")

Throw an exception unless the passed integer is a valid terminal row. See
:is_terminal_row() for further details.
/---
function :die_unless_terminal_row() {
    die_unless_args_1_to_2 'Expected one terminal row and optional error message.'
    :is_terminal_row "${1}" or {
        :string terminal_row="${1}"
        die "${2-Terminal row \"${terminal_row}\" invalid (i.e., not an integer in [1, ${COLUMNS}]).}"
    }
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_terminal(void)

Report success if the current shell is running under a *text terminal emulator*
(i.e., software emulating a physical text-based terminal under some other
display architecture), also referred to as a *term* or *Teletype (TTY)*.
Specifically, report success if canonical string global ${TERM} both exists
_and_ is *nonempty* (i.e., currently set to any string other than `""`).

== Implications ==

If this function reports success, all *terminal functions* (i.e., functions
assuming the current process to be running under such a terminal) are safely
callable (e.g., :set_int_to_terminal_width(), move_terminal_cursor_to()).

If this function reports failure, however, no such functions are safely
callable.  Attempting to do so throws an immediate exception. To avoid this,
consider calling terminal functions _only_ after a call to this function reports
success.
/---
function :is_terminal() {
    # For efficiency, default such variable to the empty string if currently
    # undefined. While such test is also implementable as follows, this
    # function is called sufficiently often to warrant minor optimization:
    #    :is_var TERM and is_string_nonempty "${TERM}"
    die_if_args
    is_string_nonempty "${TERM-}"
}

# ....................{ TESTERS ~ position                 }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_terminal_column(int terminal_column)

Report success if the passed integer is a valid *terminal column* (i.e., an
integer in the range `[1, ${COLUMNS}]`).
/---
function :is_terminal_column() {
    # Validate sanity.
    die_unless_arg 'Expected one terminal column.'
    :int terminal_width

    # Test such column against the current terminal width.
    :set_int_to_terminal_width terminal_width
    is_integer_in_range "${1}" 1 "${terminal_width}"
}

declare_function_with_stdin <<'/---'
[status: bool] :is_terminal_row(int terminal_row)

Report success if the passed integer is a valid *terminal row* (i.e., an
integer in the range `[1, ${LINES}]`).
/---
function :is_terminal_row() {
    # Validate sanity.
    die_unless_arg 'Expected one terminal row.'
    :int terminal_height

    # Test such row against the current terminal height.
    :set_int_to_terminal_height terminal_height
    is_integer_in_range "${1}" 1 "${terminal_height}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: The phrase "line_width" is *VERY* odd nomenclature. Both this and the
#tester below should be renamed to something readable -- say, "terminal_column".
#(Yeah: that's demonstrably *MUCH* better than "line_width". Where were we even
#going with that terminology?)

# Handle terminals and terminal attributes (e.g., VT100 emulation).
# declare_function_with_stdin <<'/---'
# integer get_terminal_width(void)
# 
# Get the width in characters of the current terminal.
# /---
# function get_terminal_width() {
#     # "tput columns" also (inefficiently) suffices.
#     die_if_args
#     output_string "${COLUMNS}"
# }
# 
# declare_function_with_stdin <<'/---'
# integer get_terminal_height(void)
# 
# Get the height in lines of the current terminal.
# /---
# function get_terminal_height() {
#     # "tput lines" also (inefficiently) suffices.
#     die_if_args
#     output_string "${LINES}"
# }

    #FUXME: Insane! Just call both is_integer_in_range() and
    #:set_int_to_terminal_width(). *sigh*

    # Validate sanity.
    #
    # For safety during exception handling, avoid calling is_integer_in_range().
    # Since the default exception handler transitively calls this function *AND*
    # since is_integer_in_range() may not yet be defined, simplify chaos.
    #
    # For minor efficiency, expand the terminal width directly rather than call
    # get_terminal_width().
    # die_unless_integer "${terminal_column}"

    # The current process is running under a text terminal emulator *ONLY* when
    # the canonical string global ${TERM} both exists and is nonempty.
    # the canonical string global ${TERM} both exists and is nonempty. While
    # such test could be implemented by calling the corresponding testers as
    # follows, this function is called sufficiently often to warrant inlining
    # such tests here:
    #
    #    :is_var TERM and :is_var_nonempty TERM
    #
    # :is_var_nonempty() is a particularly inefficient function

#. Such subdirectory should
#be the first letter of the current terminal's name (e.g., 
    # Numerous applications complain under long ${TERM} strings (e.g.,
    # "rtorrent"). Truncate such strings to equivalent abbreviations.
#   is "${TERM-}" == 'rxvt-unicode-256color' si and TERM='rxvt-unicode'

#declare_function_with_stdin <<'/---'
#void reset_terminal_before_input_run(
#    string history_line, string readable_line, string command)
#
#Reset the terminal attached to the current shell before running the passed
#command input by the current user. Specifically:
#
#* Reset terminal colors to terminal-specific defaults (typically, a white
#  foreground on a black background with plain typeface).
#* Reset printer function globals. See ${ZESHY_PRIOR_PRINTER_STDOUT_MTIME} and
#  ${ZESHY_PRIOR_PRINTER_NAME} for further details.
#/---
#function reset_terminal_before_input_run() {
#    # Do *NOT* bother validating sanity, as zsh calls this hook with ignorable
#    # options.
#
#    # Reset terminal colors. For safety, default to the empty string.
##   output_string_sans_newline "${ZESHY_STYLE_TO_COLOR[color.reset]-}"
#
#    # Reset printer function globals.
#    reset_output_state_and_terminal_color
#}

#   ZESHY_PRIOR_PRINTER_STDOUT_MTIME=0
#   ZESHY_PRIOR_PRINTER_NAME=''
#Avoid calling functions from subshells, where feasible.
# Prevent prompt colors from bleeding into command output.

#       print_message 'truncating ${TERM} to "rxvt-unicode" for safety...'

    # Return true if the file descriptor for standard print_string is open and
    # attached to a terminal. (Avoid testing standard input, as commands passed
    # piped input may still be attached to a terminal.)

#FUXME: Rename "shell_terminal" to "terminal" everywhere. While the former is
#strictly true, it's also cumbersome and leads to function names resembling
#get_shell_terminal_width(). Ugh.


#FUXME: I've pierced the veil. So, the difference between is_shell_interactive()
#and is_terminal() as we've currently defined them is as follows:
#
#* is_shell_interactive() == true if stdin  is a tty.
#* is_terminal()          == true if stdout is a tty.
#
#This is both silly and non-intuitive. We really need to standardize such
#terminology; how about the following, instead:
#
#* is_terminal_stdin()  == true if stdin  is a tty.
#* is_terminal_stdout() == true if stdout is a tty.
#* is_terminal()                 == true if both stdin and stdout are ttys.
#
#Or:
#
#* is_stdin_terminal()  == true if stdin  is a tty.
#* is_stdout_terminal() == true if stdout is a tty.
#* is_terminal()                 == true if both stdin and stdout are ttys.
#
#Yes! Absolutely the latter. "Standard input" and "output" are the nouns;
#"terminal" is the adjective acting on such nouns. (Reads much better, too.)
#Err... wait. But the latter's incongruous with is_terminal(). Actually, come to
#think, why do we need is_terminal_stdin() and
#is_terminal_stdout()? It certainly can't hurt to define them, but the
#only one we really care about is is_terminal(). I mean, how sensible is it to
#discuss a situation in which stdin is a tty but stdout isn't? What would that
#even mean? Ah; right. Pipes. It's all about pipes. O.K.; so, the distinction is
#sensible. It seems to me that we only care about:
#
#* is_terminal_stdin() when requiring only interactive user input
#  (mostly in this file and the "input" directory only, I suspect).
#* is_terminal_stdout() when requiring only terminal print_string (mostly in
#  this file and the "output" directory only, I suspect).
#
#In most cases, however, it seems that we really require both. So-called
#"interactive" aliases, for example, should only be active when *BOTH* stdin and
#stdout are ttys. We don't really expect them to be meaningfully called from
#pipes, etc. This suggests that most uses of the adjective "interactive" should
#really be renamed to "terminal" (e.g., terminal alias, terminal substitution).
#Ah; that *WOULD* be a fine idea, except "terminal abbreviation" doesn't read
#right. After all, VT100 is a terminal abbreviation -- but that's not at all
#what we'd mean. So keep the "interactive" for aliases, at least.
#
#Interesting: how *DO* we perfectly test for whether or not a command is called
#from an interactive prompt? It would be sensible, actually, to allow any such
#command to include piped interactive aliases. (I mean, why not? Where's the
#profit in disallowing it? None, really. Just piss people off... Including me.)
#For example, it's easy enough to allow "l | gr ok" when called from a prompt:
#"l" satisfies is_terminal_stdin() and "gr ok" satisfies
#is_terminal_stdout(). But what about the "ca" in "l | ca | gr ok"?
#Assuming "ca" to be an interactive alias for "cat", this should be allowed. But
#neither stdin or stdout or ttys. A question for another day, I suspect. Oh. Yes,
#it's true that "gr ok" satisfies is_terminal_stdout() -- but so do all
#non-interactive scripts. Hence,  is_terminal_stdout() is really non-
#useful for anything except testing explicitly whether we can muck around with
#terminal attributes. For now, consistency mandates that we allow interactive
#aliases only when *BOTH* stdin and stdout are ttys. (Hmm; assuming zsh has no
#cleaner method, permitting interactive aliases in pipes would necessitate
#testing whether stdin for the first command in the current pipe *AND* stdout
#for the last command in the current pipe are both ttys. I have little idea how
#to dynamically inspect that. The ${pipestatus} global does suggest there might
#be a way. Investigate. Hmmm; no. There doesn't seem to be a way, I'm afraid.)
#
#O.K.; O.K.; the current definition of "interactive alias" is actually fine.
#If stdin is a tty, allow interactive aliases; otherwise, do not. Pretty simple.
#It works. Why additionally require that stdout be a tty? No incentive, really.
#
#Ah. We also want to rename is_stdin_pipe() to is_stdin_pipe() and
#set_string_to_stdin_piped() to set_string_to_stdin_piped(). ("piped"
#is *MUCH* better than "pipe" here.)
#
#Conclusions:
#
#* Replace is_stdin_pipe() with is_stdin_pipe().
#* Replace is_stdout_terminal() with is_stdout_terminal().
#* Replace set_string_to_stdin_piped() with set_string_to_stdin_piped().
#* Define is_shell_interactive() to be a second name for the
#  is_stdin_terminal() function. I'm not fond of second names, in
#  general; but it just makes so much absolute sense, in this case. There are
#  two fundamentally different ways to think of this situation:
#  1. Non-semantically: standard input of the current command is a tty.
#  2. Semantically: the current shell was run "interactively" (i.e., *WHEN FIRST
#     STARTED*, standard input to such shell was a tty).
#  *OH*. Those *AREN'T THE SAME AT ALL*. They're completely different. We need
#  a separate is_shell_interactive() testing "-o interactive". That solves all
#  of the concerns above on interactive aliases and pipes, obviously; but that
#  doesn't have anything to do with whether or not the current command is
#  "interactive" (i.e., can accept interactive user input). Hence, we do need a
#  separate is_stdin_terminal() function for testing that. Now, *HERE*
#  we can provide a separate name for is_stdin_terminal():
#  is_current_command_interactive(). Nah; too complicated. Just go with the
#  canonical name here. Wow; I really confused myself a great deal on this. (To
#  be fair, it *IS* all rather confusing.)
#* Don't bother defining an is_terminal() function. There's just no use case, at
#  the moment.
    #FUXME: is_shell_interactive() does not necessarily imply
    #is_stdout_terminal(), does it? If not, we'll need to merely return rather
    #than die as we currently do if non-terminal.
#FUXME: We need a new hook type:
# run_hook_on_zeshy_startup_if_interactive startup_zeshy_terminal_attributes

#That's about it. Pretty simple. While is_shell_interactive() is a nice name, it
#also obscures the underlying idea (as evidenced by the enormous thought-spree
#above). Better to be direct, honest, and unobscured.
#* Globally replace is_shell_interactive() with is_stdin_terminal().
#In general, most current calls to is_shell_interactive() should be replaced by
#calls to the above is_terminal(). We'll probably need to evaluate on a case-by-
#case instance, however; global replace seems somewhat inadequate, in this case.
#
#Yes. Also replace "IF_INTERACTIVE" with "IF_TERMINAL" in global variables. More
#concise and coincides better with function nomenclature.
#How about the preposition "_on_", in any case? Improves readability a bit:
#
#* is_terminal_on_stdin()  == true if stdin  is a tty.
#* is_terminal_on_stdout() == true if stdout is a tty.
# ....................{ GETTERS ~ lines                    }....................
#FUXME: Rename get_wrapped_line_height(). Unsure it's used anywhere, anyway.
# integer get_displayed_line_length(string text1, string text2, ...)
#
# Get the total number of lines in the passed strings when displayed on the
# current terminal (i.e., accounting for long lines). This is a number strictly
# greater than or equal to that returned by get_string_line_length().
#function get_displayed_line_length() {
    # Validate passed arguments.
#    die_unless_args 'expected at least one string'
#    integer displayed_line_length terminal_width
#    terminal_width_plus_one=$(get_terminal_width)
#    (( ++terminal_width_plus_one ))

    # For each line of the passed string, increment line length by the sum of:
    #
    # * "1", for the physical trailing newline.
    # * The number of logical newlines zsh injects into such string for wrapping
    #   purposes, calculated as the physical line length divided by terminal
    #   width (i.e., maximum logical line length). Add 1 to avoid off-by-one.
#    for line ("${(f)@}") {
#        (( displayed_line_length += 1 + (${#line} / terminal_width) ))
#    }

    # Return such length.
#    print_string ${displayed_line_length}
#}
