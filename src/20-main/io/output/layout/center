#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

:parcel <<'/---'
Handle *string centering* (i.e., printing strings centered to the width of the
current terminal).
/---

#FIXME: Under 256-color terminals, it'd be great to incrementally subdivide the
#colors of box border characters into a gradient. Don't change the characters;
#change the colors. This is both simpler and more aesthetically pleasing.

# ....................{ SETTERS                            }....................
#FIXME: Something not quite right. Function currently appears to subtly fail
#when passed the empty string as a first parameter. This *SHOULD* work, but the
#output is off-by-one. *sigh*
declare_function_with_stdin <<'/---'
string :set_string_to_string_centered_to_width_in_style(
    string string_name,
    string text,
    int line_width,
    string style_prefix)

Set the passed string variable to the passed string centered to the passed *line
width* (i.e., integer in `[1, $(get_terminal_width)]`), using user-configurable
styles prefixed by the passed prefix.

== Styles ==

Such styles are keys of both the user-configurable map ${ZESHY_STYLE_TO_COLOR}
(specifying colors to be output) and ${ZESHY_STYLE_TO_TEXT} (specifying string
literals to be output), including:

* `${style_prefix}text`, styling the passed string itself.
* `${style_prefix}corner_left` and `${style_prefix}corner_right`, styling the
  left and right *corners* (i.e., first and last substrings to be printed on the
  line), each defaulting to the empty string.
* `${style_prefix}border_left` and `${style_prefix}border_right`, styling the
  left and right *borders* (i.e., substrings repeatedly printed until filling
  all space between the corresponding corner and joiner substrings), each
  defaulting to a space.
* `${style_prefix}joiner_left` and `${style_prefix}joiner_right`, styling the
  left and right *joiners* (i.e., substrings immediately prefixing and suffixing
  the passed string), each defaulting to the empty string.
/---
function :set_string_to_string_centered_to_width_in_style() {
    # Validate sanity.
    die_unless_args_4\
        'Expected one string name, one string, one line width, and one style prefix.'
    string\
        string_name__sstsctwwsp="${1}"\
        text__sstsctwwsp="${2}"\
        line_width__sstsctwwsp="${3}"\
        style_prefix__sstsctwwsp="${4}"\
        corner_left__sstsctwwsp\
        corner_right__sstsctwwsp\
        border_left__sstsctwwsp\
        border_right__sstsctwwsp\
        joiner_left__sstsctwwsp\
        joiner_right__sstsctwwsp
    integer\
        text_length__sstsctwwsp\
        cipher_left_length__sstsctwwsp\
        cipher_right_length__sstsctwwsp\
        corner_left_length__sstsctwwsp\
        corner_right_length__sstsctwwsp\
        border_left_length__sstsctwwsp\
        border_left_repeated_length__sstsctwwsp\
        border_right_length__sstsctwwsp\
        border_right_repeated_length__sstsctwwsp\
        joiner_left_length__sstsctwwsp\
        joiner_right_length__sstsctwwsp
    :die_unless_terminal_column "${line_width__sstsctwwsp}"

    # Length of such text excluding non-printable characters and sequences.
    :set_int_to_string_length_printable\
        text_length__sstsctwwsp "${text__sstsctwwsp}"
#   print "text: ${text__sstsctwwsp}; text_length__sstsctwwsp: ${text_length__sstsctwwsp}"

    # Number of characters preceding such text, when centering such text in the
    # middle of an output terminal line. By design, assigning a floating point
    # value to an integer variable implicitly rounds such value down to the
    # nearest whole integer. In this case, such rounding ensures that, when the
    # terminal width and text length are of differing parity (i.e., one is even
    # and the other odd), the text will be offset to the left by one character
    # of "the true center": e.g.,
    #
    #     # Centering a 4-character string on a 9-character wide terminal.
    #     123456789   # terminal width indices; note "5" to be the center
    #       test      # string offset to the left 1 character from center
    cipher_left_length__sstsctwwsp=$((\
        (line_width__sstsctwwsp - text_length__sstsctwwsp) / 2 ))

    # Number of characters following such text, defined to be the number of
    # characters on a terminal line neither preceding or containing such text.
    cipher_right_length__sstsctwwsp=$((\
        line_width__sstsctwwsp -\
        text_length__sstsctwwsp -\
        cipher_left_length__sstsctwwsp ))

    # Substrings to be measured (but not repeated) below and hence *NOT* yet
    # injected with color. Such substrings are optional and hence default to the
    # empty string.
    corner_left__sstsctwwsp="${ZESHY_STYLE_TO_TEXT[${style_prefix__sstsctwwsp}corner_left]-}"
    corner_right__sstsctwwsp="${ZESHY_STYLE_TO_TEXT[${style_prefix__sstsctwwsp}corner_right]-}"
    joiner_left__sstsctwwsp="${ZESHY_STYLE_TO_TEXT[${style_prefix__sstsctwwsp}joiner_left]-}"
    joiner_right__sstsctwwsp="${ZESHY_STYLE_TO_TEXT[${style_prefix__sstsctwwsp}joiner_right]-}"
#   print "border left: ${border_left}"

    # Substrings to be repeated below and hence never injected with color. Since
    # :set_string_to_string_ansiless_repeated_to_length() requires strings *NOT*
    # containing colors, shift such colors to preceding substrings. Such
    # substrings are mandatory and hence default to a single space.
    border_left__sstsctwwsp="${ZESHY_STYLE_TO_TEXT[${style_prefix__sstsctwwsp}border_left]- }"
    border_right__sstsctwwsp="${ZESHY_STYLE_TO_TEXT[${style_prefix__sstsctwwsp}border_right]- }"

    # Lengths of such substrings. For efficiency, inline such implementations.
    # See get_string_ansiless_length_printable() for further details.
    corner_left_length__sstsctwwsp="${(m)#corner_left__sstsctwwsp}"
    corner_right_length__sstsctwwsp="${(m)#corner_right__sstsctwwsp}"
    border_left_length__sstsctwwsp="${(m)#border_left__sstsctwwsp}"
    border_right_length__sstsctwwsp="${(m)#border_right__sstsctwwsp}"
    joiner_left_length__sstsctwwsp="${(m)#joiner_left__sstsctwwsp}"
    joiner_right_length__sstsctwwsp="${(m)#joiner_right__sstsctwwsp}"
#   print "right_length: ${right_length}\ncorner_right_length: ${corner_right_length}\njoiner_right_length: ${joiner_right_length}\nborder_right_length: ${border_right_length}"

    # If either border substring is empty, throw an exception. Subsequent
    # centering expects such substrings to be strictly nonempty.
    :int.die_unless_positive "${border_left_length__sstsctwwsp}"\
        'Expected nonempty left border.'
    :int.die_unless_positive "${border_right_length__sstsctwwsp}"\
        'Expected nonempty right border.'

    # Inject colors into all prior substrings *EXCEPT* substrings to be
    # subsequently repeated, as previously discussed.
    corner_left__sstsctwwsp="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstsctwwsp}corner_left]-}${corner_left__sstsctwwsp}${ZESHY_STYLE_TO_COLOR[${style_prefix__sstsctwwsp}border_left]-}"
    joiner_left__sstsctwwsp="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstsctwwsp}joiner_left]-}${joiner_left__sstsctwwsp}${ZESHY_STYLE_TO_COLOR[${style_prefix__sstsctwwsp}text]-}"
    joiner_right__sstsctwwsp="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstsctwwsp}joiner_right]-}${joiner_right__sstsctwwsp}${ZESHY_STYLE_TO_COLOR[${style_prefix__sstsctwwsp}border_right]-}"
    corner_right__sstsctwwsp="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstsctwwsp}corner_right]-}${corner_right__sstsctwwsp}"

    # Number of "free" characters to the left and right of such string (i.e.,
    # number of characters *NOT* already allotted to corner and joiner
    # substrings), to be allotted to the left and border substrings.
    border_left_repeated_length__sstsctwwsp=$((\
        cipher_left_length__sstsctwwsp -\
        corner_left_length__sstsctwwsp -\
        joiner_left_length__sstsctwwsp ))
    border_right_repeated_length__sstsctwwsp=$((\
        cipher_right_length__sstsctwwsp -\
        corner_right_length__sstsctwwsp -\
        joiner_right_length__sstsctwwsp ))

    # If the length of either such border is non-positive, increase such length
    # to the minimum (namely, the length of a single border substring). Such
    # error condition implies the passed line width to be insufficient to
    # properly display such string. While any number of responses would suffice,
    # this is both the most expedient and (arguably) aesthetically pleasing.
    if (( border_left_repeated_length__sstsctwwsp < 1 )) {
          border_left_repeated_length__sstsctwwsp="${border_left_length__sstsctwwsp}"
    }
    if (( border_right_repeated_length__sstsctwwsp < 1 )) {
          border_right_repeated_length__sstsctwwsp="${border_right_length__sstsctwwsp}"
    }

    # Repeat border substrings as needed to fill all available space.
    :set_string_to_string_ansiless_repeated_to_length\
        border_left__sstsctwwsp\
        "${border_left__sstsctwwsp}"\
        "${border_left_repeated_length__sstsctwwsp}"
    :set_string_to_string_ansiless_repeated_to_length\
        border_right__sstsctwwsp\
        "${border_right__sstsctwwsp}"\
        "${border_right_repeated_length__sstsctwwsp}"

    # Set such variable to such centered string.
    :string.set "${string_name__sstsctwwsp}"\
        "${corner_left__sstsctwwsp}${border_left__sstsctwwsp}${joiner_left__sstsctwwsp}${text__sstsctwwsp}${joiner_right__sstsctwwsp}${border_right__sstsctwwsp}${corner_right__sstsctwwsp}"
}

# ....................{ CENTERERS                          }....................
declare_function_with_stdin <<'/---'
string center_string(string text1, ...)

Center the passed string(s) to the width of the current terminal, using user-
configurable styles prefixed by the dot-suffixed name of this function (i.e.,
`center_string.`). Assuming default `zeshy` settings, such styles are undefined,
implying such string(s) to be centered with spaces as expected. See
center_string_in_style_caller() for further details: e.g.,

.center_string()
==========================================
[source]
------------------------------------------
>>> string on_preventative_care=\
...    "\"So you think our medicine's pretty primitive?\"
...     \"That's the wrong word. It isn't primitive. It's fifty percent terrific
...     and fifty percent non-existent. Marvellous antibiotics — but absolutely
...     no methods for increasing resistance, so that antibiotics won't be
...     necessary. Fantastic operations — but when it comes to teaching people
...     the way of going through life without having to be chopped up,
...     absolutely nothing. And it's the same all along the line. Alpha Plus for
...     patching you up when you've started to fall apart; but Delta Minus for
...     keeping you healthy. Apart from sewerage systems and synthetic vitamins,
...     you don't seem to do anything at all about prevention. And yet you've
...     got a proverb: prevention is better than cure.\""
>>> center_string "$(get_string_word "${on_preventative_care}" -1)"
                                    cure."
------------------------------------------
==========================================
/---
function center_string() {
    # While deceptively trivial, this function should *NOT* be reduced to a
    # simple synonym of center_string_in_style_caller(). This function is
    # discretely separate from the latter to ensure that the style prefix used
    # expands to "center_string.". Assuming default zeshy styles, such prefix
    # prefixes no existing style, ensuring this function reliably centers such
    # string with spaces. (Phew!)
    die_unless_args 'Expected one or more strings.'
    center_string_in_style_caller "${*}"
}

# ....................{ CENTERERS ~ style                  }....................
declare_function_with_stdin <<'/---'
string center_string_in_style_caller(string text1, ...)

Center the passed string(s) to the width of the current terminal, using user-
configurable styles prefixed by the dot-suffixed caller's name (i.e.,
`$(get_caller).`) See center_string_in_style() for further details.
/---
function center_string_in_style_caller() {
    die_unless_args 'Expected one or more strings.'
    center_string_in_style "${*}" "$(get_caller)."
}

declare_function_with_stdin <<'/---'
string center_string_in_style(string text, string style_prefix)

Center the passed string to the width of the current terminal, using user-
configurable styles prefixed by the passed prefix. See
center_string_to_width_in_style() for further details.
/---
function center_string_in_style() {
    die_unless_args_2 'Expected one string and one style prefix.'
    :int terminal_width

    # Width of the current terminal.
    :set_int_to_terminal_width_if_found_or_default terminal_width

    # Center such strings.
    center_string_to_width_in_style "${1}" "${terminal_width}" "${2}"
}

declare_function_with_stdin <<'/---'
string center_string_to_width_in_style(
    string text,
    integer line_width,
    string style_prefix)

Center the passed string to the passed *line width* (i.e., an integer in
`[1, $(get_terminal_width)]`), using user-configurable styles prefixed by the
passed prefix. See :set_string_to_string_centered_to_width_in_style()
for further details.
/---
function center_string_to_width_in_style() {
    # Validate sanity.
    die_unless_args_3\
        'Expected one string, one line width, and one style prefix.'
    string output

    # Set and output such centered string.
    :set_string_to_string_centered_to_width_in_style output "${@}"
    :string.output "${output}"
}

#FIXME: In lieu of unit tests...
#function sayh() {
##   output_call_stack
#    print 'upended'  # should be two newlines after this!
#    print_message_heading 'dancing to'
#    print 'life'
#
#    function sayhsayh() {
#        print_message_heading 'beyond'
#        print 'genesis'
#        print_message_heading 'ein'
#        print 'lichtschein'
#
#        print
#        print 'line:'
#        output_line
#    }
#    sayhsayh
#    print_message_heading 'road to'
#    print 'ubar'
#}

# --------------------( WASTELANDS                         )--------------------
    # While deceptively trivial, this function should *NOT* be reduced to a
    # simple synonym of :output_string_centered(). This function is discretely
    # separate from the latter to ensure that the style prefix used expands to
    # "center_string.". Assuming default zeshy styles, such prefix prefixes no
    # existing style, ensuring this function reliably centers such string with
    # spaces. (Phew!)
#declare_function_with_stdin <<'/---'
#string :output_string_centered(string text1, ...)
#
#Center the passed string to the width of the current terminal, using user-
#configurable styles prefixed by the dot-suffixed caller's name (i.e.,
#`$(get_caller).`) See center_string_in_style() for further
#details.
#/---
#function :output_string_centered() {
#    die_unless_args 'Expected one or more strings.'
#    center_string_in_style "${*}" "$(get_caller)."
#}

#   runner_filename_prefix="${quote_double_left}"
#   runner_filename_suffix="${quote_double_right}"

        # print_message_heading(), printing output resembling:
        #
        # ────────{ hello }─────────
        # ────────╢ hello ╟─────────
        # ────────┨ hello ┠─────────
        # ├───────╼ hello ╾────────┤
        # ┠───────╼ hello ╾────────┨
        # ┌───────╼ hello ╾────────┐
        # ┎───────╼ hello ╾────────┒
        # ────────╼ hello ╾─────────
        # ────────• hello •─────────

    # If such line width is not in the required range, throw an exception.
#   terminal_width__sstsctwwsp="$(get_terminal_width)"
#   :int.die_unless_in_range\
#       "${line_width__sstsctwwsp}" 1 "${terminal_width__sstsctwwsp}"\
#       "Line width \"${line_width__sstsctwwsp}\" not an integer in [1, ${terminal_width__sstsctwwsp}]."

    # Width in characters of the current terminal.
#   print "terminal width: $(get_terminal_width) (${terminal_width})"

#FUXME: Generalize a new setter
#:set_string_to_string_centered_to_width_in_style() from such function.
#    string\
#        text="${1}"\
#        line_width="${2}"\
#        style_prefix="${3}"\
#        corner_left\
#        corner_right\
#        border_left\
#        border_right\
#        joiner_left\
#        joiner_right
#    integer\
#        terminal_width\
#        text_length\
#        cipher_left_length\
#        cipher_right_length\
#        corner_left_length\
#        corner_right_length\
#        border_left_length\
#        border_left_repeated_length\
#        border_right_length\
#        border_right_repeated_length\
#        joiner_left_length\
#        joiner_right_length
#
#    # If such line width is not in the required range, throw an exception.
#    terminal_width="$(get_terminal_width)"
#    :int.die_unless_in_range "${line_width}" 1 "${terminal_width}"\
#        "Line width \"${line_width}\" not an integer in [1, ${terminal_width}]."
#    # Width in characters of the current terminal.
##   print "terminal width: $(get_terminal_width) (${terminal_width})"
#
#    # Length of such text excluding non-printable characters and sequences.
#    :set_int_to_string_length_printable text_length "${text}"
#
#    # Number of characters preceding such text, when centering such text in the
#    # middle of an output terminal line. By design, assigning a floating point
#    # value to an integer variable implicitly rounds such value down to the
#    # nearest whole integer. In this case, such rounding ensures that, when the
#    # terminal width and text length are of differing parity (i.e., one is even
#    # and the other odd), the text will be offset to the left by one character
#    # of "the true center": e.g.,
#    #
#    #     # Centering a 4-character string on a 9-character wide terminal.
#    #     123456789   # terminal width indices; note "5" to be the center
#    #       test      # string offset to the left 1 character from center
#    cipher_left_length=$(( (line_width - text_length) / 2 ))
#
#    # Number of characters following such text, defined to be the number of
#    # characters on a terminal line neither preceding or containing such text.
#    cipher_right_length=$(( line_width - text_length - cipher_left_length ))
#
#    # Substrings to be measured but not repeated below and hence not yet
#    # injected with color.
#    #
#    # Corner and joiner substrings are optional, defaulting to the empty string.
#    corner_left="${ZESHY_STYLE_TO_TEXT[${style_prefix}corner_left]-}"
#    corner_right="${ZESHY_STYLE_TO_TEXT[${style_prefix}corner_right]-}"
#    joiner_left="${ZESHY_STYLE_TO_TEXT[${style_prefix}joiner_left]-}"
#    joiner_right="${ZESHY_STYLE_TO_TEXT[${style_prefix}joiner_right]-}"
##   print "border left: ${border_left}"
#
#    # Substrings to be repeated below and hence never injected with color. Since
#    # :set_string_to_string_ansiless_repeated_to_length() requires strings *NOT*
#    # containing colors, shift such colors to preceding substrings.
#    #
#    # Border substrings are mandatory, defaulting to a single space.
#    border_left="${ZESHY_STYLE_TO_TEXT[${style_prefix}border_left]- }"
#    border_right="${ZESHY_STYLE_TO_TEXT[${style_prefix}border_right]- }"
#
#    # Lengths of such substrings. For efficiency, inline such implementation.
#    # See get_string_ansiless_length_printable() for further details.
#    corner_left_length="${(m)#corner_left}"
#    corner_right_length="${(m)#corner_right}"
#    border_left_length="${(m)#border_left}"
#    border_right_length="${(m)#border_right}"
#    joiner_left_length="${(m)#joiner_left}"
#    joiner_right_length="${(m)#joiner_right}"
##   print "right_length: ${right_length}\ncorner_right_length: ${corner_right_length}\njoiner_right_length: ${joiner_right_length}\nborder_right_length: ${border_right_length}"
#
#    # This function centers with border substrings, rendering such substrings
#    # mandatory. If either such substring is empty, throw an exception.
#    :int.die_unless_positive "${border_left_length}"\
#        'Expected nonempty left border.'
#    :int.die_unless_positive "${border_right_length}"\
#        'Expected nonempty right border.'
#
#    # Number of "free" characters to the left and right of such string (i.e.,
#    # number of characters *NOT* already allotted to corner and joiner
#    # substrings), to be allotted to the left and border substrings.
#    border_left_repeated_length=$((\
#        cipher_left_length -\
#        corner_left_length -\
#        joiner_left_length ))
#    border_right_repeated_length=$((\
#        cipher_right_length -\
#        corner_right_length -\
#        joiner_right_length ))
#
#    # If the length of either such border is non-positive, increase such length
#    # to the minimum (namely, the length of a single border substring). Such
#    # error condition implies the passed line width to be insufficient to
#    # properly display such string. While any number of responses would suffice,
#    # this is both the most expedient and (arguably) aesthetically pleasing.
#    if (( border_left_repeated_length < 0 )) {
#          border_left_repeated_length="${border_left_length}"
#    }
#    if (( border_right_repeated_length < 0 )) {
#          border_right_repeated_length="${border_right_length}"
#    }
#
#    # Repeat such border substrings as needed to fill all available space.
#    :set_string_to_string_ansiless_repeated_to_length\
#        border_left  "${border_left}"  ${border_left_repeated_length}
#    :set_string_to_string_ansiless_repeated_to_length\
#        border_right "${border_right}" ${border_right_repeated_length}
#
#    #FIXME: Shift colors above.
#    # Print such text.
#    :string.output\
#        "${ZESHY_STYLE_TO_COLOR[${style_prefix}corner_left]-}${corner_left}${ZESHY_STYLE_TO_COLOR[${style_prefix}border_left]-}${border_left}${ZESHY_STYLE_TO_COLOR[${style_prefix}joiner_left]-}${joiner_left}${ZESHY_STYLE_TO_COLOR[${style_prefix}text]-}${text}${ZESHY_STYLE_TO_COLOR[${style_prefix}joiner_right]-}${joiner_right}${ZESHY_STYLE_TO_COLOR[${style_prefix}border_right]-}${border_right}${ZESHY_STYLE_TO_COLOR[${style_prefix}corner_right]-}${corner_right}"

    #FUXME: This now smacks of overcomplexity. Thanks to
    #:set_string_to_string_ansiless_repeated_to_length(), we can (and should)
    #seemlessly repeat substrings not perfectly filling the allotted length.
    #This implies that we don't really need or want any excess space characters
    #and hence no variables ${space_left_length} or ${space_right_length} below.
    #Jeez! Shame we didn't concoct such function earlier. Contemplate excising
    #all or most of this, I should think.

    # Number of times to repeat the left and right border substrings to
    # produce a borderline filling as much of the space between the
    # corresponding corner and joiner substrings as possible. If such
    # substring is a single character, this is always possible; else, this
    # is only possible if the length of such substring evenly divides the
    # length of such space.
#   borderline_left_count=$((  border_left_length  / border_left_length ))
#   borderline_right_count=$(( border_right_length / border_right_length ))

    #FUXME: Excise.
    # Number of space characters to precede and follow such text. Such
    # characters are required *ONLY* if the corresponding border substring
    # is longer than a single character and cannot perfectly fill the space
    # allotted to such border, as discussed above.
#    space_left_length=$(( border_left_length -\
#        (borderline_left_count *  border_left_length) ))
#    space_right_length=$(( border_right_length -\
#        (borderline_right_count * border_right_length) ))
##   print "left_length: ${left_length}\ncorner_left_length: ${corner_left_length}\njoiner_left_length: ${joiner_left_length}\nborder_left_length: ${border_left_length}\nborderline_left_count: ${borderline_left_count}\nspace_left_length: ${space_left_length}\n\nright_length: ${right_length}\ncorner_right_length: ${corner_right_length}\njoiner_right_length: ${joiner_right_length}\nborder_right_length: ${border_right_length}\nborderline_right_count: ${borderline_right_count}\nspace_right_length: ${space_right_length}"

    #FUXME: Excise.
    # If either such numbers are negative, throw an exception. Note that
    # corner and joiner substrings are optional and hence do not require such
    # exception handling.
#    :int.die_unless_nonnegative "${space_left_length}"\
#        'Left whitespace string length negative.'
#    :int.die_unless_nonnegative "${space_right_length}"\
#        'Right whitespace string length negative.'

    #FUXME: Refactor to simply call
    #:set_string_to_string_ansiless_repeated_to_length().
    # Left and right border lines.
#    borderline_left="$( repeat_string "${border_left}"  ${borderline_left_count})"
#    borderline_right="$(repeat_string "${border_right}" ${borderline_right_count})"

    #FUXME: Excise.
    # Left and right space fillers.
#    space_left="$( repeat_string ' ' ${space_left_length})"
#    space_right="$(repeat_string ' ' ${space_right_length})"

    #FUXME: Such variables must exclude ANSI escape sequences! Shift such
    #sequences to the prior left corner and prior left joiner, respectively.
    #FUXME: Rename such variables, please.

    # If the number of characters preceding such text is less than 1, the
    # current terminal is insufficiently wide to border such text. Print such
    # text as is and immediately return.
#    if (( cipher_left_length <= 1 )) {
#        # Text to be returned.
#        string text_centered
#
#        # Color such text.
#        text_centered+="${ZESHY_STYLE_TO_COLOR[${style_prefix}text]-}"
#
#        # If such number is 1, such text's length is either 2 or 3 characters
#        # less than such width. Hence, 1 character to the left of and either 1 or 2
#        # characters to the right of such text remain for a border. This isn't
#        # terribly much. In the absence of anything better to do, print such text
#        # offset from the beginning of the terminal line by 1 character.
#        if (( cipher_left_length == 1 )) {
#            text_centered+=' '
#        # Else such number is nonpositive (i.e., less than or equal to 0).
#        #
#        # If such number is negative, such text exceeds such terminal in length.
#        # In the absence of anything better to do, print such text as is. While
#        # this guarantees such text to wrap around at least once, truncating such
#        # text to the current terminal width often produces worse results.
#        #
#        # If such number is 0, such text's length is either the terminal width or
#        # one character less than such width. In the former case, no space remains
#        # for a border; in the latter case, only one character of space remains,
#        # hardly enough for even delimiting whitespace. In the absence of anything
#        # better to do, again print such text as is.
#        #
#        # For both efficiency and simplicity, unify both such cases here.
#        } # elif (( left_length <= 0 )) { }
#
#        # Return such text.
#        text_centered+="${text}"
#        return_string  "${text}"
#    }

    #FUXME: Actually, if the length of such string exceeds the terminal width,
    #it turns out to be quite a bit better aesthetically to prefix and suffix
    #such string with *ONLY* the appropriate corner styles (but not border or
    #joiner styles). This helps to visually distinguish long lines as either
    #(typically) headers or footers, despite their length.
    #FUXME: Actually, printing a single corner, border, and joiner for both the
    #left and right sides should do nicely, I should think. Which is to say,
    #simply floor such substrings to ensure their length is never less than 1.
    #FUXME: Simplify as documented above by simply flooring the prior lengths to 1.

    # If either such number is negative, the current terminal is sufficiently
    # wide to print such text but *NOT* such corners, borders, and joiners. Any
    # number of possible responses to such problem exist. For convenience, we
    # currently adopt the simplest: reduce all corners and joiners on each
    # problem side to the empty string and recalculate the corresponding number,
    # which should now be nonnegative.
#   if (( border_left_length < 0 )) {
#        corner_left=''
#        joiner_left=''
#        corner_left_length=0
#        joiner_left_length=0
#        border_left_length="${left_length}"
#   }
#   if (( border_right_length < 0 )) {
#        corner_right=''
#        joiner_right=''
#        corner_right_length=0
#        joiner_right_length=0
#        border_right_length="${right_length}"
#   }

#   text_length="$(get_string_length_printable "${text}")"
    #FUXME: Permit caller to set such width. We'll need a new function
    #center_string_to_width_in_style() called by this
    #function. Yum! yum.

# if either are
    # empty. (Since corner and joiner substrings are optional, such exception
    # handling applies only to border substrings.)
# If the length of such string
#exceeds such width, such string will be printed ``as is'' (i.e., without
#prefixing or suffixing such string by styles documented below).

#       :string.output "ok${(l:$(( text_line_length - ${(m)#text_line})):: :):-}ko"
        # Construct such line.
#       if is -n "${match['${ZESHY_PCRE_WRAPPING_INDEX_DELIMITED}']}" si {
#           text_line="${text_color}${match['${ZESHY_PCRE_WRAPPING_INDEX_DELIMITED}']}"
#       } else {
#           text_line="${text_color}${match['${ZESHY_PCRE_WRAPPING_INDEX_UNDELIMITED}']}-"
#       }

    # Length of such text, excluding non-printable characters and sequences.
#   text_length="$(get_string_length_printable "${text}")"
#       text_length\
#       line_prefix_length\

    # If such width is sufficiently small, it's not feasible to print both a box
    # and at least one character in such box. In such cases, print such string
    # as is and immediately return.
#   if (( terminal_width <= 5 )) {
#       return_string "${text}"
#   }

# substring to be printed on each output line.

    #FUXME: Create such function, which should simply call
    #reset_terminal_color() currently (but which subsequently could be made to
    #perform additional functionality).
    # If required, print delimiting prefixing whitespace.
#   :print_stdout_separated_start

    #FUXME: It'd be silly to reimplement a method printing a box header, given
    #the already sufficiently complex print_message_heading() function. We'll need to
    #generalize such function to call a new "driver" function, doing the lion's
    #share of printing work -- say, print_string_centered_with_border().
    #FUXME: Interestingly, given such function, we can instantly a new
    #print_string_centered() to simply call such function with a map whose
    #border characters all simply expand to a single space. Nice.

    # If the current locale encodes to UTF-8, output UTF-8; else, ASCII.
#   if { is_locale_encoding_utf8 } {
#       border_north='═'
#       border_south='─'
#       border_west='│'
#       border_east='│'
#       border_north_west='╒'
#       border_north_east='╕'
#       border_south_west='╰'
#       border_south_east='╯'
#   } else {
#       border_north='-'
#       border_south='-'
#       border_west='|'
#       border_east='|'
#       border_north_west='/'
#       border_north_east='\'
#       border_south_west='\'
#       border_south_east='/'
#   }

#Print the passed string wrapped to the current terminal width, prefixing each
#resulting line with the passed prefix. Specifically:
#
#. Split such string into substrings satisfying the following constraints:
#** Each substring is suffixed by either whitespace or the end of such string.
#** Each substring is no longer than the current terminal width subtracted by the
#   length of such prefix.
#. Print each substring prefixed by such prefix and suffixed by a newline.
#
#For example:
#
#.print_string_boxed_with_color_style_prefix()
#==========================================
#[source]
#------------------------------------------
#>>> string on_boxes=\
#...    "The box is full of salmon, and a man sits atop the box. Long ago this"\
#...    "man hired armed guards to keep anyone from eating his fish. The many"\
#...    "people who sit next to the empty river starve to death. But they do"\
#...    "not die of starvation. They die of a belief. Everyone believes that"\
#...    "the man atop the box owns the fish. The soldiers believe it, and they"\
#...    "will kill to protect the illusion. The others believe it enough that"\
#...    "they are willing to starve. But the truth is that there is a box,"\
#...    "there is an emptied river, there is a man sitting atop the box, there"\
#...    "are guns, and there are starving people."
#>>> print_string_wrapped_with_line_prefix "${on_boxes}" box
#box: The box is full of salmon, and a man sits atop the box. Long ago this man
#box: hired armed guards to keep anyone from eating his fish. The many people who
#box: sit next to the empty river starve to death. But they do not die of
#box: starvation. They die of a belief. Everyone believes that the man atop the
#box: box owns the fish. The soldiers believe it, and they will kill to protect
#box: the illusion. The others believe it enough that they are willing to starve.
#box: But the truth is that there is a box, there is an emptied river, there is a
#box: man sitting atop the box, there are guns, and there are starving people.
#------------------------------------------
#==========================================

#(i.e., substrings "joining" borders to adjacent text)
#If such styles do not exist,
#this function defaults to simply centering such string without embellishment.
#
#This function supports a variety of color and text styles.
#all of the following styles that are existing keys of maps
#${ZESHY_STYLE_TO_COLOR} (identifying the colors to be output) and
#${ZESHY_STYLE_TO_TEXT} (identifying the string literals to be output):

#As configured by the
#current user and theme, such styles identify the colors and string literals with
#which to aesthetically embellish the passed string. If such styles do not exist,
#this function defaults to simply centering such string without embellishment.

#string print_string_centered_and_string_wrapped_in_style(

#FUXME: Oh, wait! We can get the 'color_style_category' just by calling
#"$(get_caller)", so don't bother explicitly passing it. (Let's simplify life a
#tad, in other words.)
#FUXME: It'd be great to eventually support the subdivision of the border
#into appropriate subsections: e.g.,
#
#     ====~~~-{ text }--~~~===
#
#The principal annoyance there, of course, is that for each possible
#subdivision you add, you have to add the corresponding number of
#conditionals below. Hmmm; or perhaps not? Hmmm. Right. We should be able to
#concoct a single governing equation determining how many characters of each
#subdivision to print, even in edge cases of small terminal lines: e.g.,
#
#     ~-{ text }-~
#FUXME: Actually, we'd probably just want to subdivide the *COLORS* of the
#single-character border into a gradient. Don't change the characters;
#change the colors. This is both simpler and more aesthetically pleasing,
#particularly under 256-color terminals.

    # If either such number is negative, the current terminal is sufficiently
    # wide to print such text but *NOT* such corners, borders, and joiners. Any
    # number of possible responses to such problem exist. For convenience, we
    # currently adopt the simplest: reduce all corners and joiners on each
    # problem side to the empty string and recalculate the corresponding number,
    # which should now be nonnegative.
#   if (( borderline_left_count < 0 )) {
#       corner_left_length=0
#       joiner_left_length=0
#       borderline_left_count=$(( left_length / border_left_length ))
#   }
#   if (( borderline_right_count < 0 )) {
#       corner_right_length=0
#       joiner_right_length=0
#       borderline_right_count=$(( right_length / border_right_length ))
#   }

    # If the current locale encodes to UTF-8, prefer UTF-8 substrings.
    # Default unset border substrings to a single space and all other
    # substrings to the empty string.
#   if { is_locale_encoding_utf8 } {
#        corner_left="${ZESHY_STYLE_TO_TEXT.corner_left_utf8__lm-}"
#       corner_right="${corner_right_utf8__lm-}"
#        border_left="${border_left_utf8__lm- }"
#       border_right="${border_right_utf8__lm- }"
#        joiner_left="${joiner_left_utf8__lm-}"
#       joiner_right="${joiner_right_utf8__lm-}"
    # Else, fallback to ASCII substrings.
#   } else {
#        corner_left="${corner_left_ascii__lm-}"
#       corner_right="${corner_right_ascii__lm-}"
#        border_left="${border_left_ascii__lm- }"
#       border_right="${border_right_ascii__lm- }"
#        joiner_left="${joiner_left_ascii__lm-}"
#       joiner_right="${joiner_right_ascii__lm-}"
#   }

    # Localize all keys of such map into string locals suffixed by "__lm".
#   localize_map "${map_name}"

    # Prefix for all color style names expanded below, defaulting to the name
    # of the caller suffixed by "." (e.g., "print_message_heading."). Should no such
    # styles exist, such styles will simply be ignored. Since get_caller() must
    # be called in the current function, such initialization must be performed
    # manually rather than by set_string_if_unset_to_evaluation().
#   :var.is color_style_prefix__lm or {
#       string color_style_prefix__lm; color_style_prefix__lm="$(get_caller)."
#   }

#FUXME: Once we get this working, there's a far better alternative generalizing
#substring choices in the same manner that ${ZESHY_STYLE_TO_COLOR} generalizes
#color choices. In order:
#
#* Create a new *EMPTY* parcel tree "src/if_theme/vanilla", as before.
#* Shift "src/if_config/color" to "src/if_config/theme/color".
#* Create a new parcel            "src/if_config/theme/text".
#* Add two new map globals to the latter such parcel:
#  * ${ZESHY_STYLE_TO_TEXT_ASCII}.
#  * ${ZESHY_STYLE_TO_TEXT_UTF8}.
#* Rename map global ${ZESHY_STYLE_TO_COLOR} to ${ZESHY_STYLE_TO_COLOR_NAMES}, in
#  keeping with such nomenclature.
#* Replace the last parameter to this function with
#  'string style_prefix = "$(get_caller)."'. This thus reduces most functions
#  calling this function to simply the function call only the passed text: e.g.,
#
#    # This works even *WITHOUT* defining any color styles for
#    # "print_string_centered", thanks to helpful defaults.
#    function print_string_centered() {
#        get_string_centered_with_map_attributes "${*}"
#    }
#
#    # This works assuming we convert passed arguments to map attributes: e.g.,
#    # ZESHY_STYLE_TO_TEXT_ASCII=(
#    #     'print_message_heading.border_left' '-'
#    # )
#    function print_message_heading() {
#        get_string_centered_with_map_attributes "${*}"
#    }
#
#The answer to the question "What are zeshy styles?" is thus "Unique strings
#index maps in parcels under src/if_config/theme/".
#FUXME: Reimplement to simply call print_string_centered_with_border().

#   map map_attributes; map_attributes=(
        # Popular alternative schemes:
        #
        # ────────{ hello }─────────
        #
        # ────────╢ hello ╟─────────
        #
        # ────────┨ hello ┠─────────
        #
        # ┠───────╼ hello ╾────────┨
        #
        # ├───────╼ hello ╾────────┤
        #
        # ┎───────╼ hello ╾────────┒
        #
        # ────────╼ hello ╾─────────
        #
#       'border_left_utf8'   '─'
#       'border_left_ascii'  '-'
#       'border_right_utf8'  '─'
#       'border_right_ascii' '-'
#       'joiner_left_utf8'   '╼ '
#       'joiner_left_ascii'  '{ '
#       'joiner_right_utf8'  ' ╾'
#       'joiner_right_ascii' ' }'
#   )
#   get_string_centered_with_map_attributes "${*}" 'map_attributes'

    # String to be printed, concatenated from remaining arguments.
#   text="${*}"

    # If such text length and terminal width have different parity (i.e.,
    # one is even and the other odd), such text cannot be evenly centered in
    # the current terminal and hence must be offset either one character to the
    # left or right of "true" center. For subjectively (and entirely marginally)
    # better aesthetics, offset such text to the left.
    #
    # If additionally the right border substring is a single character, such
    # offsetting is best achieved by extending such border to the right by a
    # single character; else, such offsetting will be achieved below by
    # appending a space after such text.
#   if (( border_right_length__pscwm == 1 )) and
#       { not :is_int_parity_equals\
#           ${terminal_width__pscwm} ${text_length__pscwm} } {
#       borderline_right_count__pscwm+=1
#   }

#   die_unless_map_keys "${map_name__pscwm}"\
#       'color_style_prefix'
#       :int.die_unless_nonnegative "${borderline_left_count__pscwm}"\
#           ''
#       :int.die_unless_nonnegative "${borderline_right_count__pscwm}"\

    # suggesting either the left or right extend such border by another character. While the left border
    # could instead be extended in this way, extending the right border
    # produces a subjectively (and entirely marginally) better aesthetic.
    # If such number is at least 2, such text is at least 4 characters less
    # than such width. Hence, at least 2 characters to the left of *AND* to the
    # right of such text remain for a border. Since this suffices for simple
    # border art, print such text preceded by a colorfully aesthetic border.
    # While it would be nice to split this conditional into a separate function,
    # dependency on multiple local variables above makes this a bad proposition.
#   if (( left_count__pscwm >= 2 )) {

#   string color_style_prefix__lm="${color_style_prefix__lm}-$(get_caller).}"
# these numbers are typically 0.
        #FUXME: If the length of either border substring is greater than 1, it's
        #feasible such length may not perfectly divide the allotted space, in
        #which case... what? Well, we should probably just fill the remaining
        #space immediately adjacent to such text with horizontal whitespace.

        #FUXME: Just inline such calls below. This is extreme overkill.
        #FUXME: Actually, we need to reuse the border l

#       (( borderline_left_count__pscwm = border_count_right__pscwm =\
#           character_count_left__pscwm - 2 ))
        # Number of border characters preceding and succeeding such text,
        # respectively. Such numbers are always nonnegative (i.e., >= 0).

        # Characters constituting:
        #
        # * Both left and right borders.
        # * Both left and right joiners (i.e., character "joining" text
        #   titles to adjacent borders).
#       string\
#           character_border__pscwm\
#           character_joiner_left__pscwm='{ '\
#           character_joiner_right__pscwm=' }'

        # Default unpassed substrings to the empty string space.
#declare_function_with_stdin <<'/---'
#string print_message_heading(string heading1 = "", string heading2, ...)
#
#Print the passed strings (defaulting to the empty string) as a section heading
#suffixed by a newline to standard output. See :string.output() for further
#details.
#/---
#function print_message_heading() {
#    # Heading to be printed, concatenated from passed arguments.
#    string heading="${*}"
#    integer terminal_width heading_length character_count_left
#
#    # If the current call stack has already called a high-level print function,
#    # print delimiting whitespace.
#    :print_stdout_separated_start
#
#    # Lengths of the current terminal and heading. The latter excludes non-
#    # printable characters, including ANSI color escapes.
#    terminal_width="$(get_terminal_width)"
#    heading_length="$(get_string_length_printable\
#        "${heading}")"
#
#    # Number of characters preceding such heading, when centering such heading
#    # in the middle of an output terminal line. By design, assigning a floating
#    # point value to an integer variable implicitly rounds such value down to
#    # the nearest whole integer. In this case, such rounding ensures when the
#    # terminal width and heading length are of differing parity that the heading
#    # will be offset to the left one character from the true "center": e.g.,
#    #
#    #     # Centering a 4-character string on a 9-character wide terminal.
#    #     123456789   # terminal width indices; note "5" to be the center
#    #       test      # string offset to the left 1 character from center
#    (( character_count_left = (terminal_width - heading_length) / 2 ))
#
#    #FUXME: It'd be great to eventually support the subdivision of the border
#    #into appropriate subsections: e.g.,
#    #
#    #     ====~~~-{ heading }--~~~===
#    #
#    #The principal annoyance there, of course, is that for each possible
#    #subdivision you add, you have to add the corresponding number of
#    #conditionals below. Hmmm; or perhaps not? Hmmm. Right. We should be able to
#    #concoct a single governing equation determining how many characters of each
#    #subdivision to print, even in edge cases of small terminal lines: e.g.,
#    #
#    #     ~-{ heading }-~
#    #FUXME: Actually, we'd probably just want to subdivide the *COLORS* of a
#    #single-character border into a gradient. Don't change the characters;
#    #change the colors.
#
#    # If such number is at least 2, such heading is at least 4 characters less
#    # than such width. Hence, at least 2 characters to the left of *AND* to the
#    # right of such heading remain for a border. Since this suffices for simple
#    # ANSI art, print such heading preceded by a colorfully aesthetic border.
#    # While it would be nice to split this conditional into a separate function,
#    # dependency on multiple local variables above makes this a bad proposition.
#    if (( character_count_left >= 2 )) {
#        # Number of border characters (e.g., "-") preceding and succeeding such
#        # heading, respectively. Such numbers are always nonnegative (>= 0).
#        integer border_count_left border_count_right
#        (( border_count_left = border_count_right = character_count_left - 2 ))
#
#        # If such heading length and terminal width have different parity (i.e.,
#        # one is even and the other odd), 1 additional character of space to the
#        # right of such heading remains for a border; allocate such space!
#        if { not :is_int_parity_equals\
#            ${terminal_width} ${heading_length} } {
#            border_count_right+=1
#        }
#
#        # Characters constituting:
#        #
#        # * Both left and right borders.
#        # * Both left and right joiners (i.e., character "joining" heading
#        #   titles to adjacent borders).
#        character\
#            character_border\
#            character_joiner_left='{ '\
#            character_joiner_right=' }'
#
#        # If the current locale encodes to UTF-8, output UTF-8; else, ASCII.
#        if { is_locale_encoding_utf8 } {
#            character_border='─'
#        } else {
#            character_border='-'
#        }
#
#        # Left and right borders consisting of such characters.
#        string left_border right_border
#        left_border="$( repeat_string "${character_border}" ${border_count_left})"
#        right_border="$(repeat_string "${character_border}" ${border_count_right})"
#
#        # Print such heading.
#        :string.output\
#            "${ZESHY_STYLE_TO_COLOR[print_message_heading.border]-}${left_border}${ZESHY_STYLE_TO_COLOR[print_message_heading.joiner]-}${character_joiner_left}${ZESHY_STYLE_TO_COLOR[print_message_heading.heading]-}${heading}${ZESHY_STYLE_TO_COLOR[print_message_heading.joiner]-}${character_joiner_right}${ZESHY_STYLE_TO_COLOR[print_message_heading.border]-}${right_border}"
#    # If such number is 1, such heading's length is either 2 or 3 characters
#    # less than such width. Hence, 1 character to the left of and either 1 or 2
#    # characters to the right of such heading remain for a border. This isn't
#    # terribly much. In the absence of anything better to do, print such heading
#    # offset from the beginning of the terminal line by 1 character.
#    } elif (( character_count_left == 1 )) {
#        :string.output " ${heading}"
#    # Else such number is nonpositive (i.e., less than or equal to 0).
#    #
#    # If such number is negative, such heading exceeds such terminal in length.
#    # In the absence of anything better to do, print such heading as is. While
#    # this guarantees such heading to wrap around at least once, truncating such
#    # heading to the current terminal width often produces worse results.
#    #
#    # If such number is 0, such heading's length is either the terminal width or
#    # one character less than such width. In the former case, no space remains
#    # for a border; in the latter case, only one character of space remains,
#    # hardly enough for even delimiting whitespace. In the absence of anything
#    # better to do, again print such heading as is.
#    #
#    # For both efficiency and simplicity, unify both such cases here.
#    } else {  # guard condition :: elif (( character_count_left <= 0 ))
#        :string.output "${heading}"
#    }
#}


#FUXME: Actually, we want to pass a map name, where the map is structured:
#
#     "${map_name}"=(
#         'color_style_category' 'print_message'
#     )
#. This PCRE assumes *multiline matching*
#(i.e., the `.` quantifier matches all characters _except_ newline) and hence
#should only be used under such matching
# Match
    # multiline to prevent "." from matching newlines.
    # Return such string.
#   return_string "${text_wrapped}"

#Wouldn't you like to see a positive LSD story on the news? To base your decision on information rather than scare tactics and superstition? Perhaps? Wouldn't that be interesting? Just for once?
#   "Today, a young man on acid realized that all matter is merely energy condensed to a slow vibration – that we are all one consciousness experiencing itself subjectively. There's no such thing as death, life is only a dream, and we're the imagination of ourselves. Here's Tom with the weather."

    # PCRE wrapping lines to such length.
#   pcre_wrapping_lines="$(get_pcre_wrapping_at_line_length "${line_length}")"

    #FUXME: Abstract into a string global.
    # PCRE matching such a substring. To ensure human-readable output, wrap at
    # word endings by requiring such substring be suffixed by either whitespace
    # or the end of such string. To accept zsh code embedded in such input,
    # avoid character classes "\w" and "\W" matching spoken language words.
    # Dismantled, this is:
    #
    # * "\G", anchoring such match immediately after the end of the prior match.
    # * "\h*+", matching ignorable horizontal whitespace (i.e., non-newline)
    #   without backtracking, for efficiency.
    # * "(?:...)", matching either:
    #   * "\n", a newline, in which case ${match[1]} will be the empty string,
    #     ensuring an equivalent of ':string.output "${match[1]}"' will simply
    #     reprint the matched newline.
    #   * "(.{...})", a line's worth of text to ${match[1]}, optionally:
    #     * "(-)", capturing a hyphen suffix to ${match[2]}.
    # * "(?(2)|(?:...))", matching either:
    #   * If a hyphen suffix previously matched, then nothing else.
    #   * Else, mandatory horizontal whitespace, a newline, or the string end.
    #     In any case, such suffix will typically be converted into a newline.
#   line_pcre='\G\h*+(?:\n|(.{1,'${line_length}'}(-)?)(?(2)|(?:\h+|$))'
    # * "(?:...)", matching such line's delimiter as either:

#Minimizing Line Count versus Right Raggedness 
#a maximal line's worth  substring. To ensure human-readable output, wrap at
#word endings by requiring such substring be suffixed by either whitespace
#or the end of such string.
