#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "COPYING" for additional details.

:parcel <<'-/-'
Handle *character locale encodings* (e.g., UTF-8, US-ASCII).
-/-

# ....................{ GLOBALS                            }....................
:map_global ZESHY_STYLE_TO_TEXT <<'/---'
Map from each style to the string literal printing such style under the current
locale. Literal styles improve readability, genericity, and configurability by
substituting hard-coded literals with user-configurable style names (e.g.,
substituting `┨` with `${ZESHY_STYLE_TO_COLOR[print_usage.joiner_left]}`). See
${ZESHY_STYLE_TO_TEXT_UTF8} and ${ZESHY_STYLE_TO_TEXT_ASCII} for the maps from
which this map is initialized.
/---

:string_global ZESHY_LOCALE_ENCODING <<'/---'
Character locale encoding, cached by calling get_locale_encoding() on `zeshy`
startup. See such function.
/---

# ....................{ TESTERS                            }....................
#FIXME: Rename to :locale.is_encoding_utf8().
declare_function_with_stdin <<'/---'
[status = :bool] is_locale_encoding_utf8()

Return success if the current character locale encodes to UTF-8. Specifically,
return success if such locale is suffixed by either:

* `.utf8`, the canonical identifier for such encoding.
* `.UTF-8`, a non-canonical (but common) identifier for such encoding.

For example:

.is_locale_encoding_utf8()
==========================================
[source]
------------------------------------------
>>> get_locale_character
en_CA.utf8
>>> is_locale_encoding_utf8 and :string.output '☺' or :string.output ':)'
☺
------------------------------------------
==========================================
/---
function is_locale_encoding_utf8() {
    die_if_args
    is "$(get_locale_encoding)" == ('utf8'|'UTF-8') si
}

# ....................{ GETTERS                            }....................
#FIXME: Refactor into a setter :locale.set_encoding().
declare_function_with_stdin <<'/---'
string get_locale_encoding()

Get the current *character locale encoding* (i.e., a unique identifier
signifying the character map the current shell decodes standard input from and
encodes standard output to). Such character map and hence encoding is typically
defined for each locale at locale creation time via `localedef -f`: e.g.,

.get_locale_encoding()
==========================================
[source]
------------------------------------------
>>> get_locale_character
en_CA.utf8
>>> get_locale_encoding
UTF-8
------------------------------------------
==========================================
/---
function get_locale_encoding() {
    # Validate sanity.
    die_if_args

    #FIXME: Does "locale charmap" either fail or return the empty string if no
    #charmap option was passed to "localedef"? One or the other must certainly
    #be the case. Not terribly sure how to reliably test this. In any case,
    #revert to matching get_character_locale() output if "locale" fails.

    # If "locale" is in the current ${PATH}, defer to such command. See locale
    # documentation for the complex details.
    if { is_pathable locale } {
        command locale charmap
    # Else, attempt to extract such encoding from the current character locale
    # with extended glob matching.
    } else {
        string locale_character; locale_character="$(get_locale_character)"
        get_string_text_matching_glob_group_if_found "${locale_character}" '*.(?*)' or {
            print_warning "character locale \"${locale_character}\" not suffixed by a \".\"-prefixed encoding; defaulting to \"ISO-8859-1\""
            return_string 'ISO-8859-1'
        }
    }
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void set_locale_encoding_globals()

Set all globals whose values depend on the character encoding of the current
locale, including:

* ${ZESHY_LOCALE_ENCODING}.
* ${ZESHY_STYLE_TO_TEXT}.
/---
function set_locale_encoding_globals() {
    # Validate sanity.
    die_if_args

    # Set such encoding.
    ZESHY_LOCALE_ENCODING="$(get_locale_encoding)"

    # If such encoding is UTF-8, set map globals accordingly.
    if { is_locale_encoding_utf8 } {
        set_map_to_map ZESHY_STYLE_TO_TEXT ZESHY_STYLE_TO_TEXT_UTF8
    # Else, assume such encoding is ASCII. Set map globals accordingly.
    } else {
        set_map_to_map ZESHY_STYLE_TO_TEXT ZESHY_STYLE_TO_TEXT_ASCII
    }
}

# ....................{ HOOKS                              }....................
# Initialize all remaining color globals before compiling zeshy's user digest
# file, ensuring such globals to be compiled into such file and hence *ALWAYS*
# accessible on zeshy startup. Such hook function expands configuration-specific
# globals inaccessible until precompilation (e.g., ${ZESHY_STYLE_TO_TEXT_UTF8})
# and hence cannot be reduced to an anonymous function run immediately here.
:run_hook_on_zeshy_precompile precompile_zeshy_locale_encoding
run_hook_on_zeshy_startup       startup_zeshy_locale_encoding

declare_function_with_stdin <<'/---'
void precompile_zeshy_locale_encoding()

Initialize character locale encoding-specific globals to be compiled into
`zeshy`\'s user digest file. If the current such encoding differs from such
encoding on subsequent `zeshy` startup, startup_zeshy_locale_encoding() will
necessarily reinitialize globals whose values depend on such encoding.
/---
function precompile_zeshy_locale_encoding() {
    die_if_args
    set_locale_encoding_globals
}

declare_function_with_stdin <<'/---'
void startup_zeshy_locale_encoding()

If the the current character locale encoding differs from such encoding at the
time of the most recent compilation of `zeshy`\'s user digest file,
reininitialize globals whose values depend on such encoding. See
set_locale_encoding_globals() for further details.
/---
function startup_zeshy_locale_encoding() {
    # Validate sanity.
    die_if_args

    # Reinitialize encoding globals, if necessary. Note that
    # ${ZESHY_LOCALE_ENCODING} is set by set_locale_encoding_globals() itself
    # called by precompile_zeshy_locale_encoding() during the most recent
    # compilation of zeshy's user digest file.
    if is "$(get_locale_encoding)" != "${ZESHY_LOCALE_ENCODING}" si {
        set_locale_encoding_globals
    }
}

# --------------------( WASTELANDS                         )--------------------
# For startup
    # efficiency, avoid calling set_map_to_map().
#       :var.die_unless_type_map ZESHY_STYLE_TO_TEXT_UTF8
#       ZESHY_STYLE_TO_TEXT=( ${(kv@)ZESHY_STYLE_TO_TEXT_UTF8} )

    # If such encoding has already been cached to a global, expand such global.
    # Do not bother caching such global below: since this function is typically
    # called from a command substitution, setting such global below would fail
    # to set such global in the parent shell.
#   if { is_string_nonempty "${ZESHY_LOCALE_ENCODING}" } {
#       return_string       "${ZESHY_LOCALE_ENCODING}"
#   }

#Unique identifier signifying the character map the current shell decodes
#standard input from and encodes standard output to. See get_locale_encoding()
#for further details.

    # The current character locale enables UTF-8 encoding if suffixed by either:
    #
    # * ".utf8", the canonical UTF-8 encoding name or
    # * ".UTF-8", a non-canonical but common alias of ".utf8".

#FUXME: For such a central function called countless of times elsewhere, this is
#simply too heavyweight -- particularly as is_locale_encoding_utf8() will
#readily do. The "_character" is redundant, since locale encodings are *ALWAYS*
#locale character encodings. (There's no other sort.)
#
#tl;dr
#=====
#Rename to is_locale_encoding_utf8() and shift to a new component
#"io/locale/encoding". (Shift function get_locale_encoding() as well, of
#course.)
#FUXME: Wait. Even the "_locale" is redundant, since "encoding" is, of course,
#the noun referring to the current character encoding. Hence, rename such
#family of functions to is_locale_encoding_utf8() and get_locale_encoding(). Simple!
