#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

#FIXME: This isn't right, of course. We're declaring documentation under the
#current parcel, currently. To rectify this, a technique resembling the
#following should apply:
#
#    #FIXME: Define :set_parcel_to_path(), ideally renaming
#    set_parcel_as_script().
#
#    # Set the current parcel to that of @{05-parcel}.
#    :set_parcel_to_path "${ZESHY_HOME}/"*-core/*-declare/*-parcel
#
#    # Caller declare_*() functions here.
#    ...

declare_parcel_as_script_with_stdin <<'/---'
Document all globals, functions, and aliases declared by @{*-parcel}.
/---

# ....................{ GLOBALS                            }....................
declare_global_with_stdin string ZESHY_PARCEL_NAME <<'/---'
Current parcel name, identifying the most recently declared parcel (e.g., by a
call to declare_parcel_as_script() or declare_parcel_as_script_with_stdin()).
See such functions for further details.
/---

declare_global_with_stdin map ZESHY_PARCEL_NAME_TO_ALIAS_NAMES <<'/---'
Map each parcel name to an internally null-delimited string of the names of all
aliases contained in such parcel. Since such names can technically contain null
characters (although rare in practice), all actual nulls in such names are
escaped (i.e., prefixed with `\`) and must be ignored as delimiters.

Ideally, this would be structured as a *map of lists* (i.e., mapping each parcel
name to the list of the names of all aliases contained in such parcel). Since
`zsh` currently fails to support nested structures (along with all other popular
shells, to be fair), the desired map value instead joins each such list on the
null character into a string. The original list is losslessly retrievable from
such string value by:

* Splitting such string on nulls, ignoring *escaped nulls* (i.e., `\`-prefixed
  null characters).
* Removing the `\` character prefixing each escaped null in the resulting list.
/---

declare_global_with_stdin map ZESHY_PARCEL_NAME_TO_FUNCTION_NAMES <<'/---'
Map each parcel name to an internally null-delimited string of the names of all
functions contained in such parcel. See ${ZESHY_PARCEL_NAME_TO_ALIAS_NAMES} for
further details.
/---

declare_global_with_stdin map ZESHY_PARCEL_NAME_TO_GLOBAL_NAMES <<'/---'
Map each parcel name to an internally null-delimited string of the names of all
globals contained in such parcel. See ${ZESHY_PARCEL_NAME_TO_ALIAS_NAMES} for
further details.
/---

# ....................{ FUNCTIONS                          }....................
declare_function_with_stdin <<'/---'
void die_if_parcel(
    string parcel_name,
    string error_message = "parcel \"${parcel_name}\" already declared")

Throw an exception with the passed message if such parcel exists.
/---

declare_function_with_stdin <<'/---'
void die_unless_parcel(
    string parcel_name,
    string error_message = "parcel \"${parcel_name}\" undeclared")

Throw an exception with the passed message unless such parcel exists.
/---

declare_function_with_stdin <<'/---'
[status: boolean] is_parcel(string parcel_name)

Return success if such parcel exists.
/---

declare_function_with_stdin <<'/---'
void set_parcel(string parcel_name)

Set the current parcel to the previously declared parcel with the passed
(possibly nonextant) absolute path. See declare_parcel() for further details.
/---

declare_function_with_stdin <<'/---'
void set_parcel_as_script(string script_name)

Set the current parcel to the previously declared parcel with the passed path
referring to an existing `zeshy` script. Unless such path refers to an existing
`zeshy` script associated with a previously declared parcel, an exception is
thrown. For simplicity, such path may be absolute or relative and contain
symbolic link components. See convert_path_to_parcel() for further details.
/---

declare_function_with_stdin <<'/---'
string convert_path_to_parcel(string pathname)

Convert the passed existing absolute or relative path to the parcel name
corresponding to such path. If such path does _not_ exist, an exception is
thrown. Relative paths will be converted to absolute paths. Symbolic link path
components will be replaced with their transitive targets. If such path begins
with an overlay directory, such system-specific directory will be replaced with
a system-agnostic parcel scheme as discussed below (e.g., from
`/usr/share/zeshy/always/zsh/zsh` to `zeshy://always/zsh/zsh`).

All `zeshy` scripts reside in one of the following `zeshy` overlays:

* ${ZESHY_OVERLAY_DIR}, the system-wide overlay of official scripts.
* ${ZESHY_USER_OVERLAY_DIR}, the user-specific overlay of third-party scripts.
* ${ZESHY_USER_CONFIG_DIRNAME}, the user-specific overlay of user-specific
  configuration scripts.

In either case, the overlay directories prefixing script paths are system-
specific. For portability, this function replaces such prefixes with the
following system-agnostic schemes:

* `zeshy://`, for paths prefixed by ${ZESHY_OVERLAY_DIR}.
* `zeshy.user://`, for paths prefixed by ${ZESHY_USER_OVERLAY_DIR}.
* `zeshy.user.config://`, for paths prefixed by ${ZESHY_USER_CONFIG_DIRNAME}.

For example:

.convert_path_to_parcel()
==========================================
[source]
------------------------------------------
>>> change_dir "${ZESHY_OVERLAY_DIR}"
>>> convert_path_to_parcel "is_pathable/mutt"
zeshy://is_pathable/mutt
>>> convert_path_to_parcel "${ZESHY_OVERLAY_DIR}/is_pathable/mutt"
zeshy://is_pathable/mutt
>>> convert_path_to_parcel "${ZESHY_USER_OVERLAY_DIR}/is_pathable/awesome"
zeshy.user://is_pathable/awesome
------------------------------------------
==========================================
/---

declare_function_with_stdin <<'/---'
void add_parcel_alias(string parcel_name, string alias_name)

Add the passed alias to the passed parcel. Since parcels are `zeshy`-specific
abstractions, this only notes such parcel to ``contain'' such alias for
documentation and lookup purposes.
/---

declare_function_with_stdin <<'/---'
void add_parcel_function(string parcel_name, string function_name)

Add the passed function to the passed parcel. See add_parcel_alias() for further
details.
/---

declare_function_with_stdin <<'/---'
void add_parcel_global(string parcel_name, string global_name)

Add the passed global to the passed parcel. See add_parcel_alias() for further
details.
/---

declare_function_with_stdin <<'/---'
void declare_parcel(string parcel_name, string documentation)

Declare a new *parcel* (i.e., `zeshy`-specific abstraction packaging
aliases, globals, and functions declared by some `zeshy` script or scripts),
uniquely identified with the passed <<parcel.name,absolute path>> and documented
with the passed <<parcel.help,help string>>.

While most high-level languages provide native support for declaring package-
like abstractions (e.g., `perl` packages, `python` modules, `ruby` gems), `zsh`
does not. Even if `zsh` did, however, `zeshy`\'s compilation into unstructured
digest files would likely render such packaging moot.

== Motivation ==

Parcels implement a useful (if limited) pure-`zsh` facsimile of the typical
package motif, aggregating logically related `zsh` objects into abstract units.
Under most high-level languages, such units form a language-specific topology
of reusable components and readable documentation. Under `zsh`, only the latter
applies. Since digest files offer no internal structure (and hence no reusable
components), *parcels currently only serve to structure `zeshy` documentation.*

And that's it. At such time as `zsh` adds native support for declaring package-
like abstractions, however, this could conceivably change.

[[parcel.name]]
== Parcel Names ==

Parcel names are arbitrary strings containing no null characters, typically
formatted as URIs prefixed by one of the following two schemes:

* `zeshy://`, for parcels declared by official `zeshy` scripts residing in
  the system-wide `zeshy` overlay.
* `zeshy.user://`, for parcels declared by thirdy-party `zeshy` scripts residing
  in the system-wide `zeshy` overlay.

Since parcels are only abstractions, such URIs need _not_ refer to existing
filesystem paths. Under the typical
<<parcel.relations.1to1,one-to-one relationship>> between parcels and scripts,
however, this is the case. See convert_path_to_parcel() for further details.

[[parcel.help]]
== Parcel Documentation ==

Parcel documentation adheres to http://asciidoc.org[AsciiDoc] syntax, augmented
with `zeshy`-specific syntax for cross-referencing other `zeshy` documentation.
Since single- and double-quoted `zsh` string syntax conflicts with such syntax,
consider passing such documentation to declare_parcel_with_stdin() as a here-
document on standard input instead.

=== Cross-reference Syntax ===

Cross-referencing other `zeshy` aliases, functions, globals, and parcels
requires simple `zeshy`-specific syntax, typically in a human-readable manner
inspired by the corresponding `zsh` syntax.

==== Globals ====

To cross-reference a global, simply delimit such global's name by `${` and `}`
(e.g., `${ZESHY_FUNCTION_NAME_TO_DOCUMENTATION}`).

==== Aliases or Functions ====

To cross-reference an alias or function, simply suffix the name of such alias or
function by `()` (e.g., `die_with_your_boots_on()`). If both an alias and
function exist with such name, the alias rather than function will be cross-
referenced (in keeping with `zsh` precedent).

==== Function Disambiguation ====

To cross-reference a function for which there exists an alias of the same name,
simply delimit such function's name by `function://` and `()`
(e.g., `function://die_with_your_boots_on()`).

==== Parcels ====

To cross-reference a parcel, delimit by `@{` and `}` either:

* Such parcel's name (e.g., `@{zeshy://always/zsh/zsh}`). Since parcel names
  form unique identifiers, this has the advantage of disambiguity but the
  disadvantage of subsequently failing should the script declaring such parcel
  be moved (e.g., from `/usr/share/zeshy/always/zsh/zsh` to
  `/usr/share/zeshy/always/lang/zsh/zsh`).
* Any suffix of such parcel's name following but _not_ including a directory
  separator `/` (e.g., `@{always/zsh/zsh}`, `@{zsh/zsh}`, or `@{zsh}`). This
  induces a depth-first search for the first parcel name suffixed by `/`
  followed by such suffix of:
+
--
. All `zeshy` overlays in the following order (thus giving official parcels
  precedent over third-party parcels):
.. `zeshy://`, the system-wide overlay of official parcels.
.. `zeshy.user://`, the user-specific overlay of third-party parcels.
. All subdirectories of each such overlay in lexicographic order.

This has the disadvantage of ambiguity but the advantage (especially with
shorter suffixes) of preserving a cross-reference should the script declaring
such parcel be moved. Note that creating a new script residing in a
lexicographically ``earlier'' path declaring a parcel of the same suffix
rewires existing cross-references to target the new script (e.g., creating
`/usr/share/zeshy/always/00-declare/zsh/zsh` rewires `@{zsh/zsh}` and `@{zsh}`).
In some cases, this may be beneficial; in others, however, this is probably not.
--

For example, all of the following cross-reference parcel
`zeshy://always/zsh/zsh` (in order of increasing brevity and hence ambiguity):

. `@{zeshy://always/zsh/zsh}`, unambiguously cross-referencing such parcel.
. `@{always/zsh/zsh}`, cross-referenced by depth-first search under overlay
  `zeshy://`.
. `@{zsh/zsh}`, cross-referenced by depth-first search under overlay
  subdirectory `zeshy://always/`.
. `@{zsh}`, cross-referenced by depth-first search under overlay subdirectory
  `zeshy://always/zsh/`.

== Parcel-script Relationships ==

Parcels are non-physical abstractions related to (but _not_ necessarily
synonymous with) the physical `zeshy` scripts declaring such parcels.

[[parcel.relations.1to1]]
=== One-to-one Parcel-script Relationships ===

There typically exists a one-to-one relationship between parcels and scripts.
For each such script, there exists a corresponding parcel whose name is the
absolute path of such script -- both guaranteeing uniqueness between parcel
names and establishing a convenient means of associating parcels with scripts.
With such relationships, a script's absolute path identifies its parcel and a
parcel's name its script's absolute path.

To implement such relationship, such scripts should call a *parcel declarer*
(e.g., declare_parcel_as_script(), declare_parcel_script_with_stdin()) before calling any
other declarers (e.g., declare_alias(), declare_function_with_stdin()).

=== One-to-many Parcel-script Relationships ===

A one-to-many relationship between parcels and scripts, in which one parcel is
distributed across multiple scripts (hereafter referred to as the *swarm* of
scripts declaring and defining such parcel), is also feasible. As with aliases,
functions, and variables, parcels are typically only declared once. Hence, for
one script in each such swarm, there exists a corresponding parcel whose name
is the absolute path of such script. All other scripts in such swarm non-
ambiguously refer to such parcel by such path.

To implement such relationship, the declaring script in such swarm should call
a parcel declarer before calling any parcel-specific declarers. All other
scripts in such swarm should call a *parcel setter* (e.g., set_parcel(),
set_parcel_script()) before calling any parcel-specific declarers.

=== Many-to-one Parcel-script Relationships ===

A many-to-one relationship between parcels and scripts, in which multiple
parcels (hereafter referred to as the *passel* of parcels being declared and
defined) are centralized into one script, is also feasible. For each such
script, there exist multiple corresponding parcels. To guarantee uniqueness
between parcel names, only one such parcel name may be the absolute path of
such script. All other parcel names in such passel must be arbitrary (probably
nonextant) absolute paths (e.g., by appending arbitrary integers to the path of
such script).

To implement such relationship, such script should be internally subdivided into
such parcels, calling a parcel declarer for each such parcel before calling all
declarers specific to such parcel.

=== Many-to-many Parcel-script Relationships ===

Lastly, a many-to-many relationship between parcels and scripts, in which
multiple parcels are distributed across multiple scripts, is also feasible.
Since such relationships blend one-to-many and many-to-one relationships, see
prior sections for further details. (Given the subtle complexities of such
relationships, many-to-many parcel-script relationships are rather uncommon.)

=== Parcel-script Relationships in zeshy ===

Since one-to-one relationships tend to conform more closely to user expectations
than one-to-many, many-to-one, or many-to-many relationships, all scripts in the
`zeshy` codebase declare and define exactly one parcel.
/---

declare_function_with_stdin <<'/---'
void declare_parcel_with_stdin[
    args: string parcel_name, stdin: string documentation]

Declare a new parcel, uniquely identified with the passed absolute path and
documented with standard input (e.g., as a here-document). See declare_parcel()
for further details.
/---

declare_function_with_stdin <<'/---'
void declare_parcel_as_script(
    string script_name = "${ZESHY_SCRIPT_NAME}",
    string documentation)

Declare a new parcel, uniquely identified with the passed `zeshy` script
(defaulting to the currently sourced script, if compiling `zeshy`\'s user digest
file) and documented with the passed help string. See declare_parcel() for
further details.
/---

declare_function_with_stdin <<'/---'
void declare_parcel_as_script_with_stdin[
    args:  string script_name = "${ZESHY_SCRIPT_NAME}",
    stdin: string documentation]

Declare a new parcel, uniquely identified with the passed `zeshy` script
(defaulting to the currently sourced script, if compiling `zeshy`\'s user digest
file) and documented with standard input (e.g., as a here-document). See
declare_parcel() for further details.
/---

declare_function_with_stdin <<'/---'
void run_runnable_with_stdin[
    args: (string runnable_name, string argument1, string argument2, ...),
    stdin: string input]

Run the passed *runnable* (i.e., alias, function, command), passing such
function first all passed arguments in the passed order and finally all standard
input to this function as a single argument. For safety, this function closes
such input immediately after running such runnable: e.g.,

.run_runnable_with_stdin()
==========================================
[source]
------------------------------------------
>>> string on_commodities=\
...     "In proportion as the bourgeoisie, i.e., capital, is developed, in the
...      same proportion is the proletariat, the modern working class, developed
...      â€” a class of labourers, who live only so long as they find work, and
...      who find work only so long as their labour increases capital. These
...      labourers, who must sell themselves piecemeal, are a commodity, like
...      every other article of commerce, and are consequently exposed to all
...      the vicissitudes of competition, to all the fluctuations of the market."
>>> output_string "${on_commodities}" | run_runnable_with_stdin head -2 -
In proportion as the bourgeoisie, i.e., capital, is developed, in the
same proportion is the proletariat, the modern working class, developed
------------------------------------------
==========================================
/---

# --------------------( WASTELANDS                         )--------------------
