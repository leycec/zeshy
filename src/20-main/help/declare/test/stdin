#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Document all globals, functions, and aliases declared by @{*-test/stdin}.
/---

# ....................{ TESTERS ~ stdin                    }....................
:document_func <<'/---'
[status = :bool] :is_stdin_readable_sans_blocking()

Report success if standard input to the current context is *readable without
blocking* (i.e., readable without waiting indefinitely _and_ silently for such
input to become available). Since reading from standard input via conventional
techniques (e.g., `< /dev/stdin`, zsh builtin read(), zeshy alias get_stdin())
typically blocks or behaves erratically if no such input has been written,
consider polling this function before reading from standard input.

== Caveats ==

*This function is inherently unreliable without iterative polling.* Only call
this function as the test of an indefinite wait or for loop: e.g.,

.:is_stdin_readable_sans_blocking() Called Properly
==========================================
[source]
------------------------------------------
>>> :string on_perfect_security=\
...     "There is a contradiction in wanting to be perfectly secure in a
...      universe whose very nature is momentariness and fluidity."
>>> :output_string "${on_perfect_security}" | {
...     :output_string "Waiting for input."
...     while { not :is_stdin_readable_sans_blocking } {
...         :output_string_sans_newline "."
...     }
...     :output_string "Received input: $(get_stdin)"
... }
Waiting for input.....
Received input: There is a contradiction in wanting to be perfectly secure in a
universe whose very nature is momentariness and fluidity.
------------------------------------------
==========================================

*Never call this function as a non-iterative test* (e.g., modifying the line
reading `while { not :is_stdin_readable_sans_blocking } {` in the prior example
to `if { not :is_stdin_readable_sans_blocking } {`). Preparing to write and then
writing to standard input requires a non-deterministic and hence non-computable
amount of wall clock time regardless of the underlying mechanism used to do so
(e.g., pipe, process substitution, here-string, here-document). Indeed,
establishing pipes requires forking one asynchronous subshell for each pipe
subcommand excluding the last -- an extremely computationally expensive task.
Given such expense, there exists no guarantee that the source of standard input
will have provided such input by the time of a non-iterative call to this
function. Moreover, given such non-determinism, whether such call succeeds or
not depends principally on current system load! To demonstrate this, consider
the following output from calling this function non-iteratively:

.:is_stdin_readable_sans_blocking() Called Improperly
==========================================
[source]
------------------------------------------
>>> :int count=0
>>> for  count ({0..7}) {
...     :output_newline | {
...         :is_stdin_readable_sans_blocking and
...             :output_string "Input available." or
...             :output_string "No input available."
...     }
... }
No input available.
Input available.
No input available.
No input available.
Input available.
No input available.
Input available.
------------------------------------------
==========================================

In cases where iterative polling is inappropriate, consider calling
:is_stdin_pipe_or_file_simple() instead. Such function typically only reports
success when standard input is readable without blocking, and does so without
requiring iterative polling.
/---

# --------------------( WASTELANDS                         )--------------------
