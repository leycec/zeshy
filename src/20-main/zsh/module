#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *`zsh` modules* (i.e., C extensions typically bundled with `zsh`).
/---

#FIXME: To improve safety, we should probably add the command
#"zmodload -ui zsh/mapfile" to the top-level print_exception_with_status()
#implementation, absolutely guaranteeing such module to be unloaded in the event
#of an exception.

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_module(
    string module_name,
    string exception_message = "Module \"${module_name}\" not found.")

Throw an exception with the passed message unless the passed module exists. See
is_module() for further details.
/---
function die_unless_module() {
    die_unless_args_1_or_2\
        'Expected one module name and optional exception message.'
    :string module_name="${1}"
    is_module "${module_name}" or
        die "${2-Module \"${module_name}\" not found.}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: bool] is_module(string module_name)

Report success if the passed `zsh` module exists.
/---
function is_module() {
    # Dismantled, this is:
    #
    # * "-F", testing module features.
    # * "-e", returning success if such module is loaded and failure otherwise.
    #
    # Since zsh guarantees such command not to output, this suffices.
    die_unless_arg 'Expected one module name.'
    :string module_name="${1}"

    #FIXME: *UGH*. We should *REALLY* have become familiar with "man zshparams"
    #sooner. Look, all we have to do is manually search each path in list global
    #${module_path} for a file matching such module name. It's really simple.
    #Honestly... *sigh*

    # If such module is already loaded, such module exists. Avoid calling
    # is_module_loaded(), which implicitly calls this function.
    zmodload -Fe -- "${module_name}" or (
        # Else, if loading such module succeeds, such module exists.
        # Astonishingly, zsh offers no means of testing whether such module
        # exists without loading such module. Since merely loading numerous
        # modules can have unpleasant side effects (e.g., resource consumption
        # under "zsh/zprof" profiling), we take the following precautions:
        #
        # * Load such module in a subshell rather than the current shell (e.g.,
        #   with a "("- and ")"- rather than "{"- and "}"-delimited block).
        # * Immediately unload such module if successfully loaded.
        #
        # Due to said side effects, avoid calling zeshy functions here.
        if { zmodload     -- "${module_name}" &>/dev/null } {
             zmodload -ui -- "${module_name}" &>/dev/null
        }
    )
}

declare_function_with_stdin <<'/---'
[status: bool] is_module_loaded(string module_name)

Report success if the passed `zsh` module is currently loaded.
/---
function is_module_loaded() {
    # Validate sanity.
    die_unless_arg 'Expected one module name.'
    string module_name="${1}"
    die_unless_module "${module_name}"

    # Test such module. Since zsh guarantees such command not to output, the
    # following suffices:
    #
    # * "-F", handling module features.
    # * "-e", reporting success if such module is loaded and failure otherwise.
    zmodload -Fe -- "${module_name}"
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_module_features(string module_name)

List each feature provided by the passed `zsh` module, delimited by newlines.
/---
function get_module_features() {
    # Validate sanity.
    die_unless_arg 'Expected one module name.'
    string module_name="${1}"
    die_unless_module "${module_name}"

    #FIXME: Since "zmodload -Fl" fails if such module has not yet been loaded,
    #this could arguably be improved as follows: if such module has not yet been
    #loaded, do so, run "zmodload -Fl", and then immediately unload such module.
    #*DON'T FORGET TO UNLOAD*, in such case; unloading arbitrary modules can
    #often have dangerous side effects. Nonetheless, this seems quite sensible.

    # Get such features. Dismantled, this is:
    #
    # * "-F", handling module features.
    # * "-l", listing such features.
    zmodload -Fl -- "${1}"
}

# ....................{ LOADERS                            }....................
declare_function_with_stdin <<'/---'
void load_module(string module_name1, ...)

Load the passed `zsh` modules.
/---
function load_module() {
    die_unless_args 'Expected one or more module names.'
    zmodload -- "${@}"
}

#FIXME: Odd example. We should do actually something constructive with
#${mapfile} in the example, which we certainly don't at the moment.
declare_function_with_stdin <<'/---'
void :load_module_mapfile(void)

Load `zsh` module `mapfile` exporting map global ${mapfile}: e.g.,

.:load_module_mapfile()
==========================================
[source]
------------------------------------------
>>> :load_module_mapfile
>>> try {
...     string observe open_your_eyes
...     observe="${mapfile[/culture/is/not/your/friend]}"
...     open_your_eyes="${mapfile[/religion/is/not/your/friend]}"
...     die "But we are led by the least among us: the least intelligent, the
...          least noble, the least visionary. We are led by the least among us
...          and we do not fight back against the dehumanizing values that are
...          handed down as control icons. Culture is not your friend. It is not
...          your friend. It insults you. It disempowers you. It uses and abuses
...          you. The culture is a perversion. It fetishizes objects, creates
...          consumer mania. It preaches endless forms of false happiness,
...          endless forms of false understanding in the form of squirrelly
...          religions and silly cults. It invites people to diminish themselves
...          and dehumanize themselves by behaving like machines, meme
...          processors of memes passed down from Madison Avenue and Hollywood."
... } always :{
...     :unload_module_mapfile
... }:
------------------------------------------
==========================================

== Caveats ==

*${mapfile} is the most dangerous global in the `zsh` cannon.* While such map
does offer more efficient read-write access to text file contents than simpler,
arguably safer techniques (e.g., `$(< "${filename}")`, `$(cat "${filename}")`),
unsetting ${mapfile} keys has the non-idempotent side effect of silently,
permanently deleting the corresponding files!

Such map and hence module remains inherently unsafe. To mitigate these risks,
consider unsetting ${mapfile} and unloading `mapfile` immediately after use.
Specifically, either:

* Call run_code_with_mapfile:(), which safely handles such lifecycle issues on
  your behalf, rather than this function.
* Call :unload_module_mapfile() from an `always :{...:}` block situated
  immediately _after_ calling this function, as in the prior example.
/---
function :load_module_mapfile() {
    die_if_args
    load_module zsh/mapfile
}

# ....................{ UNLOADERS                          }....................
declare_function_with_stdin <<'/---'
void unload_module(string module_name1, string module_name2, ...)

Unload the passed `zsh` modules.
/---
function unload_module() {
    # Dismantled, this is:
    #
    # * "u", unloading this module.
    # * "i", a noop if this module is not currently loaded.
    die_unless_args 'Expected one or more module names.'
    zmodload -ui -- "${@}"
}

declare_function_with_stdin <<'/---'
void :unload_module_mapfile(void)

Unload `zsh` module `mapfile`. See :load_module_mapfile() for further details.
/---
function :unload_module_mapfile() {
    die_if_args
    unload_module zsh/mapfile
}

# ....................{ AUTOLOADERS                        }....................
declare_function_with_stdin <<'/---'
void autoload_module_builtins(
    string module_name,
    string builtin_name1, string builtin_name2, ...)

Define the passed builtins to autoload the passed module defining such builtins:
e.g.,

.autoload_module_builtins()
==========================================
[source]
------------------------------------------
# Define builtins pcre_compile(), pcre_study(), and pcre_match() to autoload
# module "zsh/pcre" defining such builtins.
>>> autoload_module_builtins zsh/pcre pcre_compile pcre_study pcre_match
>>> is_module_loaded zsh/pcre or print_string '"zsh/pcre" not loaded'
"zsh/pcre" not loaded
>>> pcre_compile "I will not be pushed, filed, stamped, indexed, briefed,
...                          debriefed, or numbered."
>>> is_module_loaded zsh/pcre and print_string '"zsh/pcre" loaded'
"zsh/pcre" loaded
------------------------------------------
==========================================
/---
function autoload_module_builtins() {
    # Validate sanity.
    die_unless_args_2_or_more\
        'expected one module name and at least one builtin name'
    string module_name="${1}"
    die_unless_module "${module_name}"
    shift_arg

    # Autoload such builtins. See startup_zeshy_module_autoloads() for details.
    zmodload -abi -- "${module_name}" "${@}"
}

declare_function_with_stdin <<'/---'
void autoload_module_globals(
    string module_name,
    string global_name1, string global_name2, ...)

Define the passed globals to autoload the passed module defining such globals:
e.g.,

.autoload_module_globals()
==========================================
[source]
------------------------------------------
# Define globals keymaps() and widgets() to autoload module "zsh/zleparameter".
>>> autoload_module_globals zsh/zleparameter keymaps widgets
>>> is_module_loaded zsh/zleparameter or print_string '"zsh/zle..." not loaded'
"zsh/zle..." not loaded
>>> print_string "${keymaps}"
listscroll command .safe vicmd main menuselect isearch viins emacs
>>> is_module_loaded zsh/zleparameter and print_string '"zsh/zle..." loaded'
"zsh/zle..." loaded
------------------------------------------
==========================================
/---
function autoload_module_globals() {
    # Validate sanity.
    die_unless_args_2_or_more\
        'expected one module name and at least one global name'
    string module_name="${1}"
    die_unless_module "${module_name}"
    shift_arg

    # Autoload such globals. See startup_zeshy_module_autoloads() for details.
    zmodload -api -- "${module_name}" "${@}"
}

# ....................{ STARTUP                            }....................
run_hook_on_zeshy_startup_first startup_zeshy_module_autoloads

declare_function_with_stdin <<'/---'
void startup_zeshy_module_autoloads(void)

Autoload all `zsh` modules not already loaded on the first call of a function or
expansion of a global provided by such module.
/---
function startup_zeshy_module_autoloads() {
    # Validate sanity.
    die_if_args

    # Define autoloads for all autoloadable functions defined by zsh modules not
    # autoloaded above. Unlike above, this requires manually mapping modules to
    # function names -- an unctuous proposition. Dismantled, this is:
    #
    # * "-a", autoloading the following builtins ("b"), functions ("f"), or
    #   global parameters ("p") from the following module.
    # * "i", ignoring rather than failing when such builtins, functions, or
    #   parameters have already been loaded by such module.
    #
    # Avoid mapping modules already loaded by the main Zeshy script as well as:
    #
    # * "mapfile", whose overly permissive style poses a profound risk of
    #   permanent, silent file deletion or modification. For safety, this module
    #   must be manually loaded and unloaded.
    # * "prof", which when loaded begins aggressively profiling zsh functions.
    #   While useful, autoloading the zprof() function this module defines will
    #   begin profiling *ONLY* at the first call of such function, whereas such
    #   function is intended to be called after having already loaded this
    #   module and performed the profiled code. By intentional design, this
    #   module must be manually loaded and unloaded.
    zmodload -abi zsh/cap cap getcap setcap
    zmodload -abi zsh/clone clone
    zmodload -abi zsh/compctl compctl compcall
    zmodload -abi zsh/computil comparguments compdescribe compfiles compgroups\
        compquote comptags comptry compvalues
    zmodload -afi zsh/deltochar delete-to-char zap-to-char
    zmodload -api zsh/langinfo langinfo
    zmodload -afi zsh/mathfunc abs int float acos acosh asin asinh atan atanh\
        cbrt ceil cos cosh erf erfc exp expm1 fabs floor gamma j0 j1 lgamma log\
        log10 log1p logb sin sinh sqrt tan tanh y0 y1 ilogb signgam copysign\
        fmod hypot nextafter jn yn ldexp scalb rand48
    zmodload -abi zsh/pcre pcre_compile pcre_study pcre_match
    zmodload -abi zsh/sched sched
    zmodload -abi zsh/net/socket zsocket
    zmodload -abi zsh/net/tcp ztcp
    zmodload -abi zsh/system syserror sysread syswrite zsystem
    zmodload -api zsh/system errnos sysparams
    zmodload -abi zsh/termcap echotc
    zmodload -api zsh/termcap termcap
    zmodload -abi zsh/zftp zftp
    zmodload -api zsh/zleparameter keymaps widgets
    zmodload -abi zsh/zpty zpty
    zmodload -abi zsh/zselect zselect
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Actually, there is a way of improving this. It's fairly sneaky, but
    #it should work. Note that if you run "zmodload oeuntoheuntoheuntoehunotehu"
    #with an arbitrarily long string basically guaranteed to fail, zsh always
    #responds with an error message giving the absolute path of the directory
    #containing such modules: e.g.,
    #
    #    zsh: failed to load module `oeuntoheuntoheuntoehunotehu': /usr/lib64/zsh/5.0.2/oeuntoheuntoheuntoehunotehu.so: cannot open shared object file: No such file or directory
    #
    #There's no other reliable means of determining such path, but the above at
    #least works (and hopefully portably).
    #
    #For efficiency (and safety), we could parse such message *AT DIGEST COMPILE
    #TIME* for such path and store such path in a string global to be serialized
    #into such digest -- say, ${ZESHY_ZSH_MODULE_DIR}. Then, this function could
    #perform the following test:
    #
    #* First, try 'zmodload -Fe -- "${module_name}"' as we currently do.
    #* Failing that, try 'is_file "${ZESHY_ZSH_MODULE_DIR}/${module_name}"'.
    #  *NO MODULE LOAD REQUIRED*.
    #
    #Actually, it's not *QUITE* that simple. Modules can be statically linked
    #into the "zsh" binary itself, in which case the above isn't quite enough.
    #Hence, we require a third test doing exactly what we do now: try loading it
    #manually. *sigh* Can't really get away from that; but, the above does at
    #least substantially reduce the likelihood of spurious module loads, as one
    #would only ever call this function with a module likely to exist as a
    #dynamically linked library on most systems.

# Ensure "mapfile" to be unloaded despite throwing an exception.

# Whenever calling this function, _always_ call :unload_module_mapfile() on no
# longer requiring ${mapfile} access -- even if such access throws an exception

#FUXME: Uhm; how actually does one do this? The zsh manual explicitly suggests
#the best method is:
#
#    run_code_silent zmodload "${1}"
#
#But that's demonstrably silly. A test method shouldn't actually have non-
#idempotent side effects. In lieu of any builtin method, the best way might
#simply be to search the appropriate path under "/usr/share/zsh" for filenames
#corresponding to passed modules.

# void load_mapfile(void)
#
# Load zsh module "mapfile". This module is *INHERENTLY* dangerous; in
# particular, unsetting list elements permanently and silently deletes files
# with the same name as such elements. To prevent accidental calamity, either:
#
# * If possible, call run_code_with_mapfile:() rather than this function, which safely
#   handles such lifecycle issues for you.
# * Otherwise, unload "mapfile" immediately after use via unload_mapfile().
#function load_mapfile() {
#    load_module zsh/mapfile
#}

# void unload_mapfile(void)
#
# Unload zsh module "mapfile". See load_mapfile().
#function unload_mapfile() {
#    unload_module zsh/mapfile
#}

