#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *PIDs* (i.e., process identifiers).
/---

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
void die_unless_pid(
    integer pid,
    string error_message =
        "PID ${pid} not found (i.e., no process running with such ID).")

Throw an exception with the passed message unless the passed process ID (PID)
currently exists. See is_pid() for further details.
/---
function die_unless_pid() {
    die_unless_args_1_to_2 'Expected one PID and optional error message.'
    string pid="${1}"
    is_pid "${pid}" or die
        ${2-PID ${pid} not found (i.e., no process running with such ID).}
}

# ....................{ TESTERS                            }....................
#FIXME: Improve example.
declare_function_with_stdin <<'/---'
[status: bool] is_pid(integer pid)

Report success if there exists a process with the passed ID: e.g.,

.is_pid()
==========================================
[source]
------------------------------------------
>>> sleep 10s &
>>> is_pid $! and output_string "Awaken, young master."
Awaken, young master.
------------------------------------------
==========================================
/---
# If the current OS is Linux, such test is efficiently implementable by testing
# whether a "/proc" subdirectory with such PID exists.
if { :is_os_trait_linux } {
    function is_pid() {
        die_unless_arg 'Expected one process ID.'
        is_dir "/proc/${1}"
    }
# Else, fallback to a less efficient OS-agnostic test.
} else {
    function is_pid() {
        # Signal 0 is a poorly documented pseudo-signal. On attempting to send
        # signal 0 to a process, kill() returns success only if such process exists
        # and the current user has permission to signal such process. Specifically,
        # according to "man 2 kill":
        #
        #     "If sig is 0, then no signal is sent, but error checking is still
        #      performed; this can be used to check for the existence of a process
        #      ID or process group ID."
        #
        # While merely sending signal 0 to such process does *NOT* suffice to decide
        # whether such process exists, kill() prints one of the following two error
        # messages to standard error on failure:
        #
        # * When failing due to such process not existing,
        #   "kill: kill ${pid} failed: no such process".
        # * When failing due to such process not being signalable by the current
        #   user, "kill: kill ${pid} failed: operation not permitted"
        #
        # Hence, match such output to discriminate between the two error conditions.
        die_unless_arg 'Expected one process ID.'
        :string pid="${1}"
        :die_unless_int_nonnegative "${pid}"
        is "$({ kill -0 "${pid}" } to_stdout:)" == *'no such process' si
    }
}

# ....................{ GETTERS                            }....................
#FIXME: Refactor into a setter (e.g., as set_integer_to_pid_shell_root()).
#FIXME: Define an analogous setter set_integer_to_pid() that *ACTUALLY* sets
#such integer to the PID of the current shell. To do so, expand ${pid} rather
#than ${$}.
declare_function_with_stdin <<'/---'
int get_pid(void)

Return the process ID (PID) of the main shell owning the current shell.
/---
function get_pid() {
    die_if_args
    output_string ${$}
}

#FIXME: Generalize to not require "pgrep".
#FIXME: Actually, this is horrible. Eliminate *ENTIRELY* in favor of a setter.
declare_function_with_stdin <<'/---'
[stdout: string, status: bool] get_pids_running_command_under_user_if_found(
    string command_name, string username)

Get a newline-delimited list of all process IDs (PIDs) running the passed
command as the passed user if at least one such PID exists (i.e., if such
command is currently running) or return failure.
/---
function get_pids_running_command_under_user_if_found() {
    # Validate sanity.
    die_unless_args_2 'Expected one command name and one username.'
    die_unless_pathable pgrep
    :string command_name="${1}" username="${2}"

    # Get such PIDs.
    if { is_path_absolute "${command_name}" } {
        run_code_silent pgrep -u "${username}" -fx "${command_name}"
    } else {
        run_code_silent pgrep -u "${username}"  -x "${command_name}"
    }
}

# ....................{ GETTERS ~ name                     }....................
declare_function_with_stdin <<'/---'
string get_pid_command_line(int pid)

Get the command line of the process with the passed process ID (PID). While
system-specific and hence non-portable, such line is typically a string
consisting of (in order):

* Either the absolute or relative path to the command. In the latter case,
  there is no reliable means of resolving this path into an absolute path.
* Each command line argument passed to such command prefixed by a null
  delimiter (i.e., `\x00`).

Due to such inconsistencies, use such strings _only_ for non-critical
display purposes rather than critical functionality.
/---
function get_pid_command_line() {
    # Validate sanity.
    die_unless_arg 'Expected one PID.'
    string pid="${1}"
    die_unless_pid "${pid}"

    # Absolute path to the file with the command line for the passed process.
    get_file_text "/proc/${pid}/cmdline"
}

#FIXME: This probably doesn't work as expected for scripts preceeded by set
#variables (e.g., "TMP=~/.tmp script.zeshy"). Test; hack; fix! Actually,
#stackoverflow can probably help us here.
#FIXME: Ugh. This is pretty terrible. Do we really still require or desire this?

declare_function_with_stdin <<'/---'
string get_pid_command_name(integer pid)

Get the name of the command running under the process with the passed process ID
(PID).
/---
function get_pid_command_name() {
    # Validate sanity.
    die_unless_arg 'Expected one PID.'
    string pid="${1}"

    # List splitting the command-line the current process is running on words.
    # Dismantled, this is:
    #
    # * "(0)", split the command-line on null bytes. By Linux convention (and
    #   hence probably not applicable to other *nix), a null byte delimits each
    #   shell word of such line.
    list command_line_words
         command_line_words=( "${(0)$(get_pid_command_line "${pid}")}" )
#   print_warning "pclp: ${command_line_words[@]}"

    # The name and absolute path of the command the current process is running.
    string command_name="${command_line_words[1]}" command_path

    # If this process is a zsh script (which it usually is), the absolute path
    # to this command is given by the third string in this array: e.g.,
    #
    #   # For a zeshy script "h3110", this array resembles...
    #   command_line_words=( zsh /usr/bin/zeshy h3110 )
    if is "${command_name}" == *sh si and (( ${#command_line_words} >= 3 )) {
        command_path="${command_line_words[3]}"
    } else {
        command_path="${command_name}"
    }

    # If the command path is "-su" (as occurs under "su"), strip the hyphen.
    is "${command_path}" == '-'* si and command_path="${command_path[2,-1]}"

    # Return the basename of this command path.
#   print "\ncommand_line_words: ${command_line_words[@]}"
#   print "command_path: ${command_path}"
    get_path_basename "${command_path}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Define new setters :set_list_to_process_pids() and
#:set_list_to_process_pids_if_found(). Reimplement these getters to call such
#setters.
#FUXME: Generalize to not require "pgrep". The preferred command for obtaining
#this is "pidof", if pathable, for example.
#FUXME: Looks like the following fallback should also suffice:
#    ps -o pid -C "${command_name}" | grep -v PID
# declare_function_with_stdin <<'/---'
# [stdout: string, status: bool] get_pids_running_command_if_found(
#     string command_name)
# 
# Get a newline-delimited list of all process IDs (PIDs) running the passed
# command if at least one such PID exists (i.e., if such command is currently
# running) or return failure.
# /---
# function get_pids_running_command_if_found() {
#     :set_list_to_process_pids_if_found
#     # Validate sanity.
#     die_unless_arg 'Expected one command name.'
#     die_unless_pathable pgrep
#     string command_name="${1}"
# 
#     # Get such PIDs.
#     {
#         if { is_path_absolute "${command_name}" } {
#             command pgrep -fx "${command_name}"
#         } else {
#             command pgrep  -x "${command_name}"
#         }
#     } :silent
# }

    #FUXME: Not quite right, obviously. This only returns success if such
    #process exists and is signalable by the current user. Hence, rename this
    #function to is_pid_signalable(). We'll need to concoct a new function
    #is_pid() if we want to genuinely implement this.
    #FUXME: O.K.; so, kill() returns different output on stderr when failing
    #with exit status 1 depending on whether or not it failed due to such
    #process not existing or due to such process not being signalable by the
    #current user. Here are the two error messages:
    #
    #
    #Simple to implement then. Just match on stderr.

    #FUXME: New getter command getting such path?
#FUXME: Rename to get_pid_shell_main().
    #FUXME: We should instate a stronger check than this -- namely, that such
    #PID is actually valid.

#FUXME: Double-check what occurs if no such command is running. We should throw
#an exception rather than 
#FUXME: Make the argument mandatory; optional arguments are largely harmful.
#FUXME: Rename to convert_pid_to_command_name() or get_pid_command_name().
#Yes, clearly the latter!
#FUXME: Rename to get_pid_command().
#FUXME: Make the argument mandatory; optional arguments are largely harmful.
