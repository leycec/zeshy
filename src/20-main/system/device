#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle devices and device files.
/---

#FIXME: Refactor getters into setters.

#FIXME: Check out "inxi". Looks to be a rather swag, single large bash script
#for printing human-readable profiles of system hardware, complete with a rather
# professional manpage. See: http://smxi.org/site/about.htm#inxi
#FIXME: Add support for "command aplay -L". "aplay" is typically bundled with
#ALSA and hence reliably available where ALSA is available; passing option "-L"
#outputs a human-readable synopsis of all current ALSA-discovered audio devices,
#which is quite helpful.

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_device(
    string pathname,
    string error_message = "Path \"${pathname}\" not a device.")

Throw an exception with the passed message unless the passed device file exists.
/---
function die_unless_device() {
    die_unless_args_1_to_2\
        'Expected one pathname and optional error message.'
    :string pathname="${1}"
    is_device "${pathname}" or :die "${2-Path \"${pathname}\" not a device.}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_device(string pathname)

Return success if the passed *device file* (i.e., block- or character-special
file corresponding to some physical device attached to the current system).
/---
function is_device() {
    die_unless_arg 'Expected one pathname.'
    :string pathname="${1}"
    :is -b "${pathname}" or -c "${pathname}" :si
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_device_first(string filename1, string filename2, ...)

Get the absolute path of the first device file in the passed list of filenames
to exist or throw an exception if no such file exists.
/---
function get_device_first() {
    # Dismantled, this is:
    #
    # * "-", resolving symbolic links prior to matching.
    # * "%", including only device files.
    get_path_matching_qualifier_first_if_found "${@}" '-%' or :die\
        "$(join_strings_readable: "${@}") not found or not device files"
}

# ....................{ GETTERS ~ random                   }....................
declare_function_with_stdin <<'/---'
string get_device_random_nonblocking()

Get the absolute path of the preferred *non-blocking random device* (i.e., the
canonical system-wide device file generating pseudo-random bytes _without_
blocking on external entropy). Specifically, return the first device file that
exists on the current system in the following list:

* `/dev/frandom`, a non-blocking generator commonly cited as faster than
  `/dev/urandom`, but available only after installing third-party software.
* `/dev/erandom`, a non-blocking generator by the same author as
  `/dev/frandom`, but consuming no entropy.
* `/dev/urandom`, the canonical non-blocking generator.
/---
function get_device_random_nonblocking() {
    die_if_args
    get_device_first '/dev/'{f,e,u,}'random'
}

declare_function_with_stdin <<'/---'
string get_device_random_blocking()

Get the absolute path of the preferred *blocking random device* (i.e., the
canonical system-wide device file generating pseudo-random bytes by blocking on
external entropy), typically `/dev/random`.

Such device blocks after consuming all available input entropy and hence
generates bytes in a more cryptographically secure manner than that of the
non-blocking device returned by get_device_random_nonblocking(). See such
function for further details.
/---
function get_device_random_blocking() {
    die_if_args
    :output_string '/dev/random'
}

# ....................{ PRINTERS                           }....................
#FIXME: Actually implement :print_devices_on_bus_usb() -- presumably, in a new
#parcel @{usb/usb}. See @{pci/pci} for related functionality.
:func_ 'string :print_devices()' :func{
    # Validate sanity.
    die_if_args

    # Print such devices.
    {
        #FIXME: Silly. Replace the iteration below with a single call to a new
        #utility function :call_func_if_found_or_noop(), called like so:
        #
        #    :call_func_if_found_or_noop\
        #        :print_devices_on_bus_pci\
        #        :print_devices_on_bus_usb
        :string printer_func_name
        for     printer_func_name (
            :print_devices_on_bus_pci
            :print_devices_on_bus_usb) {
            if { :is_func "${printer_func_name}" } {
                "${printer_func_name}"
            }
        }
    } | page_stdin
}:func <<'/---'
Print a human-readable synopsis of all devices on the current system.
/---

declare_function_with_stdin <<'/---'
string print_device(string device_filename)

Print a human-readable synopsis of the passed device.
/---
function print_device() {
    # Validate sanity.
    die_unless_arg 'Expected one device filename.'
    :string device_filename="${1}"
    die_unless_device "${device_filename}"

    #FIXME: Linux-specific, clearly. This requires some generalization.
    #FIXME: Technically, this only tests whether or not "udev" is installed. Add
    #an additional test ensuring "udev" is also currently running, probably
    #implemented in "if_installed/udevadm" to test whether or not "udevd" is
    #currently running: say, is_udevd_running(). Actually, that seems fairly
    #straight-forward. Just implement as is here?
    #FIXME: Clearly, if such tests fail, an exception should be thrown.

    # If the current system is running a "udev" daemon, beg such daemon for data
    # on the passed device.
    run_code_if_pathable print_udev_device
}

# --------------------( WASTELANDS                         )--------------------
#Typically, such device file blocks after consuming available input entropy.
#If undesirable, consider calling get_device_printing_pseudo_randomly()
#instead, which generates only pseudo-random bytes and hence never blocks.

#FUXME: Consider shifting to a new parcel @{os/random}, aggregating random
#number generation-related functionality. Consider shifting function
#get_integer_random_in_range()
# * "/dev/random", the canonical blocking generator.
#   print_message "really format "${device_file}" as ${filesystem_type}? [yes/no] "
#   string is_sure
#   read   is_sure
#   if is "${is_sure}" == y || "${is_sure}" == ye || "${is_sure}" == yes si; then
#       print_message      "formatting \"${device_file}\" as ${filesystem_type}..."
