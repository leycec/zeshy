#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *variable serialization* (i.e., export to and import from on-disk files).
/---

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_variable_binding(string variable_name1, string variable_name2, ...)

Get *bindings* (i.e., declarations with definitions) for all passed variables in
the passed order: e.g.,

.get_variable_binding()
==========================================
[source]
------------------------------------------
>>> string_constant_global on_world3=\
...     "Our world model was built specifically to investigate five major trends
...      of global concern -- accelerating industrialization, rapid population
...      growth, widespread malnutrition, depletion of nonrenewable resources,
...      and a deteriorating environment. These trends are all interconnected in
...      many ways, and their development is measured in decades or centuries,
...      rather than in months or years. With the model we are seeking to
...      understand the causes of these trends, their interrelationships, and
...      their implications as much as one hundred years in the future."
>>> map_global on_world3_conclusions; on_world3_conclusions=(
...     "Our" "conclusions are:" )
>>> list on_world3_conclusion_1; on_world3_conclusion_1=(
...     "1. If the present growth trends in world population,"
...     "industrialization, pollution, food production, and resource depletion"
...     "continue unchanged, the limits to growth on this planet will be"
...     "reached sometime within the next one hundred years. The most probable"
...     "result will be a rather sudden and uncontrollable decline in both"
...     "population and industrial capacity." )
>>> get_variable_binding on_world3 on_world3_conclusions on_world3_conclusion_1
typeset -g -r on_world3='Our world model was built specifically to investigate five major trends
of global concern -- accelerating industrialization, rapid population
growth, widespread malnutrition, depletion of nonrenewable resources,
and a deteriorating environment. These trends are all interconnected in
many ways, and their development is measured in decades or centuries,
rather than in months or years. With the model we are seeking to
understand the causes of these trends, their interrelationships, and
their implications as much as one hundred years in the future.'
typeset -g -A on_world3_conclusions
on_world3_conclusions=( Our conclusions\ are: )
typeset -a on_world3_conclusion_1
on_world3_conclusion_1=( 1.\ If\ the\ present\ growth\ trends\ in\ world\ population, industrialization,\ pollution,\ food\ production,\ and\ resource\ depletion continue\ unchanged,\ the\ limits\ to\ growth\ on\ this\ planet\ will\ be reached\ sometime\ within\ the\ next\ one\ hundred\ years.\ The\ most\ probable result\ will\ be\ a\ rather\ sudden\ and\ uncontrollable\ decline\ in\ both population\ and\ industrial\ capacity. )
------------------------------------------
==========================================
/---
function get_variable_binding() {
    # Validate sanity.
    die_unless_args 'expected one or more variable names'

    # For each such variable, both declare and define such variable.
    # Ideally, the following command would suffice to do so:
    #
    # >>> typeset -p -- "${@}"
    #
    # Unfortunately, such command suffers numerous deficiencies (arguably,
    # reportable zsh bugs):
    #
    # * It fails to annotate global variables with option "-g", thus localizing
    #   variable declarations to the current context.
    # * It fails to quote nonscalar variable elements when such elements are
    #   single shell words: e.g.,
    #
    # >>> list l; l=( and or is )
    # zsh: parse error near `&&'
    #
    # Typically, quoting single shell words is safe. As the prior example
    # demonstrates, however, if such words are equal to global alias names,
    # then the result is typically a fatal parse error.
    #
    # Only manually iterating such variables suffices to amend such issues.

    # Type string of the current variable (e.g., "string-local").
    string variable_type__gvb

    # Options to be passed to "typeset" for the current variable.
    string typeset_options__gvb

    # Print each such variable's binding. For efficiency, inline all zeshy
    # functions referenced below into such implementation.
    string variable_name__gvb
    for    variable_name__gvb ("${@}") {
        # If such variable does *NOT* exist, throw an exception. See
        # is_variable() for further details.
        is -n "${(P)variable_name__gvb+x}" si or die\
            "variable \"${variable_name__gvb}\" not found"

        # Get such variable's type string. See get_variable_type() for further
        # details.
        variable_type__gvb="${(tP)variable_name__gvb}"

        # If such variable is local, pass no further options to "typeset". See
        # is_variable_local() for further details.
        if is "${variable_type__gvb}" == ${~ZESHY_VARIABLE_TYPE_GLOB_LOCAL} si {
            typeset_options__gvb=''
        # Else, such variable is global. Pass option "-g" to "typeset".
        } else {
            typeset_options__gvb='-g '
        }

        # If such variable is a list, escape all reserved characters in list
        # elements. While parameter expansion flag "q" also suffices for such
        # purposes, such flag needlessly increases the length of such string and
        # hence serialization and deserialization time -- especially on large
        # lists and maps, the principle use case for serializing variables: e.g.,
        #
        # >>> output_string "${(q):-Laissez-faire was planned; planning was not.}"
        # Laissez-faire\ was\ planned\;\ planning\ was\ not.
        # >>> output_string "${(qq):-Laissez-faire was planned; planning was not.}"
        # 'Laissez-faire was planned; planning was not.'
        #
        # See is_variable_list() for further details.
        if is "${variable_type__gvb}" == ${~ZESHY_VARIABLE_TYPE_GLOB_LIST} si {
            # Sadly, a more readable implementation expanding output_stdin()
            # rather than output_string() fails to properly quote list elements.
            # Yes, the space preceding the "\" is necessary.
            output_string \
"typeset ${typeset_options__gvb}-a ${variable_name__gvb}
${variable_name__gvb}=( ${(qq@P)variable_name__gvb} )"
#           output_string hello
        # Else if such variable is a map, escape all reserved characters in map
        # keys and values.  See is_variable_map() for further details.
        } elif is "${variable_type__gvb}" ==\
            ${~ZESHY_VARIABLE_TYPE_GLOB_MAP} si {
            output_string \
"typeset ${typeset_options__gvb}-A ${variable_name__gvb}
${variable_name__gvb}=( ${(qqkv@P)variable_name__gvb} )"
        # Else, such variable is scalar. If passing at least one option to
        # "typeset", "typeset -p" output must be modified to do so.
        # Dismantled, this is:
        #
        # * "/", performing such replacement at most once.
        # * "(#s)", matching only at the start of such output.
        } elif is -n "${typeset_options__gvb}" si {
            output_string "${"$(typeset -p -- "${variable_name__gvb}"\
                )"/(#s)typeset /typeset ${typeset_options__gvb}}"
        # Else, such variable is scalar and "typeset" output suffices.
        } else {
            typeset -p -- "${variable_name__gvb}"
        }
    }
}

# ....................{ WRITERS                            }....................
declare_function_with_stdin <<'/---'
void write_file_with_variable(
    string filename,
    string variable_name1, string variable_name2, ...)

Overwrite the passed file with the current definitions of the passed variables.
Since such definitions conform to `zsh` syntax, such file will be a sourceable
`zsh` script. Consider calling source_shell_script() to deserialize such file
back into such variables.
/---
function write_file_with_variable() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected one or more variable names and one filename'
    string filename="${1}"
    shift_arg

    # Overwrite such file. Dismantled, this is:
    #
    # * ">!", forcefully overwriting such file if already extant.
    {
        # For safety, prefix such script with the canonical zsh shebang line.
        get_zsh_shebang_line

        # Print such variables' bindings (i.e., declarations and definitions).
        get_variable_binding "${@}"
    } >! "${filename}"
}

declare_function_with_stdin <<'/---'
void append_file_with_variable(
    string filename,
    string variable_name1, string variable_name2, ...)

Append the passed file with the current definitions of the passed variables.
See write_file_with_variable() for further details.
/---
function append_file_with_variable() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected one or more variable names and one filename'
    string filename="${1}"
    shift_arg

    # If such file already exists, append such variables.
    if { is_file "${filename}" } {
        # Print such variables' bindings (i.e., declarations and definitions).
        # Avoid operator ">>!" here; such operator creates such file if not
        # already extant, which in this case would create a shell script *NOT*
        # prefixed with a shebang line. Using operator ">>" instead ensures an
        # exception will be thrown in the unlikely event such file is moved or
        # removed in between the prior conditional succeeding and this command
        # running.
        get_variable_binding "${@}" >> "${filename}"
    # Else, such file does not exist. Call write_file_with_variable() to prefix
    # the contents of such file with a shebang line.
    } else {
        write_file_with_variable "${filename}" "${@}"
    }
}

# --------------------( WASTELANDS                         )--------------------
#            output_stdin <</---
#typeset ${typeset_options__gvb}-a ${variable_name__gvb}
#${variable_name__gvb}=( ${(qq@P)variable_name__gvb} )
#/---
    # List containing quoted copies of the current list variable's elements.
#   list variable_elements__gvb
#            variable_elements__gvb=( \"${^${(P)variable_name__gvb}}\" )
#            output_stdin <</---
#typeset ${typeset_options__gvb}-a ${variable_name__gvb}
#${variable_name__gvb}=( ${variable_elements__gvb[@]} )
#/---
#            variable_elements__gvb=( \"${^${(kvP)variable_name__gvb}}\" )
#            output_stdin <</---
#typeset ${typeset_options__gvb}-A ${variable_name__gvb}
#${variable_name__gvb}=( ${variable_elements__gvb[@]} )
#/---

#>>> map_global on_world3_conclusion_2=(
#...     "2." "It is possible to alter these growth trends and to establish"
#...     "a"  "condition of ecological and economic stability that is"
#...     "sustainable" "far into the future. The state of global equilibrium"
#...     "could"       "be designed so that the basic material needs of each"
#...     "person"      "on earth are satisfied and each person has an equal"
#...     "opportunity" "to realize his individual human potential."
#>>> string_global on_world3_conclusion_3=\
#...     "3."      "If the world's people decide to strive for this second
#...     "outcome" "rather than the first, the sooner they begin working to attain it, the
#...      greater will be their chances of success."
## Naturally, such logic
#    # admits a subtle race condition: if such file is created after the call to
    # is_file() but before the call to typeset(), such file will not necessarily
    # be prepended with a shebang line. While irksome, this is mostly acceptable.
#       typeset -p -- "${@}" >>! "${filename}"
