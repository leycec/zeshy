#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle core variable functionality.
/---

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_variable(
    string variable_name,
    string error_message = "\${${variable_name}} undefined.")

Throw an exception with the passed message unless the passed variable exists.
See is_variable() for further details.
/---
function die_unless_variable() {
    die_unless_args_1_to_2\
        'Expected one variable name and optional error message.'
    string variable_name__duv="${1}"
    is_variable "${variable_name__duv}" or
        die "${2:-\${${variable_name__duv}} undefined.}"
}

declare_function_with_stdin <<'/---'
void die_unless_variables(
    string variable_name1, string variable_name2, ...)

Throw an exception with a stock message unless all passed variables exist. See
is_variable() for further details.
/---
function die_unless_variables() {
    # Validate sanity.
    die_unless_args 'Expected one or more variable names.'

    #FIXME: The following hackery should yield a significantly more efficient
    #implementation. Nice! Actually, it's nearly bloody brilliant:
    #
    #   eval "(( ${@//(#m)*/\${+${MATCH}\} +} 0 == ${#} ))"
    #
    #Such optimization is reasonably helpful, as this function is called
    #frequently in core functionality (e.g., is_exception()). Test us up,
    #naturally. (Looks good from the command line, though.)
    #FIXME: Right. We've implemented a working variant on the above idea for the
    #is_pathable() function, so see such function first.

    # Test such variables.
    string variable_name__duvs
    for    variable_name__duvs ("${@}") {
        is_variable "${variable_name__duvs}" or
            die "\${${variable_name__duvs}} undefined."
    }
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_variable(string variable_name)

Return success if the passed variable exists.
/---
function is_variable() {
    # Dismantled, this is:
    #
    # * "(P)1", referencing the variable with passed name.
    # * "+x", expanding to "x" if such variable is set or to the empty string
    #   otherwise. Since any arbitrary non-empty value will do, use "x". (zsh
    #   precedent, and all.)
    #
    # While it would be preferable to use parameter expansion flag "+", such
    # flag unfortunately fails to respect parameter expansion flag "P": e.g.,
    #
    #     # Fails with error "zsh: error in flags".
    #     (( ${(+P)1} ))
    #
    #     # Fails with error "zsh: bad substitution".
    #     (( ${+(P)1} ))
    #
    # While this could be corrected by embedding such test in an "eval"
    # statement, this remains more efficient. Interestingly, such test is also
    # efficiently implementable as follows:
    #
    #     (( ${+parameters[${1}]} ))
    #
    # Since map lookup is likely to prove slightly less efficient than parameter
    # expansion, however, we retain the current implementation.
    die_unless_arg 'Expected one variable name.'
    is -n "${(P)1+x}" si
}

declare_function_with_stdin <<'/---'
[status: boolean] is_variable_empty(string variable_name)

Return success if the passed variable expands to an empty value, where emptiness
depends on variable type in the typical way. Specifically, return success if
such variable is:

* A float and such variable expands to *real zero* (i.e., `0.0`).
* An integer and such variable expands to *integer zero* (i.e., `0`).
* A list and such variable expands to the *empty list* (i.e., `()`).
* A map and such variable expands to the *empty map* (i.e., `()`).
* A string and such variable expands to the *empty string* (i.e., `""`).
/---
function is_variable_empty() {
    not  is_variable_nonempty "${@}"
}

declare_function_with_stdin <<'/---'
[status: boolean] is_variable_nonempty(string variable_name)

Return success if the passed variable is set to a nonempty value. See
is_variable_empty() for further details.
/---
function is_variable_nonempty() {
    # Validate passed arguments.
    die_unless_arg 'Expected one variable name.'
    string variable_name__ivn="${1}"

    # Test such variable. Since is_variable_number() calls
    # die_unless_variable(), avoid doing so above.
    if { is_variable_number "${variable_name__ivn}" } {
            (( ${(P)variable_name__ivn} ))  and report_status
    } else {
        is -n "${(P)variable_name__ivn}" si and report_status
    }
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_variable_first(
    string variable_name1, variable_name2, ...)

Get the name of the first passed defined variable expanding to a nonempty string
or throw an exception if all such variables are either undefined or expand to the
empty string: e.g.,

.get_variable_first()
==========================================
[source]
------------------------------------------
>>> string on_growth=\
...    "Unfortunately, once an economy is geared to expansion, the means rapidly
...     turn into an end and \"the going becomes the goal.\" Even more
...     unfortunately, the industries that are favored by such expansion must,
...     to maintain their output, be devoted to goods that are readily
...     consumable either by their nature, or because they are so shoddily
...     fabricated that they must soon be replaced. By fashion and built-in
...     obsolescence the economies of machine production, instead of producing
...     leisure and durable wealth, are duly cancelled out by the mandatory
...     consumption on an even larger scale."
>>> get_variable_first on_sustenance on_decline on_growth
on_growth
------------------------------------------
==========================================
/---
function get_variable_first() {
    get_variable_first_if_found "${@}" or
        die "Variables $(join_strings_readable: "${@}") undefined."
}

declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] get_variable_first_if_found(
    string variable_name1, variable_name2, ...)

Get the name of the first passed variable with non-empty value or return failure
if no such variable has a non-empty value: e.g.,

.get_variable_first_if_found()
==========================================
[source]
------------------------------------------
>>> string on_modernity=\
...    "[The processes of the paleotechnic period are] doubly ruinous: they
...     impoverish the earth by hastily removing, for the benefit of a few
...     generations, the common resources which, once expended and dissipated,
...     can never be restored; and second, in its technique, its habits, its
...     processes, the paleotechnic period is equally inimical to the earth
...     considered as a human habitat, by its destruction of the beauty of the
...     landscape, its ruining of streams, its pollution of drinking water, its
...     filling the air with a finely divided carboniferous deposit, which
...     chokes both life and vegetation."
>>> get_variable_first_if_found on_ruination on_rusticity on_modernity
on_modernity
------------------------------------------
==========================================
/---
function get_variable_first_if_found() {
    # Validate sanity.
    die_unless_args 'Expected one or more variable names.'

    # Get such variable. For efficiency, inline such implementation. See
    # is_variable() for further details.
    string variable_name__gvnfif
    for    variable_name__gvnfif ("${@}") {
        if { is -n     "${(P)variable_name__gvnfif+x}" si } {
            return_string "${variable_name__gvnfif}"
        }
    }
    report_failure
}

# ....................{ GETTERS ~ value                    }....................
declare_function_with_stdin <<'/---'
string get_variable_value_first(
    string variable_name1, variable_name2, ...)

Get the value of the first passed variable with non-empty value or throw an
exception if no such variables have a non-empty value: e.g.,

.get_variable_value_first()
==========================================
[source]
------------------------------------------
>>> string on_obsolescence=\
...    "But what would become of mass production and its system of financial
...     expansion if technical perfection, durability, social efficiency, and
...     human satisfaction were the guiding aims? The very conditions for
...     current financial success — constantly expanding production and
...     replacement — works against these ends. To ensure the rapid absorption
...     of its immense productivity, megatechnics resort to a score of different
...     devices: consumer credit, installment buying, multiple packaging, non-
...     functional designs, meretricious novelties, shoddy materials, defective
...     workmanship, built-in fragility, or forced obsolescence through frequent
...     arbitrary changes of fashion. Without constant enticement and
...     inveiglement by advertising, production would slow down and level off to
...     normal replacement demand. Otherwise many products could reach a plateau
...     of efficient design which would call for only minimal changes from year
...     to year."
>>> get_string_line "$(get_variable_value_first\
...     on_durability on_efficiency on_obsolescence)" 1
But what would become of mass production and its system of financial
------------------------------------------
==========================================
/---
function get_variable_value_first() {
    get_variable_value_first_if_found "${@}" or
        die "Variables $(join_strings_readable: "${@}") undefined."
}

declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] get_variable_value_first_if_found(
    string variable_name1, variable_name2, ...)

Get the value of the first passed variable with non-empty value or return
failure if no such variables has a non-empty value: e.g.,

.get_variable_value_first_if_found()
==========================================
[source]
------------------------------------------
>>> string on_suburbia=\
...    "In the mass movement into the suburban areas a new kind of community was
...     produced, which caricatured both the historic city and the archetypal
...     suburban refuge: a multitude of uniform, unidentifiable houses, lined up
...     inflexibly, at uniform distances, on uniform roads, in a treeless
...     communal waste, inhabited by people of the same class, the same income,
...     the same age group, witnessing the same television performances, eating
...     the same tasteless prefabricated foods, from the same freezers,
...     conforming in every outward and inward respect to a common mold,
...     manufactured in the central metropolis. Thus the ultimate effect of the
...     suburban escape in our time is, ironically, a low-grade uniform
...     environment from which escape is impossible."
>>> get_string_line "$(get_variable_value_first_if_found\
...     on_usurpation on_conurbations on_suburbia)" -1
environment from which escape is impossible.
------------------------------------------
==========================================
/---
function get_variable_value_first_if_found() {
    # Validate sanity.
    die_unless_args 'Expected one or more variable names.'

    # Get such variable's value. For efficiency, inline such implementation. See
    # is_variable() for further details.
    string variable_name__gvnvfif
    for    variable_name__gvnvfif ("${@}") {
        if { is -n        "${(P)variable_name__gvnvfif+x}" si } {
            return_string "${(P)variable_name__gvnvfif}"
        }
    }
    report_failure
}

# --------------------( WASTELANDS                         )--------------------
# ....................{ PRINTERS                           }....................
#declare_function_with_stdin <<'/---'
#string print_variables(string variable_name1, string variable_name2, ...)
#
#Print a human-readable synopsis of the passed variables (e.g., printing the
#current type and value of such variables).
#/---
#function print_variables() {
#    #FUXME: While fine, this output is rather bland and difficult to read. For
#    #readability, lightly parse and colorify such output. See
#    #print_aliases_cli() for similar code.
#
#    # Validate sanity.
#    die_unless_args 'Expected one or more variable names.'
#
#    # Print such variables.
#    typeset -p -- "${@}"
#}

#       is_string_nonempty "${variable_name__gvnfif}" and
#           return_string  "${variable_name__gvnfif}"

    # Write such variables. Dismantled, this is:
    #
    # * "-p", printing the current definitions of such variables.
    # * ">!", forcefully overwriting such file if already extant.
#   typeset -p -- "${@}"

    #FUXME: Shift the following block to a separate function to permits its
    #calling in append_file_with_variable() as well.
            # In this case, "typeset -p" output
            # safely declares and defines such variable.
#           die_unless_variable 

            # See is_variable_list() for further details.
#           if { is_variable_list "${variable_name__wfwv}" "${}" ${~ZESHY_VARIABLE_TYPE_GLOB_SCALAR si}

    # * "+g +", listing newline-delimited global names, each such line prefixed
    #   by zero or more space-delimited attributes (e.g., "ZSH_VERSION",
    #   "integer 10 readonly ZESHY_AND_THE_BLOOD_DIMMED_TIDE").
    # * "(f)", splitting such list on newlines.
    # * "##* ", removing the space-delimited attributes from each line.
#   case "$(get_variable_type "${variable_name__ivn}")" {
#, defined
#depending on variable type as follows:
#
#* For string variables, `""`.
#* For integer variables, `0`.
#* For float variables, `0.0`.
#* For list and map variables, `()`.

#   ${~ZESHY_VARIABLE_TYPE_GLOB_NUMBER})
#           (( ${(P)variable_name__ivn} ))  and report_status;;
#   *)
#       is -n "${(P)variable_name__ivn}" si and report_status;;
#   }

#   die_unless_variable "${variable_name__ivn}"
    # See get_variable_type() for further details.
#   die_unless_arg 'expected one variable name'
#   string variable_type="${(tP)1}"
#   is_string_nonempty "${variable_type}" and
#       is_string_suffix "${variable_type}" '-local'

    # See get_variable_type() for further details.
#   string variable_type="${(tP)1}"
#   is "${variable_type}" == '-global' si
#   is_string_nonempty "${variable_type}" and
#       "${variable_type}" '-global'

#       is_variable "${variable_name}" or die_unless_variable
#           die "${2:-variable \"${variable_name}\" undefined}"
#   case "${variable_type}" {
#   integer*|float*) (( ${(P)variable_name} )) and report_status_silent;;
#   *)          is -n "${(P)variable_name}" si and report_status_silent;;
#   }

#Serialize the passed variables to the passed file, appending the contents
#of such file with the current definitions of such variables. Subsequently call
#source_shell_script() to deserialize such variables from such file.

#FUXME: Silly function. Replace everywhere with a call to
#die_unless_string_nonempty(). (The reason? For safety, the passed variable name
#is usually suffixed by something resembling "__duvn", which is hardly human-
#readable. This function promotes bad output and hence bad behavior. Excise!)
#declare_function '
#void die_unless_variable_nonempty(
#    string variable_name,
#    string error_message = "\"${variable_name}\" not set or empty")
#
#Throw an exception unless the passed variable is set to a non-empty value.
#See is_variable_empty() for the definition of "empty value."
#'
#function die_unless_variable_nonempty() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string variable_name="${1}"
#    is_variable_nonempty "${variable_name}" or
#        die "${2:-\"${variable_name}\" not set or empty}"
#}

#FUXME: No longer fond of such nomenclature. The script is the dominant object
#to which the action "write" is applied -- not the variable. Hence, rename to
#write_file_with_variable().
        #FUXME: Implement new get_zsh_path() and get_zsh_shebang_line()
        #functions. The latter function should first test if either "env" is a
        #pathable and, if so, print a shebang line to such command; otherwise,
        #default to get_zsh_path(), as implemented below.

        # For safety, ensure the first line of such script is a zsh shebang.
#       string zsh_path; zsh_path="$(get_pathable_path zsh)"
#       print_string "#!${zsh_path}"

# -- particularly, names, types, values, and related metadata
# (e.g., globality, writability)
#       variable_type="$(get_variable_type "${variable_name}")"
#       print_string "variable type: ${variable_type}\nglob: ${glob}"
#       is_string_matches_glob "${variable_type}" "${glob}" # do not quote such glob!
    # * "is -n ... si", true if such expansion is non-empty and thus the passed
    #   valiable is set.
#FUXME: I'm somewhat unhappy with the nomenclature of the current write_*() and
#append_*() methods. Reconsider. (These function names, however, are great.)

# ....................{ FREEZERS                           }....................
#FUXME: Fairly certain all of the freeze_*() and unfreeze_*() functions below
#are fundamentally dangerous. The reason, unfortunately, is that each call of
#typeset() on a variable replaces all prior attributes of such variable rather
#than merely supplementing them. The result? Unhappy chaos. This is
#astonishingly hard to do, actually. I suspect the best will be to first
#print out the current definitions of all passed variables with
#'typeset -p -- "${@}"', string munge such definitions to remove all "-r" flags,
#and then embed the munged definitions in an "eval" statement. Ugly and rather
#inefficient, but I don't see why it wouldn't work. That said, I don't currently
#require such functionality, so... cut 'em!

# void freeze_variable(string variable_name1, string variable_name2, ...)
#
# Make the passed variables read-only (e.g., "const", "final").
#function freeze_variable() {
#    die_unless_args 'expected at least one variable name'
#    die_unless_variables "${@}"
#    die 'implement me'
#}

# void unfreeze_variable(string variable_name1, string variable_name2, ...)
#
# Make passed variables writable (i.e., non-read-only).
#function unfreeze_variable() {
#    die_unless_args 'expected at least one variable name'
#    die_unless_variables "${@}"
#    die 'implement me'
#}

# ....................{ FREEZERS ~ glob                    }....................
# void freeze_variables_matching(string glob)
#
# Make all variabless matching the passed glob read-only (e.g., "const").
#function freeze_variables_matching() {
#    die_unless_arg 'expected one glob'
#    die 'implement me'
#   typeset -mr -- "${1}"
#}

# void unfreeze_variables_matching(string glob)
#
# Make all variabless matching the passed glob writable (i.e., non-read-only).
#function unfreeze_variables_matching() {
#    die_unless_arg 'expected one glob'
#    die 'implement me'
#   typeset -m +r -- "${1}"
#}

# ....................{ UNDEFINERS                         }....................
#FUXME: Define corresponding undefine_local() *ALIASES*. It's critical they not
#be functions to guarantee correct scope. *WAIT.* These functions are
#practically useless; there appears to be no coherent means of undefining
#global variables from a function context. At least, I couldn't do it!
#Unsetting just unsets locally, which seems miserably stupid. *sigh*
#We'd need to define these as aliases; but then, of course, there's no means of
#adding in the essential "typeset +r". In any case, the resulting aliases
#*STILL* wouldn't work globally - just in the local function context.

# void undefine_global(string global_name1, string global_name2, ...)
#
# Undefine the passed global variables.
#function undefine_global() {
    # Validate passed arguments.
#    die_unless_args 'expected at least one global name'

    # zsh refuses to unset read-only globals. But zsh didn't count on us. Mark
    # such globals writable before undefining such globals. Haha!
#   unfreeze_global_export "${@}"
#   typeset +r ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY\
#       ZESHY_MAP_SHELL_NAME_TO_EMULATABLE_SHELL_NAME
#   typeset -p -- "${@}"
#    typeset +r -- "${@}"
#   for variable_name ("${@}") {
#       env --unset="${variable_name}" &>/dev/null
#   }
#    unset -- "${@}"
#   typeset +r ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY=2
#   typeset -p -- "${@}"
#   print_string "unset: "
#   print_strings_newlined "${@}"
#   [[ -n "${ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY+x}" ]] and print 'hmmmmm'
#}

# void undefine_globals_matching(string glob)
#
# Undefine all global variables matching the passed glob.
#function undefine_globals_matching() {
    # See undefine_global() for discussion.
#    die_unless_arg 'expected one glob'
#    string glob="${1}"
#    typeset -m +rg -- "${@}"
#    unset -m -- "${glob}"
#}

#   unfreeze_variables_matching "${glob}"
#FUXME: Improve to accept multiple variable names. Requires a loop, amusingly,
#to manually ensure each such variable exists.

#   for variable_name ("${@}"
#   string variable_name="${1}"
#   die_unless_variable "${variable_name}"
#   string variable_name="${1}" filename="${2}"
#   die_unless_variable "${variable_name}"

    # Write such variable. Dismantled, this is:
    #
    # * "-p", printing the current definition of such variable.
    # * ">!", forcefully overwriting such file if already extant.
#   typeset -p "${variable_name}" >! "${filename}"
# read_variables_from_file() to deserialize such variable from such file.
# ....................{ READERS                            }....................
# void read_variable_from_file(string variable_name, string filename)
#
# Deserialize the passed variable from the passed file, presumably written by a
# prior call to write_variable_to_file().
# set_variable_to_file_contents() to deserialize such variable from such file.
#function read_variable_from_file() {

#, concatenated into a single string.
        # If this word defines a global variable, continue to the next; else,
        # break with this word. Dismantled, this is:
        # * "[a-zA-Z_]", matching the first character of a variable name.
        # * "[a-zA-Z0-9_]#", matching all remaining characters of such name.
        # * '=', a "=" delimiter.
        # * "*", matching zero or more characters as the variable value.
#       is "${word}" == [a-zA-Z_][a-zA-Z0-9_]#'='* si or break
# Clearly, these
#functions should all be shifted to the same component.
#FUXME: Fails to account for prefixing temporary globals: e.g.,
#   LD_PATH="oeu=oeu" ssh -o hmm
#       is "${word}" == *?'='* si or break
# This function currently fails to return the expected name for exotic command
# lines containing pathological, but technically valid, syntax (e.g.,
# '"{!! This is a sadistic variable name !!}"="===" ls').
#   list words; words=( "${(z)*}" )
#   for word ("${words[@]}") {
#   string args; args="$(get_args)"
    # Exclude prefixing temporary global variable definitions.
    # Return the first shell word of remaining arguments.
#   get_word "${args}" 1
        # If such variable's type is numeric, emptiness is equality with zero;
        # otherwise, emptiness is equality with the empty string.
#FUXME: Remove at least two of the following functions. I'm thinking
#get_variable_first_or() and get_variable_value_first_or().
#FUXME: Rename "_if_found" back to "_if_found" *EVERYWHERE*. Much more readable.

    # Validate passed arguments.
#   die_unless_arg 'expected one variable name'
#   string variable_name; variable_name="${1}"

    # If such variable exists, test such variable's value for emptiness
    # depending on its type.
#   is_variable "${variable_name}" and {
#       string variable_type; variable_type="$(get_variable_type)"

#       case "${variable_type}" in
        # If such variable's type is numeric, emptiness is equality with zero.
#       integer*|float*) (( "${(P)variable_name}" == 0 )) and report_status;;
        # Otherwise, emptiness is equality with the empty string.
#       *) is -z "${(P)variable_name}" si and report_status;;
#       esac
#   }

#FUXME: Such functions only return string values; rename to
#get_variable_first_expansion_if_found().
    # If the passed variable is unset, expand to the empty string; otherwise,
    # expand as is. Return true if such expansion is non-empty.
#   is -n "${${(P)1-}#0}" si

# string get_variable_first_or(
#   string default_value,
#   string variable_name1, variable_name2, ...)
#
# Get the name of the first passed variable with non-empty value or the passed
# default value if no such variable has a non-empty value: e.g.,
#
#     >>> unset_variable PEGANUM HARMALA
#     >>> get_variable_first_or('Thank you, Iran.' PEGANUM HARMALA)
#     Thank you, Iran.
#function get_variable_first_or() {
#    die_unless_args_2_or_more\
#        'expected one default value and at least one variable name'
#    get_variable_first_if_found "${@[2,-1]}" or print_string "${@[1]}"
#}

# string get_variable_value_first_or(
#   string default_value,
#   string variable_name1, variable_name2, ...)
#
# Get the value of the first passed variable with non-empty value or the passed
# default value if no such variable has a non-empty value: e.g.,
#
#     >>> unset_variable PEGANUM
#     >>> string HARMALA='Esfand svanta'
#     >>> get_variable_value_first_or('Thank you.' PEGANUM HARMALA)
#     Esfand svanta
#function get_variable_value_first_or() {
#    die_unless_args_2_or_more\
#        'expected one default value and at least one variable name'
#    get_variable_value_first_if_found "${@[2,-1]}" or print_string "${@[1]}"
#}

    # If the passed variable is unset, expand to "x"; otherwise, expand as is.
    # Return true if such expansion is empty. Dismantled, this is:
    #
    # * "#0", removing a prefixing "0" if present and hence treating "0" as
    #   empty. By default, zsh only treats the empty string as empty. Since
    #   integers are scalars that are *ALWAYS* some integer and hence never the
    #   empty string, integers would never be treated as empty without such fix.
#   is -z "${${(P)1-x}#0}" si

#       string*)
#       array*|association*) (( "${(P)variable_name}" == 0 ));;
# or throw an
# exception if no such object exists# void die_unless_unset(string variable_name, string error_message = 'already set')
#
# Throw an exception unless the variable with the passed name is unset.
#function die_unless_unset() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string variable_name="${1}"
#    is_undeclared "${variable_name}" or die "${2:-\"${variable_name}\" already set}"
#}

    # Validate passed arguments.
    # Iterate passed arguments for the first non-empty variable or return false.
# boolean is_variable(string text)
#
# Return true if the variable with the passed name is unset (i.e., undeclared).
#function is_variable() {
    # Negate the condition is_variable_declared() tests for.
#    die_unless_arg 'expected one variable name'
#    is -z "${(P)1+x}" si
#}

#FUXME: I'm no longer enamoured with our use of "set" in this context, which
#conflicts with our use of "set" when referring to list and map sets. Rather,
#let's rename the former uses of "set" with "defined": e.g.,
# string get_first_defined_nonempty_variable(...)

#FUXME: Uhm... what? I'm fairly certain we never call this. Doesn't is_declared()
#suffice? We probably want to replace this with a new is_global() function.
# boolean is_variable(string variable_name)
#
# Return true if there exists a variable with the passed name.
#is_variable() {
#    die_unless_arg 'expected one name'
#    is_string_nonempty "${(tP)1}"  # see get_type() for details
#}

#FUXME: Rename is_local().
#       string object_type
#       object_type="$(whence -w -- "${object_name}")" or true  # ignore errors

# * Reflection functionality for dynamically inspecting functions and aliases
#   like first-class constructs.
#FUXME: Uhm; shouldn't "_runnable" be "_callable" everywhere below? Do we really
#need a distinction between the two? Arguably, functions aren't runnable and
#commands and builtins aren't callable. Perhaps

# ....................{ DEPENDENCIES                       }....................
#FUXME: This is generic functionality which should probably be provided by
#"core". Shift us up the genericity!
# void _zeshy_type(void)
#
# Import Zeshy components specific to the current OS.
#_zeshy_type() {
#    string current_dir="$(dirname "${zeshy_script_path}")"
#    is_dir "${current_dir}" and zimport "${current_dir}"
#}

# ....................{ MAIN                               }....................
# Call and then immediately unset (i.e., delete) _zeshy_os().
#_zeshy_os
#unset _zeshy_os
