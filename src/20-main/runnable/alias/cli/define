#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

:parcel <<'/---'
Handle *CLI alias definers* (i.e., functions defining CLI aliases).
/---

#FIXME: Actually, the approach below effects nothing, effectively. Why? Simple:
#any function already defined by the current shell remains defined even if the
#${FPATH} is subsequently changed. While such approach *WOULD* prevent
#additional CLI aliases from being autoloaded and hence defined in non-CLI
#contexts, it fails to undefine CLI aliases previously autoloaded from a CLI
#context. Indeed, such undefinition could never be made efficient or reliable.
#Instead, a *MUCH* simpler alternative presents itself: the true issue, as I
#see it, is to prevent non-interactive scripts from calling CLI aliases.
#Happily, this, at least, is relatively easy to implement:
#
#* In "src/compile", *AFTER* calculating ${function_names} the list of all
#  functions newly defined by the previous sourcing of the zeshy codebase, copy
#  such list into a new list ${function_names_sans_cli_aliases}. Then remove all
#  CLI alias names from ${function_names_sans_cli_aliases} with the list
#  subtraction operator.
#* Call zcompile() twice, once with:
#  * ${function_names}, compiled into digest file
#    "~/.zeshy/cache/digest/interactive.zwc". Note the use of subdirectory
#    "digest" for organizational purposes.
#  * ${function_names_sans_cli_aliases}, compiled into digest file
#    "~/.zeshy/cache/digest/noninteractive.zwc".
#* We'll need to start recording CLI alias names with a list or map global, if
#  we don't already. Such global is required above, clearly.
#* On zeshy startup, rather than always prepending ${FPATH} with
#  "~/.zeshy/cache/digest/interactive.zwc", test string global ${ZSH_EVAL_CONTEXT} for
#  equality with... Wait, no. This is a simple shell interactivity test. If the
#  current shell is:
#  * Interactive, prepend ${FPATH} with "~/.zeshy/cache/digest/interactive.zwc".
#  * Else, with "~/.zeshy/cache/digest/noninteractive.zwc".
#
#Yup. This is absolutely the way to go. It's all readily and elegantly doable.
#FIXME: Genius! (Or, at the least, modestly clever. Oh, very well: it's merely
#obvious.) We can dramatically improve efficiency and reliability by
#partitioning the digest file into two such files:
#* One compiling the gamut of all Zeshy functions and active interactively.
#* The other compiling all Zeshy functions *EXCEPT* interactive aliases and
#  active non-interactively. (This is easy; just prepend a second call to a
#  Zeshy compilation function with temporary disabling of such globals via
#  ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS= and
#  ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS=).
#Override the zsh hook called immediately:
#* Before evaluation of a new user-input interactive command to prepend the
#  ${FPATH} with the prior digest file, excising the latter digest file if
#  already prepended.
#* After evaluation of a new user-input interactive command to prepend the
#  ${FPATH} with the latter digest file, excising the former digest file if
#  already prepended.
#All of this assumes zsh exposes sufficient hooks, of course. It may not. It
#probably doesn't, in fact. But if it does... coolness is ours, baby.

#FIXME: Technically, we can support interactive aliases on functions -- but only
#in somewhat roundabout fashion. We would need detect this to be an alias on a
#function (easy), then define a new function with the same implementation as the
#function to be replaced by such alias but with a new name, say,
#"${alias_name}____tmp" (perhaps easy; doesn't "which ${function_name}" provide
#us a function implementation which we could then eval into a new function with
#such placeholder name?), then replace the old with the new function name in the
#alias expansion (easy). It's a bit involved, but nothing too intractable.

# ....................{ DEFINERS ~ abbreviation            }....................
#FIXME: Such functions should be calling declare_function_with_stdin() to
#ensure their addition to the current parcel for documentation and lookup
#purposes. Incidentally, perhaps we want to treat CLI aliases as a genuine alias
#type rather than a function? In such case, we'll want a new function
#declare_alias_cli_with_stdin() and corresponding map globals in
#"00-declare/05-parcel" (e.g., ${ZESHY_PARCEL_NAME_TO_ALIAS_CLI_NAMES}).

declare_function_with_stdin <<'/---'
void alias_cli_abbreviation(string alias_name, string alias_expansion = "")

Define a CLI abbreviation alias with the passed name expanding to the passed
expansion if such name (sans `{` and `}` delimiters) is *NOT* the name of an
existing *runnable* (i.e., external command or `zsh` alias, builtin, or
function) or throw an exception otherwise. If no expansion is passed, such
name must be formatted as a conventional `=`-delimited alias specification
(e.g., `l="ls -l"`).

CLI abbreviation aliases never replace existing runnables _and_ always throw
exceptions when _not_ expanded directly from the command line. This differs from
CLI substitution aliases (which always replace existing runnables and expand to
such runnables when _not_ expanded directly from the command line) and normal
`zsh` aliases (which also always replace existing runnables and do _not_ alter
their behavior when _not_ expanded directly from the command line). See
alias_cli() for further details: e.g.,

.alias_cli_abbreviation()
==========================================
[source]
------------------------------------------
>>> :string on_heritage=\
...    "Stop to consider how the so-called owners of the land got hold of it.
...     They simply seized it by force, afterwards hiring lawyers to provide
...     them with title-deeds. In the case of the enclosure of the common
...     lands, which was going on from about 1600 to 1850, the land-grabbers
...     did not even have the excuse of being foreign conquerors; they were
...     quite frankly taking the heritage of their own countrymen, upon no
...     sort of pretext except that they had the power to do so."
>>> alias_cli_abbreviation ls=':string.output "${on_heritage}"'
zeshy: CLI abbreviation alias "ls" already an existing runnable
>>> alias_cli_abbreviation common_lands=':string.output "${on_heritage}"'
>>> common_lands | head 1
Stop to consider how the so-called owners of the land got hold of it.
>>> get_string_line "$(common_lands)" 1
zeshy: CLI abbreviation alias "common_lands" expandable only at the command line
------------------------------------------
==========================================
/---
function alias_cli_abbreviation() {
    :string ZESHY_ALIAS_CLI_TYPE='abbreviation'
    alias_cli "${@}"
}

# ....................{ DEFINERS ~ substitution            }....................
declare_function_with_stdin <<'/---'
void alias_cli_substitution(string alias_name, string alias_expansion?)

Define a CLI substitution alias with the passed name expanding to the passed
expansion if such name (sans `{` and `}` delimiters) is the name of an existing
*runnable* (i.e., external command or `zsh` alias, builtin, or function) or
throw an exception otherwise. If no expansion is passed, such name must be
formatted as a conventional `=`-delimited alias specification (e.g.,
`l="ls -l"`).

CLI substitution aliases always replace existing runnables _and_ expand to such
runnables rather than the passed expansion when _not_ expanded directly from the
command line. This differs from CLI abbreviation aliases (which never replace
existing runnables and throw exceptions when _not_ expanded directly from the
command line) and normal `zsh` aliases (which always replace existing runnables
but do _not_ alter their behavior when _not_ expanded directly from the command
line). See alias_cli() for further details: e.g.,

.alias_cli_substitution()
==========================================
[source]
------------------------------------------
>>> :string on_totalitarianism=\
...    "The fallacy is to believe that under a dictatorial government you can be
...     free inside. Quite a number of people console themselves with this
...     thought, now that totalitarianism in one form or another is visibly on
...     the up-grade in every part of the world. Out in the street the
...     loudspeakers bellow, the flags flutter from the rooftops, the police
...     with their tommy-guns prowl to and fro, the face of the Leader, four
...     feet wide, glares from every hoarding; but up in the attics the secret
...     enemies of the regime can record their thoughts in perfect freedom —
...     that is the idea, more or less."
>>> alias_cli_substitution in_the_attics=':string.output "${on_totalitarianism}"'
zeshy: CLI substitution alias "in_the_attics" not an existing runnable
>>> alias_cli_substitution ls=':string.output "${on_totalitarianism}"'
>>> ls | head -1
The fallacy is to believe that under a dictatorial government you can be
>>> get_string_line "$(ls)" 1
./                .mutt/             pub/            .screenrc
------------------------------------------
==========================================
/---
function alias_cli_substitution() {
    :string ZESHY_ALIAS_CLI_TYPE='substitution'
    alias_cli "${@}"
}

declare_function_with_stdin <<'/---'
[status: bool] alias_cli_substitution_if_found(
    string alias_name, string alias_expansion?)

Define a CLI substitution alias with the passed name expanding to the passed
expansion if such name (sans `{` and `}` delimiters) is the name of an existing
*runnable* (i.e., external command or `zsh` alias, builtin, or function) or
return failure otherwise. If no expansion is passed, such name must be formatted
as a conventional `=`-delimited alias specification (e.g., `l="ls -l"`). See
alias_cli_substitution() for further details: e.g.,

.alias_cli_substitution_if_found()
==========================================
[source]
------------------------------------------
>>> :string on_superstructure=\
...    "Ideas may not change, but emphasis shifts constantly. It could be
...     claimed, for example, that the most important part of Marx's theory is
...     contained in the saying: 'Where your treasure is, there will your heart
...     be also.' But before Marx developed it, what force had that saying had?
...     Who had paid any attention to it? Who had inferred from it — what it
...     certainly implies — that laws, religions and moral codes are all a
...     superstructure built over existing property relations? It was Christ,
...     according to the Gospel, who uttered the text, but it was Marx who
...     brought it to life. And ever since he did so the motives of politicians,
...     priests, judges, moralists and millionaires have been under the deepest
...     suspicion — which, of course, is why they hate him so much."
>>> alias_cli_substitution_if_found\
...     in_the_gospel=':string.output "${on_superstructure}"' or :string.output\
...     "Either we all live in a decent world, or nobody does."
Either we all live in a decent world, or nobody does.
>>> alias_cli_substitution_if_found ls=':string.output "${on_superstructure}"'
>>> ls | head -1
Ideas may not change, but emphasis shifts constantly. It could be
>>> get_string_line "$(ls)" 1
./                .mutt/             pub/            .screenrc
------------------------------------------
==========================================
/---
function alias_cli_substitution_if_found() {
    :string ZESHY_ALIAS_CLI_TYPE='substitution'
    :bool   ZESHY_ALIAS_CLI_SUBSTITUTION_IS_RETURNING_IF_UNFOUND=${ZESHY_BOOLEAN_TRUE}
    alias_cli "${@}"
}

# ....................{ DEFINERS                           }....................
declare_function_with_stdin <<'/---'
void alias_cli(string alias_name, string alias_expansion?)

Define a CLI alias with the passed name expanding to the passed expansion. If no
expansion is passed, the name must be formatted as a conventional `=`-delimited
alias specification (e.g., `l="ls -l"`). Unlike normal `zsh` aliases, CLI
aliases are expanded only when run directly from the command line by a
interactive user. Consider calling the higher-level wrappers
alias_cli_abbreviation() and alias_cli_substitution() rather than this
comparatively lower-level function: e.g.,

.alias_cli()
==========================================
[source]
------------------------------------------
# Alias print() to print arguments in lexicographic order when interactive.
>>> print T M D
T M D
>>> alias_cli print="print -o"
>>> print T M D
D M T
# Run print() from a non-interactive subshell. Note the normal behavior.
>>> (print T M D)
T M D
------------------------------------------
==========================================

== External Input Variables ==

For convenience, this function also accepts the following externally set
variables as optional input:

* String `${ZESHY_ALIAS_CLI_TYPE}`. This is a `zeshy`-specific lowercase string
  identifying the type of CLI alias to be defined (e.g., `abbreviation`). See
  ${ZESHY_ALIAS_CLI_NAME_TO_TYPE} for further details.
* Boolean `${ZESHY_ALIAS_CLI_SUBSTITUTION_IS_RETURNING_IF_UNFOUND}`. If true,
  this function fails by returning *failure* (i.e., non-zero exit status) if the
  passed alias is of type `substitution` and the passed alias name sans `{` and
  `}` delimiters is _not_ already the name of an existing runnable.

Callers should generally avoid explicitly setting such variables. Consider
calling the higher-level wrapper functions alias_cli_abbreviation() and
alias_cli_substitution() instead.
/---
function alias_cli() {
    # Validate passed arguments, splitting the "="-delimited alias name and
    # expansion split from all passed strings. Dismantled, this is:
    #
    # * "${*...}", expanding to all passed strings concatenated together.
    # * "[[:space:]]#", excluding zero or more whitespace characters (e.g.,
    #   tab, space) and hence ignoring whitespace surrounding such delimiter.
    die_unless_args_1_to_2\
        'Expected either one "="-delimited alias specification or one alias name and one alias expansion.'
    :string\
        alias_name\
        alias_name_passed\
        alias_expansion_passed\
        alias_type_readable\
        alias_name_type\
        alias_expansion_if_noncli\
        alias_logic_if_cli\
        alias_logic_if_noncli
#   print "cli alias: ${*}"  # print "args: ${*%%=*}"

    # Type of interactive alias to be defined, defaulting to "alias" if not
    # already set by the caller. Recognized types include:
    #
    # * "substitution", only set by alias_cli_substitution().
    # * "abbreviation", only set by alias_cli_abbreviation().
    # * "alias", only set by this function.
    :string ZESHY_ALIAS_CLI_TYPE="${ZESHY_ALIAS_CLI_TYPE:-untyped}"

    # If passed the name and expansion as explicit arguments, localize such
    # arguments. Since this is the common case, handle this first.
    if { is_args_2 } {
        alias_name_passed="${1}"
        alias_expansion_passed="${2}"
    # Else, only one argument delimiting such name and expansion by "=" was
    # passed. Match such name and expansion.
    } else {
        # The glob expression '(*)=(*)' is glorious to behold, indeed.
        :string alias_specification="${1}"
        :die_unless_string_matches_glob_grouped\
            "${alias_specification}" '([^=]#)=(*)'\
            'CLI '${ZESHY_ALIAS_CLI_TYPE:-alias}' specifier "${*}" has no "=" delimiter.'
        alias_name_passed="${match[1]}"
        alias_expansion_passed="${match[2]}"
#       :string.output "alias name: ${alias_name}; expansion: ${alias_expansion}"
    }

    # Copy such alias name to ${alias_name}, from which "{" and "}" delimiters
    # will subsequently be removed if present.
    alias_name="${alias_name_passed}"
#   is "${ZESHY_ALIAS_CLI_TYPE}" == abbreviation si and print "alias type: ${ZESHY_ALIAS_CLI_TYPE}\nalias name: ${alias_name}\nalias expansion: ${alias_expansion}" 1>&2
#   is "${alias_name}" == '{acr}oread' si and { print "acroread!"; curse_call_stack }

    # For readability, convert such type to a human-readable label.
    case "${ZESHY_ALIAS_CLI_TYPE}" {
    abbreviation)
        alias_type_readable='CLI abbreviation alias'
        :case.break
    substitution)
        alias_type_readable='CLI substitution alias'
        :case.break
    untyped)
        alias_type_readable='CLI alias'
        :case.break
    # If such type is unrecognized, throw an exception.
    *) die 'CLI alias type "'${ZESHY_ALIAS_CLI_TYPE}'" unrecognized (i.e., neither "substitution", "abbreviation", or "alias").'
    }

    # If such name or expansion are the empty string, throw an exception.
    die_unless_string_nonempty "${alias_name}"\
        "Expected nonempty alias name in ${alias_type_readable}:${ZESHY_ASCII_NEWLINE}${*}."
    die_unless_string_nonempty "${alias_expansion_passed}"\
        "Expected nonempty alias expansion in ${alias_type_readable}:${ZESHY_ASCII_NEWLINE}${*}."

    # If such alias name contains at least one "{" or "}" delimiter,
    # concatenating all substrings delimited by such delimiters provides the
    # abbreviation name embedded in such alias name (e.g., abbreviation "ichy"
    # in alias "l{ich}mumm{y}"). Parse and possibly define such abbreviation.
    if :is "${alias_name}" == *[{}]* :si {
        alias_cli_parse_embedding
    }

    #FIXME: Subshells are horrible! Correct.
    #FIXME: Replace the "if" portion of this conditional with a single call to
    #die_if_runnable().

    # If such alias name is already a declared runnable, handle such case.
    if { alias_name_type="$(get_runnable_type_if_found "${alias_name}")" } {
        # If such alias already exists, throw an exception. CLI aliases are
        # implemented as actual aliases and hence cannot replace aliases of the
        # same name without silently obliterating such aliases. As there is no
        # compelling use case for permitting this, don't.
        if :is "${alias_name_type}" == 'alias' :si {
            :die ${alias_type_readable}' "'${alias_name}'" already an alias defined as:'${ZESHY_ASCII_NEWLINE}$(print_runnable "${alias_name}")
        # ...any other runnable (e.g., alias, builtin, command) and this is a
        # CLI abbreviation alias, throw an exception. Such aliases *NEVER*
        # replace existing runnables.
        } elif :is "${ZESHY_ALIAS_CLI_TYPE}" == 'abbreviation' :si {
            die ${alias_type_readable}' "'${alias_name}'" already a defined '${alias_name_type}':'${ZESHY_ASCII_NEWLINE}$(print_runnable "${alias_name}")
        # Else, silently wrap such runnable in the passed alias.
        }
    # Else, such alias name is *NOT* already an existing runnable, in which case
    # ${alias_name_type} is now the empty string (as tested below).
    #
    # If this is a CLI substitution alias, however, there exists nothing to be
    # substituted. Fail with an appropriate exception or warning.
    } elif :is "${ZESHY_ALIAS_CLI_TYPE}" == 'substitution' :si {
        # If the caller requests returning failure in such case, do so.
        if (( ${ZESHY_ALIAS_CLI_SUBSTITUTION_IS_RETURNING_IF_UNFOUND-${ZESHY_BOOLEAN_FALSE}} )) {
            report_failure
        # Else, throw an exception.
        } else {
            :die ${alias_type_readable}' "'${alias_name}'" not an existing runnable and hence unsubstitutable.'
        }
    # Else, declare such runnable to be such CLI alias.
    }
#   is "${ZESHY_ALIAS_CLI_TYPE}" == abbreviation si and print "still alias name: ${alias_name}" 1>&2

    #FIXME: I'm no longer convinced such distinctions are necessary. Standard
    #input should *ALWAYS* be accessible to whatever is being expanded without
    #our needing to explicitly pass it. If this is indeed the case, reduce such
    #logic to:
    #    alias_logic_if_cli=':string.output "'${alias_expansion_passed}'"'
    #FIXME: In such case, reduce the similar logic below as well.

    # Interactive logic to be performed by the function definition below.
    alias_logic_if_cli='if { :is_stdin_pipe } {
        :string.output "get_stdin | '${alias_expansion_passed}'"
    } else {
        :string.output "'${alias_expansion_passed}'"
    }'

    # Non-interactive logic to be performed by the function definition below. If
    # this alias name is not already an existing runnable (e.g., as in the case
    # of interactive abbreviations), throw an exception. Otherwise, call this alias
    # name as is without expanding the passed expansion.
    if { is_string_empty "${alias_name_type}" } {
        alias_logic_if_noncli=':string.output "die '''${alias_type_readable}' \"'${alias_name}'\" expandable only at the command line; passed arguments:'${ZESHY_ASCII_NEWLINE}'''"'
    } else {
        alias_logic_if_noncli='
    if { :is_stdin_pipe } {
        :string.output "get_stdin | '${alias_name}'"
    } else {
        :string.output "'${alias_name}'"
    }'
    }

    # Define such alias.
    :alias_command.define "${alias_name}" \
'$(if { is_context_cli_command_substitution } {
    '${alias_logic_if_cli}'
} else {
    '${alias_logic_if_noncli}'
})'

    # Map such alias name to the passed name, expansion, and type *AFTER*
    # successfully defining such alias.
    ZESHY_ALIAS_CLI_NAME_TO_EXPANSION_PASSED[${alias_name}]="${alias_expansion_passed}"
    ZESHY_ALIAS_CLI_NAME_TO_NAME_PASSED[${alias_name}]="${alias_name_passed}"
    ZESHY_ALIAS_CLI_NAME_TO_TYPE[${alias_name}]="${ZESHY_ALIAS_CLI_TYPE}"
}

declare_function_with_stdin <<'/---'
void alias_cli_parse_embedding()

Parse `{`- and `}`-delimited substrings from the current interactive alias
name of the current type (`substitution` or `abbreviation`) expanding to the
current alias expansion. Concatenating such substrings gives the interactive
abbreviation embedded in such name (e.g., alias name "`{ich}mumm{y}` embeds
abbreviation `ichy`). If such type is:

* An abbreviation, return such abbreviation name.
* A substitution and:
** If all possible extensions of the embedded abbreviation have been claimed
   by existing runnables, print a warning and define no such abbreviation.
** Otherwise, define such abbreviation to the passed expansion.
** In either case, return such alias name stripped of `{` and `}` characters.

This function is a helper intended to be called only by alias_cli(),
thus accepting no arguments and returning no values.
/---
function alias_cli_parse_embedding() {
    # Validate sanity.
    die_if_args

    # If such abbreviation is syntactically invalid, throw an exception.
    :is "${ZESHY_ALIAS_CLI_TYPE}" != 'alias' :si or :die\
        ${alias_type_readable}' "'${alias_name}'" delimited by "{" and "}" but neither an abbreviation or substitution CLI alias.'
    :is "${alias_name}" != '{'[^{}]#'}' :si or :die\
        ${alias_type_readable}' "'${alias_name}'" fully delimited by "{" and "}" (i.e., no characters before "{" or after "}").'
    :is "${alias_name}" != *'{}'* :si or :die\
        ${alias_type_readable}' "'${alias_name}'" delimited by empty "{" and "}".'
    :is "${alias_name}" != *'{'[^}]# :si or :die\
        ${alias_type_readable}' "'${alias_name}'" undelimited by "}".'
    :is "${alias_name}" != [^{]#'}'* :si or :die\
        ${alias_type_readable}' "'${alias_name}'" undelimited by "{".'

    # Copy of the passed alias name.
    :string alias_name_copy="${alias_name}"

    # Abbreviation name parsed from ${alias_name_copy}.
    :string abbre_name

    # Character succeeding the leftmost "}" in ${alias_name_copy}.
    :string abbre_next_char

    # 1-based indices of the characters immediately preceding and succeeding
    # the leftmost "}" in ${alias_name_copy}.
    :int\
        abbre_last_char_index\
        abbre_next_char_index\
        abbre_next_next_char_index

    # Iteratively shift the leftmost "}" in ${alias_name_copy} right one
    # character until either finding an abbreviation conflicting with no
    # existing runnables *OR* reaching the end of ${alias_name_copy}.
    while { true } {
        abbre_name="${alias_name_copy//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
#       print_string_with_escapes "abbreviation: ${abbre_name}"

        # If such abbreviation conflicts with no existing runnables, halt.
        is_runnable "${abbre_name}" or break

        # Find the index of the leftmost "}" in ${alias_name_copy} by
        # matching the first "{..}" in such copy. Dismantled, this is:
        #
        # * "#", matching from the beginning of ${alias_name_copy}.
        # * "(#m)", setting global integer ${MEND}, the 1-based index of
        #   the last character matched -- in this case, the leftmost "{".
        :noop "${alias_name_copy#(#m)[^\{\}]#\{[^\{\}]##\}}"

        # If the index of the leftmost "}" is the last character in
        # ${alias_name_copy}, the prior iteration shifted such "}" to the
        # end of such copy and hence exhausted all characters. Return!
        abbre_next_char_index=$(( MEND + 1 ))
        (( abbre_next_char_index < ${#alias_name_copy} )) or break

        # Else, get the character succeeding the leftmost "}".
        abbre_last_char_index=$(( MEND - 1 ))
#       :string.output "abbre_next_char_index: ${abbre_next_char_index}"
        abbre_next_char="${alias_name_copy[${abbre_next_char_index}]}"

        # Shift the leftmost "}" in ${alias_name_copy} right one character.
        #
        # If the character succeeding the leftmost "}" is a "{", there exist
        # two adjacent "{..}" expressions (e.g., "{mk}{d}ir"). Do not shift
        # the "}" to the right of the "{" (e.g., "{mk{}d}ir"); rather, merge
        # the two expressions (e.g., "{mkd}ir").
        if :is "${abbre_next_char}" == '{' :si {
            abbre_next_char_index+=1
            alias_name_copy="${alias_name_copy[1,${abbre_last_char_index}]}${alias_name_copy[${abbre_next_char_index},-1]}"
        # Otherwise, simply shift the leftmost "}" right one character.
        } else {
            abbre_next_next_char_index=$(( abbre_next_char_index + 1 ))
            alias_name_copy="${alias_name_copy[1,${abbre_last_char_index}]}${abbre_next_char}}${alias_name_copy[${abbre_next_next_char_index},-1]}"
        }
#       :string.output "new alias name: ${alias_name_copy}"
    }

    # If all possible abbreviation names have already been claimed by
    # existing runnables and:
    #
    # * This is an interactive substitution, print a warning and define no
    #   such abbreviation.
    # * This is an interactive abbreviation, do nothing (i.e., attempt to
    #   use the entire alias name stripped of "{" and "}" characters as the
    #   abbreviation name).
    if (( abbre_next_char_index == ${#alias_name_copy} )) {
        if :is "${ZESHY_ALIAS_CLI_TYPE}" == 'substitution' :si {
            :string abbre_name_type
            abbre_name="${alias_name//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
            abbre_name_type="$(get_runnable_type "${abbre_name}")"
            print_warning 'Abbreviation "'${abbre_name}'" in '${alias_type_readable}' "'${alias_name}'" already a defined '${abbre_name_type}':'${ZESHY_ASCII_NEWLINE}$(print_runnable "${abbre_name}")
        }
    # If this is an interactive substitution, define an interactive
    # abbreviation of the above abbreviation name and same expansion as this
    # substitution. While this does recursively call alias_cli(), such
    # call *NEVER* performs another recursive call. (Why? Listen close: such
    # abbreviation name contains no "{" or "}" characters and hence no embedded
    # abbreviation. Since such recursive call never calls this function, all
    # recursion is guaranteed to "bottom out" after the first recursion.)
    } elif :is "${ZESHY_ALIAS_CLI_TYPE}" == 'substitution' :si {
#       print "abbreviating embedded ${abbre_name}:catch\"${alias_expansion}\"" 1>&2
        alias_cli_abbreviation "${abbre_name}" "${alias_expansion_passed}"
    # If this is an interactive abbreviation, set the alias name to be returned
    # to the above abbreviation name.
    } else {
        alias_name="${abbre_name}"
    }

    # Strip "{" and "}" characters from the alias name to be returned.
    alias_name="${alias_name//[\{\}]}"
}

# --------------------( WASTELANDS                         )--------------------
        # For efficiency, inline such implementation. See is_runnable()
        # for further details.
        # whence -- "${abbre_name}" &>/dev/null or break

        # Default such boolean to false, implying this cases causes an exception
        # to be thrown unless the caller specifies otherwise.
        # :bool ZESHY_ALIAS_CLI_SUBSTITUTION_IS_RETURNING_IF_UNFOUND="${ZESHY_ALIAS_CLI_SUBSTITUTION_IS_RETURNING_IF_UNFOUND-${ZESHY_BOOLEAN_FALSE}}"
        # if (( ZESHY_ALIAS_CLI_SUBSTITUTION_IS_RETURNING_IF_UNFOUND )) {
 # Default
        # such boolean to false, implying such logic to throw an exception
        # unless the caller explicitly requests otherwise.

    # if :is "${alias_name}" == *'{'*'}'* :si {

#FUXME: When calling die() and embedding a command substitution of
#print_runnable() in the error message to such call in alias_cli() below, a
#subtle bug destroys the readability of such message: namely, print_runnable()
#calls print_message_heading() which formats its output for the current terminal
#width. Since such call is embedded within a call to die() and hence an ANSI
#box, however, print_message_heading() should instead be formatting its output
#for the width of such box. So how do we rectify this in a relatively sane
#manner? Here goes:
#
#* Call a new helper function die_and_print_runnable() in place of such die()
#  calls below, passed an error message followed by the name of a runnable.
#* die_and_print_runnable() should call a new low-level exception handler
#  die_evaluated().
#* die_evaluated() accepts one or more strings and evaluates such strings *IN
#  THE CONTEXT* of box drawing. Principally, this means such function should
#  locally override the values of ${COLUMNS} (but *NOT* ${LINES}) to account for
#  the width of the left and right borders of the body of such box. Not terribly
#  hard, of course. It just has to be done!
#
#The only genuinely "hard" part is deciding how to safely evaluate such a
#string. Consider an example culled from below:
#
#           die_evaluated '${alias_type_readable} "${alias_name}" already an alias defined as:${ZESHY_ASCII_NEWLINE}$(print_runnable "${alias_name}")'
#
#Oh, O.K. I suppose there's no genuine issue. Well, there *IS* but it's
#solvable. The issue is one of safety. Since aliases can technically include
#arbitrary characters and hence a substring inducing side-effects (e.g., an
#alias name 'terrible_alias_$(command rm -rf /)'), we absolutely must *NOT*
#attempt to evaluate the following:
#
#           die_evaluated '${alias_type_readable} "'${alias_name}'" already an alias defined as:${ZESHY_ASCII_NEWLINE}$(print_runnable "${alias_name}")'
#
#The only difference between the two are two single quotes, but OH-BOY does that
#change everything. (Thus the danger of evaluations, obviously.) Since just
#single-quoting everything solves this, I consider the danger to be mostly
#minimal. Just heavily document this!
#FUXME: Sweet; this works exactly as described, suggesting we have green light:
#    COLUMNS=$(( COLUMNS - 6 )) print_runnable info
#FUXME: Given the above risks, we probably want to segregrate such logic into
#new exception handlers die_if_alias() and so on rather than into a general
#die_and_print_runnable() function. The rest of the above plan stands.
#FUXME: Wait. Perhaps there's a simpler way. Rather than a function
#die_evaluated() introducing such insanity, what if we simply created a new
#alias die() (--woh!) as follows:
#
#    alias die="COLUMNS=$(get_terminal_width_for_errors) die"
#
#Man. This is pretty sweet. Parcel @{message/error} can define
#get_terminal_width_for_errors() in a sensible manner... and that's that!
#FUXME: Hmm. For safety, I suppose that should probably be something resembling:
#
#    alias die='COLUMNS="$(\
#       if { typeset -f get_terminal_width_for_errors &>/dev/null } {
#           get_terminal_width_for_errors
#       } else {
#           print -r -- "${COLUMNS}"
#       })" die'
#FUXME: Indeed, given such definition, we should probably just define such alias
#at the top level for sanity. Err, perhaps not the *TOP* level. @{main} is
#rather full already. How about in a new parcel @{10-alias/zsh/exception} or
#some such?
#FUXME: Oh. Right. But if we want such alias to apply to every die() call (which
#we really do), then it *DOES* need to be defined by @{main}. Right. Just bite
#that bullet and do so, I should think. It does fit in fairly well with the
#other die() functionality, so... Right. Make it so!
#FUXME: Indeed, this paradigm can be extended to print_message() and cohorts as
#well, ensuring calls to such functions enjoy the same functionality. All in
#good time, I s'ppose!

#        "${ZESHY_ALIAS_CLI_ABBREVIATIONS[@]}"
#        "${ZESHY_ALIAS_CLI_SUBSTITUTIONS[@]}"
#        "${ZESHY_ALIAS_CLI_UNTYPED_NAMES[@]}"
#    )

#FUXME: Actually, this *CAN* and should be implemented as a process
#substitution-driven alias: e.g.,
#
#    :alias_command.define "${alias_name}" '$(
#        if { is_context_cli_command_substitution } {
#            :string.output "'${alias_expansion}'"
#        } else {
#            :string.output "'${alias_name}'"
#        }
#    )'
#
#I've verified we do *NOT* need to disable such alias name within such
#expansion, unlike the equivalent function-based implementation. The only
#downside, of course, is in the forking of a subshell. But, honestly, the
#advantages appear to substantially outweigh this single disadvantage.
#FUXME: We'll need a new alias is_context_cli_command_substitution(). Shouldn't
#be *TOO* terribly hard, eh? I've just confirmed this to test for context
#"toplevel:cmdsubst". Go-go!
#FUXME: Actually, we (probably) need to retain the current function-based
#implementation. Why? Well, I'm unconvinced we can pass arguments to an alias
#defined in such way. We certainly can't use a herestring approach. This
#implies we'll need to add additional aliases to
#"00-declare/05-alias/zsh/context" for handling functions called from the CLI.
#FUXME: I'm fairly certain that there's no justifiable reason to continue
#internally implementing CLI aliases as functions. No, really. They should just
#be aliases expanding to code embedded in a "{"- and "}"-delimited block: e.g.,
#
#   alias ${alias_name}:catch"{${alias_expansion}}"
#
#This ensures that such aliases can be piped to. (Though, to be fair, can't
#"if" conditionals also be piped to? I'm fairly sure. In which case, no need
#even for the "{" and "}" delimiters. Erhm; nope! I've verified that we do
#indeed need to use such delimiters. Document this fact, naturally.)
#What's particularly nice about this approach is that it reduces the test for
#CLI-ness to simply:
#
#   is -o interactive and "${ZSH_EVAL_CONTEXT}" == 'toplevel' si
#
#That's it. Sweet, no? (I've double-checked this manually. Yup; it works.)
#
#It also allows functions to be aliased with CLI substitutions, which is *MUCH*
#more interesting and important than allowing aliases to be aliased with CLI
#substitutions (which really doesn't make much sense, on the face of it.)


# Assume "cal" but not "cancer" to be an existing pathable, as expected.
#>>> alias_cli_substitution_if_found\
#...     {c}ancer=":string.output Caloric restriction" or true
#>>> c
#zsh: command not found: c
#>>> alias_cli_substitution_if_found {c}al="print Caloric restriction"
#>>> c
#Caloric restriction

#CLI substitution aliases _always_ replace existing runnables and hence differ
#from CLI abbreviation aliases (which _never_ replace existing runnables) and
#normal `zsh` aliases (which _always_ replace existing runnables but never throw
#exceptions, print errors, or return failure if such runnables do not exist). See
#alias_cli() for further details: e.g.,

#Define an interactive abbreviation with the passed `=`-delimited specification.
#Interactive abbreviations are interactive aliases (and hence intended to be
#called only directly from the command line) subject to two additional
#constraints:
#
#== Runnable Replacement ==
#
#Interactive abbreviations _never_ replace existing runnables (i.e., external
#commands or `zsh` aliases, builtins, or functions). If the passed alias name
#duplicates the name of an existing runnable, this function prints a warning
#and silently returns with zero exit status without defining such alias.
#Interactive abbreviations thus differ from both interactive substitutions and
#conventional aliases, which silently replace existing runnables without error:
#e.g.,
#
#.alias_cli_abbreviation() Runnable Replacement
#==========================================
#[source]
#------------------------------------------
## Arguably not the best idea.
#>>> alias_cli_abbreviation ls="print Lysergic acid diethylamide"
#zeshy: interactive abbreviation "ls" already a defined command:
#/bin/ls
#>>> alias_cli_substitution ls="print Lysergic acid diethylamide"
#>>> ls
#Lysergic acid diethylamide
#------------------------------------------
#==========================================
#
#== Calling Conventions ==
#
#Interactive abbreviations _always_ throw exceptions when expanded from non-
#interactive shells or shell scripts: e.g.,
#
#.alias_cli_abbreviation() Calling Conventions
#==========================================
#[source]
#------------------------------------------
#>>> alias_cli_abbreviation ptm="print Thunnus maccoyii"
#>>> ptm
#Thunnus maccoyii
#>>> () { ptm }
#ptm: interactive abbreviation "ptm" cannot be called non-interactively
#ptm: "ptm" failed with exit status 1
#------------------------------------------
#==========================================

#== Runnable Replacement ==
#
#CLI substitution aliases only replace existing runnables. If such name is _not_
#the name of an existing runnable, print a warning to standard error
#and return with zero exit status without defining such alias: e.g.,

#Define an interactive substitution with the passed `=`-delimited specification.
#Interactive substitutions are interactive aliases (and hence intended to be
#called only directly from the command line) subject to one additional
#constraint:

#aliases, which are expandable from both interactive shells and non-interactive
#shell scripts, CLI aliases are expandable from directly at the command line of
#an interactive shell. Attempting to expand interactive aliases from any other
#context calls the unexpanded name of such alias, instead: e.g.,
    # Else, the name and expansion were explicitly passed.
#   } else {
#       alias_name_passed="${1}"
#       alias_expansion_passed="${2}"

        #FUXME: Remove this case; it *REALLY* shouldn't apply.
        # If such alias does not exist but was erroneously detected as existing,
        # throw an exception. This constitutes a fatal bug and shouldn't happen!
#       if is -z "${alias_name_type}" si {
#           die "${alias_type_readable} \"${alias_name}\" undefined:${ZESHY_ASCII_NEWLINE}$(print_runnable "${alias_name}")"

    #FUXME: Remind me again why we don't simply precede a call to
    #alias_cli_substitution() with an "is_pathable ${alias_name} and" check? Why
    #do we have a discrete function devoted to this admittedly simple task?

#and that command is in the current user's
#${PATH}. If present, `{`- and `}`-delimited substrings define the alias name.
#
#For example, the single line `{cali}bre` listed below produces aliases `cali`
#and `calibre` running Calibre disowned when the current shell is interactive
#and the current ${PATH} contains `calibre` (i.e., when Calibre is installed).
#`zeshy` effectively converts this single line to a block of code resembling:
#
#Since closing a shell should implicitly close all commands started under such
#shell excluding GUI and headless daemon commands, consider only listing the
#latter commands here.

#Concatenating all `{`- and `}`-delimited substrings in the substring left of the
#`=` in such an alias denotes a preferred alias name. If not an existing runnable
#name, `zeshy` promptly assigns this alias this alias name; otherwise, `zeshy`
#iteratively shifts the leftmost `}` in such name to the right one character and
#tries again until finding a name not already an existing runnable or shifting
#the leftmost `}` past the `=`. In the latter case, since no available alias name
#exists for such alias; `zeshy` prints an error and continues: e.g.,

# * Run directly from the command line. (If the current shell is non-
#   interactive, `zeshy` throws an exception on expanding such alias.)
# * "lr" is not already an existing runnable. (If "lr" is an existing
#   runnable, `zeshy` iteratively tries the following alias names until
#   either finding a name not already taken by an existing runnable or
#   exhausting all available choices, in which case `zeshy` prints an error:
#   "lsr", "lsre", "lsrec", "lsrecu", "lsrecur", "lsrecurs", "lsrecurse").
#>>> alias_cli_abbreviation {l}s{r}ecurse="ls -lR"
#------------------------------------------
#==========================================
# This is a normal zsh alias, always expanding "md" to call
# make_dir_if_not_found_with_options() regardless of whether "md" is already an
# existing command.
#>>> alias md="make_dir_if_not_found_with_options"

#List of aliases to be expanded only when run from an interactive `zeshy` shell,
#_always_ replacing existing runnables (i.e., external commands or `zsh` aliases,
#builtins, or functions). Interactive substitutions are useful for wrapping
#conventional runnables with convenience wrapper functions (e.g., replacing
#`ls` with list_path_with_options()). List current interactive substitutions with
#list_alias_cli_substitutions().

# This is a CLI

        # Type of failure action to perform, defaulting to "die" if not already
        # set by the caller. Recognized types include:
        #
        # * "die", only set by alias_cli_substitution().
        # * "return", only set by alias_cli_abbreviation_if_pathable().
        # * "cry", only set by alias_cli_abbreviation_if_pathable_or_warn().
#       string ZESHY_CLI_SUBSTITUTION_ACTION_IF_NOT_PATHABLE="${ZESHY_CLI_SUBSTITUTION_ACTION_IF_NOT_PATHABLE:-die}"

        # Error message to be printed.
#       string error_message="${alias_type_readable} \"${alias_name}\" not an existing command or builtin"

        #FUXME: This is terrible. Just *ALWAYS* throw an exception. If the
        #caller doesn't like that, it's *THEIR* responsibility to manually
        #catch such exception and convert it into a warning. Eliminate this
        #horrific kludge immediately. *feigned sigh*
        #FUXME: Wait the distinction between throwing an exception ("die") and
        #merely returning non-zero exit status is still required ("return"). The
        #"cry" action, however, is *NOT* required. Such action should simply
        #throw an exception, as with "die". Since this leaves two actions, we
        #should implement this as a simple boolean. Much simpler and readable.
        #FUXME: Rename ${ZESHY_CLI_SUBSTITUTION_ACTION_IF_NOT_PATHABLE} to
        #${ZESHY_ALIAS_CLI_SUBSTITUTION_IS_RETURNING_IF_NONEXTANT}. If such
        #boolean global is unset, simply throw an exception. Since throwing an
        #exception should always be the default action, such nomenclature
        #strikes me as inherently sane.

        # Perform such failure action.
#       case "${ZESHY_CLI_SUBSTITUTION_ACTION_IF_NOT_PATHABLE}" {
#       die) die "${error_message}";;
#       cry) print_warning "${error_message}"; report_failure;;
#       return) report_failure;;
#       *) die "${alias_type_readable} error action \"${ZESHY_CLI_SUBSTITUTION_ACTION_IF_NOT_PATHABLE}\" unrecognized";;
#       }

#FUXME: Such functions do *NOT* implement error handling properly. While I
#appreciate the convenience of the current approach, it's simply wrong to only
#print a warning and return success on fatal errors. Happily, the solution is
#simple: throw exceptions on such errors *BUT* catch and convert such errors to
#mere warnings during zeshy precompilation, to avert innocuous failure. This is
#*SIMPLE*. Really. Just do it. ;}

#declare_function_with_stdin <<'/---'
#void alias_cli_substitution_if_found_or_warn(string alias_specification)
#
#Define an interactive substitution with the passed `=`-delimited specification
#if the alias name excluding `{` and `}` characters in such specification is the
#name of an existing pathable or print a warning and return otherwise: e.g.,
#
#.alias_cli_substitution_if_found_or_warn()
#==========================================
#[source]
#------------------------------------------
## Assume "ps" but not "psoriasis" to be an existing pathable, as expected.
#>>> alias_cli_substitution_if_found_or_warn\
#...     {p}soriasis=":string.output Circumin" or true
#alias_cli: "psoriasis" not an existing command or builtin
#>>> alias_cli_substitution_if_found_or_warn {p}s="print Circumin"
#>>> p
#Circumin
#------------------------------------------
#==========================================
#/---
#function alias_cli_substitution_if_found_or_warn() {
#    string\
#        ZESHY_ALIAS_CLI_TYPE='substitution'\
#        ZESHY_CLI_SUBSTITUTION_ACTION_IF_NOT_PATHABLE='cry'
#    alias_cli "${@}"
#}

    # Parse and possibly define such abbreviation *AND* set ${alias_name} by
    # removing all "{" and "}" delimiters from such string.
#   if is "${alias_name_passed}" == *'{'*'}'* si {
#       alias_cli_parse_embedding
    # Else, such alias name contains no "{" and "}" delimiters. Set
    # ${alias_name} to such name, in such case.
#   } else {
#   }

#   case "${ZESHY_ALIAS_CLI_TYPE}" {
#   abbreviation)
#       ZESHY_ALIAS_CLI_ABBREVIATION_NAMES[${alias_name}]='';;
#   substitution)
#       ZESHY_ALIAS_CLI_SUBSTITUTION_NAMES[${alias_name}]='';;
#   alias)
#       ZESHY_ALIAS_CLI_UNTYPED_NAMES[${alias_name}]='';;
#   }

#FUXME: Replace the following three maps with a single map
#${ZESHY_ALIAS_CLI_NAME_TO_TYPE}, which *VASTLY* simplifies logic below.
#:map_global ZESHY_ALIAS_CLI_UNTYPED_NAMES <<'/---'
#Map from *CLI untyped alias* (i.e., a CLI alias neither a substitution or
#abbreviation) names to the empty string. This structure is a map rather than
#list as the former permits efficient lookup.
#/---

#:map_global ZESHY_ALIAS_CLI_SUBSTITUTION_NAMES <<'/---'
#Map from CLI substitution alias names (sans `{` and `}` delimiters) to the empty
#string. This structure is a map rather than list as the former permits efficient
#lookup.
#/---

#:map_global ZESHY_ALIAS_CLI_ABBREVIATION_NAMES <<'/---'
#Map from CLI abbreviation alias names (sans `{` and `}` delimiters) to the empty
#string. This structure is a map rather than list as the former permits efficient
#lookup.
#/---

#FUXME: Brilliant. I've verified "${ZSH_EVAL_CONTEXT}" to expand to the string:
#
#    toplevel:shfunc
#
#...whenever expanded directly by a function called directly from the CLI, even
#if embedded in a pipe: e.g.,
#
#    >>> function tst() { :string.output "${ZSH_EVAL_CONTEXT}" }
#    >>> tst
#    toplevel:shfunc
#    >>> print ok | tst | head
#    toplevel:shfunc
#    >>> print $(tst)
#    toplevel:cmdsubst:shfunc
#
#Folks, we've found our mechanism. Proceed with a mass renaming and
#reimplementation. This should prove considerably better, I imagine.
#FUXME: Woops! I'd *LOVE* the logic below to work. But it might not, due to
#pipes. Commands run in pipes run directly from the CLI should be treated
#equivalent to commands run directly from the CLI for purposes of CLI alias
#expansion. But I seriously doubt that "${ZSH_EVAL_CONTEXT}" is still "toplevel"
#in such cases. I suppose we could test "${zsh_eval_context}" against
#"pipe:toplevel", or something? Would that work? Clearly, before we go half-
#cocked and completely muck everything up below, we need to just run a few
#sanity checks and see whether or not this is even sensible. Perhaps implement a
#placeholder alias_cli() function with some simple test logic simply printing
#"${ZSH_EVAL_CONTEXT}" in the expansion of the defined alias, initially,
#*WITHOUT CHANGING ANYTHING ELSE, BELOW*.
#FUXME: Unconvinced the current approach of testing whether or not the current
#shell is interactive is appropriate. In truth, we don't really care whether
#this is the case; we only care whether or not the caller invoked an interactive
#alias from the command-line, perhaps suggesting we rename "interactive alias"
#to some variant of: "CLI alias", "toplevel alias", etc. As expected, I quite
#like "CLI alias". It's far more concise *AND* descriptive than "interactive
#alias".
#FUXME: In any event, I recently discovered how to efficiently test for
#invocation from the shell CLI:
#
#    # This should work.
#    is "${zsh_eval_context}" == (?*':'|)'toplevel' si
#
#    # So should this.
#    is "${ZSH_EVAL_CONTEXT}" == 'toplevel' si
#
#It'd be helpful to implement a new parcel "zsh/context" parsing these two
#globals and providing corresponding testers and getters. Yum!
#FUXME: Given that most CLI aliases are defined implicitly by configuration file
#settings rather than explicitly by calling cli_alias(), it's rather silly to
#require "="-delimited alias specifications. Certainly, we should *SUPPORT* such
#specifications, but there should be an alternative function accepting two
#distinct arguments: the alias name and expansion. To effect this, how about a
#new cli_alias_with_expansion() function? To improve matters, simply have
#cli_alias() split the alias name and expansion from the passed specification on
#"=" and then pass such name and expansion straight to
#cli_alias_with_expansion(), which performs the lion's share of the
#implementation?

#Since CLI aliases are high-level `zeshy` abstractions implemented as low-level
#`zsh` aliases by extracting `{` and `}` delimiters from such names and wrapping
#additional logic around such expansions, the actual names and expansions of the
#associated `zsh` aliases differ from the original names and expansions specified
#for such `zeshy` abstractions. Specifically:
#
#* Alias names in this map may contain `{` and `}` delimiters omitted from their
#  actual alias names in `zsh`.
#* Alias expansions in this map never contain the additional logic of their
#  actual alias expansions in `zsh`.

#FUXME: Ensure that keys of this map actually contain the original "{" and "}"
#passed delimiters. (I don't believe they do, at the moment.)
#       alias_expansion_if_noncli='"'${alias_name}'" "${@}" and report_status"'
#       alias_name="${1%%[[:space:]]#\=*}"
#       alias_expansion="${1#*\=[[:space:]]#}"
    # If the first shell word such alias expands to equals its name but not an
    # existing command or builtin, the caller is probably attempting to
    # interactively alias a function of the same name: e.g.,
    #
    #  alias_cli recursion='recursion -not -ok'
    #  function recursion() { print 'does not work as expected'; }
    #
    # While zsh does permit aliases to functions of the same name, interactive
    # aliases are themselves implemented as functions. Hence, the above
    # definition of "function recursion()" silently destroys the previously
    # defined "alias_cli recursion". To avoid subtle bugs, explicitly
    # prohibit such situations by throwing an exception here.
#   command_name="${alias_expansion[(w)1]}"
#   is "${alias_name}" == "${command_name}" si and
#       not whence -- "${command_name}" &>/dev/null and
#       die "${alias_type_readable} alias \"${alias_name}\" recursively expands to undefined command or builtin"
#   command_name_type="${$(whence -w -- "${command_name}")##*: }" or
#   is "${ZESHY_ALIAS_CLI_TYPE}" == abbreviation si and print "still alias name: ${alias_name}" 1>&2

    #FUXME: Sadly, this *CANNOT* be made to work with the current alias-driven
    #approach. I'm afraid there's no way around that. That said, everything
    #*SHOULD* still work as advertised, simply because *NO* CLI alias should
    #ever directly call a run_code_*() function. *shrug*
    # If the first shell word such alias expands to is prefixed by
    # "run_code_", assume such word to be a zeshy function transitively
    # calling run_code() with arguments requiring quote protection.
#   if is "${command_name}" == 'run_code_'* si {
#       alias_expansion_if_cli=${alias_expansion}' \"${(q)@}\" and report_status'
#   # Otherwise, pass arguments to such expansion as is.
#   } else {
#       alias_expansion_if_cli=${alias_expansion}' \"${@}\" and report_status'
#   }

    #FUXME: The alias name sorting isn't quite right, as sorting should be
    #performed on alias names *SANS* rather than including "{" and "}"
    #delimiters. We could conceivably declare a new list global
    #${ZESHY_ALIAS_CLI_NAMES_ACTUAL}, but this single use hardly seems worth it.
    #Instead, just cobble together 

#Each direct call to
#alias_cli() adds the passed alias name sans `{` and `}` delimiters to this map.
#Each call to alias_cli_abbreviation() and
#alias_cli_substitution() (when the latter is passed an alias name containing `{`
#and `}` delimiters) appends such name sans such delimiters to this list.
# For efficiency, inline such
        # implementations. See is_map_key() for further details.
#    as strings such aliases expand to include but are
#guaranteed to be longer than these original expansions.
#
#Since 
#Unlike lists
#${ZESHY_ALIAS_CLI_UNTYPED_NAMES},
#${ZESHY_ALIAS_CLI_SUBSTITUTION_NAMES}, and
#${ZESHY_ALIAS_CLI_ABBREVIATION_NAMES}, such alias names are exactly as passed.
#
#Since alias_cli() implements CLI aliases by wrapping such expansions in
#additional logic, the actual strings such aliases expand to include but are
#guaranteed to be longer than these original expansions.

#Since `{` and `}` delimiters in such names are only of use at  mapped alias names omit such delimiters.

# Each call to
#alias_cli(), alias_cli_abbreviation(), and alias_cli_substitution()
#adds the selected alias name and passed expansion to this map.
#FUXME: Rename to ${ZESHY_ALIAS_CLI_ABBREVIATION_NAMES} and convert to list
#type. There's no demonstrable reason to duplicate expansions into another map,
#when ${ZESHY_ALIAS_CLI_NAME_TO_EXPANSION} already reliably maps *ALL* CLI
#alias expansions.
#FUXME: Rename to ${ZESHY_ALIAS_CLI_SUBSTITUTION_NAMES} and convert to list
#type as above.
#Map from interactive abbreviation name to corresponding expansion. Each call to
#alias_cli_abbreviation() and alias_cli_substitution() (if embedding a `{`-
#and `}`-delimited abbreviation name in the passed alias name) adds the selected
#abbreviation name and passed expansion to this map.

#Map from interactive substitution name to corresponding expansion. Each call to
#alias_cli_substitution() adds the passed substitution name sans `{`- and `}`-
#delimited abbreviation name and passed expansion to this map.

    # Define such alias as a function of the same name. Specifically:
    #
    # * Temporarily disable such function to prevent infinite recursion if
    #   such expansion transitively calls an alias, builtin, or command of the
    #   same name.
    # * If the current shell is interactive (thus excluding non-interactive
    #   scripts) and such function was called directly from the command line
    #   (thus excluding intermediate calls by interactively called functions),
    #   run the interactive expansion; else run the non-interactive expansion.
    # * Regardless of whether an exception is thrown, reenable such function.
#   eval "function \"${alias_name}\"() {
#   {
#       disable -f ${alias_name}
#       if [[ -o interactive && \${#funcstack} -eq 1 ]] {
#           ${alias_logic_if_cli}
#       } else {
#           ${alias_logic_if_noncli}
#       }
#   } always {
#       enable -f ${alias_name}
#   }
#}"

#FUXME: Embody the above test in a new alias in a new parcel
#"05-alias/zsh/context" as follows:
#
#   alias is_context_toplevel='is "${ZSH_EVAL_CONTEXT}" == 'toplevel' si'
#
#Simple.
    # Though this implementation could simply call
    # alias_cli_substitution_if_found(), this is altogether more efficient
    # and straightforward. (Since we have to match the command name anyway, we'd
    # might as well employ it.)
# Avoid calling alias_cli_substitution(),
    # which throws exceptions and hence disrupts digest recompilation for
    # aliases not existing pathables.
#always {
        # If an exception was thrown, convert such exception to a nonfatal
        # warning and proceed to the next alias.
#       catch * and print_warning "${CAUGHT}"
#   }
        # If an exception was thrown, convert such exception to a nonfatal
        # warning and proceed to the next alias.
#       catch * and print_warning "${CAUGHT}"
    # If an exception was thrown, convert such exception to a nonfatal
    # warning and proceed to the next alias.
    # Define listed substitutions. Avoid calling alias_cli_substitution(),
    # which throws exceptions and hence disrupts digest recompilation for
    # aliases not existing pathables.
#   for_map_key_value_pairs ZESHY_ALIAS_CLI_SUBSTITUTIONS\
#       alias_name alias_expansion\
#       'alias_cli_substitution_if_found_or_warn\
#           "${alias_name}" "${alias_expansion}"'
    #FUXME: Wherever we print a message prefixed by "CLI ${ZESHY_ALIAS_CLI_TYPE}",
    #we should *REALLY* be printing a message prefixed by a new string local
    #"${alias_cli_type}", expanding to a human-readable version of such prefix
    #(e.g., "CLI abbreviation alias", "CLI alias"). I believe we've already
    #doctored up code elsewhere that does so, so... recover that code here!

#       "${alias_type_readable} \"${1}\" contains no alias expansion"
    # Validate passed arguments.
#   (( ${#alias_name} )) or
#       die "CLI ${ZESHY_ALIAS_CLI_TYPE} specifier \"${*}\" contains no '='-suffixed alias name"
#   (( ${#alias_expansion} )) or
#       die "CLI ${ZESHY_ALIAS_CLI_TYPE} specifier \"${*}\" contains no '='-prefixed alias expansion"

#   is "${ZESHY_ALIAS_CLI_TYPE}" ==\
#       ('substitution'|'abbreviation'|'alias') si or
#       die "CLI alias type \"${ZESHY_ALIAS_CLI_TYPE}\" unrecognized (expected \"substitution\", \"abbreviation\", or \"alias\")"
    # Since this alias name is not already an existing runnable, this alias
    # cannot be a substitution. To improve error readability, produce a
    # human-readable alias type as follows.
        #FUXME: O.K.; this doesn't apply anymore. Instead, check whether it's an
        #existing alias and, if so, simply *REPLACE* such alias. Ideally, we
        #should be a bit circumspect about this. While replacing an existing
        #function with another function of the same name internally calling the
        #former is infeasible, replacing an existing alias with another alias of
        #the same name internally expanding the former should be feasible.
        #FUXME: Actually, no. I can't think of any reasonable way that would
        #work. I mean, obviously, it *CAN'T*. We're defining a new alias with
        #the same name. There's a conflict, so throw an exception. Simple.

#   if { alias_name_type="${$(whence -w -- "${alias_name}")##*: }" } {
        # interactive abbreviation, print a warning indicating such abbreviation
        # could not be defined and immediately return.
#       alias_name="${1%%[[:space:]]#\=*}"
#       alias_expansion="${1#*\=[[:space:]]#}"
#   is "${alias_name}" == "${alias_expansion}" si and
#       die "CLI ${ZESHY_ALIAS_CLI_TYPE} specifier \"${*}\" contains no '=' delimiter"
        # ...zsh function, throw an exception. Interactive aliases are
        # themselves implemented as functions and hence cannot replace
        # functions of the same name without destroying such functions. As
        # functions may be implemented to account for interactivity (e.g., by
        # calling is_shell_interactive() or interactively()), there is no compelling
        # reason for interactive aliases to silently (usually, erroneously)
        # replace previously declared functions.
#       if is "${alias_name_type}" == 'function' si {
#           die "interactive ${ZESHY_ALIAS_CLI_TYPE} \"${alias_name}\" already a defined function:\n$(which "${alias_name}")"

#Due to implementation details, CLI aliases cannot expand functions of
#the same name. Doing so would silently replace the prior defined function with
#the interactive alias, thus inducing `command not found` errors on alias
#expansion. If passed an interactive alias name of the same name as an existing
#function, this function throws an exception: e.g.,
#
#.alias_cli() Runnable Replacement
#==========================================
#[source]
#------------------------------------------
#>>> function 4-HO-MET() { :string.output "${1} is colour" }
#>>> alias_cli 4-HO-MET="4-HO-MET Methylcybin"
#zeshy: interactive abbreviation "4-HO-MET" already a defined function:
#4-HO-MET() { :string.output "${1} is colour" }
#------------------------------------------
#==========================================

#== Caveats ==
#
#`zeshy` implements interactive aliases as functions rather than genuine aliases.
#This solves the prior problem of zsh assigning aliases higher precedence
#than functions, but could potentially trip up the unawares. (In practice, the
#difference between aliases and functions tends to be negligible. Usually,
#anyway!)

#`zeshy` requires such functionality before compiling its digest, sadly. Since
#`zeshy` confines most functionality to its digest, no function below may call
#`zeshy` functions. All functions below must manually implement `zeshy` functions
#defined elsewhere!

#=== Algorithm ===
#
#Interactive substitutions and abbreviations parse "{..}" expressions according
#to a simple exhaustive algorithm, which for each iteration:
#
#* Concatenates all "{"- and "}"-delimited substrings in the original alias
#  name into an implied abbreviation name: e.g.,
#
#  # In this iteration, the implied abbreviation name is "md".
#  alias_cli_abbreviation {m}k{d}ir="mkdir --parents --verbose --"
#
#* If the implied abbreviation name is not already an existing command name,
#  creates such abbreviation; otherwise, shifts the leftmost "}" right by one
#  character in the original alias name unless prior to the last character of
#  such name in which case prints a warning: e.g.,
#
#  # First test whether "md" is already an existing command. If not, run:
#  alias_cli_abbreviation {m}k{d}ir="mkdir --parents --verbose --"
#
#  # Else, test whether "mkd" is already an existing command. If not, run:
#  alias_cli_abbreviation {mk}{d}ir="mkdir --parents --verbose --"
#
#  # Else, test whether "mkdi" is already an existing command. If not, run:
#  alias_cli_abbreviation {mkdi}ir="mkdir --parents --verbose --"
#
#  # Else, all such names already exist. Emit a vile warning.
#  print_warning 'interactive abbreviations "md", "mkd", and "mkdi" already existing commands'
#
##Such substrings reduce repetition by combining multiple alias_cli_substitution() and
##alias_cli_abbreviation() calls repeating the same expansion into a single call.

#`{`- and `}`-delimited
#substrings in alias names . The
#concatenation of all `{`- and `}`-delimited substrings excluding such delimiters
#in a CLI alias name provides the *preferred name* for such alias' abbreviation.
#Since such name may already be claimed by an existing runnable (e.g., commands
#`l` and `lp` in the current user's ${PATH}), `zeshy` iteratively shifts the
#leftmost `}` in such name right by one character until finding a name _not_
#already claimed by an existing runnable: 

#== Syntax ==
#
#CLI aliases are both declared and defined with `=`-delimited alias syntax.

#CLI substitution and abbreviation aliases parse `{`- and `}`-delimited
#substrings according to a simple exhaustive algorithm, which for each iteration:
#
#* Concatenates all "{"- and "}"-delimited substrings in the original alias
#  name into an implied abbreviation name: e.g.,
#
#* If the implied abbreviation name is not already an existing command name,
#  creates such abbreviation; otherwise, shifts the leftmost "}" right by one
#  character in the original alias name unless prior to the last character of
#  such name in which case prints a warning: e.g.,

# p
#`{`- and `}`-delimited substrings in a CLI abbreviation alias name implicitly
#define  preferred name is the concatenation of
#such substrings excluding delimiting `{` and `}`, to be expanded to the same
#expansion. If the preferred abbreviation name is claimed by an existing
#runnable, alias_cli_substitution() iteratively lengthens such abbreviation until
#finding a name _not_ already claimed by an existing runnable: e.g.,

#Interactive abbreviations interpret embedded `{..}` expressions as the
#interactive abbreviation name to be expanded to. This is principally useful
#for generic safety, to accommodate heterogenous end user systems under which
#one has no control and hence could have conceivably installed commands with
#the same names as desired abbreviations: e.g.,

#if available
#(i.e., if not already the name of an existing runnable)
# for both convenience and safety. whose result dynamically depends on current system state --
#user's shell environment and contents of the filesystem accessible to such user.
# for normal,
#global, and suffix aliases, as the above examples demonstrate
#. Specifically, the alias name is followed by delimiter `=`
#followed by the alias expansion: e.g.,
#
#For example:
#
#Like traditional aliases, the various types of CLI aliases are defined
#by various `zeshy` functions:
#
#* alias_cli_abbreviation(), abbreviating an existing zsh builtin or external
#  command in ${PATH} with an interactive alias of a different name: e.g.,
#
#    # Abbreviate the external "ls" command with an interactive alias "l".
#    alias_cli_abbreviation l="ls"
#
#* alias_cli(), a low-level helper function declaring an interactive
#  alias _not_ substituting or abbreviating an existing zsh builtin or external
#  command in ${PATH}. However, most interactive aliases substitute or
#  abbreviate such builtins or commands! For improved portability and safety,
#  consider calling the high-level functions alias_cli_substitution() or
#  alias_cli_abbreviation() instead.

#`zeshy` throws an exception on attempting to:
#
#* Define either a CLI:
#** Substitution of a non-existing command. (Substitutions always replace
#   existing commands, thus preventing declaration of interactive aliases
#   inapplicable to the current system and user.)
#** Abbreviation of an existing alias, function, or command. (Abbreviations
#   never shadow existing runnables, unlike typical aliases.)
#* Call an interactive abbreviation non-interactively.
#
#Calling an interactive substitution non-interactively runs the substituted
#command as is, as if never shadowed by an interactive alias. In other words,
#"things just work as expected."

    #FUXME: Calling run_code_with_stdin_piped() both here and below is rather
    #overkill, as such expansion is *ALREADY* being evaluated. No sense in doing
    #so twice. We really just need an alias expa

    # Validate sanity and that Zeshy's user configuration has been sourced.
#   die_if_args
#   string command_name
#   :var.die_unless_type_map ZESHY_ALIAS_CLI_ABBREVIATIONS\
#       "map \"ZESHY_ALIAS_CLI_ABBREVIATIONS\" undeclared; zeshy's user configuration either unsourced or corrupt"
#   print "ZIS: ${(kv@)ZESHY_ALIAS_CLI_SUBSTITUTIONS}"
    #FUXME: Call map iterables rather than iterating manually.

# Consider calling alias_cli_abbreviation() or
#alias_cli() if such functionality is preferable.
    #FUXME: Terrible name, really. How about simply "punctuation_bold"?
    #FUXME: Actually, "punctuation" is increasingly terrible the more I consider
    #it in frustration. What if you want to change, say, the color of the colon
    #say() emits without changing *ALL* such punctuation? You can't. Hence, we
    #should avoid such generalized styles for function-specific styles. Remove
    #btho this and "punctuation".
#   punctuation          grey
#   punctuation_semantic grey_bold

#List all declared interactive alias names with corresponding expansions.
# Handle interactive abbreviations (i.e., interactive aliases *NOT* replacing
# existing runnables).

# Handle all interactive alias functionality *OTHER* than defining such aliases.
# See "define" for the latter.
# See "handle" for all other interactive alias-related functionality.
    #FUXME: Define and call a new alias_cli_substitution_if_found_or_warn() instead
    #to avoid crashing the entire compilation process when such command is not
    #installed on the current system. Robustness for the win!

# (It *SHOULDN'T* ever be, and since it
    # shouldn't ever be, print warnings instead.)
        #FUXME: Should probably centralize into a new
        #alias_cli_substitution_if_found().
#       alias_name="${specification%%\=*}"
#       command_name="${alias_name//[\{\}]}"
#       is_pathable "${command_name}" and alias_cli_substitution\
#           "${specification}"
#FUXME: How essential are these, actually? I'm thinking... not. The difficulty
#is coherently coordinating colors between the three. *sigh*
#I print_message we excise these, for now.
#declare_function '
#void list_alias_cli_abbreviations()
#
#List all declared interactive abbreviation names with corresponding expansions.
#'
#function list_alias_cli_abbreviations() {
#    # Validate sanity.
#    die_if_args
#
#    # List such aliases.
#    for name ( $(get_map_keys_sorted_lexically_ascending\
#        ZESHY_ALIAS_CLI_ABBREVIATION_NAMES) ) {
#        :string.output "alias_cli_abbreviation ${name}:catch\"${ZESHY_ALIAS_CLI_ABBREVIATION_NAMES[${name}]}\""
#    } | page_stdin
#}
#
#declare_function '
#void list_alias_cli_substitutions()
#
#List all declared interactive substitution names with corresponding expansions.
#'
#function list_alias_cli_substitutions() {
#    # Validate sanity.
#    die_if_args
#
#    # List such aliases.
#    for name ( $(get_map_keys_sorted_lexically_ascending\
#        ZESHY_ALIAS_CLI_SUBSTITUTION_NAMES) ) {
#        :string.output "alias_cli_substitution ${name}:catch\"${ZESHY_ALIAS_CLI_SUBSTITUTION_NAMES[${name}]}\""
#    } | page_stdin
#}
#
    # Reset colors in preparation for subsequent output.
#   reset_
#   :string.output "${ZESHY_COLOR_RESET}"
    #FUXME: Excellent. We should probably define (and expand here) a new *ALIAS*
    #set_colors_locally<> testing whether or not standard output for the current
    #function is attached to a terminal and, if not, temporarily locally
    #replacing all color strings and maps previously globally defined with
    #strings expanding to the empty string. (Clearly, such maps should have the
    #same keys but empty values.) Rather than expensively redeclaring such
    #variables on each such alias expansion, predeclare such variables in
    #"io/terminal/color" as, perhaps, ${ZESHY_COLOR_EMPTY} and so on.
    #FUXME: Actually, localize_colors<> is a significantly better name. Yum-yum.

#FUXME: Colorify such output; it's a tad difficult to read without helpful
#syntax highlighting.

#       if is_map_key ZESHY_ALIAS_CLI_ABBREVIATION_NAMES "${name}"
#       elif is_map_key ZESHY_ALIAS_CLI_SUBSTITUTION_NAMES "${name}"
        #FUXME: Let's try improving is_map_key() efficiency, shall we?
#       if is_map_key ZESHY_ALIAS_CLI_ABBREVIATION_NAMES "${name}"
#       elif is_map_key ZESHY_ALIAS_CLI_SUBSTITUTION_NAMES "${name}"
#       if is_map_key ZESHY_ALIAS_CLI_ABBREVIATION_NAMES "${name}"
#       elif is_map_key ZESHY_ALIAS_CLI_SUBSTITUTION_NAMES "${name}"
        # If such alias is an abbreviation, prefix such declaration with that.
        # If such alias is a substitution, prefix such declaration with that.
        # Otherwise, prefix such declaration with a generic alias type.
#   {
#       list_alias_cli_abbreviations
#       print_newline
#       list_alias_cli_substitutions
#   } | page_stdin
#   =(
#       "${ZESHY_ALIAS_CLI_ABBREVIATION_NAMES[@]}"
#       "${ZESHY_ALIAS_CLI_SUBSTITUTION_NAMES[@]}"
#   )
#       say_first_section 'interactive abbreviation list'
#       say_next_section 'interactive substitution list'

#       ${(k)ZESHY_ALIAS_CLI_ABBREVIATION_NAMES}) {

# This includes list element of:
#* ${ZESHY_ALIAS_CLI_ABBREVIATIONS}, define:
#  * An interactive abbreviation from such element stripped of "{"- and "}"-
#    non-delimited substrings to such element stripped of "{"- and "}"-
#    delimited substrings (e.g., for list element "{v}im",
#    "alias_cli_abbreviation v=vim"), if the former exists.
#* ${ZESHY_ALIAS_CLI_SUBSTITUTIONS_RUN_DISOWNED}, define:
#  * An interactive substitution from such element stripped of "{"- and "}"-
#    delimited substrings to the same string (e.g., for "{cali}bre",
#    "alias_cli_substitution calibre=''run_code_disowned calibre''").
#  * An interactive abbreviation from such element stripped of "{"- and "}"-
#    non-delimited substrings to the above string (e.g., for "{cali}bre",
#    "alias_cli_abbreviation cali=''run_code_disowned calibre''"), if the former
#    exists.
    #FUXME: Defer to a canonical splitter function instead of splitting manually.
# This component resides under "00-setup" to guarantee its importation prior to
# other Zeshy components during compilation of Zeshy's digest file. Typically,
# other Zeshy components call functions this component defines (e.g.,
# alias_cli_substitution()) in a global context.

    # If such alias is either an
    # interactive abbreviation or substitution as is usual, .
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #Note: avoid calling die() or functions calling die() below.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# algorithmically selected abbreviation name to this list.

#List of aliases to be expanded when run from an interactive shell. Each alias
#name (excluding embedded "{" and "}" characters) must be the name of an
#existing runnable. See ${ZESHY_ALIAS_CLI_ABBREVIATIONS} for further details.

#Interactive abbreviations and substitutions are generally safer than and hence
#preferable to normal zsh aliases, for most uses.

    #   the next name until either finding a
    #   name not already taken by an existing runnable or exhausting all
    #   available choices, in which case Zeshy prints a warning.

#heuristics find the shortest desired alias name not already
#claimed by an existing runnable
#with "{"- and "}"-delimited substrings in the alias name
#
#embedding Zeshy-specific "heuristics."
#For all three 
#With normal zsh aliases, the substring left of the "=" specifies the alias name
#while the substring right of the "=" the alias expansion: e.g.,
#
#Normal zsh aliases have the familiar format
#"alias ${alias_name}:catch${alias_expansion}": e.g.,
#
#    alias this_is_the_alias_name="this --is --the -- alias expansion"
#
#With interactive abbreviations and substitutions, the substring left of the "="
#is a heuristic helping Zeshy to find the shortest desired alias name not already
#claimed by an existing runnable while the substring right of the "=" still defines the alias
#expansion as for normal aliases.
#see ${ZESHY_ALIAS_CLI_SUBSTITUTIONS} for interactive aliases
#always replacing existing runnables.

# on the current system (i.e., not already the name of
#an existing alias, builtin, or function or external command in the current
#user''s ${PATH}),
#Interactive abbreviations *NEVER* replace existing runnables (i.e., external
#commands or zsh aliases, builtins, or functions). Hence, such abbreviations are
#appropriate for abbreviating but not replacing an existing 

#By contrast, interactive substitutions *ALWAYS* replace existing runnables. 

    #FUXME: It'd be great to add a new list ${ZESHY_ALIAS_CLI_SUBSTITUTIONS}
    #with "="-delimited elements, which would allow us to do away with a few
    #currently extraneous "if_installed" components: e.g.,
    #ZESHY_ALIAS_CLI_SUBSTITUTIONS=(
    #    {m}utt='mutt -y'
    #)
    #FUXME: Come to think, it'd be great to shift *ALL* current calls to
    #alias_cli_abbreviation() and alias_cli_substitution() into
    #"if_config/alias", thus rendering such aliases accessible to user
    #configuration (as well as cleaning up and simplifying the syntax). I'm
    #fully for it! Huz-zzah!


# See "help alias_cli_abbreviation" for further details on abbreviations.

#       alias_cli_substitution_if_found "${specification}"
#   for specification ("${ZESHY_ALIAS_CLI_ABBREVIATIONS_IF_RUNNABLE[@]}") {
#       alias_cli_abbreviation_if_pathable "${specification}"
#   }
#   ZESHY_ALIAS_CLI_ABBREVIATIONS_IF_RUNNABLE\
# List of interactive aliases in "="-delimited syntax to be expanded only if run
# from an interactive shell *AND* the alias name (excluding embedded "{" and "}"
# characters) is the name of an existing runnable on the current zsh system.
# See above for further details on such syntax.
#ZESHY_ALIAS_CLI_ABBREVIATIONS_IF_RUNNABLE=(
#)

#alias_cli_abbreviation ${subst_name}:catch"${command_name}"

# operate slightly
# differently.
# intername alias 
# All "{"- and "}"-delimited substrings within alias
# names denote preferred abbreviation names. See
# alias_cli_abbreviation() for further details.
#
# For example, the single line "{v}im" listed below produces alias "v" running
# ViM when the current shell is interactive and the current ${PATH} contains
# "vim" (i.e., when ViM is installed). In effect, Zeshy converts this line to
# code resembling:
#
#     >>> is_shell_interactive and is_pathable vim and alias v='vim'

#   is "${ZESHY_ALIAS_CLI_TYPE}" == abbreviation si and print "which alias name: $(which ${alias_name})" 1>&2

#Interactive abbreviations are thus suitable for abbreviating existing runnables
#with a unique name. See alias_cli() for further details: e.g.,
#
#Interactive abbreviations refuse to replace existing runnables. Specifically,
#are interactive aliases (and hence intended to be
#called only directly from the command line) subject to an additional constraint:
#interactive abbreviations *NEVER* replace existing runnables (i.e., external
#commands or zsh aliases, builtins, or functions).

#Interactive aliases are inactive in non-interactive scripts and
#functions, and hence helpful for applying human-readable options on that
#builtin or command when run directly by a human. This function fails if the
#builtin or command to be aliased does not exist. See
#alias_cli_if_installed() for an alternative not failing in such cases.

# >>> print_noninteractively() { print "${@}" }
# >>> print_noninteractively T M D
# T M D
#The alias specification format is identical to that of normal aliases:
#   (( ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS )) or report_success
#   (( ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS )) or report_success

#whereas 
#if the passed alias name has the same name as some existing runnable (e.g.,
#builtin, command), print a warning and return without defining such alias.

#Interactive abbreviations *NEVER* replace existing runnables, but are
#otherwise identical to interactive aliases.
#If the current user has enabled the configuration global
#${ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS},
#   ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS\
#   ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS
# ....................{ BOOLEANS ~ alias                   }....................

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#FUXME: Actually, these are thoroughly obsolete. Stop using them everywhere and
#excise. Replace with proper granular support for "="-delimited aliases in
#configuration file "alias".
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# If non-empty, ...

# "1" if wrapping interactively run external commands (e.g., "cp", "grep", "ls")
# with corresponding Zeshy functions and "" otherwise. If enabled, Zeshy runs
# such commands with default options defined by the corresponding list below
# (e.g., wrapping interactively run "cp" commands with copy_path(), a Zeshy
# function passing "cp" the ZESHY_OPTIONS_CP list). If disabled, Zeshy runs
# such commands with no such defaults.
#
# For sanity, Zeshy never wraps core commands when run non-interactively (e.g.,
# "cp" when run from a script always executes "cp" with no such defaults).
#ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS=${ZESHY_BOOLEAN_TRUE}

#FUXME: Document.
#ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS=${ZESHY_BOOLEAN_TRUE}

    #   * Standard :string.output is attached to a terminal, thus excluding all
    #     commands in pipe except the last such command.
#&& -t ${ZESHY_STDOUT_FILE_DESCRIPTOR}

# ....................{ GLOBALS                            }....................
#FUXME: It'd be great to make this somehow configurable. Ah; obviously, this
#should go into a configuration file. I s'pose that was very obvious. How about
#simply "alias" at the top-level? Not convinced we need the
#add_interactive_gui_substitution() function, honestly; cut it to the wastes.
#Since there only exists one remaining small function, move such function to
#"alias_cli".

#a similar
#   interactive substitution and abbreviation to the such strings run disowned
#   (e.g.,     # For each such name, if such name stripped of "{"- and "}"-delimited
    # substrings produces a currently installed command name, define such name
    # to interactively expand to such command name.
#"disowned" from the current
    # shell. GUI commands should almost always run "disowned" to prevent their
    # termination on termination of the parent shell.
# While GUI commands should avoid terminating on termination of their
# originating shell, CLI commands should always terminate on , this list typically lists .
# Such substitutions
# either were previously added to
# ${ZESHY_ALIAS_CLI_SUBSTITUTIONS_RUN_DISOWNED} by prior calls to
# add_alias_cli_substitutions() or are hard-coded into this function.#
# Interactive substitution name embeds "{"- and "}"-delimited strings defining the corresponding
# interactive abbreviation name).
# by the embedded
# interactive substitution name. Typically, such commands are graphical.
# ....................{ ADDERS                             }....................
# void add_interactive_gui_substitution(
#   string substitution_name1, string substitution_name2, ...)
#
# Add the passed strings to list global
# ${ZESHY_ALIAS_CLI_SUBSTITUTIONS_RUN_DISOWNED}, to be subsequently defined by
# startup_interactive_gui_substitutions() as interactive substitutions running
# GUI commands (i.e., disowned from the current shell).
#function add_interactive_gui_substitution() {
#    die_unless_args 'expected at least one substitution name'
#    ZESHY_ALIAS_CLI_SUBSTITUTIONS_RUN_DISOWNED+=( "${@}" )
#}

    #FUXME: DeVeDe appears to fail under:
    #   {d}e{v}e{de}                   # DeVeDe DVD Creator.
    #Why?
    #FUXME: Declare as a "listset_global" here and below, to preserve uniqueness.
# as interactive substitutions running
# interactive substitutions for a subset of hard-coded GUI commands.
#FUXME: It'd be nice to permit users to dynamically add aliases to such list.
#Since we already helpfully use a global_export variable below, we need only add a few
#helper functions to enable this.

#Of course, this begins to raise awkward timing issues, as well... Ah. No; it
#doesn't, really.

# Unlike Zeshy Interactive Alias, this component need not reside under
# "00-startup". It does, however, need be imported after importing Zeshy
# Interactive Alias. Thus, its filename.
        # If such command is installed, define such substitution.
# Thus, this component is a
# hard dependency of typical Zeshy components.
#FUXME: This still isn't quite right. The reason is subtle:
#    alias_cli ssh='TERM="xterm" ssh -v'
#See what happens there? We attempt to call a command "TERM=\"xterm\"" when
#non-interactive. Of course, we should be calling "ssh". So, this is subtly
#broken. Fixing it requires ignoring all prefixing words containing a "="
#character if such word is not an extant command. (Since, of course, a command
#basename could contain an "=" character. Highly unlikely, but there you go...)
#   *sigh*

#FUXME: Record each added substitution and abbreviation in respective global
#maps, for use in displaying a dynamically constructed "cheat sheet" of all
#current interactive substitutions and abbreviations.
#FUXME: It would be nice to define interactive substitutions and abbreviations
#together in the same function. While this should only ever be an optional
#convenience not replacing the original functions below, it would enable us (in
#particular) to dynamically search for the "nearest" unclaimed abbreviation. For
#example:
#
#    >>> alias_cli_substitution [p]rint='print -r --'
#
#Way cool. If passed an alias name containing one "[" preceding one "]",
#interpret the alias name with such characters omitted as the full name and the
#substring of such name embedded in such characters as the abbreviation. If the
#latter name has already been claimed by an existing runnable, iteractively try
#"pr", "pri", and "prin" before giving up with a warning (but *NOT* exception).
#
#Let's admit it: this is pretty great. But it's not quite enough. We also need
#to handle discontiguous embedded abbreviations resembling:
#
#    >>> alias_cli_substitution [m]k[d]ir='mkdir -v --'
#
#This suggests a lexical algorithm as follows:
#
#* If the desired abbreviation already exists, iteratively shift the leftmost
#  "]" right unless already prior to the last character of the alias name, in
#  which case print a warning. Hence, we try the following embeddings:
#
#    >>> alias_cli_substitution {m}k{d}ir='mkdir -v --'
#    >>> alias_cli_substitution {mkd}ir='mkdir -v --'
#    >>> alias_cli_substitution {mkdi}r='mkdir -v --'
#
#I suspect this is efficiently implementable without actually shifting around
#lexical characters. Also, note that the implementation requires *NO* changes
#to the existing alias_cli_abbreviation() or alias_cli() commands.
#Such commands should, ideally, be entirely unaware of substitution embeddings.
#FUXME: This functionality has become a bit... extreme. It's great, but too
#large for a top-level component. Shift into a new "always/shell/interactive" or
#"always/shell/alias/interactive" component; then, manually import such
#component if and only if compiling a new digest. The only catch here is that
#such component *CANNOT* call any functions defined in other components. This
#needs to be explicitly documented, up front.

# Unlike traditional aliases, :
# substitution and abbreviation interactive aliases. 
#
# Interactive aliases are declarable with one of the following functions:
#
# the "alias_cli"
# helper (as above), Zeshy recommends using the following  "interactive 
#
# While interactive aliases are declarable directly with the "alias_cli"
# helper (as above), Zeshy recommends using the following  "interactive 
# There are two prominent types of interactive aliases.
#
# Like traditional aliases, there are two prominent types of interactive
# aliases: substitution and abbreviation interactive aliases. 
#
# Defer defining the following functions until having defined all prior aliases.
    # While the following block would ideally be encapsulated in a separate
    # function, its calling of alias_cli_abbreviation() and hence dynamic
    # evaluation of a new function definition would erroneously confine such
    # definition to the subshell
#       alias_name="$(parse_embedded_alias_cli_abbreviation "${alias_type}" "${alias_name}" "${alias_expansion}")"


#       print -r -- "${alias_name//[\{\}]}"
#       alias_name="$(parse_embedded_alias_cli_abbreviation "${alias_type}" "${alias_name}" "${alias_expansion}")"
# string parse_embedded_alias_cli_abbreviation(
#   string alias_type, string alias_name, string alias_expansion)
#
# Parse "{"- and "}"-delimited substrings from the passed interactive alias name
# of the passed type (either "substitution" or "abbreviation") expanding to the
# passed expansion. Concatenating such substrings provides the interactive
# abbreviation embedded in such name (e.g., alias name "l{ich}mumm{y}" embeds
# abbreviation "ichy"). If such type is:
#
# * An abbreviation, return such abbreviation name.
# * A substitution and:
#   * If all possible extensions of the embedded abbreviation have been claimed
#     by existing runnables, print a warning and define no such abbreviation.
#   * Otherwise, define such abbreviation to the passed expansion.
#   * In either case, return such alias name stripped of "{" and "}" characters.
    # Validate passed arguments.
#   die_unless_args_3\
#       'expected one alias type, one alias name, and one alias expansion'
#   string alias_type="${1}" alias_name="${2}" alias_expansion="${3}"
#   print_string_with_escapes "abbreviation: ${abbre_name}\nmatch[1]: ${match[1]}"

#           match=()
#           (( abbre_first_char_index = ${mend[1]} - 1 ))
#           (( abbre_right_brace_index = MEND ))
    # Return unless the current user configuration enables substitutions.
    # Return unless the current user configuration enables abbreviations.
#   string alias_name="${*%%[[:space:]]#\=*}"
#   noop "${(S)alias_name//*\{(#b)(*?)\}*}"
#   if ; then
#   if is "${alias_name}" == *'{'(#b)(*?)'}'* si; then
#   if is -n "${(MS)alias_name//*\{(#b)(*?)\}*}" si; then
#   :string.output "match attempt: ${(SI:1:)alias_name//*\{(#b)(*?)\}*}"
#   :string.output "match attempt: ${(SI:1:)alias_name#\{(#b)(*?)\}}"
#   match=()
#   noop "${(SI:1:)alias_name#\{(#b)(*?)\}}"
#   if is -n "${match}" si; then
#       match=()
#       is "${alias_name}" == (#b)[^{}]#'{'([^{}]##)'}'[^{}]# si
#       is "${alias_name}" == ([^{}]#'{'(#b)([^{}]##)'}')## si
#       is "${alias_name}" == (#b)([^{}]#'{'([^{}]##)'}')## si
#       :string.output "alias_name: ${alias_name}"
#       print "${alias_name//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
#       :string.output "embedding: ${match[*]}"
#       :string.output "embedding: ${(S)alias_name//*\{(#b)(*?)\}*/${match[1]}}"
#       :string.output "embedding: ${(S)alias_name//*\{(#b)(*?)\}*/${match[1]}}"
#       integer embedded_first_char_index=$(( ${mend[1]} - 1 ))
#       :string.output "match: ${match[1]}; mend: ${mend[1]}"

#   string abbre_name="${alias_name//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
#   if is "${abbre_name}" != "${alias_name}" si; then
#       integer alias_name_length="${#alias_name}" abbre_next_char_index
#       print_string_with_escapes "abbreviation: ${abbre_name}\nmatch[1]: ${match[1]}\nalias name length: ${alias_name_length}"
#   else
#By design, the passed alias must be either an interactive abbreviation or
# substitution. #       while whence -- "${abbre_name}" 1>/dev/null 2>&1; do
#           (( abbre_next_char_index < 10 )) or break
                #FUXME: Should be handled by the above exception handling, no?
#               (( abbre_next_char_index < alias_name_length )) or
#                   die "interactive substitution \"${alias_name}\" contains an unclosed '{'"
    # If *NOT* a raw interactive alias (e.g., if either an interactive
    # substitution or abbreviation) and 
#           string abbre_name_definition
#           abbre_name_definition=""
#           print_warning "embedded abbreviation interactive substitution \"${alias_name}\" contains"

#           case "${alias_cli_type}" in
            # ...this is an interactive substitution alias and the current user
            # prohibits substituting runnables with such aliases, return!
#           substitution) report_success;;
#               is -n "${ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS}" si or
#                   report_success
            # ...this an interactive abbreviation alias, return! Also, if the
            # current user prohibits abbreviating runnables with such aliases,
            # print a warning indicating such abbreviation could not be defined.
#           elif is "${alias_cli_type}" == 'abbreviation' si; then
#               is -n "${ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS}" si or
#                   print_warning "interactive abbreviation \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#               report_success

    #FUXME: Document. I get it. We were trying to make the above
    #'alias_cli print="print -o"' example work as expected. But, if you
    #think about it, that's pretty much impossible in the general case. For example,
    #'alias_cli print="run_code_paged print -o"' pretty much fails under non-
    #interactivity with the naive assumption of the first word being the command to be
    #run. I'd print_message this needs dramatic generalization. Basically, the function should
    #strictly accept only one or two arguments; if passed, the second argument tells
    #what to run when non-interactive and otherwise defaults to the following:
    #
    #* If the alias name and first word of the alias expansion are the same and:
    #  * Such name is an existing function, throw an exception (as below) when run
    #    non-interactive.
    #  * Default to such name without arguments (as below) when non-interactive.
    #* Otherwise, default to such name without arguments (as below) when non-interactive.
    #
    #Oh, wait. The above FUXME handles such edge cases, so... simply default to:
    #
    #* If the first word of the alias expansion is a non-empty, non-alias, non-function
    #  (i.e., is a command, builtin, or reserved), such word.
    #* Else if the first word of the alias expansion matches the "run_code_"* glob and the
    #  second word of such expansion is a non-empty, non-alias, non-function, such word.
    #* Else if the alias name is a non-empty, non-alias, non-function, such name.
    #* Otherwise, throw an exception from within such function definition.
    #
    #Note that *': function' erroneously fails to match aliases. So, just glob
    #*': '(builtin|command|reserved) explicitly. *shrug*
    #
    #This default cleanly handles the prior examples. It won't work in all cases, of
    #course, which is why we permit parameters resembling:
    #
    #    alias_cli print_up="do_something_curious print -o"' 'print'
    #
    #*ACTUALLY*, the more I think about, the more I realize the above heuristics only
    #apply to the case that the alias name is a non-function (e.g., external command);
    #in such case, the above heuristic can be seemlessly reduced to simply calling such
    #name. If, on the other hand, the alias name is an *ABBREVIATION*, then it should
    #*NEVER* be runnable non-interactively; an exception should always be thrown. Since
    #this logic biffurcates cleanly between alias_cli() and
    #alias_cli_abbreviation()... You know, why do we even have those two functions?
    #Any interactive alias for which the alias name is *NOT* already an existing non-
    #function is implicitly an abbreviation or something similar. I believe we can
    #dispense with alias_cli_abbreviation(), therefore.

    #FUXUP: We should probably throw an exception under cases such as:
    #
    #  alias_cli recursive='recursive -not -ok'
    #  function recursive() { print 'uh oh'; }
    #
    #While recursion *USUALLY* works (due to our use of function disabling and
    #enabling below), it fails if the first word of the alias expansion expands
    #to a zsh function of the same name as the alias. In the case above, such
    #function has yet to be defined. Hence, *UNLESS* such word has a non-empty,
    #non-function type, we assume its type to be function and throw an exception.

    # The command to expand this alias to when called non-interactively. If the
    # the command to expand this alias to when called interactively is a:
    #
    # * Builtin or command, then this is that builtin or command name sans
    #   subsequent arguments.
    # * Alias or function and:
    #   * The original passed alias name is a builtin or command, then this is
    #     that builtin or command name.
    #   * Otherwise, raise an exception.

#   then alias_logic_if_noncli="die '\"${alias_name}\" and \"${command_name}\" are neither builtins or commands and hence cannot be called non-interactively'"
#alias_cli ff="firefox"
    # The string to expand this alias to when called non-interactively.
#   if is "${alias_name}" == "${command_name}" and\
#      "$(whence -w "${command_name}")" == *': function' si
#   then alias_logic_if_noncli="die '\"${alias_name}\" and \"${command_name}\" are neither builtins or commands and hence cannot be called non-interactively'"
        #FUXME: Have my doubts about this logic; it feels... dubious. Too
        #clever, and arguably bug-prone. Let's ride bareback for a bit.
#       if is "${alias_name_type}" != 'function' si
#       then alias_expansion_if_noncli="${alias_name}"
#       else alias_expansion_if_noncli=
#       fi
#   else
#       alias_expansion_if_noncli="${command_name} \"\${@}\""
#       alias_logic_if_noncli="
#   if :is_stdin_pipe
#   then run_code_with_stdin_piped ${alias_expansion_if_noncli}
#   else ${alias_expansion_if_noncli}
#   fi"
#   fi

#FUXME: Implement me. Basically, disembowel alias_cli(). ;]
#define_alias_cli() {
#}

    #SUBSTITUTION
#   if alias_name_type="${$(whence -w -- "${alias_name}")##*: }"; then
#       if is "${alias_name_type}" == 'function' si; then
#           die "interactive substitution \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#       else
#           is -n "${ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS}" si or
#               report_success
#       fi
#   else
#       die "interactive substitution \"${alias_name}\" not found in \$PATH"
#   fi

    #ABBREVIATION
    # If a function, throw an exception. While zsh does behave sensibly when
    # aliasing functions (e.g., "alias rm='rm -i'" behaves non-recursively),
    # interactive aliases are functions rather than aliases. Defining an
    # interactive alias of the same name as an existing function thus
    # silently overwrites such function, which is never helpful. Prohibit!
    # If anything other than a function (e.g., builtin, command),
    # emit a warning and return without redefining such builtin or command.
#   alias_name_type="${$(whence -w -- "${alias_name}")##*: }" and
#       is "${alias_name_type}" != 'function' si and {
#       print_warning "interactive abbreviation \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#       report_success
#   }

    # If such alias name is an existing runnable, either emit a warning or throw
    # an exception (depending on the type of such runnable).
        # Definition of such runnable and appropriate error message.
#       string alias_definition error_message
#       alias_definition=""

#FUXME: ${ZESHY_IS_WRAPPING_BUILTINS} is a rather poor name. Globally rename to
#${ZESHY_IS_WRAPPING_BUILTINS_WITH_CLI_ALIASES}, please.

    # Alias name type, if the passed alias name is already declared to be an
    # alias, builtin, command, or function.
#   alias_name_type="${$(whence -w -- "${alias_name}")##*: }" and {
        #FUXME: Shouldn't interactive aliases of real aliases be O.K., also? Hmm; no,
        #I suppose not! We don't call eval() in the function definition, and doing so
        #would introduce yet more bizarre edge-casing. Explicitly document why we
        #currently prohibit this. The current logic here suffices, in any case.

        # Die if already declared unless the current user requests wrapping such
        # types with interactive aliases. In particular, replacing a declared
        # zsh alias or function with an interactive alias is largely senseless;
        # zsh aliases and functions may always be implemented to account for
        # interactivity (e.g., by calling is_shell_interactive() or interactively()),
        # thus obviating the need for interactive aliases in such cases. Since
        # silently replacing declared zsh aliases and functions seems an
        # inherently risky (and certainly useless) proposition, disallow it.
#       if   is "${alias_name_type}" == (builtin|reserved) si
#       then is -n "${ZESHY_IS_WRAPPING_BUILTINS-}" si or report_success
#       elif is "${alias_name_type}" == command si
#       then is -n "${ZESHY_IS_WRAPPING_COMMANDS-}" si or report_success
#       else die\
#           "interactive alias \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#       fi
#   }

    #FUXME: Shouldn't interactive aliases of real aliases be O.K., also? Hmm; no,
    #I suppose not! We don't call eval() in the function definition, and doing so
    #would introduce yet more bizarre edge-casing. Explicitly document why we
    #currently prohibit this. The current logic here suffices, in any case.

    #   and functions with interactive aliases is senseless, as the
    #   former may always be implemented to account for
    #   interactivity (e.g., by calling is_shell_interactive() or interactively()),
    #   thus obviating the need for interactive aliases in such cases. Since
    #   silently replacing declared zsh aliases and functions seems an
    #   inherently risky (and certainly useless) proposition, disallow it.

        #FUXME: Hmm; we can't print_message whether or not an alias is invalid without
        #expanding it to its expansion and then taking the name of 
    # Non-interactive logic to be performed by the function definition below.
#   if is -n "${alias_expansion_if_noncli}" si; then
#       alias_expansion_if_noncli+=' "${@}"'
#       alias_logic_if_noncli="
#   if :is_stdin_pipe
#   then run_code_with_stdin_piped ${alias_expansion_if_noncli}
#   else ${alias_expansion_if_noncli}
#   fi"
#   else alias_logic_if_noncli="die '\"${alias_name}\" and \"${command_name}\" are neither builtins or commands and hence cannot be called non-interactively'"
#   fi

    # Otherwise, such alias name is either an existing zsh function or has yet
    # to be declared. In the former case, we (optimistically) assume 
#FUXME: In the event of conflict with existing commands or builtins, it'd be
#great to
#FUXME: Excise this everywhere used. Since alias_cli() now integrates
#such functionality directly, we no longer require this at all.
# bool is_zeshy_wrapping_core_commands()
#
# Return true if the current user requests Zeshy wrap interactively run core
# commands (e.g., "cp", "grep", "ls") with Zeshy functions.
#is_zeshy_wrapping_core_commands() {
#    (( # == 0 )) or die 'no arguments expected'
#    [[ -n "${ZESHY_IS_WRAPPING_COMMANDS-}" ]]
#}

    # Die if the passed alias name is already a defined runnable.
#   is "$(whence -w "${alias_name}")" == *': '(alias|function) si and
#       die "\"${alias_name}\" already defined as:\n$(which "${alias_name}")"
    # Return true if the current user requests Zeshy wrap interactively run core
    # commands (e.g., "cp", "grep", "ls") with Zeshy functions.
#   [[ -n "${ZESHY_IS_WRAPPING_CORE_COMMANDS-}" ]]

    #FUXME: Hmm; disabling the function makes piped calls such as:
    #cat /proc/cpuinfo|cat
    #...fail, which is clearly undesirable.
# void alias_cli_of_core_command(string alias_specification)
#
# Declare the passed specification as an interactive alias if .
# See alias_cli() for further details.
#alias_cli_of_core_command() {
#    is_zeshy_wrapping_core_commands and
#    alias_cli ls='list_path'
#}

# As a convenience, all argument aliases except die_unless_no_args() first
# attempt to read their argument from stdin when the caller passed no explicit
# argument. This implies all functions expanding these aliases implicitly "get"
# piped input support, which is nice.

# Make a string suitable for use as the right-hand side of a "die_unless_*"-
# specific alias statement. This string parses standard input into function
# parameters if such input exists (i.e., if another function piped input to
# this function) and the caller passed insufficient parameters.

#   print --\
#       '[[ -p /dev/stdin && ${#} -eq 0 ]] && '\
#       'set -- "${@}" "$(< /dev/stdin)"'"; (( ${1} )) || die"
    # We can't quite recall why, but double quotes *MUST* be embedded in this
    # expression via "'" rather than the customary \".
#       "is -p /dev/stdin si and not (( ${1} )) and set -- "\

#       typeset command
#       if [[ -o interactive && \${#funcstack} -eq 1 ]]
#       then command=\"${(q)alias_expansion}\"
#       else command=\"${(q)alias_expansion_if_noncli}\"
#       fi
#       if :is_stdin_pipe
#       then run_code_with_stdin_piped \${command}
#       else                     \${command}
#       fi

#           if :is_stdin_pipe
#           then run_code_with_stdin_piped ${alias_expansion}
#           else ${alias_expansion}
#           fi
#       then ${alias_expansion}
#       else ${alias_expansion_if_not_interactive}
# bool is_stdout_terminal()
#
# Return true if shell :string.output is attached to a terminal device. Specifically,
# return true if the file descriptor for standard :string.output is open and attached to
# a terminal. (Avoid testing standard input, as commands passed piped input may
# still be "attached" to a terminal.) Do not implement this as a function, as a
# functions tests theirs rather than their callers' file descriptors.
#alias is_stdout_terminal='is -t ${ZESHY_STDOUT_FILE_DESCRIPTOR} si'

# bool is_terminal_color()
#
# Return true if the current shell is attached to a color-aware terminal device
# supporting at least the customary 8 colors (i.e., black, white, red, green,
# blue, yellow, magenta, and cyan).
#alias is_terminal_color='is_stdout_terminal and (( terminfo[colors] >= 8 ))'

#alias die_unless_no_args=die_if_args

# See Zeshy List and Map for functions returning lists and maps, respectively.
# Such functions are rather non-trivial and hence shifted there.

#FUXME: Reads a bit awkwardly, and superfulous. Supplant everywhere with
#"not is_args".

# void prepend_args(string arg1, string arg2, ...)
#
# Prepend the passed arguments to the beginning of the current argument list.
#alias prepend_args='set_args "${@}"'

# Define critical command-specific aliases. Zeshy Process implements similar
# functionality as functions where not implementable here as aliases.
# Define critical boolean-specific aliases. Zeshy Shell implements similar
# functionality as functions where not implementable here as aliases.

    # * If such run throws an exception:
    #   * Catch such exception.
    #   * Reenable this function for subsequent use.
    #   * Rethrow such exception.
    # * Otherwise, reenable this function for subsequent use.

# * O.K.; I've become convinced the "global" global alias is harmful. Why?
#   Because it obfuscates manipulation of files named "global" at the command
#   line. Also, it's non-orthogonal with the ":alias_global" global. (Though,
#   technically the two convey completely different options.) In the future, we
#   should clearly minimize the number of global aliases.
# * Ah; I think I've devised a mechanism for accomplishing this sanely. Simply
#   define a function proclaim() (or some other synonym of declare(), but not
#   declare() as that's already a zsh builtin) aliased as:
#   alias map='proclaim map' 
#   alias string='proclaim string' 
#   And so forth. Then define proclaim() to parse the first argument as the type
#   to be declared, the last argument as the name to be declared, and all
#   intermediate arguments as human-readable options condensed to typeset
#   options: e.g., "map_global_export const set" expands to
#   "proclaim map_global_export const set", which eventually... ah, wait. No. That
#   obviously runs up against the classical eval issue, since the executed
#   typeset runs in the local context of proclaim(). *sigh*
# * Right, then. There's no recourse but to manually define the set of all
#   possible aliases: e.g., map_global, global_const_map, etc. For sanity, just
#   define the most commonly used types.
#FUXME: The word "arguments" should probably be truncated to "args", here.
#Rewriting "arguments" every function is slightly silly (and cumbersome).

#       or die "neither \"${alias_name}\" or \"${alias_expansion_if_not_interactive}\" are builtins or commands"
#       alias_expansion_if_not_interactive="${alias_name}"

#   "${alias_expansion_if_not_interactive:c}" == /* or
#   if command_path="$(whence -cp "${command_name}")"; then
#   fi
#   
#   == *': function'
#   not whence -cp "${command_name}"; then
#   fi

    # If the builtin or command to be aliased does not exist, return with error.
    # To avoid costly exception handling on this frequently called helper
    # function, do not throw an exception.
#   if not whence "${command_name}" 1>/dev/null 2>&1; then
#       print_warning "\"${command_name}\" not a zsh builtin or command in \$PATH"
#       report_failure
#   fi

# void alias_cli_if_installed(string alias_specification)
#
# Declare the passed specification as an interactive alias only if the builtin
# or command to be aliased exists. This function is a no-nop if it does not.
#alias_cli_if_installed() {
#    FUXME: Rewrite. Only call alias_cli if the passed command is installed.
#    alias_cli "${@}" 1>/dev/null 2>&1 or true
#}

#   eval "function ${alias_name}() {
#   ${alias_expansion} "\${@}"
#}"
#}
#
#testem() {

#FUXME: No longer convinced these to be necessary. "(( VARNAME1 <= varname2 ))"
#reads much more sensibly than "is ${VARNAME1} deceeds_or_equals ${varname2} si". We
#should probably shift all instances of the latter to the former.
#:alias_global equals='-eq'
#:alias_global deceeds='-lt'
#:alias_global deceeds_or_equals='-le'
#:alias_global exceeds='-gt'
#:alias_global exceeds_or_equals='-ge'

# ....................{ DECLARATORS ~ modifiers            }....................
# Mark the declared variable as global (i.e., exported). By zsh convention,
# this and the variable type are ordered opposite to C order: e.g.,
#
#   list_global_export two_hunters; two_hunters=( "ktulu" "orion" )  # or...
#   local -Ax   two_hunters; two_hunters=( "ktulu" "orion" )  # equivalent!
#:alias_global global='-x'

# Mark the declared variable as constant (i.e., read-only). By zsh convention,
# this and the variable type are ordered opposite to C order: e.g.,
#
#   string const fwtbt="ride the lightning"  # or...
#   local -r     fwtbt="ride the lightning"  # equivalent!
#:alias_global const='-r'
