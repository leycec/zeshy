#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *alias testers* (i.e., functions testing aliases, typically for
existence).
/---

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_alias(
    string alias_name,
    string error_message = "Alias ${alias_name}() not found.")

Throw an exception with the passed message unless the passed alias exists. See
is_alias() for further details.
/---
function die_unless_alias() {
    die_unless_args_1_to_2 'Expected one alias name and optional error message.'
    :string alias_name="${1}"
    is_alias "${alias_name}" or die "${2-Alias ${alias_name}() not found.}"
}

declare_alias_with_stdin <<'/---'
void die_unless_aliases(string alias_name1, ...)

Throw an exception with a stock message unless all passed aliases exist.
/---
function die_unless_aliases() {
    # Validate sanity.
    die_unless_args 'Expected one or more alias names.'

    # If at least one such alias is undefined, manually iterate such aliases
    # until discovering the first undefined such alias and throw an exception
    # given such alias. Such theatrics are necessitated by inadequacies in
    # builtin alias(), which always succeeds if piped to another command (e.g.,
    # page_stdin()).
    is_alias "${@}" or {
        :string alias_name
        for     alias_name ("${@}") {
            die_unless_alias "${alias_name}"
        }
    }
}

# ....................{ EXCEPTIONS ~ type                  }....................
declare_function_with_stdin <<'/---'
void :die_unless_alias_simple(
    string alias_name,
    string error_message = "Simple alias ${alias_name}() not found.")

Throw an exception with the passed message unless the passed simple alias
exists. See :is_alias_simple() for further details.
/---
function :die_unless_alias_simple() {
    die_unless_args_1_to_2\
        'Expected one simple alias name and optional error message.'
    :string alias_name="${1}"
    :is_alias_simple "${alias_name}" or
        die "${2-Simple alias ${alias_name}() not found.}"
}

declare_function_with_stdin <<'/---'
void die_unless_alias_global(
    string alias_name,
    string error_message = "Global alias ${alias_name}() not found.")

Throw an exception with the passed message unless the passed global alias
exists. See is_alias_global() for further details.
/---
function die_unless_alias_global() {
    die_unless_args_1_to_2\
        'Expected one global alias name and optional error message.'
    :string alias_name="${1}"
    is_alias_global "${alias_name}" or
        die "${2-Global alias ${alias_name}() not found.}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: bool] is_alias(string alias_name1, ...)

Report success if all passed *aliases* (i.e., simple, global, or suffix
aliases) exist.
/---
function is_alias() {
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with testers below.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Validate sanity.
    die_unless_args 'Expected one or more alias names.'

    # Test such aliases. Technically, such tests are also implementable by
    # calling builtin alias(). However, doing so requires explicitly escaping
    # all alias-reserved characters in such names as well as squelching such
    # builtin's standard output, rendering the current implementation more
    # straightforward (if not necessarily more efficient): e.g.,
    #
    #    :list alias_names
    #    :set_list_to_alias_name_escaped alias_names "${@}"
    #    :string alias_name
    #    for     alias_name ("${alias_names[@]}") {
    #        alias -- "${alias_name}" or alias -s -- "${alias_name}" or
    #            report_failure
    #    } silent_stdout:
    :string alias_name
    for     alias_name ("${@}") {
        # If such alias does *NOT* exist (i.e., is neither a simple, global, or
        # suffix alias), report failure.
        (( ${+aliases[${alias_name}]} +\
           ${+dis_aliases[${alias_name}]} +\
           ${+galiases[${alias_name}]} +\
           ${+dis_galiases[${alias_name}]} +\
           ${+saliases[${alias_name}]} +\
           ${+dis_saliases[${alias_name}]} )) or
            report_failure
    }

    # Else, all such aliases exist. Report jubilation.
    report_success
}

# ....................{ TESTERS ~ nonsuffix                }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_alias_simple(string alias_name1, ...)

Report success if all passed *simple aliases* (i.e., aliases conditionally
expanded only when in command position) exist.
/---
function :is_alias_simple() {
    # See :is_alias_simple() for further details.
    die_unless_args 'Expected one or more alias names.'
    :string alias_name
    for     alias_name ("${@}") {
        (( ${+aliases[${alias_name}]} + ${+dis_aliases[${alias_name}]} )) or
            report_failure
    }
    report_success
}

declare_function_with_stdin <<'/---'
[status: bool] is_alias_global(string alias_name1, ...)

Report success if all passed *global aliases* (i.e., aliases unconditionally
expanded, regardless of their positions in surrounding commands) exist.
/---
function is_alias_global() {
    # See :is_alias_simple() for further details.
    die_unless_args 'Expected one or more alias names.'
    :string alias_name
    for     alias_name ("${@}") {
        (( ${+galiases[${alias_name}]} + ${+dis_galiases[${alias_name}]} )) or
            report_failure
    }
    report_success
}

declare_function_with_stdin <<'/---'
[status: bool] is_alias_nonsuffix(string alias_name1, ...)

Report success if all passed *non-suffix aliases* (i.e., simple or global
aliases) exist. See :is_alias_simple() and is_alias_global() for further
details.
/---
function is_alias_nonsuffix() {
    # Ideally, such test should be implementable as:
    #
    #    { alias -- "${@}" } silent_stderr:
    #
    # Unfortunately, such implementation fails for alias names containing
    # characters reserved for use in alias definition syntax (e.g., "="). In
    # particular, alias() *ALWAYS* reports success if the passed alias name
    # contains the literal substring "\=": e.g.,
    #
    #    # Note such alias to remain undefined, despite alias() succeeding.
    #    >>> alias 'utter\=fail' and output_string "This should not be."
    #    This should not be.
    #    >>> 'utter=fail'
    #    zsh: command not found: utter=fail
    #
    # The only alternative is to report success if such alias is either a
    # disabled or enabled simple or global alias, requiring four map lookups
    # during manual iteration. See :is_alias_simple() for further details.
    die_unless_args 'Expected one or more alias names.'
    :string alias_name
    for     alias_name ("${@}") {
        (( ${+aliases[${alias_name}]} +\
           ${+galiases[${alias_name}]} +\
           ${+dis_aliases[${alias_name}]} +\
           ${+dis_galiases[${alias_name}]} )) or
            report_failure
    }
    report_success
}

# --------------------( WASTELANDS                         )--------------------
