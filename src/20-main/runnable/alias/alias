#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle core alias functionality.
-/-

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_alias(
    string alias_name,
    string error_message = "Alias ${alias_name}() not found.")

Throw an exception with the passed message unless the passed alias exists. See
is_alias() for further details.
/---
function die_unless_alias() {
    die_unless_args_1_to_2 'Expected one alias name and optional error message.'
    string alias_name="${1}"
    is_alias "${alias_name}" or die "${2-Alias ${alias_name}() not found.}"
}

declare_alias_with_stdin <<'/---'
void die_unless_aliases(string alias_name1, ...)

Throw an exception with a stock message unless all passed aliases exist.
/---
function die_unless_aliases() {
    # Validate sanity.
    die_unless_args 'Expected one or more alias names.'

    # If at least one such alias is undefined, manually iterate such aliases
    # until discovering the first undefined such alias and throw an exception
    # given such alias. Such theatrics are necessitated by inadequacies in
    # builtin alias(), which always succeeds if piped to another command (e.g.,
    # page_stdin()).
    is_alias "${@}" or {
        string alias_name
        for    alias_name ("${@}") {
            die_unless_alias "${alias_name}"
        }
    }
}

# ....................{ EXCEPTIONS ~ type                  }....................
declare_function_with_stdin <<'/---'
void die_unless_alias_normal(
    string alias_name,
    string error_message = "Normal alias ${alias_name}() not found.")

Throw an exception with the passed message unless the passed alias is an
existing normal alias. See is_alias_normal() for further details.
/---
function die_unless_alias_normal() {
    die_unless_args_1_to_2 'Expected one alias name and optional error message.'
    string alias_name="${1}"
    is_alias_normal "${alias_name}" or
        die "${2:-Normal alias ${alias_name}() not found.}"
}

declare_function_with_stdin <<'/---'
void die_unless_alias_global(
    string alias_name,
    string error_message = "Global alias ${alias_name}() not found.")

Throw an exception with the passed message unless the passed alias is an
existing global alias. See is_alias_global() for further details.
/---
function die_unless_alias_global() {
    die_unless_args_1_to_2 'Expected one alias name and optional error message.'
    string alias_name="${1}"
    is_alias_global "${alias_name}" or
        die "${2:-Global alias ${alias_name}() not found.}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_alias(string alias_name1, ...)

Return success if all passed aliases exist. Specifically, each such alias must
be either an existing normal, global, or suffix alias.
/---
function is_alias() {
    # Validate sanity.
    die_unless_args 'Expected one or more alias names.'

    # Sadly, alias() explicitly requires option "-s" for testing suffix aliases
    # and no such option for testing normal and global aliases. Hence, iterate
    # such aliases and manually apply such options.
    #
    # Technically, this loop body is also implementable by testing for the
    # existence of corresponding map keys. However, six map keys would need to
    # be tested for each passed alias, rendering the current implementation
    # significantly more efficient and readable: e.g.,
    #
    #       $(( ${+aliases[${alias_name}] +\
    #           ${+dis_aliases[${alias_name}] +\
    #           ${+galiases[${alias_name}] +\
    #           ${+dis_galiases[${alias_name}] +\
    #           ${+saliases[${alias_name}] +\
    #           ${+dis_saliases[${alias_name}] ))
    string alias_name
    for    alias_name ("${@}") {
        # Since normal and global aliases are considerably more common than
        # suffix aliases, test the former first. For efficiency, inline such
        # implementation. See is_alias_nonsuffix() and is_alias_suffix() for
        # further details.
        alias -- "${alias_name}" or alias -s -- "${alias_name}" or report_failure
    # Since alias() prints the expansions of such aliases and provides no option
    # for disabling such printing, do so manually by silencing all such output.
    } 1>/dev/null

    # All such aliases exist. Return jubilation.
    report_success
}

declare_function_with_stdin <<'/---'
[status: boolean] is_alias_normal(string alias_name1, ...)

Return success if all passed aliases are existing *normal aliases* (i.e.,
aliases expanded only in command position).
/---
function is_alias_normal() {
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with is_alias_global().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Validate sanity.
    die_unless_args 'Expected one or more alias names.'

    # For each such alias, return failure unless such alias is either a
    # currently enabled or disabled normal alias.
    string alias_name
    for    alias_name ("${@}") {
        (( ${+aliases[${alias_name}]} + ${+dis_aliases[${alias_name}]} )) or
            report_failure
    }

    # All such aliases exist. Return satisfaction.
    report_success
}

declare_function_with_stdin <<'/---'
[status: boolean] is_alias_global(string alias_name1, ...)

Return success if all passed aliases are existing *global aliases* (i.e.,
aliases expanded in _all_ positions, not merely command position).
/---
function is_alias_global() {
    # See is_alias_regular() for further details.
    die_unless_args 'Expected one or more alias names.'
    string alias_name
    for    alias_name ("${@}") {
        (( ${+galiases[${alias_name}]} + ${+dis_galiases[${alias_name}]} )) or
            report_failure
    }
    report_success
}

declare_function_with_stdin <<'/---'
[status: boolean] is_alias_nonsuffix(string alias_name1, ...)

Return success if all passed aliases are existing *non-suffix aliases*
(i.e., normal or global aliases). See is_alias_normal() and is_alias_global()
for further details.
/---
function is_alias_nonsuffix() {
    die_unless_args 'Expected one or more alias names.'
    alias -- "${@}" 1>/dev/null
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_alias_expansion(string alias_name)

Get the expansion to which the passed alias expands: e.g.,

.get_alias_expansion()
==========================================
[source]
------------------------------------------
>>> alias on_idleness='output_string\
...    "Suppose that, at a given moment, a certain number of people are engaged
...     in the manufacture of pins. They make as many pins as the world needs,
...     working (say) eight hours a day. Someone makes an invention by which the
...     same number of men can make twice as many pins: pins are already so
...     cheap that hardly any more will be bought at a lower price. In a
...     sensible world, everybody concerned in the manufacturing of pins would
...     take to working four hours instead of eight, and everything else would
...     go on as before. But in the actual world this would be thought
...     demoralizing. The men still work eight hours, there are too many pins,
...     some employers go bankrupt, and half the men previously concerned in
...     making pins are thrown out of work. There is, in the end, just as much
...     leisure as on the other plan, but half the men are totally idle while
...     half are still overworked. In this way, it is insured that the
...     unavoidable leisure shall cause misery all round instead of being a
...     universal source of happiness. Can anything more insane be imagined?"'
>>> get_string_line "$(get_alias_expansion on_idleness)" -1
universal source of happiness. Can anything more insane be imagined?
------------------------------------------
==========================================
/---
function get_alias_expansion() {
    # Validate sanity.
    die_unless_arg 'Expected one alias name.'
    string alias_name="${1}"
    die_unless_alias "${alias_name}"

    #FIXME: Given the name of this function, this should transparently work for
    #suffix aliases, too. I'm fairly certain it doesn't, however. Amend!

    # Get such expansion. Happily, this is remarkably straight-forward.
    whence -- "${alias_name}"
}

declare_function_with_stdin <<'/---'
string get_alias_nonsuffix_binding(string alias_name1, ...)

Get *bindings* (i.e., declarations with definitions) for all passed aliases, in
the passed order: e.g.,

.get_alias_nonsuffix_binding()
==========================================
[source]
------------------------------------------
>>> alias_global on_hard_landings='output_string\
...    "Energy has always been the basis of cultural complexity and it always
...     will be. The past clarifies potential paths to the future. One often-
...     discussed path is cultural and economic simplicity and lower energy
...     costs. This could come about through the \"crash\" that many fear - a
...     genuine collapse over a period of one or two generations, with much
...     violence, starvation, and loss of population."'
>>> alias on_soft_landings='output_string\
...    "The alternative is the \"soft landing\" that many people hope for - a
...     voluntary change to solar energy and green fuels, energy-conserving
...     technologies and less overall consumption. This is a utopian alternative
...     that, as suggested above, will come about only if severe, prolonged
...     hardship in industrial nations makes it attractive, and if economic
...     growth and consumerism can be removed from the realm of ideology."'
>>> get_string_lines_matching_glob "$(get_alias_nonsuffix_binding\
...     on_hard_landings on_soft_landings)" ('alias'|[[:space:]]#'"')*
alias -g on_hard_landings='output_string\
   "Energy has always been the basis of cultural complexity and it always
alias on_soft_landings='output_string\
   "The alternative is the \"soft landing\" that many people hope for - a
------------------------------------------
==========================================
/---
function get_alias_nonsuffix_binding() {
    die_unless_args 'Expected one or more alias names.'
    alias -L -- "${@}"
}

# ....................{ GETTERS ~ list                     }....................
declare_function_with_stdin <<'/---'
string get_aliases(void)

List all alias names, delimited by newline.
/---
function get_aliases() {
    die_if_args
    get_aliases_nonsuffix
    get_aliases_suffix
}

declare_function_with_stdin <<'/---'
string get_aliases_nonsuffix(void)

List all *normal and global alias* names (i.e., non-suffix alias names),
delimited by newline.
/---
function get_aliases_nonsuffix() {
    die_if_args
    alias +
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void set_list_to_aliases(string list_name)

Set the passed list to all alias names.
/---
function set_list_to_aliases() {
    # Validate sanity.
    die_unless_arg 'Expected one list name.'
    string list_name__slta="${1}"
    die_unless_list "${list_name__slta}"

    # Set such list.
    set_list_to_string_lines "${list_name__slta}" "$(get_aliases)"
}

declare_function_with_stdin <<'/---'
void set_list_to_aliases_nonsuffix(string list_name)

Set the passed list to all normal and global alias (i.e., non-suffix alias)
names.
/---
function set_list_to_aliases_nonsuffix() {
    # Validate sanity.
    die_unless_arg 'Expected one list name.'
    string list_name__sltanag="${1}"
    die_unless_list "${list_name__sltanag}"

    # Set such list.
    set_list_to_string_lines "${list_name__sltanag}" "$(get_aliases_nonsuffix)"
}

# ....................{ PRINTERS                           }....................
#FIXME: This is blatantly insufficient. Suffix aliases can only be printed
#by passing option "-s". But note that there's a subtle gotcha: since
#normal, global, and suffix aliases all reside in separate namespaces, it's
#technically possible to have three distinct normal, global, and suffix
#aliases all sharing the same name. In such cases, this function *MUST*
#print all three. Ensure we handle that!
#FIXME: Syntax highlight such output, ideally via Pygments.

declare_function_with_stdin <<'/---'
string print_alias(string alias_name1, ...)

Print a human-readable synopsis of the passed aliases, typically including
syntax-highlighted declarations and definitions of such aliases.
/---
function print_alias() {
    # Validate sanity.
    die_unless_args 'Expected one or more alias names.'

    # Print such aliases.
    string alias_name
    for    alias_name ("${@}") {
        # Since alias() always succeeds if piped to another command (a probable
        # bug in core zsh), ensure the existence of such alias beforehand.
        die_unless_alias "${alias_name}"

        # Print such alias.
        print_message_heading "Alias ${alias_name}()"
        alias -- "${alias_name}"
    } | page_stdin
}

#FIXME: In lieu of unit tests...
#function pali() {
#    print_alias is_context_cli_function
#}

# ....................{ DEFINERS                           }....................
declare_function_with_stdin <<'/---'
void undefine_alias(string alias_name1, ...)

Undefine the passed aliases.
/---
function undefine_alias() {
    # Validate sanity.
    die_unless_args 'Expected one or more alias names.'

    # Sadly, unhash() and hence unalias() explicitly require option "-s" for
    # removing suffix aliases and no such option for removing normal and global
    # aliases. Hence, iterate such aliases and manually apply such options.
    # For efficiency, avoid calling Zeshy functions.
    string alias_name
    for    alias_name ("${@}") {
        # If such alias is a non-suffix alias, undefine such alias as such. See
        # is_alias_nonsuffix() for further details.
        if { alias  -- "${alias_name}" &>/dev/null } {
            unalias -- "${alias_name}"
        # Else, such alias is a non-suffix alias. Undefine such alias as such.
        } else {
            unalias -s -- "${alias_name}"
        }
    }
}

declare_function_with_stdin <<'/---'
void undefine_alias_nonsuffix(string alias_name1, ...)

Undefine the passed normal or global aliases (i.e., non-suffix aliases).
/---
function undefine_alias_nonsuffix() {
    die_unless_args 'Expected one or more alias names.'
    unalias -- "${@}"
}

# --------------------( WASTELANDS                         )--------------------
    # Validate sanity. Since alias() always succeeds if piped to another
    # command (a probable bug in the zsh core), ensure the existence of all such
    # aliases beforehand.
#   die_unless_args 'Expected one or more alias names.'
#   die_unless_aliases "${@}"

#   string output; output="$(alias -- "${@}")"
#   output_string "${output}" # | page_stdin
#FUXME: Truncate "nonsuffix" to simply "nonsuffix" everywhere.

#       is_alias_nonsuffix "${alias_name}" or
#       is_alias_suffix "${alias_name}" or
#           report_failure
    #FUXME: Replace with a call to a new is_map_keys() function, which can be
    #efficiently implemented by embedding the entire loop in an "eval".
    # Test such aliases.
#   for alias_name ("${@}") {
#       (( ${+aliases[${alias_name}]} )) or report_failure
#   }
#   report_success
    #FUXME: Generalize to accept multiple alias names. To do so, we'll want to
    #implement a new function is_map_keys() returning success only if all passed
    #keys exist in the passed map. This should be considerably faster than
    #performing an explicit loop. Such function may be implemented by noting
    #that "(( ${map[(i)(${(q)1}|...|${(q)@[-1]})]} <= ${#map} ))"
    #implements such test. I'm not quite sure about the "(q)"; however, we'll
    #certainly need some form of escaping. Right. "(q)" should do it, I think.
    #For efficiency, we certainly wouldn't want to call escape_string()
    #repeatedly. Unsure how to efficiently construct the list of keys, however.
    #Shouldn't be terribly hard; just contemplate it.
