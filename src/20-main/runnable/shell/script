#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *shell scripts* (i.e., executable text files implemented in shell
scripting languages and hence interpretable by shells interpreting such
languages).
/---

#FIXME: Refactor getters into setters.
#FIXME: Do sourcer functions defined below also suffer from the same issue as
#in @{compile} (namely, that TRAPZERR() fails to trigger on the scripts such
#functions source reporting failure)?

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
string :die_unless_script(
    string pathname,
    string error_message = "\"${pathname}\" not a recognized shell script.")

Throw an exception with the passed message unless the passed path is an
existing shell script. See :is_script() for further details.
/---
function :die_unless_script() {
    die_unless_args_1_to_2\
        'Expected one pathname and optional error message.'
    :is_script "${1}" or {
        :string pathname="${1}"
        :die "${2-Path \"${pathname}\" not a recognized shell script.}"
    }
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_script(string pathname)

Report success if the passed path is an existing *shell script* (i.e.,
executable text file implemented in a shell scripting language and hence
interpretable by all shells interpreting such language). Specifically, report
success if such path is:

* A plaintext file. See is_file_text() for further details.
* Self-identified as interpretable by a shell (e.g., due to the first line of
  such file being a `#!`-prefixed shebang line running a recognized shell). See
  :set_string_to_script_shell_if_found() for further details.
/---
function :is_script() {
    # Validate sanity.
    die_unless_arg 'Expected one pathname.'
    :string pathname="${1}"

    # If such path corresponds to a text file identified as a shell script,
    # report success. Since such identification throws exceptions if such path
    # is not a text file, ensure the former before calling the latter.
    is_file_text "${pathname}" and {
        :string shell_name
        :set_string_to_script_shell_if_found shell_name "${pathname}"
    }
}

# ....................{ GETTERS                            }....................
#FIXME: *WAY* too many subshells. Refactor into a setter!

declare_function_with_stdin <<'/---'
[stdout: string, status: bool] get_shell_script_shell(string script_name)

Get the basename of the shell interpreting the passed shell script if either the
file contents or filename of such script declare such shell or throw an
exception. See get_shell_script_shell_if_found() for further details.
/---
function get_shell_script_shell() {
    # Validate sanity.
    die_unless_args 'Expected one script filename.'
    :string filename="${1}" shell_name
    die_unless_file_text "${filename}"

    # If such script contains a shebang line matching an emulatable shell,
    # assume such shell.
    # Else, throw an exception.
    if { shell_name="$(get_shell_script_shell_if_found "${filename}")" } {
        return_string "${shell_name}"
    } else {
        die "Script \"${filename}\" shell unrecognized (i.e., unrecognized shebang or filetype)."
    }
}

declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] get_shell_script_shell_if_found(
    string script_name)

Get the basename of the shell interpreting the passed shell script if either the
file contents or filename of such script declare such shell or return failure.
Typically, the first line of such script is a `#!`-prefixed shebang line
declaring such shell.
/---
function get_shell_script_shell_if_found() {
    # Validate sanity.
    die_unless_args 'Expected one script filename.'
    :string filename="${1}" basename shell_name
    die_unless_file_text "${filename}"

    # If such script contains a shebang line, such line declares such shell.
    if { shell_name="$(get_shell_script_shebang_command_name_if_found\
        "${filename}")" } {
        return_string "${shell_name}"
    # Else, attempt to match such shell from such script's basename (i.e.,
    # either such basename's filetype *OR* substring preceding "rc" matching a
    # known shell). For convenience, leverage duplicate subpattern indices
    # (i.e., "(?|" group syntax) by matching with a PCRE rather than glob.
    } else {
        # Script basename.
        :string basename
        :set_string_to_path_basename basename "${filename}"
.

        # If such basename matches a shell, set such string to such shell.
        if { is_string_matches_pcre\
            "${basename}"\
            '(?|\.('${ZESHY_SHELL_EMULATABLE_INDIRECTLY_GLOB}')|^\.?('${ZESHY_SHELL_EMULATABLE_INDIRECTLY_GLOB}')rc)$' } {
            return_string "${match[1]}"
        }
    }

    # Else, fail.
    report_failure
}

#FIXME: Rename to get_shell_script_defining_function_autoload(). (The current
#title simply isn't specific enough: it's not just the script defining that
#function, it's the script defining that function's *AUTOLOAD* implementation.)
#FIXME: Actually, this is silly. Given :autoload_zsh_function(), zsh functions
#*SHOULD* now be autoloadable and callable as is without such theatrics.

declare_function_with_stdin <<'/---'
string get_shell_script_defining_function(string function_name)

Get the absolute path of the shell script defining the passed function if some
script with basename such function name resides in some directory listed by
list global ${FPATH} or throw an exception. If multiple scripts match such
function name, arbiratrily get the absolute path of the first such script
listed by ${FPATH}: e.g.,

.get_shell_script_defining_function()
==========================================
[source]
------------------------------------------
>>> get_shell_script_defining_function zsh-mime-handler
/usr/share/zsh/4.3.11/functions/MIME/zsh-mime-handler
------------------------------------------
==========================================
/---
function get_shell_script_defining_function() {
    # Validate sanity.
    die_unless_arg 'expected one function name'
    :string function_name="${1}"

    # Dismantled, this is:
    #
    # * "^", iteratively expanding to each directory listed by ${fpath}.
    # * "(N)", excluding non-extant filenames.
    :list shell_scripts; shell_scripts=( ${^fpath}"/${function_name}"(.N) )

    # If no shell script defines such function, throw an exception; otherwise,
    # print the absolute path of the first such script.
#   print_message "filename_matches: \"${filename_matches[@]}\""
    die_unless_list_nonempty shell_scripts\
        "zsh script defining ${function_name}() not found."
    return_string "${shell_scripts[1]}"
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void :set_string_to_script_shell(
    string string_name, string filename)

Set the passed string variable to the basename of the shell interpreting the
passed shell script if either the file contents or filename of such script
identify such shell or throw an exception otherwise. See
:set_string_to_script_shell_if_found() for further details.
/---
function :set_string_to_script_shell() {
    :set_string_to_script_shell_if_found "${@}" or :die_unless_script "${2}"
}

declare_function_with_stdin <<'/---'
[status: bool] :set_string_to_script_shell_if_found(
    string string_name, string filename)

Set the passed string variable to the basename of the shell interpreting the
passed shell script if either the file contents or filename of such script
identify such shell or report failure otherwise. Typically, the first line of
such script is a `#!`-prefixed shebang line declaring such shell (e.g.,
`#!/usr/bin/env bash`).
/---
function :set_string_to_script_shell_if_found() {
    # Validate sanity.
    die_unless_args_2 'Expected one string name and one script filename.'
    :string\
        string_name__sstsssif="${1}"\
        filename__sstsssif="${2}"\
        shell_name__sstsssif
    die_unless_file_text "${filename__sstsssif}"

    #FIXME: Ugh. Subshells.
    #FIXME: Documentation's a bit out-of-order, now.

    # If:
    #
    # * Such script is prefixed by a shebang line invoking a recognized
    #   shell, parse such shell from such line.
    # * Such script's filetype matches a recognized shell, set such shell to
    #   such filetype.
    #
    # Technically, if both tests fail, there are additional shell-specific
    # fallback tests we could perform. Since such tests are shell-specific,
    # however, their utility remains in question. Such tests include:
    #
    # * If such filename matches that of a system-wide shell dotfile (e.g.,
    #   "/etc/bash/bash_logout", "/etc/zsh/zprofile"), such filename identifies
    #   such shell.
    # * If such filename matches that of a user-specific shell dotfile (e.g.,
    #   "~/.bash_profile", "~/.zlogin"), such filename probably identifies such
    #   shell. While system-wide shell dotfiles are (typically) compile-time
    #   constants and hence uniquely identify such shell, user-specific shell
    #   dotfiles may have arbitrary pathnames (e.g., via ${ZDOTDIR})  and
    #   hence do _not_ reliably identify such shell.
    #
    # For reliability, avoid such subtle entanglements. "Cthulhu code beckons!"
    {
        shell_name__sstsssif="$(get_shell_script_shebang_command_name_if_found\
            "${filename__sstsssif}")" or
        :set_string_to_file_type_if_found\
            shell_name__sstsssif "${filename__sstsssif}"
    # If such shell was recognized, set such string to such shell.
    } and
    :is_string_matches_glob\
        "${shell_name__sstsssif}" "${ZESHY_SHELL_GLOB}" and
    :string.set\
        "${string_name__sstsssif}" "${shell_name__sstsssif}"
}

# ....................{ SOURCERS                           }....................
declare_function_with_stdin <<'/---'
[stdout: string, stderr: string, status: int] :source_script_defining_function(
    string function_name,
    string filename,
    string arg1?, ...)

Source the shell script defining the passed function with the passed
arguments, reading and executing all commands in such script under the current
shell. See:

* get_shell_script_defining_function() for discussion on finding such script.
* :source_script() for discussion on sourcing such script.
/---
function :source_script_defining_function() {
    # Validate sanity.
    die_unless_args\
        'Expected one function name, one script filename, and optional script arguments.'
    :string function_name="${1}" filename
    shift_arg

    # Source such script.
    filename="$(get_shell_script_defining_function "${function_name}")"
    :source_script "${filename}" "${@}"
}

declare_function_with_stdin <<'/---'
[stdout: string, stderr: string, status: int] :source_script(
    string script_name,
    string arg1?, ...)

Source the passed shell script with the passed arguments, interpreting all
commands in such script under the current shell.

== Shell Emulation ==

If such script:

* Has a filetype matching an emulatable shell, emulate such shell.
* Contains a shebang line matching an emulatable shell, emulate such shell.
* Contains no shebang line but transitively resides under a directory with
  basename matching an emulatable shell (e.g., `zsh` in the case of
  `/usr/share/zsh/5.0.0/functions/TCP/tcp_log`), emulate such shell.
* Otherwise, throw an exception.

For these purposes, an *emulatable shell* is any shell whose name is a key of
map global ${ZESHY_SHELL_NAME_TO_EMULATABLE_NAME} (e.g., since
`${ZESHY_SHELL_NAME_TO_EMULATABLE_NAME[tcsh]}` exists, `tcsh` is an emulatable
shell).

If such script requires a non-emulatable shell (e.g., with a shebang line
resembling `#!/usr/bin/env fish` or `#!/bin/es`), throw an exception. Such
scripts cannot be reliably emulated under `zsh` and hence cannot be sourced
under the current shell. Consider explicitly running such scripts under the
appropriate shell (e.g., `fish odd_fellows_rest.fish`).

If such script requires an emulatable non-`zeshy` shell (e.g., with a shebang
line resembling `#!/usr/bin/env zsh` or `#!/bin/bash`), source such script
``safely'' by emulating the default environment consisting of builtins, options,
and traps specific to such shell. In particular, revert to customary shell
execution of commands by not throwing exceptions on non-zero exit status.

If such script requires `zeshy` (e.g., with a shebang line resembling
`#!/usr/bin/env zeshy`), source such script as is without emulation.

See :source_script_under_shell() for further details.
/---
function :source_script() {
    # Validate sanity.
    die_unless_args\
        'Expected one script filename and optional script arguments.'
    :string filename="${1}" shell_name
    shift_arg

    # Shell interpreting such script.
    :set_string_to_script_shell shell_name "${filename}"

    # If such shell is *NOT* emulatable by zsh, throw an exception.
    :die_unless_shell_emulatable "${shell_name}"

    # Source such script emulated under such shell.
    :source_script_under_shell "${filename}" "${@}" "${shell_name}"
}

declare_function_with_stdin <<'/---'
[stdout: string, stderr: string, status: int] :source_script_under_shell(
    string script_name,
    string arg1?, ...,
    string shell_command)

Source the passed shell script with the sanity emulated under the
passed shell, interpreting all commands in such script under the current shell.
Since `zsh` emulates only some (but not all) shell commands, this function maps
the passed shell command to a `zsh`-emulated shell command according to global
map ${ZESHY_SHELL_NAME_TO_EMULATABLE_NAME}.

== Caveats ==

Unfortunately, `zsh` currently emulates `bash` as `sh` (i.e., Bourne shell).
Since this is rarely desirable, `zeshy` improves such emulation by enabling
`bash`-specific shell options (e.g., `ksh_glob`, `no_sh_glob`). While imperfect,
this is probably the best we can currently do. Consider explicitly running
`bash` scripts under `bash` (e.g., `bash sonic_excess_in_its_purest_form.bash`).
/---
function :source_script_under_shell() {
    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected one script filename, optional script arguments, and one shell name.'
    :string filename="${1}" shell_name="${@[-1]}"
    die_unless_file_text "${filename}"
    pop_arg

    # Source such script under such shell, quote-protecting such script and
    # script arguments for safety against the brute ravages of run().
    run_code_under_shell 'source --' "${(q)@}" "${shell_name}"
}

# ....................{ RUNNERS                            }....................
declare_function_with_stdin <<'/---'
[stdout: string, stderr: string, status: int] run_code_under_zsh_defaults(
    string code1, ...)

Run the passed code emulated under default `zsh` options and traps, as typically
required by autoloadable `zsh` functions bundled with `zsh`: e.g.,

.run_code_under_zsh_defaults()
==========================================
[source]
------------------------------------------
>>> run_code_under_zsh_defaults zsh-mime-setup
------------------------------------------
==========================================
/---
function run_code_under_zsh_defaults() {
    die_unless_args 'Expected one or more shell words.'
    run_code_under_shell "${@}" zsh
}

declare_function_with_stdin <<'/---'
[stdout: string, stderr: string, status: int] run_code_under_shell(
    string code1, ...,
    string shell_name)

Run the passed code emulated under the passed shell.
/---
function run_code_under_shell() {
    # Validate sanity.
    die_unless_args 'Expected one or more shell words and one shell name.'
    :string shell_name="${@[-1]}" shell_name_emulatable
    :die_unless_shell_emulatable "${shell_name}"
    pop_arg
#   :string.output "running \"${@}\" under shell \"${shell_name}\""

    # If such shell is emulatable by zsh, map such shell to the closest zsh-
    # emulatable shell. Since such assignment overwrites the prior result of
    # ${shell_name} *EVEN* if such test fails, avoid assigning the result to
    # ${shell_name}. (Yes, this is unhelpful, zsh.) Else, throw an exception.
    :set_string_to_map_key_value\
        shell_name_emulatable\
        ZESHY_SHELL_NAME_TO_EMULATABLE_NAME\
        "${shell_name}"

    # Source such script under such emulation. Dismantled, this is:
    #
    # * "-L", localizing the redefinition of TRAPZERR() to this block.
    # * "-R", resetting shell options to the default expected by such shell.
    #
    # Do not redefine TRAPINT(); printing stack traces on user interrupts
    # is universally useful and not conflicting with script expectations.
    case "${shell_name}" {
    # If such shell is directly emulatable by zsh, do so.
    (${~ZESHY_SHELL_EMULATABLE_DIRECTLY_GLOB})
        emulate -LR "${shell_name}"
        :break_case
    # If such shell is bash, attempt Bourne shell emulation with bash-specific
    # options. Such emulation is admittedly... imperfect.
    (bash)
        #FIXME: The bash_source() function defined at a Googleable URL defines
        #additional aliases (e.g., "alias shopt=':'"). Unfortunately, zeshy
        #currently has no means of temporarily defining aliases and then
        #restoring the prior definition if already defined. We'll need some
        #such mechanism prior to defining such aliases, clearly. (At least, I
        #don't think it does. Hmm; but function definitions are clearly
        #localized, as below. Surely alias definitions are as well, yes?)
        emulate -LR sh
        :enable_option_local\
            bash_rematch\
            brace_expand\
            ksh_array\
            ksh_glob\
            no_sh_glob\
        :break_case
    # Else, this function failed to properly map such script's required shell to
    # a zsh-supported shell; throw an exception.
    (*)
        :die 'Shell "'${shell_name}'" not mapped to an emulatable shell.'
        :break_case
    }

    # Temporarily cease throwing exceptions on non-zero exit status.
    TRAPZERR() { return $(( 128 + ${1} )) }

    # Run such command under such emulation. Note that the above emulation of
    # traditional TRAPZERR() behaviour persists while running such command,
    # which is helpful, *AND* processing the exit status such command returns,
    # which is unhelpful. In the latter case, non-zero exit status fails to
    # signal ZERR. Manually test such status and, if non-zero, throw the
    # expected exception.
    #
    # Avoid calling run_code(), as:
    #
    # * run_code() performs operations assuming zeshy-specific shell options
    #   (e.g., "extended_glob" for testing command names).
    # * run_code() is largely useful only for running zeshy-specific runnables.
    #   Since an emulated runnable is, by definition, not such a runnable,
    #   run_code() offers little benefit.
    eval "${@}" or :die\
        "${shell_name} code failed with exit status ${status}:${ZESHY_ASCII_NEWLINE}${@}"
}

# --------------------( WASTELANDS                         )--------------------
        # Else, attempt to parse such shell from such script's basename (i.e.,
        # either such basename's filetype *OR* substring preceding "rc"
        # matching a recognized shell). For convenience, leverage duplicate
        # subpattern indices (i.e., "(?|" group syntax) by matching via a PCRE
        # rather than glob.
        # {
        #     # Script basename.
        #     :string basename__sstsssif
        #     :set_string_to_path_basename\
        #         basename__sstsssif "${filename__sstsssif}"

        #     #FUXME: Honestly, the latter half of this PCRE is rather "naff."
        #     #While it certainly works in the laziest sense of that word for
        #     #bash and zsh, it demonstrably fails as follows:
        #     #
        #     #* It fails to match other well-known bash and zsh dotfiles (e.g.,
        #     #  "zshenv", "bash_logout").
        #     #* It fails to match system-wide bash and zsh dotfiles (e.g.,
        #     #  "/etc/zshrc").
        #     #* It fails to match dotfiles for other shells.
        #     #
        #     #Honestly, such code is sufficiently difficult to implement that we
        #     #should probably drop it entirely -- and note why.
        #     #FUXME: This then reduces such test to a filetype test (e.g.,
        #     #is_file_type_matches_glob()).

        #     # If such basename matches a recognized shell, record such fact.
        #     is_string_matches_pcre\
        #         "${basename__sstsssif}"\
        #         '(?|\.('${ZESHY_SHELL_GLOB}')|^\.?('${ZESHY_SHELL_GLOB}')rc)$' and
        #         shell_name__sstsssif="${match[1]}"

    #     :string filename="${2}"
    #     die 'Script "'${filename}'" shell unrecognized or not a shell script (i.e., unrecognized shebang line or filetype).'
    # }

 # or
 #    :die\
 #        'Shell "'${shell_name}'" not emulatable (i.e., not a key of ${ZESHY_SHELL_NAME_TO_EMULATABLE_NAME}).'
 
 # Since get_shell_script_shell() already
    # validates such file to be a sourcable shell script, avoid duplicating such
    # validation here.
#*emulatable shell* (i.e., shell emulatable by `zsh`)
#FUXME: Pretty shoddy implementation, honestly. Shell scripts lacking
#shebang lines may still be shell scripts. Now that we have get_shell_script_shell_if_found(), we should
#simply reduce to:
#
#   is_file_text "${pathname}" and
#       run_code_silent get_shell_script_shell_if_found "${pathname}"
#
#Remarkably close to the current implementation, but much more general.

# text file with first line prefixed by `#!`).
    # Else, fail.
    # report_failure

# (e.g., Bourne, `bash`, `zsh`, `zeshy`)
        # Note that if such basename is suffixed by a filetype *NOT* matching a
        # known shell, such filetype is ignorable.

# , ensuring ${match[1]} to
    # capture such shell
    # This should never happen. Force a smile if it does.
    # die "Thank you, user! But our princess is in another castle."

#FUXME: Actually, isn't this redundant? I mean, can't we simply lookup keys in
#${ZESHY_SHELL_NAME_TO_EMULATABLE_NAME} instead?
#I suspect the external command
#"file" will output much more useful output for such scripts; hence,
#consider deferring to "file" if the passed path is a text file lacking a
#shebang line. Test us up!
#FUXME: Right. 
    # Avoid calling :die_unless_script(), whose
    # implementation duplicates our parsing of the script shebang line here.
#   print_message "filename: ${filename}\nfiletype: ${filetype}"
    #FUXME: Shift into a new function get_shell_script_shell().
    # Identify the shell to be emulated. If such script's filetype matches an
    # emulatable shell, assume such shell.
    #filetype shell_name shebang_command_name
#   die_unless_file_text "${filename}"
#   if { filetype="$(get_file_type_if_matches_glob\
#       "${filename}" "${ZESHY_SHELL_EMULATABLE_INDIRECTLY_GLOB}")" } {
#       shell_name="${filetype}"
    # If such script contains a shebang line matching an emulatable shell,
    # assume such shell.
#   } elif { shebang_command_name="$(get_shell_script_shebang_command_name_if_found\
#       "${filename}")" } {
#       shell_name="$(get_string_text_matching_glob_group_if_found\
#           "${shebang_command_name}" "*(${ZESHY_SHELL_EMULATABLE_INDIRECTLY_GLOB})*")" or
#           die "shell \"${shebang_command_name}\" required by \"${filename}\" not emulatable"
    # If such script transitively resides in a directory with basename matching
    # an emulatable shell, assume such shell.
#   } elif { shell_name="$(get_string_text_matching_glob_group_if_found\
#       "${filename}" "*/(${ZESHY_SHELL_EMULATABLE_INDIRECTLY_GLOB})/*")" } {
#       noop
    # Else, throw an exception.
#   } else {
#       die "\"${filename}\" contains no shebang line"
#   }

        # Canonicalize such filename into an absolute path prior to matching
        # against such path.
#       filename="$(:canonicalize_path "${filename}")"

        # Get such filename's basename.
#       basename="$(get_path_basename "${filename}")"

        #FUXME: Technically, the methods below should match *ANY* shell name --
        #not merely those indirectly emulatable by "zsh". Since the latter
        #encompasses most shells, however, this is probably not a pressing
        #issue.
        #FUXME: The following three conditionals could be compressed into a
        #single test. For both efficiency and simplicity, such test *MUST* be
        #PCRE- rather than glob-based. Leveraging the "DUPLICATE SUBPATTERN
        #NUMBERS" functionality of libpcre, we can construct a PCRE resembling:
        #
        #    string shell_glob="${ZESHY_SHELL_EMULATABLE_INDIRECTLY_GLOB}"
        #    is "${filename}" =~\
        #       '(?|/[^/]*\.('${shell_glob}')$|/\.?('${shell_glob}')(rc)?$|/('${shell_glob}')/)' si
        #
        #Awesome! If this matches, it guaranteeably places the shell name in
        #"${match[1]}". I can't think of any reason *NOT* to adopt this
        #technique, so... just do it. ;o

        # If such script's filetype matches a shell (e.g., "hedonism_bot.zsh"),
        # assume such filetype to define such shell. If such script's filename
        # is suffixed by a filetype *NOT* matching a shell, such filetype does
        # *NOT* declare a shell and hence must be ignored.
#       if { shell_name="$(get_file_type_if_matches_glob\
#           "${basename}" ${~ZESHY_SHELL_EMULATABLE_INDIRECTLY_GLOB})" } {
#           return_string "${shell_name}"
        # If such script transitively resides in a directory with dirname
        # matching a shell (e.g., "/etc/zsh/zlogin"), assume such dirname to
        # define such shell.
#       } elif { shell_name="$(\
#           get_string_text_matching_glob_group_if_found "${filename}"\
#           *'/'(${~ZESHY_SHELL_EMULATABLE_INDIRECTLY_GLOB})'/'* 1)" } {
#           return_string "${shell_name}"
        # If such script's basename matches a shell (e.g., ".zshrc"), assume
        # the matching substring to define such shell.
#       } elif { shell_name="$(\
#           get_string_text_matching_glob_group_if_found "${basename}"\
#           ('.'|)${~ZESHY_SHELL_EMULATABLE_INDIRECTLY_GLOB}('rc'|) 1)" } {
#           return_string "${shell_name}"

    #"('.'|)${~ZESHY_SHELL_EMULATABLE_INDIRECTLY_GLOB}('rc'|)"
    #FUXME: Rename get_string_text_matching_glob_group_if_found() to
    #get_string_text_matching_glob_group_if_matches().
    #FUXME: Also support the following last-ditch matching method: if the
    #basename of such filename matches
    #"('.'|)${~ZESHY_SHELL_EMULATABLE_INDIRECTLY_GLOB}('rc'|)"
    #FUXME: The final last-ditch matching method should be "file". I'd wager
    #(almost) anything that calling "file" on an otherwise unidentifiable snippet
    #of shell script identifies it at least a shell script. Test! Unsure how to
    #reliably parse the shell name from "file" output, but... it's a start?

    # Get such shell.
#   return_string "${shell_name}"
    #FUXME: This is only helpful if such path is canonicalized. Since such file
    #is guaranteed to exist, such canonicalization is always feasible -- just do
    #it above -- probably after die_unless_file_text().

    # Identify the shell to be emulated. If such script's filetype matches an
    # emulatable shell, assume such shell.
#   if { filetype="$(get_file_type_if_matches_glob\
#       "${filename}" "${ZESHY_SHELL_EMULATABLE_INDIRECTLY_GLOB}")" } {
#       shell_name="${filetype}"
    # If such script contains a shebang line matching an emulatable shell,
    # assume such shell.
#   } elif { shebang_command_name="$(get_shell_script_shebang_command_name_if_found\
#       "${filename}")" } {
#       shell_name="$(get_string_text_matching_glob_group_if_found\
#           "${shebang_command_name}" "*(${ZESHY_SHELL_EMULATABLE_INDIRECTLY_GLOB})*")" or
#           die "shell \"${shebang_command_name}\" required by \"${filename}\" not emulatable"
    # If such script transitively resides in a directory with basename matching
    # an emulatable shell, assume such shell.
#   } elif { shell_name="$(get_string_text_matching_glob_group_if_found\
#       "${filename}" "*/(${ZESHY_SHELL_EMULATABLE_INDIRECTLY_GLOB})/*")" } {
#       noop
    # Else, throw an exception.
#   } else {
#       die "\"${filename}\" contains no shebang line"
#   }

# (i.e., a text file with first line is a "#!"-prefixed shebang line).
#Since this function is
    # transitively called before the remainder of the Zeshy codebase, avoid
    # calling conventional Zeshy functions (e.g., get_string_text_matching_glob_group_if_found()).
#FUXME: This function's just silly. Excise!
#declare_function '
#string get_shell_script_shebang_command_if_found(string filename)
#
#Get the first line excluding prefixing "#!" of the passed shell script if such
#line is prefixed with "#!" or return false otherwise: e.g.,
#
#    >>> get_shell_script_shebang_command_if_found "/etc/zsh/zshrc"
#    /usr/bin/env zsh
#'
#function get_shell_script_shebang_command_if_found() {
#    # Validate sanity.
#    die_unless_arg 'expected one filename'

#   # Validate sanity. Avoid calling :die_unless_script(), which
#   # transitively calls this function.
#   string filename="${1}" shebang_command
#   die_unless_file_text "${filename}"

#   #FUXME: Defer to 
#   # Get such command or fail trying.
#   if run_code_with_mapfile: "shebang_command=\"\$(get_string_text_matching_glob_group_if_found\
#       \"\${mapfile[\${filename}]}\"\
#       '(#s)\#!([^${ZESHY_ASCII_NEWLINE}]#)*')\""
#   then print_string "${shebang_command}"
#   else report_failure
#   fi
#}

    #FUXME: Shift run_code_with_mapfile:() and hence the whole component "module"
    #here, sadly. That said, one does really want to be able to load and unload
    #zsh modules from top-level functions, so... good change, anyway.
    #FUXME: Ugh. Wait. We don't really want to move get_string_text_matching_glob_group_if_found()
    #here, do we? Reconsider.
    #FUXME: Uhm. This implementation is wrong. Shebang lines *MUST* be the first
    #lines in such files.

#   if run_code_with_mapfile: "shebang_line=\"\$(get_string_text_matching_glob_group_if_found\
#       \"\${mapfile[\${filename}]}\"\
#       '(#s)(\#![^${ZESHY_ASCII_NEWLINE}]#)*')\""
#       is \"\${\${(f)mapfile[\${filename}]}[1]}\" ==\
#   then print_string "${shebang_line}"
#FUXME: This has utterly nothing to do with this component, but either
#"-o EMACS" or "-o VI" should be enabled depending on ${EDITOR}. Make it so! So?

#FUXME: Undefined here. *shrug* Perhaps extract into an alias in "alias"?
#freeze_variable ZESHY_SHELL_NAME_TO_EMULATABLE_NAME

# ....................{ STARTUP                            }....................
# Initialize shell script-specific constants early to permit subsequent Zeshy
# startup commands to source shell scripts "safely."
#run_hook_on_zeshy_startup startup_zeshy_shell_script_constants

# void startup_zeshy_shell_script_constants()
#
# Initialize shell script-specific constants.
#function startup_zeshy_shell_script_constants() {
    #FUXME: Interestingly, there appears to be no convenient means of defining a
    #constant map or list; of course, one can simply call freeze_variable() after
    #defining such variable, but that seems inordinantly complex. Any ideas?
    #Something like this could probably work, but it's fugly as heck.
    #   alias define_variable='output'
    #   define_variable TEST | as_map_global_constant ( hello "'ello?" )
    #Ah! Right. I believe we *CAN* (somewhat) do this by adding a new
    #freeze_list_to_evaluation() to accept... ah; no. We'd have to eval the
    #passed args, which renders the original arguments unreadable. Nope; no way,
    #really. Just call freeze_variable.

    # Declare such constants.
#       ZESHY_SHELL_EMULATABLE_DIRECTLY_GLOB\
#       ZESHY_SHELL_EMULATABLE_INDIRECTLY_GLOB

#FUXME: This needs to happen before MIME-specific startup. Hmm; either we need a
#new function with name resembling:
#   run_hook_on_zeshy_startup_first()
#   run_hook_on_zeshy_startup_before_other_commands()
#   run_hook_on_zeshy_startup_first()

#       source --  /usr/share/zsh/5.0.0/functions/MIME/zsh-mime-setup -f
#       "${(z)@}"
#       run "${@}"
#   string exit_status="${?}"
#   integer exit_status=${?}
#       print 'okok'
    # The above emulation of traditional TRAPZERR() behavior persists both while
    # running commands in such script, which is wise, *AND* processing the exit
    # status of such script, which is unwise. In the latter case, non-zero exit
    # status fails to signal ZERR. Manually test such status and, if non-zero,
    # throw the expected exception.
#   (( exit_status == ZESHY_STATUS_SUCCESS )) or
#       die "\"${@}\" failed with exit status ${exit_status}"
#   if filetype="$(get_file_type_if_found "${filename}")" and
#      :is_string_matches_glob "${filetype}" "${ZESHY_SHELL_EMULATABLE_INDIRECTLY_GLOB}"
#           print_warning "sourcing bash script \"${filename}\" as a Bourne script"
#           print_warning "emulating bash as a Bourne script"
# To avoid conflict with ImageMagick's "import" command, we prefer "require".
#FUXME: Replace with references to run_code_under_shell(); then excise.
# string :source_script_command_output(
#   string shell_name,
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Emulate the passed command under the passed shell (e.g., "sh", "csh") and, if
# successful, source the command's standard output.
#function :source_script_command_output() {
    # Validate sanity.
#    die_unless_args_2_or_more\
#        'expected at least one shell name and one command name'
#    string shell_name="${1}"
#    shift_arg

    #FUXME: Refer to the previously defined glob.
#    is "${shell_name}" == (zsh|sh|ksh|csh) si or
#        die "\"${shell_name}\" not an emulatable shell"
#   string command_name="${1}"
#   die_unless_pathable "${command_name}"

    # Source safely.
#    emulate -R "${shell_name}" -c "eval \$(${@})"
#}

# Avoid calling :die_unless_script(), whose
    # implementation duplicates our parsing of the script shebang line here.#       PATH="${PATH}:${FPATH}" source -- "${@}"
#   * A supported non-Zeshy shell (e.g., "#!/usr/bin/env zsh", "#!/bin/bash"),
#     source such script "safely" by emulating the shell environment expected by
#     such script with default shell options and traps. In particular, revert to
#     traditional shell execution of commands by not throwing exceptions on
#     commands returning non-zero exit status.
#   * An unsupported non-Zeshy shell (e.g., "#!/usr/bin/env fish", "#!/bin/es"),
#     throw an exception. Such scripts cannot currently be reliably emulated
#     under zsh and hence cannot be sourced under the current shell. Consider
#     explicitly running such scripts under the desired shell (e.g.,
#     "fish odd_fellows_rest.fish").
#   * Zeshy (e.g., "#!/usr/bin/env zeshy"), source such script as is (i.e.,
#     under the current shell environment, with no such emulation).
    #FUXME: Actually, can't we just shift the "zsh"-specific conditional below
    #into the prior function and then just call that?
    # Identify the shell to be emulated. Such script's basename is a function
    # name and hence cannot be suffixed by a filetype, so the only available
    # identifier is a shebang line if found. Attempt to find such line.
#   if shebang_command_name="$(get_shell_script_shebang_command_if_found\
#       "${filename}")"
#   then shell_name="$(get_string_text_matching_glob_group_if_found\
#       "${shebang_command_name}" "${ZESHY_SHELL_EMULATABLE_INDIRECTLY_GLOB}")" or
#       die "script \"${filename}\" requiring unknown shell \"${shebang_command_name}\" not sourceable"
    # Technically, another crude identifier exists: if such script resides under
    # a directory named "zsh", assume such shell to be zsh.
#   elif is_string_contains "${filename}" '/zsh/'
#   then shell_name='zsh'
    # Otherwise, assume such shell to be Zeshy.
#   else
#       print_warning "script \"${filename}\" lacking shebang line assumed to be a Zeshy script"
#       shell_name='zeshy'
#   fi

        # If a shell explicitly emulatable by zsh, do so.
#       ${~ZESHY_GLOB_EMULATABLE_SHELLS})
#           emulate -LR "${shell_name}";;
        # Otherwise, this function failed to properly map such script's specific
        # shell to a zsh-supported shell; throw an exception.
#       *) die "script \"${filename}\" requiring unmapped shell \"${shell_name}\" not sourceable";;
# follows:
#
# /======================^============================\
# | passed shell command | emulated shell environment |
# <======================+============================>
# | ash                  | sh                         |
# | bash                 | bash*                      |
# | csh                  | csh                        |
# | dash                 | sh                         |
# | mksh                 | ksh                        |
# | pdksh                | ksh                        |
# | resh                 | sh                         |
# | tcsh                 | csh                        |
# | sh                   | sh                         |
# | zeshy                | NONE                       |
# | zsh                  | zsh                        |
# \======================+============================/
#FUXME: Replace with a simple map. This is overkill. Extreme overkill.
# string map_shell_to_emulatable_shell(string shell_name)
#
# Get the zsh-emulatable shell closest in ancestry and hence operation to the
# passed shell if a sufficiently close shell exists (e.g., if passed "tcsh",
# return "csh") or throw an exception (e.g., if passed "fish", throw an
# exception). The emulate() builtin supports only a subset of available shells,
# requiring all other shells be mapped to the "closest" supported shell: e.g.,
#
#     >>> map_shell_to_emulatable_shell tcsh
#     csh
#     >>> map_shell_to_emulatable_shell fish
#     map_shell_to_emulatable_shell: shell "fish" not mappable to an emulatable shell
#function map_shell_to_emulatable_shell() {
#function get_shell_emulating_shell() {
    # Validate sanity.
#    die_unless_arg 'expected one shell name'
#    string shell_name="${1}"

    #FUXME: New die_unless_shell_emulatable_() function, yes? Also, rename
    #${ZESHY_SHELL_EMULATABLE_INDIRECTLY_GLOB} to ${ZESHY_GLOB_SHELL_SOURCEABLE}?
#    :is_string_matches_glob "${shell_name}" "${ZESHY_SHELL_EMULATABLE_INDIRECTLY_GLOB}" or
#        die "shell \"${shell_name}\" not mappable to an emulatable shell"

    # Map the passed shell command to the closest zsh-emulatable shell command.
#    case "${shell_name}" in
    # If such shell is supported under a generic zsh-recognized name, map
    # the former to latter.
#    (a|da|re)sh) print_string 'sh';;
#    tcsh) print_string 'csh';;
#    (m|pd)ksh) print_string 'ksh';;
#    *) print_string "${shell_name}"
#    esac
#}
#   case "${shell_name}" in
    # If such shell is supported under a generic zsh-recognized name, map
    # the former to latter.
#   (a|da|re)sh) shell_name='sh';;
#   tcsh) shell_name='csh';;
#   (m|pd)ksh) shell_name='ksh';;
#   esac


# string :source_script_command_output(
#   string shell_name,
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Emulate the passed command under the passed shell (e.g., "sh", "csh") and, if
# successful, source the command's standard output.
#function :source_script_command_output() {
    # Validate sanity.
#    die_unless_args_2_or_more\
#        'expected at least one shell name and one command name'
#    string shell_name="${1}"
#    shift_arg

    #FUXME: Refer to the previously defined glob.
#    is "${shell_name}" == (zsh|sh|ksh|csh) si or
#        die "\"${shell_name}\" not an emulatable shell"
#   string command_name="${1}"
#   die_unless_pathable "${command_name}"

    # Source safely.
#    emulate -R "${shell_name}" -c "eval \$(${@})"
#}

#         if shebang_command_name="$(get_string_text_matching_glob_group_if_found\
#           "${shebang_command}"\
#           '(/usr|)/bin/env[[:space:]]##([^[:space:]]##)')"
#       then print_string "${shebang_command_name}"
#       elif shebang_command_name="$(get_string_text_matching_glob_group_if_found\
#           "${shebang_command}"\
#           '(/usr|)/bin/env[[:space:]]##([^[:space:]]##)')"
#       then print_string "${shebang_command_name}"
#       else report_failure

# Safely source the passed non-Zeshy script by emulating the shell environment
# expected by that script with default shell options and traps (e.g., a script
# "mandibles_of_joy.sh" expects a Bourne rather than zsh shell environment).
#       string glob="[/ ](${emulatable_shells})((#e)| )" shebang
#       string regex="^.*[/ ](${emulatable_shells})($| )" shebang_command
        #FUXME: Insufficient. Search, say, the first eight lines for a shebang.
        #This suggests a call pipeline resembling:
        #  shebang_line="$(get_file_text_line_matching_pcre "$(get_file_text_lines "${filename}" 1 8)" "${shebang_regex}")"
#       shebang_line="$(get_file_text_first_line "${filename}")"
#           shell="${match[1]}"
#       print_string "shebang_line: ${shebang_line}"
#       print_string "shell=${shell}"
    #FUXME: Hmm; this appears to be fixed under zsh 5.0.0. Verify. Wait; no.
    #This should be expected behavior, given the prior TRAPZERR() statement.
    # Interestingly, zsh fails to signal ZERR when the sourced script fails with
    # non-zero exit status. Let's signal ZERR ourselves, shall we?

#If the passed filename is not absolute, convert
    # such filename to an absolute path by searching the current working
    # directory, ${PATH}, and ${FPATH} (in that order) for such basename.# string get_shell_script_path(string script_name)
#
# Get the absolute path of the passed script if in at least one path listed
# below or throw an exception. If in multiple such paths, get the first such
# path. If the passed name is the absolute path of a text file, return such file
# as is. Otherwise, this function generalizes get_autoload_path() by searching
# for (in order):
#
# * Any file in the current working directory with such name.
# * Any file in the current user's ${PATH} with such name (i.e., a command).
# * Any file in the current user's ${FPATH} with such name (i.e., an autoload).
#function get_shell_script_path() {
    # Validate sanity.
#    die_unless_arg 'expected one filename'
#    string filename="${1}"

    # If such name is the absolute path of a text file, return such name as is.
#    if is_path_absolute "${filename}"; then
#        die_unless_file_text "${filename}"
#        print_string "${filename}"
    # Otherwise, iteratively search the described paths for such file.
#    else
#        list script_paths; script_paths=( "${PWD}" "${path[@]}" "${fpath[@]}" )
#        get_shell_script_autoload_path "${filename}" script_paths
#    fi
#}

# string get_shell_script_defining_function(
#   string function_name, string autoload_dirs_list_name = 'fpath')
#
# Get the absolute path of the shell script defining the passed function if under at least one
# path in the passed list of paths or throw an exception. If under multiple such
# paths, get the first such path: e.g.,
#
#     >>> get_shell_script_autoload_path zsh-mime-handler
#     /usr/share/zsh/4.3.11/functions/MIME/zsh-mime-handler
#function get_shell_script_defining_function() {
    # Validate sanity, discarding all but the basename of the passed
    # filename.
#    die_unless_args_1_to_2\
#        'expected one basename and optional list name'
#    string basename autoload_dirs_list_name="${2:-fpath}"
#    basename="$(get_path_basename "${1}")"

    # Dismantled, this is:
    #
    # * "filename_matches_list_name", the name of the list listing all
    #   directories to be searched for the passed autoload.
    # * "(@P)", expanding to such list.
    # * "^", iteratively expanding to each such directory.
    # * "/${filename}", concatenating the passed autoload to each such
    #   directory, producing a possible absolute path to such autoload.
    # * "(N)", ignoring non-extant such absolute paths.
#    list filename_matches
#    filename_matches=( ${^${(@P)autoload_dirs_list_name}}"/${basename}"(N) )
#   filename_matches=( ${^fpath}/"${filename}"(N) )

    # Throw an exception if no path in the passed list of paths has such script.
#   print_message "filename_matches: \"${filename_matches[@]}\""
#   :var.is_type_list filename_matches or print 'ugug!'
#    die_unless_list_nonempty filename_matches
#        "autoloadable script \"${basename}\" not found"

    # Print the first such path.
#    print_string "${filename_matches[1]}"
#}

# string :source_script_(string filename, string arg1, string arg2, ...)
#
# Source the passed shell script with the sanity, reading and
# executing all commands in such script under the current shell. If such script:

    #FUXME: Not quite right. We clearly need to allow "bash", for example. To do
    #so, just match the glob '[a-z]##sh'. The emulate() builtin is smart enough
    #to default to "zsh", if all else fails.
# Safely source the passed non-Zeshy script by emulating the shell environment
# expected by that script with default shell options and traps (e.g., a script
# "mandibles_of_joy.sh" expects a Bourne rather than zsh shell environment).
# Zeshy throws such exceptions, necessitating rendering non-Zeshy shell scripts
# expecting traditional unsafe behavior inoperable.
#     regardless of non-zero exit status. (Zeshy implicitly throws exceptions on
#     command returning such status.)
#FUXME: WAIT; WAIT; WAIT. This distinction between Zeshy and non-Zeshy is
#hideous. Why? Because *we* can programmatically determine which is required by
#simple analysis of the she-bang. (We need better she-bang functions, by the
#way.) If the she-bang ends in either "/zeshy" or " zeshy", we have a Zeshy
#script on our hands and need to just source it as is. Otherwise, we need to
#source it under emulation appropriate to that shell. Roll all of this into one
#common function named simply :source_script().

# string source_zeshy_script(
#   string script_filename, string script_arg1, string script_arg2, ...)
#
# Source the passed Zeshy script with the sanity. Avoid calling this
# function with non-Zeshy shell scripts, which often behave unexpectedly under
# the default Zeshy shell environment. Zeshy implicitly throws an exception on a
# command returning non-zero exit status, rendering non-Zeshy shell scripts
# expecting conventional unsafe behavior inoperable. Consider calling
# :source_script() instead, in such cases.
#function source_zeshy_script() {
#    die_unless_args 'expected one script filename and optional script arguments'
#    source -- "${@}"
#}

# string source_zeshy_scripts(
#   string script_filename1, string script_filename2, ...)
#
# Source the passed Zeshy scripts. See source_zeshy_script() for details.
#function source_zeshy_scripts() {
#    die_unless_args 'expected at least one script filename'
#    for filename ("${@}") { source -- "${filename}" }
#}

# void zeshy_initialize_imports()
#
# Initialize the imports dictionary, used by the require() function. This is a
# global dictionary mapping from imported script name to the mtime (i.e.,
# modification time) of the script at the time of importation. The require()
# function adds script names to this dictionary on importing those scripts so
# as to record having done so. This record keeping allows that function to
# avoid importing already imported scripts.
#
# Zeshy Shell requires we separate this initialization into a distinct function,
# for hitherto inexplicable reasons. (There be subtle dragons aboot.)
#zeshy_initialize_imports() {
#    die_if_args

#    # Explicitly empty the dictionary. This is irrelevant on the first call to
#    # this function, but definitely matters on subsequent calls!
#    map_global_export ZESHY_REQUIRED_PATH_TO_MTIME; ZESHY_REQUIRED_PATH_TO_MTIME=( )
#}

#   elif is_path          "${PWD}/${zeshy_script_name}"
#   then zeshy_script_path="${PWD}/${zeshy_script_name}"

    # Initialize the imports dictionary used by the zimport() function.
#   zeshy_initialize_imports

    # Inform the user that this script is being imported. This script is usually
    # sourced via the zsh source() built-in rather than the Zeshy zimport()
    # function; thus, our failure to do this here would require callers do this
    # there, prior to their sourcing this script.
    #
    # Distinguish the former from the latter by noting whether the
    # "${zeshy_script_mtime}" variable has been set or not; if it has, this script
    # was sourced via zimport() rather than source().
#   is_undeclared 'zeshy_script_mtime' or print_message "loading \"${zeshy_core_path}\"..."

    #FUXME: Replace with single call to run_code_with_mapfile:().
#   if shebang_line="$(get_string_text_matching_glob_group_if_found\
#       "${mapfile[${pathname}]}"\
#       "([^${ZESHY_ASCII_NEWLINE}]#)")"
#   if run_code_with_mapfile: "shebang_line=\"\$(get_string_text_matching_glob_group_if_found\
#       \"\${mapfile[\${filename}]}\"\
#       '[#]!([^${ZESHY_ASCII_NEWLINE}]#)')\""
#       '\#!([^$'\n']#)')\""
#   then print_string "${shebang_line}"
#   else report_failure
#   fi
#   run_code_with_mapfile: "get_string_text_matching_glob_group_if_found\
#       \"\${mapfile[\${filename}]}\"\
#       '[#]!([^${ZESHY_ASCII_NEWLINE}]#)'"
#   load_mapfile
#   get_string_text_matching_glob_group_if_found\
#       "${mapfile[${filename}]}" "(#s)\#!([^${ZESHY_ASCII_NEWLINE}]#)*"
#   unload_mapfile
#   list lines; set_list_to_file_text_lines lines "${pathname}"
#   if is_string_prefix "${lines[1]}" '#!'
#   then print_string "${lines[1]}"
#   else report_failure
#   fi

    # Technically, we could implement this with pure-zsh.
