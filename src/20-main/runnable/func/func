#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "COPYING" for additional details.

:parcel <<'/---'
Handle core function functionality.
/---

#FIXME: Rename "_function" to "_func" everywhere.

# ....................{ GETTERS                            }....................
#FIXME: Horrid! Refactor into setters.
#FIXME: Excessive examples. Split elsewhere.

:func_ ':string get_function_binding(:string:func func_name1, ...)'
:func{
    typeset -f -- "${@}"
}:func <<'/---'
Get *bindings* (i.e., declarations with definitions) for all passed functiones,
in the passed order: e.g.,

.get_function_binding()
==========================================
[source]
------------------------------------------
>>> function on_technical_fixes() {
...     :string.output\
...    "Ever since the Industrial Revolution, Western society has benefited from
...     science, logic, and reductionism over intuition and holism.
...     Psychologically and politically we would much rather assume that the
...     cause of a problem is \"out there,\" rather than \"in here.\" It's
...     almost irresistible to blame something or someone else, to shift
...     responsibility away from ourselves, and to look for the control knob,
...     the product, the pill, the technical fix that will make a problem go
...     away."
... }
>>> function on_complex_systems() {
...     :string.output\
...    "Serious problems have been solved by focusing on external agents —
...     preventing smallpox, increasing food production, moving large weights
...     and many people rapidly over long distances. Because they are embedded
...     in larger systems, however, some of our \"solutions\" have created
...     further problems. And some problems, those most rooted in the internal
...     structure of complex systems, the real messes, have refused to go away.
...     Hunger, poverty, environmental degradation, economic instability,
...     unemployment, chronic disease, drug addiction, and war, for example,
...     persist in spite of the analytical ability and technical brilliance that
...     have been directed toward eradicating them. No one deliberately creates
...     those problems, no one wants them to persist, but they persist
...     nonetheless."
... }
>>> function on_systems_problems() {
...     :string.output\
...    "That is because they are intrinsically systems problems — undesirable
...     behaviors characteristic of the system structures that produce them.
...     They will yield only as we reclaim our intuition, stop casting blame,
...     see the system as the source of its own problems, and find the courage
...     and wisdom to restructure it."
... }
>>> get_string_lines_matching_glob "$(get_function_binding\
...     on_technical_fixes on_complex_systems on_systems_problems)"\
...     ('function'|[[:space:]]#':string.output'|'}')*
function on_technical_fixes() {
    :string.output\
}
function on_complex_systems() {
    :string.output\
}
function on_systems_systems() {
    :string.output\
}
------------------------------------------
==========================================
/---

:func_ ':string get_function_body(:string:func func_name)'
:func{
    # Localize arguments.
    :string function_name="${1}" function_binding
    :list function_binding_lines

    # zsh provides direct means of getting function bindings but *NOT* bodies.
    # The former are formatted as follows, with lines nested by incremental
    # tabbing rather than spacing:
    #
    #     function on_ideology() {
    #         :string.output\
    #             "Growth for the sake of growth is the ideology of the cancer cell."
    #     }
    #
    # Given such a binding, the corresponding body is obtainable by stripping
    # the first and last lines as well as the first tab from all other lines.

    # Such function's binding.
    function_binding="$(get_function_binding "${function_name}")"

    # List of all lines split from such binding.
    set_list_to_string_lines function_binding_lines "${function_binding}"

    # Such function's body converted from such list as documented above.
    # Dismantled, this is:
    #
    # * "[2,-2]", excluding the first and last lines.
    # * "#$'\t'", stripping the first tab from each remaining line.
    #
    # Do *NOT* quote the outermost expansion.
    :output_strings_newlined ${${function_binding_lines[2,-2]}#$'\t'}
}:func <<'/---'
Get the body of code the passed function implements: e.g.,

.get_function_body()
==========================================
[source]
------------------------------------------
>>> :string on_mechanistic_belief=\
...    "An answer might lie in the fact that economics is no more than a
...     mechanistic belief (though defended with fanatical vigour) that by
...     exchanging goods for money, countries can make themselves better off.
...     It is true that by buying from another country we can avoid resource
...     depletion and environmental degradation here, but that degradation is
...     transferred to the supplying country. If the country that sells us those
...     goods buys its materials from us, it avoids its own resource depletion
...     and environmental destruction and transfers the impact back to us. So
...     while we are all at it (and use each other's best economic advantage),
...     we cannot avoid environmental damage by trading with each other and thus
...     get perpetual environmental benefits like perpetual motion. Indeed, if
...     that worked, we could achieve absolute environmental integrity by just
...     selling our products to another country and then buying them back. That
...     proposition is clearly absurd. We shall see that globally no
...     environmental advantage can be gained from international trade and much
...     environmental capital is lost while amenity assets are destroyed in the
...     process."
>>> function on_fanatical_vigour() {
...     die_if_args
...     :string.output "${on_mechanistic_belief}"
... }
>>> get_function_body on_fanatical_vigour
die_if_args
:string.output "${on_mechanistic_belief}"
------------------------------------------
==========================================
/---

# ....................{ GETTERS ~ name                     }....................
#FIXME: Horrible for a number of obvious reasons -- particularly, as function
#names containing newlines break everything. Excise this function entirely,
#replaced with a setter aggregating together the keys of map globals
#${functions} and ${dis_functions}.
:func_ ':string get_functions()' :func{
    die_if_args
    typeset +f
}:func <<'/---'
List the names of all `zsh` functions delimited by newlines.
/---

:func_ ':string get_functions_math()' :func{
    die_if_args
    functions -M
}:func <<'/---'
List all *user-defined math function* (i.e., functions declared by
`functions -M`) names, delimited by newline.
/---

# ....................{ SETTERS                            }....................
:func_ ':void set_list_to_functions(:string:list? list_name)'
:func{
    set_list_to_string_lines "${1}" "$(get_functions)"
}:func <<'/---'
Set the passed list to all function names.
/---

#FIXME: In lieu of unit tests...
#function payy() {
#    list function_names
#    set_list_to_functions function_names
#    print_list function_names
#}

# ....................{ PRINTERS                           }....................
:func_ ':string print_function(:string:func func_name1, ...)'
:func{
    #FIXME: Syntax highlight such output, ideally via Pygments.

    # Print such functions.
    {
        typeset -f -- "${@}"
    } | page_stdin
}:func <<'/---'
Print a human-readable synopsis of the passed functions, typically including
syntax-highlighted declarations and definitions of such functions.
/---

# ....................{ PRINTERS ~ line                    }....................
:func_ ':string print_function_line_contextually(
    :string:func function_name, :int_positive line_number)' :func{
    # Localize arguments.
    :string function_name="${1}" line_number="${2}"

    #FIXME: Sadly, this isn't quite right. The line number appears to be
    #relative to the original function definition in the source file. Here's a
    #simple test:
    #
    #    command dirs -p | number_lines_highlighting_line 0
    #
    #zsh reports the failing command on a line number that could only be the
    #original file including comments and blank lines. Sadly, that means we
    #can't reliably highlight line numbers for any functions except those defined
    #in the Zeshy digest. It also means we have to manually map the function
    #name to the exact block of code in the exact Zeshy file defining such
    #function, taking into account things like conditional themes. (Commands
    #needn't be considered. But themes must.) It's all highly annoying, and
    #frankly somewhat out of bounds at the moment.
    #
    #How about this: for the moment, drop the line number highlighting. It's
    #erroneous and unhelpful. When time permits re-implement this conditional to:
    #
    #* If this function is a Zeshy function (i.e., is compiled into the Zeshy
    #  digest), perform the above behavior with line number highlighting using
    #  "awk" and a similar script to below.
    #* Otherwise, print a code listing with no such highlighting using "nl".
    #
    #Because this probably relies on advanced Zeshy functionality not readily
    #implementable without access to the Zeshy codebase, we should segregate
    #this into an autoload function (say, print_function_highlighting_line()).
    #Then test here for the existence of such function. If available, call it;
    #otherwise, do nothing. (No error, if it doesn't exist yet.)
    #FIXME: Actually, this *IS* readily doable. See @{call_stack} FIXME
    #commentary for further details.

    # If the most recent stack frame signifies an existing function, print that
    # function's definition to standard error as line-numbered code. Since line
    # numbers in stack frames start from the first line of such definition while
    # the default printer for such definitions starts from the prior line
    # declaring the function name, do *NOT* number the first printed line.
    :output_newline
    :string.output "${funcname_first}() failed on line ${fileline_first}."

    whence -f -- "${funcname_first}" | command awk -vNRBAD=${fileline_first} '
# If the function name, print a hyphen in place of the current line number
# followed by the name.
NR == 1 {
    printf("%6s   %s\n", "-", $0)
}
# If any line other than the erroneous line, print the current line number
# followed by the line. (Due to the prefixing function name declaration, the
# current line number is one larger than expected. Subtract one for comparison.)
NR > 1 && NR-1 != NRBAD {
    # If this line is "}" and hence the end of this function definition, print
    # hyphens in place of the current line number followed by the "}".
    if ($0 == "}") {
        NREND=NR
        gsub(/./, "-", NREND)
        printf("%6s   }\n", NREND)
    }
    else {
        printf("%6d   %s\n", NR-1, $0)
    }
}
# If the erroneous line, print the current line number prefixed and suffixed by
# pleasing ASCII arrows. (What? YOU CAN DO BETTER!?)
NR-1 == NRBAD {
    # Number of digits in the current line number.
    NRLEN = length(NR-1);
         if (NRLEN==1) {NRNOW = " <-~ " NR-1}
    else if (NRLEN==2) {NRNOW = "<-~ " NR-1}
    else if (NRLEN==3) {NRNOW = "<- " NR-1}
    else               {NRNOW = NR-1}       # if true, your function is horrid.
    printf("%s ~->   %s\n", NRNOW, $0)
}' 2>&1
}:func <<'/---'
Print the passed line of the passed function contextually. If such function is
sufficiently small (e.g., less than six lines), print the complete function
definition; otherwise, print only the passed line and some number of lines
preceding and succeeding such line of such function definition as context.
/---

# ....................{ UNDEFINERS                         }....................
:func_ ':void :undefine_func(:string func_name1, ...)' :func{
    unfunction -- "${@}"
}:func <<'/---'
Undefine the passed functions. If any such function does _not_ exist, an
exception is thrown.
/---

# ....................{ DEFINERS ~ enable                  }....................
:func_ ':void disable_function(:string func_name1, ...)' :func{
    disable -f -- "${@}"
}:func <<'/---'
Disable the passed functions. Disabled functions remain defined but uncallable
until reenabled by enable_function().
/---

:func_ ':void enable_function(:string func_name1, ...)' :func{
    enable -f -- "${@}"
}:func <<'/---'
Enable the passed functions. Since all functions are enabled by default, this is
useful for only undoing prior calls to disable_function().
/---

# --------------------( WASTELANDS                         )--------------------
# ....................{ EXCEPTIONS                         }....................
#FUXME: Generalize to accept multiple function names.
# :func_ ':void :func.die_unless(
#     :string:func func_name,
#     :string error_message = "Function ${function_name}() undefined.")'
# :func{
#     :func.is "${1}" or {
#         :string func_name="${1}"
#         die "${2-Function ${func_name}() undefined.}"
#     }
# }:func <<'/---'
# Throw an exception with the passed message unless the passed function exists.
# /---
# 
# #FUXME: Excise. Replace all calls to this function with calls to
# #:func.die_unless().
# :func_ ':void die_unless_functions(:string func_name1, ...)'
# :func{
#     # If at least one such function is undefined, manually iterate such
#     # functions until discovering the first undefined such function and throw an
#     # exception given such function. Such theatrics are necessitated by
#     # inadequacies in builtin "typeset -f", which fails without *ANY* message if
#     # at least one passed function is undefined. (Ughgh.)
#     :func.is "${@}" or {
#         :string func_name
#         for     func_name ("${@}") {
#             :func.die_unless "${func_name}"
#         }
#     }
# }:func <<'/---'
# Throw an exception with a stock message unless all passed functions exist.
# /---

# ....................{ TESTERS                            }....................
# :func_ '[status = :bool] :func.is(:string func_name1, ...)'
# :func{
#     { typeset -f -- "${@}" } :silent_stdout
# }:func <<'/---'
# Report success if all passed functions exist.
# /---

    # # Validate sanity.
    # die_unless_args 'Expected one or more function names.'

    # die_unless_args 'Expected one or more function names.'
    # die_unless_functions "${@}"
    # # Localize arguments.
    # :string list_name__sltf="${1}"
    # die_unless_arg 'Expected one list name.'
    # :var.die_unless_type_list "${list_name__sltf}"

    # # Set such list.
    # set_list_to_string_lines "${list_name__sltf}" "$(get_functions)"

    # Validate sanity.
    # die_unless_args 'Expected one or more function names.'
    # die_unless_functions "${@}"

    # :func.die_unless "${function_name}"
    # :int.die_unless_positive "${line_number}"

    # die_unless_args_1_to_2\
    #     'Expected one function name and optional error message.'
    # die_unless_args 'Expected one or more function names.'

    # For
    # efficiency, inline such implementation. Dismantled, this is:
    #
    # * "(f)", splitting such binding on newline into a list of lines.
    # * "[2,-2]", excluding the first and last lines.
    # * "#$'\t'", stripping the first tab from each remaining line.
    #
    # Do *NOT* quote the outermost expansion.
    # :output_strings_newlined\
    #     ${${${(f)"$(get_function_binding "${function_name}")"}[2,-2]}#$'\t'}

#           :func.is "${function_name}" or
#               die "${2:-\"${function_name}\" not a function}"
#       }

    # Validate sanity. Since run_code_paged is a function and hence
    # cannot properly run a command expanding the argument list to the current
    # function (i.e., "${@}"), localize the function names to a named list.
#   die_unless_args 'expected at least one function name'
#   list function_names; function_names=( "${@}" )
#   run_code_paged 'typeset -f -- "${function_names[@]}"'

#the passed functions. If such output exceeds the height of the current terminal,
#page such output.
# syntax-highlighted *bindings* (i.e., declarations with definitions) for

#   string function_name="${1}"
#   :func.die_unless "${function_name}"

#       ${${${(f)"$(get_function_binding "${function_name}")"}[2,-2]}#$'\t'}
#whence -f --
# if previously disabled by disable_function()
    # Validate sanity.
#   die_if_args

    # While bash has a builtin means of listing such names (i.e., "typeset -F"),
    # zsh surprisingly does not. Hence, we manually implement such listing by
    # parsing the output of builtin whence(). First, list all current runnables.
#   string runnable_names; runnable_names="$(whence -wm '*')"

    # Filter non-functions from such list.
#   remove_list_nonmatches runnable_names '*: function'

    # Print such list.
#   page_string "${runnable_names}"

# Globally re-enable the function with the passed name, presumably previously
# disabled with a call to disable_function().
#   if [[ -n "${ZESHY_IS_DEBUG-}" && -n "${funcname_first}" &&\
#         "$(whence -w -- "${funcname_first}")" == *': function' ]]; then
#   is "$(whence -w -- "${1}")" == *': function' si

# ....................{ GETTERS                            }....................
# string list_functions()
#
# List all currently declared zsh function names delimited by newlines.
#list_functions() {
#    die_if_args
#    typeset -f +   # yes, this is mind-numbingly crazy
#}

# string output(int number)
#
# Return the passed integer from the current function.
#output() {
#    die_unless_arg 'expected one integer'
#    print -- "${1}"
#}

# string output(string text1, string text2, ...)
#
# Return the concatenation of the passed strings from the current function.
#output() {
#    die_unless_args 'expected at least one string'
#    print -- "${@}"
#}
