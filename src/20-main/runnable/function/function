#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle core function functionality.
/---

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_function(
    string function_name,
    string error_message = "Function ${function_name}() undefined.")

Throw an exception with the passed message unless the passed function exists.
/---
function die_unless_function() {
    die_unless_args_1_to_2\
        'Expected one function name and optional error message.'
    :string function_name="${1}"
    is_function "${function_name}" or
        die "${2-Function ${function_name}() undefined.}"
}

declare_function_with_stdin <<'/---'
void die_unless_functions(string function_name1, ...)

Throw an exception with a stock message unless all passed functions exist.
/---
function die_unless_functions() {
    # Validate sanity.
    die_unless_args 'Expected one or more function names.'

    # If at least one such function is undefined, manually iterate such
    # functions until discovering the first undefined such function and throw an
    # exception given such function. Such theatrics are necessitated by
    # inadequacies in builtin "typeset -f", which fails without *ANY* message if
    # at least one passed function is undefined. (Ughgh.)
    is_function "${@}" or {
        :string function_name
        for     function_name ("${@}") {
            die_unless_function "${function_name}"
        }
    }
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: bool] is_function(string function_name1, ...)

Report success if all passed functions exist.
/---
function is_function() {
    die_unless_args 'Expected one or more function names.'
    { typeset -f -- "${@}" } silent:
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_function_binding(string function_name1, ...)

Get *bindings* (i.e., declarations with definitions) for all passed functiones,
in the passed order: e.g.,

.get_function_binding()
==========================================
[source]
------------------------------------------
>>> function on_technical_fixes() {
...     print_string\
...    "Ever since the Industrial Revolution, Western society has benefited from
...     science, logic, and reductionism over intuition and holism.
...     Psychologically and politically we would much rather assume that the
...     cause of a problem is \"out there,\" rather than \"in here.\" It's
...     almost irresistible to blame something or someone else, to shift
...     responsibility away from ourselves, and to look for the control knob,
...     the product, the pill, the technical fix that will make a problem go
...     away."
... }
>>> function on_complex_systems() {
...     print_string\
...    "Serious problems have been solved by focusing on external agents —
...     preventing smallpox, increasing food production, moving large weights
...     and many people rapidly over long distances. Because they are embedded
...     in larger systems, however, some of our \"solutions\" have created
...     further problems. And some problems, those most rooted in the internal
...     structure of complex systems, the real messes, have refused to go away.
...     Hunger, poverty, environmental degradation, economic instability,
...     unemployment, chronic disease, drug addiction, and war, for example,
...     persist in spite of the analytical ability and technical brilliance that
...     have been directed toward eradicating them. No one deliberately creates
...     those problems, no one wants them to persist, but they persist
...     nonetheless."
... }
>>> function on_systems_problems() {
...     print_string\
...    "That is because they are intrinsically systems problems — undesirable
...     behaviors characteristic of the system structures that produce them.
...     They will yield only as we reclaim our intuition, stop casting blame,
...     see the system as the source of its own problems, and find the courage
...     and wisdom to restructure it."
... }
>>> get_string_lines_matching_glob "$(get_function_binding\
...     on_technical_fixes on_complex_systems on_systems_problems)"\
...     ('function'|[[:space:]]#'print_string'|'}')*
function on_technical_fixes() {
    print_string\
}
function on_complex_systems() {
    print_string\
}
function on_systems_systems() {
    print_string\
}
------------------------------------------
==========================================
/---
function get_function_binding() {
    die_unless_args 'Expected one or more function names.'
    die_unless_functions "${@}"
    typeset -f -- "${@}"
}

declare_function_with_stdin <<'/---'
string get_function_body(string function_name)

Get the body of code the passed function implements: e.g.,

.get_function_body()
==========================================
[source]
------------------------------------------
>>> string on_mechanistic_belief=\
...    "An answer might lie in the fact that economics is no more than a
...     mechanistic belief (though defended with fanatical vigour) that by
...     exchanging goods for money, countries can make themselves better off.
...     It is true that by buying from another country we can avoid resource
...     depletion and environmental degradation here, but that degradation is
...     transferred to the supplying country. If the country that sells us those
...     goods buys its materials from us, it avoids its own resource depletion
...     and environmental destruction and transfers the impact back to us. So
...     while we are all at it (and use each other's best economic advantage),
...     we cannot avoid environmental damage by trading with each other and thus
...     get perpetual environmental benefits like perpetual motion. Indeed, if
...     that worked, we could achieve absolute environmental integrity by just
...     selling our products to another country and then buying them back. That
...     proposition is clearly absurd. We shall see that globally no
...     environmental advantage can be gained from international trade and much
...     environmental capital is lost while amenity assets are destroyed in the
...     process."
>>> function on_fanatical_vigour() {
...     die_if_args
...     print_string "${on_mechanistic_belief}"
... }
>>> get_function_body on_fanatical_vigour
die_if_args
print_string "${on_mechanistic_belief}"
------------------------------------------
==========================================
/---
function get_function_body() {
    # Validate sanity.
    die_unless_arg 'Expected one function name.'
    :string function_name="${1}"
    die_unless_function "${function_name}"

    # zsh provides direct means of getting function bindings but *NOT* bodies.
    # The former are formatted as follows, with lines nested by incremental
    # tabbing rather than spacing:
    #
    #     function on_ideology() {
    #         print_string\
    #             "Growth for the sake of growth is the ideology of the cancer cell."
    #     }
    #
    # Given such a binding, get the corresponding function body by stripping the
    # first and last lines *AND* the first tab in all remaining lines. For
    # efficiency, inline such implementation. Dismantled, this is:
    #
    # * "(f)", splitting such binding on newline into a list of lines.
    # * "[2,-2]", excluding the first and last lines.
    # * "#$'\t'", stripping the first tab from each remaining line.
    #
    # Do *NOT* quote the outermost expansion.
    output_strings_newlined\
        ${${${(f)"$(get_function_binding "${function_name}")"}[2,-2]}#$'\t'}
}

# ....................{ GETTERS ~ name                     }....................
declare_function_with_stdin <<'/---'
string get_functions(void)

List the names of all `zsh` functions, delimited by newline.
/---
function get_functions() {
    die_if_args
    typeset +f
}

declare_function_with_stdin <<'/---'
string get_functions_math(void)

List all *user-defined math function* (i.e., functions declared by
`functions -M`) names, delimited by newline.
/---
function get_functions_math() {
    die_if_args
    functions -M
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void set_list_to_functions(string list_name)

Set the passed list to all function names.
/---
function set_list_to_functions() {
    # Validate sanity.
    die_unless_arg 'Expected one list name.'
    :string list_name__sltf="${1}"
    die_unless_list "${list_name__sltf}"

    # Set such list.
    set_list_to_string_lines "${list_name__sltf}" "$(get_functions)"
}

#FIXME: In lieu of unit tests...
#function payy() {
#    list function_names
#    set_list_to_functions function_names
#    print_list function_names
#}

# ....................{ PRINTERS                           }....................
declare_function_with_stdin <<'/---'
string print_function(string function_name1, ...)

Print a human-readable synopsis of the passed functions, typically including
syntax-highlighted declarations and definitions of such functions.
/---
function print_function() {
    # Validate sanity.
    die_unless_args 'Expected one or more function names.'
    die_unless_functions "${@}"

    #FIXME: Syntax highlight such output, ideally via Pygments.

    # Print such functions.
    {
        typeset -f -- "${@}"
    } | page_stdin
}

# ....................{ PRINTERS ~ line                    }....................
declare_function_with_stdin <<'/---'
string print_function_line_contextually(
    string function_name, integer line_number)

Print the passed line of the passed function contextually. If such function is
sufficiently small (e.g., less than six lines), print the complete function
definition; otherwise, print only the passed line and some number of lines
preceding and succeeding such line of such function definition as context.
/---
function print_function_line_contextually() {
    # Validate sanity.
    die_unless_args_2 'Expected one function name and one line number.'
    :string function_name="${1}" line_number="${2}"
    die_unless_function "${function_name}"
    die_unless_integer_positive "${line_number}"

    #FIXME: Sadly, this isn't quite right. The line number appears to be
    #relative to the original function definition in the source file. Here's a
    #simple test:
    #
    #    command dirs -p | number_lines_highlighting_line 0
    #
    #zsh reports the failing command on a line number that could only be the
    #original file including comments and blank lines. Sadly, that means we
    #can't reliably highlight line numbers for any functions except those defined
    #in the Zeshy digest. It also means we have to manually map the function
    #name to the exact block of code in the exact Zeshy file defining such
    #function, taking into account things like conditional themes. (Commands
    #needn't be considered. But themes must.) It's all highly annoying, and
    #frankly somewhat out of bounds at the moment.
    #
    #How about this: for the moment, drop the line number highlighting. It's
    #erroneous and unhelpful. When time permits re-implement this conditional to:
    #
    #* If this function is a Zeshy function (i.e., is compiled into the Zeshy
    #  digest), perform the above behavior with line number highlighting using
    #  "awk" and a similar script to below.
    #* Otherwise, print a code listing with no such highlighting using "nl".
    #
    #Because this probably relies on advanced Zeshy functionality not readily
    #implementable without access to the Zeshy codebase, we should segregate
    #this into an autoload function (say, print_function_highlighting_line()).
    #Then test here for the existence of such function. If available, call it;
    #otherwise, do nothing. (No error, if it doesn't exist yet.)

    # If the most recent stack frame signifies an existing function, print that
    # function's definition to standard error as line-numbered code. Since line
    # numbers in stack frames start from the first line of such definition while
    # the default printer for such definitions starts from the prior line
    # declaring the function name, do *NOT* number the first printed line.
    output_newline
    output_string "${funcname_first}() failed on line ${fileline_first}."

    whence -f -- "${funcname_first}" | awk -vNRBAD=${fileline_first} '
# If the function name, print a hyphen in place of the current line number
# followed by the name.
NR == 1 {
    printf("%6s   %s\n", "-", $0)
}
# If any line other than the erroneous line, print the current line number
# followed by the line. (Due to the prefixing function name declaration, the
# current line number is one larger than expected. Subtract one for comparison.)
NR > 1 && NR-1 != NRBAD {
    # If this line is "}" and hence the end of this function definition, print
    # hyphens in place of the current line number followed by the "}".
    if ($0 == "}") {
        NREND=NR
        gsub(/./, "-", NREND)
        printf("%6s   }\n", NREND)
    }
    else {
        printf("%6d   %s\n", NR-1, $0)
    }
}
# If the erroneous line, print the current line number prefixed and suffixed by
# pleasing ASCII arrows. (What? YOU CAN DO BETTER!?)
NR-1 == NRBAD {
    # Number of digits in the current line number.
    NRLEN = length(NR-1);
         if (NRLEN==1) {NRNOW = " <-~ " NR-1}
    else if (NRLEN==2) {NRNOW = "<-~ " NR-1}
    else if (NRLEN==3) {NRNOW = "<- " NR-1}
    else               {NRNOW = NR-1}       # if true, your function is horrid.
    printf("%s ~->   %s\n", NRNOW, $0)
}' 2>&1
}

# ....................{ DEFINERS                           }....................
declare_function_with_stdin <<'/---'
void undefine_function(string function_name1, ...)

Undefine the passed functions. If any such function does _not_ exist, an
exception is thrown.
/---
function undefine_function() {
    die_unless_args 'Expected one or more function names.'
    unfunction -- "${@}"
}

# ....................{ DEFINERS ~ enable                  }....................
declare_function_with_stdin <<'/---'
void disable_function(string function_name1, ...)

Disable the passed functions. Disabled functions remain defined but uncallable
until reenabled by enable_function().
/---
function disable_function() {
    die_unless_args 'Expected one or more function names.'
    disable -f -- "${@}"
}

declare_function_with_stdin <<'/---'
void enable_function(string function_name1, ...)

Enable the passed functions. Since all functions are enabled by default, this is
useful for only undoing prior calls to disable_function().
/---
function enable_function() {
    die_unless_args 'Expected one or more function names.'
    enable -f -- "${@}"
}

# --------------------( WASTELANDS                         )--------------------
#           is_function "${function_name}" or
#               die "${2:-\"${function_name}\" not a function}"
#       }

    # Validate sanity. Since run_code_paged is a function and hence
    # cannot properly run a command expanding the argument list to the current
    # function (i.e., "${@}"), localize the function names to a named list.
#   die_unless_args 'expected at least one function name'
#   list function_names; function_names=( "${@}" )
#   run_code_paged 'typeset -f -- "${function_names[@]}"'

#the passed functions. If such output exceeds the height of the current terminal,
#page such output.
# syntax-highlighted *bindings* (i.e., declarations with definitions) for

#   string function_name="${1}"
#   die_unless_function "${function_name}"

#       ${${${(f)"$(get_function_binding "${function_name}")"}[2,-2]}#$'\t'}
#whence -f --
# if previously disabled by disable_function()
    # Validate sanity.
#   die_if_args

    # While bash has a builtin means of listing such names (i.e., "typeset -F"),
    # zsh surprisingly does not. Hence, we manually implement such listing by
    # parsing the output of builtin whence(). First, list all current runnables.
#   string runnable_names; runnable_names="$(whence -wm '*')"

    # Filter non-functions from such list.
#   remove_list_nonmatches runnable_names '*: function'

    # Print such list.
#   page_string "${runnable_names}"

# Globally re-enable the function with the passed name, presumably previously
# disabled with a call to disable_function().
#   if [[ -n "${ZESHY_IS_DEBUG-}" && -n "${funcname_first}" &&\
#         "$(whence -w -- "${funcname_first}")" == *': function' ]]; then
#   is "$(whence -w -- "${1}")" == *': function' si

# ....................{ GETTERS                            }....................
# string list_functions(void)
#
# List all currently declared zsh function names delimited by newlines.
#list_functions() {
#    die_if_args
#    typeset -f +   # yes, this is mind-numbingly crazy
#}

# string output(int number)
#
# Return the passed integer from the current function.
#output() {
#    die_unless_arg 'expected one integer'
#    print -- "${1}"
#}

# string output(string text1, string text2, ...)
#
# Return the concatenation of the passed strings from the current function.
#output() {
#    die_unless_args 'expected at least one string'
#    print -- "${@}"
#}
