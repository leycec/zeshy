#!/usr/bin/env zsh
# ====================[ alias                              ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# ZeshyInit Alias, implementing core Zeshy aliases.
#
# --------------------( TODO                               )--------------------
# * Technically, we can support interactive aliases on functions -- but only
#   in somewhat roundabout fashion. We would need detect this to be an alias on a
#   function (easy), then define a new function with the same implementation as the
#   function to be replaced by such alias but with a new name, say,
#   "${alias_name}____tmp" (perhaps easy; doesn't "which ${function_name}" provide
#   us a function implementation which we could then eval into a new function with
#   such placeholder name?), then replace the old with the new function name in the
#   alias expansion (easy). It's a bit involved, but nothing too intractable.

# ....................{ TYPES ~ aliases                    }....................
# void global_alias(char *name, char *value)
#
# Declare a global alias (i.e., an alias expandable anywhere in an expression
# rather than only in command position).
alias global_alias="alias -g"

# void suffix_alias(char *name, char *value)
#
# Declare a suffix alias (i.e., an alias expandable only at the end of
# expressions, typically for filetypes).
alias suffix_alias="alias -s"

# ....................{ TYPES ~ integer                    }....................
# void bool(char *name)
#
# Locally declare a boolean. Due to current inadequacies in Zsh, this only
# declares a scalar string local to the current scope. Nonetheless, we
# encourage users use this alias for clarity, forwards compatibility, and
# functional symmetry with the existing integer() and float() built-ins.
alias bool='local'

# void global_bool(char *name)
#
# Globally declare a boolean.
alias global_bool='typeset -x'

# ....................{ TYPES ~ integer                    }....................
# Zsh already provides built-in integer() for declaring local integers.

# void global_integer(char *name)
#
# Globally declare an integer (i.e., non-real number).
alias global_integer='integer -x'

# ....................{ TYPES ~ float                      }....................
# Zsh already provides built-in float() for declaring local floats.

# void global_float(char *name)
#
# Globally declare a float (i.e., real number).
alias global_float='float -x'

# ....................{ TYPES ~ string                     }....................
# void string(char *name)
#
# Locally declare a string.
alias string='local'

# void global_bool(char *name)
#
# Globally declare a string.
alias global_string='typeset -x'

# ....................{ TYPES ~ list                       }....................
# Due to current inadequacies in Zsh, lists must be externally initialized:
# e.g.,
#
#   list sequence; sequence=( 'value 1' 'value 2' 'value 3' 'value 4' )

# void list(char *name)
#
# Locally declare a list (i.e., sequential array).
alias list='typeset -a'

# void list_set(char *name)
#
# Locally declare a list set (i.e., a list ignoring duplicate values).
alias list_set='typeset -Ua'

# void list_tied_string(
#   char *string_name, char *list_name, char *separator = ':')
#
# Declare a string with the passed name "tied" to the list with the passed name.
# This resembles a Perl tie by joining the list's elements with the passed
# separator, defaulting to ":", into a string and updating that string on each
# update (i.e., change) to that list: e.g.,
#
#   list_tied_string arroyo array ' '
#   list array; array=( 'Cuidad' 'Juarez' )
#   print "${arroyo}"  # prints "Cuidad Juarez"
#   array=( 'El' 'Paso' )
#   print "${arroyo}"  # prints "El Paso"
#
# Importantly, note Zsh leaves the list-tied string initially unset -- even if
# the list to which it is tied is set! Hence, list-tied strings should usually
# be declared prior to the list to which they tie. Yes, this is unintuitive.
alias list_tied_string='typeset -T'

# void global_list(char *name)
#
# Globally declare a list (i.e., sequential array).
alias global_list='typeset -ax'

# ....................{ TYPES ~ map                        }....................
# Due to current inadequacies in Zsh, maps must be externally initialized: e.g.,
#
#   map hash_map; hash_map=( 'key 1' 'value 1' 'key 2' 'value 2' )

# void map(char *name)
#
# Locally declare a map (i.e., associative array).
alias map='typeset -A'

# void map_set(char *name)
#
# Locally declare a map set (i.e., a map ignoring duplicate values).
alias map_set='typeset -UA'

# void global_map(char *name)
#
# Globally declare a map (i.e., associative array).
alias global_map='typeset -Ax'

# ....................{ GLOBAL ALIASES                     }....................
# bool is(...)
#
# Syntactic sugar signifying the delimiting prefix for a boolean test: e.g.,
#
#   is "PatGoD" == *GoD si and print "Piper methysticum"  # or...
#   [[ "PatGoD" == *GoD ]]  && print "Piper methysticum"  # equivalent!
global_alias is='[['

# void si(void)
#
# Syntactic sugar signifying the delimiting suffix for a boolean test.
global_alias si=']]'

global_alias not='!'
global_alias or='||'
global_alias and='&&'

# ....................{ OPERATORS                          }....................
# void noop(...)
#
# Perform parameter expansion on all passed parameters. This alias runs no
# commands and thus always returns successfully.
alias noop=':'

# ....................{ EXIT STATUS                        }....................
# void return_exit_status(void)
#
# Return the exit status of the most recently called callable (i.e., external
# command or Zsh built-in or function).
alias return_exit_status='return $?'

# ....................{ OPTIONS                            }....................
# void localize_zsh_options(char *option_name1, char *option_name2, ...)
#
# Confine the passed Zsh options to the current context. This is particularly
# helpful for localizing such options to function calls: e.g.,
#
#     risky_non_business() {
#         localize_zsh_options no_warn_create_global
#         a_new_hopelessness="This shall not fail!"
#     }
alias localize_zsh_options='setopt local_options'

# ....................{ INTERACTIVE ~ tests                }....................
#FIXME: Not quite right. Should technically read "#funcstack == 1". We
#temporarily permit one additional layer of function calls to permit calls by
#interactive aliases to be considered as "directly." While we should certainly
#revert this back to "#funcstack == 1", doing so requires we leverage function
#aliases rather than interactive aliases: e.g., rather than this
#
#    interactive_alias cd='change_path'
#    change_path() { ... }
#
#we do this:
#
#    change_path cd() { ... }
#
#It's more or less fine for now, but should be looked at.

# char *is_interactive_directly(char *command_name, char *option1, char *option2, ...)
#
# Return true if:
#
# * The current function was not called by another function (i.e., was called
#   directly by the current user from the command-line interface).
# * The current shell is attached to a terminal device and interactively reading
#   commands from standard input.
alias is_interactive_directly='(( ${#funcstack} <= 2 )) and is_interactive'

# ....................{ INTERACTIVE ~ commands             }....................
# char *interactively(char *command_name, char *option1, char *option2, ...)
#
# Run the passed command only where the current shell is interactive.
alias interactively='is_interactive and'

# ....................{ ARGUMENTS ~ tests                  }....................
# Define critical argument-specific aliases.

# bool is_no_args(void)
#
# Return true if the caller was called with no arguments.
alias is_no_args='(( # == 0 ))'

# bool is_args(void)
#
# Return true if the caller was called with at least one argument.
alias is_args='(( # > 0 ))'
alias is_at_least_one_arg=is_args

# bool is_at_least_two_args(void)
#
# Return true if the caller was called with at least two arguments.
alias is_at_least_two_args='(( # >= 2 ))'

# bool is_at_least_three_args(void)
#
# Return true if the caller was called with at least three arguments.
alias is_at_least_three_args='(( # >= 3 ))'

# bool is_one_arg(void)
#
# Return true if the caller was called with exactly one argument.
alias is_one_arg='(( # == 1 ))'

# bool is_two_args(void)
#
# Return true if the caller was called with exactly two arguments.
alias is_two_args='(( # == 2 ))'

# ....................{ ARGUMENTS ~ exceptions             }....................
# As a convenience, all argument aliases except die_unless_no_args() first
# attempt to read their argument from stdin when the caller passed no explicit
# argument. This implies all functions expanding these aliases implicitly "get"
# piped input support, which is nice.

# char *make_die_unless_alias(char *test_condition)
#
# Make a string suitable for use as the right-hand side of a "die_unless_*"-
# specific alias statement. This string parses standard input into function
# parameters if such input exists (i.e., if another function piped input to
# this function) and the caller passed insufficient parameters.
make_die_unless_alias() {
    # We can't quite recall why, but double quotes *MUST* be embedded in this
    # expression via "'" rather than the customary \".
    print "is -p /dev/stdin si and not (( ${1} )) and set -- "'"$(< /dev/stdin)"'"; (( ${1} )) or die"
}

# void die_unless_no_args(void)
#
# Die with a canonical message unless the caller passed no arguments.
alias die_unless_no_args='is_no_args or die "expected no arguments"'

# void die_unless_args(char *error_message)
#
# Die with the passed message unless the caller passed at least one argument.
alias die_unless_args="$(make_die_unless_alias '# > 0')"

# void die_unless_one_arg(char *error_message)
#
# Die with the passed message unless the caller passed exactly one argument.
alias die_unless_one_arg="$(make_die_unless_alias '# == 1')"

# void die_unless_two_args(char *error_message)
#
# Die with the passed message unless the caller passed exactly two arguments.
alias die_unless_two_args="$(make_die_unless_alias '# == 2')"

# void die_unless_three_args(char *error_message)
#
# Die with the passed message unless the caller passed exactly three arguments.
alias die_unless_three_args="$(make_die_unless_alias '# == 3')"

# void die_unless_four_args(char *error_message)
#
# Die with the passed message unless the caller passed exactly four arguments.
alias die_unless_four_args="$(make_die_unless_alias '# == 4')"

# void die_unless_one_or_two_args(char *error_message)
#
# Die with the passed message unless the caller passed either one or two
# arguments.
alias die_unless_one_or_two_args="$(make_die_unless_alias '# == 1 || # == 2')"

# void die_unless_two_or_three_args(char *error_message)
#
# Die with the passed message unless the caller passed either two or three
# arguments.
alias die_unless_two_or_three_args="$(make_die_unless_alias '# == 2 || # == 3')"

# void die_unless_one_to_three_args(char *error_message)
#
# Die with the passed message unless the caller passed at least one and at most
# three arguments.
alias die_unless_one_to_three_args="$(make_die_unless_alias '# >= 1 && # <= 3')"

# void die_unless_one_to_four_args(char *error_message)
#
# Die with the passed message unless the caller passed at least one and at most
# four arguments.
alias die_unless_one_to_four_args="$(make_die_unless_alias '# >= 1 && # <= 4')"

# void die_unless_at_least_one_arg(char *error_message)
#
# Die with the passed message unless the caller passed at least one argument.
alias die_unless_at_least_one_arg="$(make_die_unless_alias '# >= 1')"

# void die_unless_at_least_two_args(char *error_message)
#
# Die with the passed message unless the caller passed at least two arguments.
alias die_unless_at_least_two_args="$(make_die_unless_alias '# >= 2')"

# void die_unless_at_least_three_args(char *error_message)
#
# Die with the passed message unless the caller passed at least three arguments.
alias die_unless_at_least_three_args="$(make_die_unless_alias '# >= 3')"

# void die_unless_at_most_one_arg(char *error_message)
#
# Die with the passed message unless the caller passed at most one argument.
alias die_unless_at_most_one_arg="$(make_die_unless_alias '# <= 1')"

# void die_unless_at_most_two_args(char *error_message)
#
# Die with the passed message unless the caller passed at most two arguments.
alias die_unless_at_most_two_args="$(make_die_unless_alias '# <= 2')"

# void die_unless_at_most_three_args(char *error_message)
#
# Die with the passed message unless the caller passed at most three arguments.
alias die_unless_at_most_three_args="$(make_die_unless_alias '# <= 3')"

# void die_unless_at_most_four_args(char *error_message)
#
# Die with the passed message unless the caller passed at most four arguments.
alias die_unless_at_most_four_args="$(make_die_unless_alias '# <= 4')"

# Delete the temporary function used to construct the above aliases.
unfunction make_die_unless_alias

# ....................{ ARGUMENTS ~ modifiers              }....................
# void append_args(char *arg1, char *arg2, ...)
#
# Append the passed arguments to the end of the current argument list.
alias append_args='set -- "${@}"'

#FIXME: Rename remove_*(), for clarity.
# void shift_args(int args = 1)
#
# Remove the passed number of arguments (defaulting to 1) from the current
# argument list.
alias shift_args='shift'

# void shift_one_arg(void)
#
# Remove the first argument from the current argument list.
alias shift_one_arg='shift 1'

# void shift_two_args(void)
#
# Remove the first two arguments from the current argument list.
alias shift_two_args='shift 2'

# void shift_three_args(void)
#
# Remove the first three arguments from the current argument list.
alias shift_three_args='shift 3'

# ....................{ ARGUMENTS ~ parsers                }....................
# void parse_args(char *argument_spec1, char *argument_spec2, ...)
#
# Parse script (or function) arguments according to the passed zparseopts()-
# style argument specifications into map "ARGS". For details on specification
# format, search "man zshmodules" for "zparseopts". For convenience, "-h" and
# "--help" are always parsed as valid argument options: e.g.,
#
#   # Set fake command-line arguments.
#   >>> set -- -d --ad --crest "glass arm shattering"
#
#   # Parse such arguments as:
#   #
#   # * "--ad", a long option followed by no value.
#   # * "--crest", a long option followed by some value.
#   # * "--wing", a long option optionally followed by some value.
#   >>> parse_args d e -ad -crest: -wing::
#
#   # Validate such parsing.
#   >>> is_map_key 'ARGS' '-d' and print 'option "-d" parsed'
#   option "-d" parsed
#   >>> echo "-d: ${ARGS[-d]}\n--ad: ${ARGS[--crest]}\n--wing: ${ARGS[--wing]}"
#   -d:
#   --crest: glass arm shattering
#   --wing:
alias parse_args='zparseopts -D -E -A ARGS -- h -help' 

# ....................{ TYPES ~ interactive aliases        }....................
# Defer defining this function until having defined all prior aliases.

#FIXME: This still isn't quite right. The reason is subtle:
#    interactive_alias ssh='TERM="xterm" ssh -v'
#See what happens there? We attempt to call a command "TERM=\"xterm\"" when
#non-interactive. Of course, we should be calling "ssh". So, this is subtly
#broken. Fixing it requires ignoring all prefixing words containing a "="
#character. *sigh*

# void interactive_alias(char *alias_specification)
#
# Declare the passed specification as an interactive alias, active only when the
# builtin or command to be aliased is run directly from an interactive shell.
# Due to implementation details, functions cannot currently be interactively
# aliased. Interactive aliases are inactive in non-interactive scripts and
# functions, and hence helpful for applying human-readable options on that
# builtin or command when run directly by a human. This function fails if the
# builtin or command to be aliased does not exist. See 
# interactive_alias_if_installed() for an alternative not failing in such cases.
#
# The alias specification format is identical to that of normal aliases: e.g.,
#
#   # Alias print() to sort arguments only when called interactively.
#   >>> print T M D
#   T M D
#   >>> interactive_alias print="print -o"
#   >>> print T M D
#   D M T
#   >>> print_indirectly() { print "${@}" }
#   >>> print_indirectly T M D
#   T M D
interactive_alias() {
    die_unless_args

    # Split the passed '='-divided alias specification into name and expansion.
#   print "args: ${*%%=*}"
    string alias_name=${*%%\=*} alias_expansion=${*#*\=}
#   split_first "${@}" 'alias_name' 'alias_expansion' '='
#   print "alias_name: ${alias_name}\nalias_expansion: ${alias_expansion}"

    # Die if the passed alias name is already a defined callable.
    is "$(whence -w "${alias_name}")" == *': '(alias|function) si and
        die "\"${alias_name}\" already defined as:\n$(which "${alias_name}")"

    # The command to expand this alias to when called non-interactively. If the
    # the command to expand this alias to when called interactively is a:
    #
    # * Builtin or command, then this is that builtin or command name sans
    #   subsequent arguments.
    # * Alias or function and:
    #   * The original passed alias name is a builtin or command, then this is
    #     that builtin or command name.
    #   * Otherwise, raise an exception.
    string command_name="${alias_expansion[(w)1]}"
    string alias_expansion_if_not_interactive="${command_name}"
    if is "$(whence -w   "${command_name}")" != *': '(builtin|command) si; then
        if is "$(whence -w "${alias_name}")" == *': '(builtin|command) si
        then alias_expansion_if_not_interactive="${alias_name}"
        else alias_expansion_if_not_interactive=
        fi
    fi

    # The string to expand this alias to when called interactively.
    alias_expansion+=' "${@}"'

    # The string to expand this alias to when called non-interactively.
    if is -n "${alias_expansion_if_not_interactive}" si
    then alias_expansion_if_not_interactive+=' "${@}"'
    else alias_expansion_if_not_interactive="die 'neither \"${alias_name}\" or \"${command_name}\" are builtins or commands and hence cannot be called non-interactively'"
    fi

    # Define the desired alias as a function of the same name, which:
    #
    # * Temporarily disables this function to prevent infinite recursion on
    #   subsequently calling a builtin or command of the same name.
    # * If this shell is interactive (thus excluding non-interactive scripts)
    #   and this "alias" was called directly from the command line (thus
    #   excluding non-interactive calls from function implementations), runs
    #   the passed alias expansion.
    # * Else if some non-interactive expansion exists, runs such expansion.
    # * Regardless of whether such run throws an exception, always reenable this
    #   function for subsequent use. 
    eval "function ${alias_name}() {
    {
        disable -f ${alias_name}
        if is -o interactive and \${#funcstack} -eq 1 si
        then ${alias_expansion}
        else ${alias_expansion_if_not_interactive}
        fi
    } always {
        enable -f ${alias_name}
    }
}"
}

#FIXME: Obsolete.
# Define critical command-specific aliases. Zeshy Process implements similar
# functionality as functions where not implementable here as aliases.
# Define critical boolean-specific aliases. Zeshy Shell implements similar
# functionality as functions where not implementable here as aliases.

    # * If such run throws an exception:
    #   * Catch such exception.
    #   * Reenable this function for subsequent use.
    #   * Rethrow such exception.
    # * Otherwise, reenable this function for subsequent use.

# * O.K.; I've become convinced the "global" global alias is harmful. Why?
#   Because it obfuscates manipulation of files named "global" at the command
#   line. Also, it's non-orthogonal with the "global_alias" global. (Though,
#   technically the two convey completely different options.) In the future, we
#   should clearly minimize the number of global aliases.
# * Ah; I think I've devised a mechanism for accomplishing this sanely. Simply
#   define a function proclaim() (or some other synonym of declare(), but not
#   declare() as that's already a Zsh builtin) aliased as:
#   alias map='proclaim map' 
#   alias string='proclaim string' 
#   And so forth. Then define proclaim() to parse the first argument as the type
#   to be declared, the last argument as the name to be declared, and all
#   intermediate arguments as human-readable options condensed to typeset
#   options: e.g., "global_map const set" expands to
#   "proclaim global_map const set", which eventually... ah, wait. No. That
#   obviously runs up against the classical eval issue, since the executed
#   typeset runs in the local context of proclaim(). *sigh*
# * Right, then. There's no recourse but to manually define the set of all
#   possible aliases: e.g., global_map, global_const_map, etc. For sanity, just
#   define the most commonly used types.
#FIXME: The word "arguments" should probably be truncated to "args", here.
#Rewriting "arguments" every function is slightly silly (and cumbersome).

#       or die "neither \"${alias_name}\" or \"${alias_expansion_if_not_interactive}\" are builtins or commands"
#       alias_expansion_if_not_interactive="${alias_name}"

#   "${alias_expansion_if_not_interactive:c}" == /* or
#   if command_path="$(whence -cp "${command_name}")"; then
#   fi
#   
#   == *': function'
#   not whence -cp "${command_name}"; then
#   fi

    # If the builtin or command to be aliased does not exist, return with error.
    # To avoid costly exception handling on this frequently called helper
    # function, do not throw an exception.
#   if not whence "${command_name}" 1>/dev/null 2>&1; then
#       curse "\"${command_name}\" not a Zsh builtin or command in \$PATH"
#       return_failure
#   fi

# void interactive_alias_if_installed(char *alias_specification)
#
# Declare the passed specification as an interactive alias only if the builtin
# or command to be aliased exists. This function is a no-nop if it does not.
#interactive_alias_if_installed() {
#    FIXME: Rewrite. Only call interactive_alias if the passed command is installed.
#    interactive_alias "${@}" 1>/dev/null 2>&1 or true
#}

#   eval "function ${alias_name}() {
#   ${alias_expansion} "\${@}"
#}"
#}
#
#testem() {

#FIXME: No longer convinced these to be necessary. "(( VARNAME1 <= varname2 ))"
#reads much more sensibly than "is ${VARNAME1} deceeds_or_equals ${varname2} si". We
#should probably shift all instances of the latter to the former.
#global_alias equals='-eq'
#global_alias deceeds='-lt'
#global_alias deceeds_or_equals='-le'
#global_alias exceeds='-gt'
#global_alias exceeds_or_equals='-ge'

# ....................{ DECLARATORS ~ modifiers            }....................
# Mark the declared variable as global (i.e., exported). By Zsh convention,
# this and the variable type are ordered opposite to C order: e.g.,
#
#   global_list two_hunters; two_hunters=( "ktulu" "orion" )  # or...
#   local -Ax   two_hunters; two_hunters=( "ktulu" "orion" )  # equivalent!
#global_alias global='-x'

# Mark the declared variable as constant (i.e., read-only). By Zsh convention,
# this and the variable type are ordered opposite to C order: e.g.,
#
#   string const fwtbt="ride the lightning"  # or...
#   local -r     fwtbt="ride the lightning"  # equivalent!
#global_alias const='-r'

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
