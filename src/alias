#!/usr/bin/env zsh
# ====================[ alias                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Alias, handling Zeshy aliases. For efficiency, Zeshy is autoload-based.
# Only functions are autoloadable, so aliases are not autoloadable. Only this
# file defines Zeshy aliases.
#
# --------------------( TODO                               )--------------------
# * Technically, we can support interactive aliases on functions -- but only
#   in somewhat roundabout fashion. We would need detect this to be an alias on a
#   function (easy), then define a new function with the same implementation as the
#   function to be replaced by such alias but with a new name, say,
#   "${alias_name}____tmp" (perhaps easy; doesn't "which ${function_name}" provide
#   us a function implementation which we could then eval into a new function with
#   such placeholder name?), then replace the old with the new function name in the
#   alias expansion (easy). It's a bit involved, but nothing too intractable.

# ....................{ TYPES ~ aliases                    }....................
# void global_alias(string alias_name, string alias_expansion)
#
# Declare a global alias (i.e., an alias expandable anywhere in an expression
# rather than only in command position).
alias global_alias="alias -g"

# void suffix_alias(string alias_name, string alias_expansion)
#
# Declare a suffix alias (i.e., an alias expandable only at the end of
# expressions, typically for filetypes).
alias suffix_alias="alias -s"

# ....................{ TYPES ~ boolean                    }....................
# void bool(string variable_name)
#
# Locally declare a boolean. Due to current inadequacies in Zsh, this only
# declares a scalar string local to the current scope. Nonetheless, we
# encourage users use this alias for clarity, forwards compatibility, and
# functional symmetry with the existing integer() and float() built-ins.
alias bool='local'

# void global_bool(string variable_name)
#
# Globally declare a boolean.
alias global_bool='typeset -x'

# ....................{ TYPES ~ integer                    }....................
# Zsh already provides built-in integer() for declaring local integers.

# void integer_in_base(int base, string variable_name)
#
# Locally declare an integer in the passed base (e.g., "16" for hexadecimal).
# Zsh internally retains each integer's base for formatting the string
# representation of each integer in its base when output.
alias integer_in_base='typeset -i'  # yes, "integer" does *NOT* suffice here.

# void global_integer(string variable_name)
#
# Globally declare an integer (i.e., non-fractional number).
alias global_integer='integer -x'

# ....................{ TYPES ~ float                      }....................
# Zsh already provides built-in float() for declaring local floats.

# void float_with_fractional_digit_length(int length, string variable_name)
#
# Locally declare a float (i.e., real number) with exactly the passed number of
# fractional digits.
alias float_with_fractional_digit_length='typeset -F'

# void global_float(string variable_name)
#
# Globally declare a float (i.e., real number).
alias global_float='float -x'

# ....................{ TYPES ~ string                     }....................
# void string(string variable_name)
#
# Locally declare a string.
alias string='local'

# void global_bool(string variable_name)
#
# Globally declare a string.
alias global_string='typeset -x'

# ....................{ TYPES ~ list                       }....................
# Due to current inadequacies in Zsh, lists must be externally initialized:
# e.g.,
#
#   list sequence; sequence=( 'value 1' 'value 2' 'value 3' 'value 4' )

# void list(string variable_name)
#
# Locally declare a list (i.e., sequential array).
alias list='typeset -a'

# void list_set(string variable_name)
#
# Locally declare a list set (i.e., a list ignoring duplicate values).
alias list_set='typeset -Ua'

# void list_tied_string(
#   string text_name, string list_name, string separator = ':')
#
# Declare a string with the passed name "tied" to the list with the passed name.
# This resembles a Perl tie by joining the list's elements with the passed
# separator, defaulting to ":", into a string and updating that string on each
# update (i.e., change) to that list: e.g.,
#
#   list_tied_string arroyo array ' '
#   list array; array=( 'Cuidad' 'Juarez' )
#   print "${arroyo}"  # prints "Cuidad Juarez"
#   array=( 'El' 'Paso' )
#   print "${arroyo}"  # prints "El Paso"
#
# Importantly, note Zsh leaves the list-tied string initially unset -- even if
# the list to which it is tied is set! Hence, list-tied strings should usually
# be declared prior to the list to which they tie. Yes, this is unintuitive.
alias list_tied_string='typeset -T'

# void global_list(string variable_name)
#
# Globally declare a list (i.e., sequential array).
alias global_list='typeset -ax'

# ....................{ TYPES ~ map                        }....................
# Due to current inadequacies in Zsh, maps must be externally initialized: e.g.,
#
#   map hash_map; hash_map=( 'key 1' 'value 1' 'key 2' 'value 2' )

# void map(string variable_name)
#
# Locally declare a map (i.e., associative array).
alias map='typeset -A'

# void map_set(string variable_name)
#
# Locally declare a map set (i.e., a map ignoring duplicate values).
alias map_set='typeset -UA'

# void global_map(string variable_name)
#
# Globally declare a map (i.e., associative array).
alias global_map='typeset -Ax'

# ....................{ GLOBAL ALIASES                     }....................
# bool is(...)
#
# Syntactic sugar signifying the delimiting prefix for a boolean test: e.g.,
#
#   is "PatGoD" == *GoD si and print "Piper methysticum"  # or...
#   [[ "PatGoD" == *GoD ]]  && print "Piper methysticum"  # equivalent!
global_alias is='[['

# void si(void)
#
# Syntactic sugar signifying the delimiting suffix for a boolean test.
global_alias si=']]'

global_alias not='!'
global_alias or='||'
global_alias and='&&'

# ....................{ OPERATORS                          }....................
# void noop(string arg1, string arg2, ...)
#
# Perform parameter expansion on all passed parameters. This alias runs no
# commands and thus always returns successfully.
alias noop=':'

# ....................{ OPTIONS                            }....................
# void localize_zsh_options(string option_name1, string option_name2, ...)
#
# Confine the passed Zsh options to the current context. This is particularly
# helpful for localizing such options to function calls: e.g.,
#
#     risky_non_business() {
#         localize_zsh_options no_warn_create_global
#         a_new_hopelessness="This shall not fail!"
#     }
alias localize_zsh_options='setopt local_options'

# ....................{ PIPES                              }....................
# bool is_piped_input(void)
#
# Return true if standard input to the current function or script is a pipe.
alias is_piped_input='is -p /dev/stdin si'

# string pass_piped_input_to(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command by piping the standard input piped to the current
# function or script to such command. Typically, this alias is used in concert
# with the is_piped_input() alias to seemlessly propagate input: e.g.,
#
#     >>> salvia() {
#     ...     if is_piped_input
#     ...     then pass_piped_input_to cat
#     ...     else print -- "${@}"     cat
#     ...     fi
#     ... }
#     >>> print  divinorum | salvia
#     divinorum
#     >>> salvia divinorum
#     divinorum
alias pass_piped_input_to='cat /dev/stdin |'

# string get_piped_input(void)
#
# Get the standard input piped to the current function or script as a string.
# This is typically used with is_piped_input(): e.g.,
#
#     >>> ska_maria() {
#     ...     if is_piped_input
#     ...     then print -- "$(get_piped_input)"
#     ...     else print -- "${@}"
#     ...     fi
#     ... }
#     >>> print pastora | ska_maria
#     pastora
#     >>> ska_maria pastora
#     pastora
alias get_piped_input='< /dev/stdin'

# ....................{ RETURN VALUES                      }....................
#FIXME: Fix now-broken examples in "README.dev". Also, extend to restore_map().
# void restore_list(void)
#
# Convert the string piped on standard input to a local list named "list",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_list().
alias restore_list='{
    is -p /dev/stdin si or die "\"/dev/stdin\" not a pipe";
    list list; list=( ${(z)"$(< /dev/stdin)"} )
}'

# void return_exit_status(void)
#
# Return the exit status of the callable piped into this alias: e.g.,
#
#     # Returns the exit status of one of two randomly selected greps.
#     >>> catamount() {
#     ...     if is_odd $(get_random_number)
#     ...     then grep Panthera /onca | return_exit_status
#     ...     else grep Puma /concolor | return_exit_status
#     ...     fi
#     ... }
#     >>> catamount or print 'Mountain lions abound/Ever abiding onward.'
#     Mountain lions abound/Ever abiding onward.
#
# Do not use the conventional implementation of such logic (e.g., "${?}"). Due
# to our use of TRAPZERR(), such logic does not work as expected: e.g.,
#
#     # Raises exceptions rather than returning false on grep failure.
#     >>> catamount_bad() {
#     ...     if is_odd $(get_random_number)
#     ...     then grep Panthera /onca; return $?
#     ...     else grep Puma /concolor; return $?
#     ...     fi
#     ... }
#     >>> catamount_bad or print 'Tricolor ipomoea and the congress of concolor'
#     catamount_bad: "/onca" not found
alias return_exit_status='true and return ${pipestatus[-2]}'

# ....................{ UI                                 }....................
# string interactively(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command only where the current shell is interactive.
alias interactively='is_interactive and'

#FIXME: Not quite right. Should technically read "#funcstack == 1". We
#temporarily permit one additional layer of function calls to permit calls by
#interactive aliases to be considered as "directly." While we should certainly
#revert this back to "#funcstack == 1", doing so requires we leverage function
#aliases rather than interactive aliases: e.g., rather than this
#
#    interactive_alias cd='change_path'
#    change_path() { ... }
#
#we do this:
#
#    change_path cd() { ... }
#
#It's more or less fine for now, but should be looked at.

#FIXME: Actually, this is pretty terrible, and should be excised everywhere
#currently called (which shouldn't be terribly many, by now).

# string is_interactive_directly(string command_name, string option1, string option2, ...)
#
# Return true if:
#
# * The current function was not called by another function (i.e., was called
#   directly by the current user from the command-line interface).
# * The current shell is attached to a terminal device and interactively reading
#   commands from standard input.
alias is_interactive_directly='(( ${#funcstack} <= 2 )) and is_interactive'

# ....................{ ARGUMENTS ~ tests                  }....................
# Define critical argument-specific aliases.

# bool is_no_args(void)
#
# Return true if the caller was called with no arguments.
alias is_no_args='(( # == 0 ))'

# bool is_args(void)
#
# Return true if the caller was called with at least one argument.
alias is_args='(( # > 0 ))'
alias is_at_least_one_arg=is_args

# bool is_one_arg(void)
#
# Return true if the caller was called with exactly one argument.
alias is_one_arg='(( # == 1 ))'

# bool is_two_args(void)
#
# Return true if the caller was called with exactly two arguments.
alias is_two_args='(( # == 2 ))'

# bool is_at_least_two_args(void)
#
# Return true if the caller was called with at least two arguments.
alias is_at_least_two_args='(( # >= 2 ))'

# bool is_at_least_three_args(void)
#
# Return true if the caller was called with at least three arguments.
alias is_at_least_three_args='(( # >= 3 ))'

# bool is_at_most_two_args(void)
#
# Return true if the caller was called with at most two arguments.
alias is_at_most_two_args='(( # <= 2 ))'

# bool is_at_most_three_args(void)
#
# Return true if the caller was called with at most three arguments.
alias is_at_most_three_args='(( # <= 3 ))'

# ....................{ ARGUMENTS ~ exceptions             }....................
# string make_die_unless_alias(string test_condition)
#
# Convert the passed math condition into a die_unless_*() alias expansion.
make_die_unless_alias() {
    print -- "(( ${1} )) || die"
}

# void die_if_args(void)
#
# Die with a canonical message if the caller passed any arguments.
alias die_if_args='is_args and die "expected no arguments"'

# void die_unless_args(string error_message)
#
# Die with the passed message unless the caller passed at least one argument.
alias die_unless_args="$(make_die_unless_alias '# > 0')"

# void die_unless_one_arg(string error_message)
#
# Die with the passed message unless the caller passed exactly one argument.
alias die_unless_one_arg="$(make_die_unless_alias '# == 1')"

# void die_unless_two_args(string error_message)
#
# Die with the passed message unless the caller passed exactly two arguments.
alias die_unless_two_args="$(make_die_unless_alias '# == 2')"

# void die_unless_three_args(string error_message)
#
# Die with the passed message unless the caller passed exactly three arguments.
alias die_unless_three_args="$(make_die_unless_alias '# == 3')"

# void die_unless_four_args(string error_message)
#
# Die with the passed message unless the caller passed exactly four arguments.
alias die_unless_four_args="$(make_die_unless_alias '# == 4')"

# void die_unless_one_or_two_args(string error_message)
#
# Die with the passed message unless the caller passed either one or two
# arguments.
alias die_unless_one_or_two_args="$(make_die_unless_alias '# == 1 || # == 2')"

# void die_unless_two_or_three_args(string error_message)
#
# Die with the passed message unless the caller passed either two or three
# arguments.
alias die_unless_two_or_three_args="$(make_die_unless_alias '# == 2 || # == 3')"

# void die_unless_three_or_four_args(string error_message)
#
# Die with the passed message unless the caller passed either three or four
# arguments.
alias die_unless_three_or_four_args="$(make_die_unless_alias '# == 3 || # == 4')"

# void die_unless_one_to_three_args(string error_message)
#
# Die with the passed message unless the caller passed at least one and at most
# three arguments.
alias die_unless_one_to_three_args="$(make_die_unless_alias '# >= 1 && # <= 3')"

# void die_unless_one_to_four_args(string error_message)
#
# Die with the passed message unless the caller passed at least one and at most
# four arguments.
alias die_unless_one_to_four_args="$(make_die_unless_alias '# >= 1 && # <= 4')"

# void die_unless_at_least_one_arg(string error_message)
#
# Die with the passed message unless the caller passed at least one argument.
alias die_unless_at_least_one_arg="$(make_die_unless_alias '# >= 1')"

# void die_unless_at_least_two_args(string error_message)
#
# Die with the passed message unless the caller passed at least two arguments.
alias die_unless_at_least_two_args="$(make_die_unless_alias '# >= 2')"

# void die_unless_at_least_three_args(string error_message)
#
# Die with the passed message unless the caller passed at least three arguments.
alias die_unless_at_least_three_args="$(make_die_unless_alias '# >= 3')"

# void die_unless_at_most_one_arg(string error_message)
#
# Die with the passed message unless the caller passed at most one argument.
alias die_unless_at_most_one_arg="$(make_die_unless_alias '# <= 1')"

# void die_unless_at_most_two_args(string error_message)
#
# Die with the passed message unless the caller passed at most two arguments.
alias die_unless_at_most_two_args="$(make_die_unless_alias '# <= 2')"

# void die_unless_at_most_three_args(string error_message)
#
# Die with the passed message unless the caller passed at most three arguments.
alias die_unless_at_most_three_args="$(make_die_unless_alias '# <= 3')"

# void die_unless_at_most_four_args(string error_message)
#
# Die with the passed message unless the caller passed at most four arguments.
alias die_unless_at_most_four_args="$(make_die_unless_alias '# <= 4')"

# Delete the temporary function used to construct the above aliases.
unfunction make_die_unless_alias

# ....................{ ARGUMENTS ~ modifiers              }....................
# For clarity, Zeshy uses the verbs "shift" and "pop" in the Perl sense.

# void set_args(string arg1, string arg2, ...)
#
# Set the current argument list to the passed arguments.
alias set_args='set --'

# void append_args(string arg1, string arg2, ...)
#
# Append the passed arguments to the end of the current argument list.
alias append_args='set_args "${@}"'

# void shift_args(int args = 1)
#
# Remove the passed number of arguments (defaulting to 1) from the beginning of
# the current argument list.
alias shift_args='shift'

# void shift_one_arg(void)
#
# Remove the first argument from the current argument list.
alias shift_one_arg='shift 1'

# void shift_two_args(void)
#
# Remove the first two arguments from the current argument list.
alias shift_two_args='shift 2'

# void shift_three_args(void)
#
# Remove the first three arguments from the current argument list.
alias shift_three_args='shift 3'

# void pop_one_arg(void)
#
# Remove the last argument from the current argument list.
alias pop_one_arg='set -- ${@[1,-2]}'
#alias pop_one_arg='@[-1]=()'

# void pop_two_args(void)
#
# Remove the last two arguments from the current argument list.
alias pop_two_args='set -- ${@[1,-3]}'

# void pop_three_args(void)
#
# Remove the last three arguments from the current argument list.
alias pop_three_args='set -- ${@[1,-4]}'

# ....................{ ARGUMENTS ~ parsers                }....................
# void parse_args(string argument_spec1, string argument_spec2, ...)
#
# Parse script (or function) arguments according to the passed zparseopts()-
# style argument specifications into map "ARGS". For details on specification
# format, search "man zshmodules" for "zparseopts". For convenience, "-h" and
# "--help" are always parsed as valid argument options: e.g.,
#
#   # Set fake command-line arguments.
#   >>> set -- -d --ad --crest "glass arm shattering"
#
#   # Parse such arguments as:
#   #
#   # * "--ad", a long option followed by no value.
#   # * "--crest", a long option followed by some value.
#   # * "--wing", a long option optionally followed by some value.
#   >>> parse_args d e -ad -crest: -wing::
#
#   # Validate such parsing.
#   >>> is_map_key 'ARGS' '-d' and print 'option "-d" parsed'
#   option "-d" parsed
#   >>> echo "-d: ${ARGS[-d]}\n--ad: ${ARGS[--crest]}\n--wing: ${ARGS[--wing]}"
#   -d:
#   --crest: glass arm shattering
#   --wing:
alias parse_args='zparseopts -D -E -A ARGS -- h -help'

# ....................{ TYPES ~ interactive aliases        }....................
# Defer defining such functions until having defined all core aliases.

#FIXME: Excise this everywhere used. Since interactive_alias() now integrates
#such functionality directly, we no longer require this at all.
# bool is_zeshy_wrapping_core_commands(void)
#
# Return true if the current user requests Zeshy wrap interactively run core
# commands (e.g., "cp", "grep", "ls") with Zeshy functions.
is_zeshy_wrapping_core_commands() {
    (( # == 0 )) or die 'no arguments expected'
    [[ -n "${ZESHY_IS_WRAPPING_CORE_COMMANDS-}" ]]
}

#FIXME: This still isn't quite right. The reason is subtle:
#    interactive_alias ssh='TERM="xterm" ssh -v'
#See what happens there? We attempt to call a command "TERM=\"xterm\"" when
#non-interactive. Of course, we should be calling "ssh". So, this is subtly
#broken. Fixing it requires ignoring all prefixing words containing a "="
#character if such word is not an extant command. (Since, of course, a command
#basename could contain an "=" character. Highly unlikely, but there you go...)
#   *sigh*
# void interactive_alias(string alias_specification)
#
# Declare the passed specification as an interactive alias, active only when the
# builtin or command to be aliased is run directly from an interactive shell.
# Due to implementation details, functions cannot currently be interactively
# aliased. Interactive aliases are inactive in non-interactive scripts and
# functions, and hence helpful for applying human-readable options on that
# builtin or command when run directly by a human. This function fails if the
# builtin or command to be aliased does not exist. See
# interactive_alias_if_installed() for an alternative not failing in such cases.
#
# The alias specification format is identical to that of normal aliases: e.g.,
#
#   # Alias print() to sort arguments only when called interactively.
#   >>> print T M D
#   T M D
#   >>> interactive_alias print="print -o"
#   >>> print T M D
#   D M T
#   >>> print_indirectly() { print "${@}" }
#   >>> print_indirectly T M D
#   T M D
interactive_alias() {
    # Validate passed arguments.
    die_unless_args
#   print "args: ${*%%=*}"

#   # "="-delimited alias name and expansion split from the passed declaration.
    string alias_name=${*%%\=*} alias_expansion=${*#*\=}
#   print "alias_name: ${alias_name}\nalias_expansion: ${alias_expansion}"

    # Alias name type, if the passed alias name is already declared to be an
    # alias, builtin, command, or function.
    string alias_name_type
    if alias_name_type="${$(whence -w -- "${alias_name}")##*: }"; then
        # Die if already declared unless the current user requests wrapping such
        # types with interactive aliases. In particular, replacing a declared
        # Zsh alias or function with an interactive alias is largely senseless;
        # Zsh alias and functions may always be implemented so as to account for
        # interactivity (e.g., by calling is_interactive() or interactively()),
        # thus obviating the need for interactive aliases in such cases. Since
        # silently replacing declared Zsh aliases and functions seems an
        # inherently risky (and certainly useless) proposition, disallow it.
        if   is "${alias_name_type}" == (builtin|reserved) si
        then is -n "${ZESHY_IS_WRAPPING_BUILTINS-}" si or return_true
        elif is "${alias_name_type}" == command si
        then is -n "${ZESHY_IS_WRAPPING_COMMANDS-}" si or return_true
        else die\
            "interactive alias \"${alias_name}\" already defined as type ${alias_name_type}:\n$(which "${alias_name}")"
        fi
    fi

    # The command to expand this alias to when called non-interactively. If the
    # the command to expand this alias to when called interactively is a:
    #
    # * Builtin or command, then this is that builtin or command name sans
    #   subsequent arguments.
    # * Alias or function and:
    #   * The original passed alias name is a builtin or command, then this is
    #     that builtin or command name.
    #   * Otherwise, raise an exception.
    string command_name="${alias_expansion[(w)1]}"
    string alias_expansion_if_non_interactive="${command_name}"
    if is "$(whence -w   "${command_name}")" != *': '(command|reserved) si; then
        if is "${alias_name_type}" == (command|reserved) si
        then alias_expansion_if_non_interactive="${alias_name}"
        else alias_expansion_if_non_interactive=
        fi
    fi

    # The string to expand this alias to when called interactively.
    alias_expansion+=' "${@}"'

    # The string to expand this alias to when called non-interactively.
    if is -n "${alias_expansion_if_non_interactive}" si
    then alias_expansion_if_non_interactive+=' "${@}"'
    else alias_expansion_if_non_interactive="die 'neither \"${alias_name}\" or \"${command_name}\" are builtins or commands and hence cannot be called non-interactively'"
    fi

    # Define the desired alias as a function of the same name, which:
    #
    # * Temporarily disables this function to prevent infinite recursion on
    #   subsequently calling a builtin or command of the same name.
    # * If:
    #   * This shell is interactive, thus excluding non-interactive scripts.
    #   * Standard output is attached to a terminal, thus excluding all
    #     commands in pipe except the last such command.
    #   * This "alias" was called directly from the command line, thus
    #     excluding non-interactive calls from functions.
    #   * Then run the passed alias expansion.
    # * Else, run the desired non-interactive expansion.
    # * Regardless of whether such run throws an exception, always reenable this
    #   function for subsequent use.
    eval "function ${alias_name}() {
    {
        disable -f ${alias_name}
        if [[ -o interactive && -t ${ZESHY_STDOUT} && \${#funcstack} -eq 1 ]]; then
            if is_piped_input
            then pass_piped_input_to ${alias_expansion}
            else ${alias_expansion}
            fi
        else
            if is_piped_input
            then pass_piped_input_to ${alias_expansion_if_non_interactive}
            else ${alias_expansion_if_non_interactive}
            fi
        fi
    } always {
        enable -f ${alias_name}
    }
}"
}

# --------------------( WASTELANDS                         )--------------------
    # Die if the passed alias name is already a defined callable.
#   is "$(whence -w "${alias_name}")" == *': '(alias|function) si and
#       die "\"${alias_name}\" already defined as:\n$(which "${alias_name}")"
    # Return true if the current user requests Zeshy wrap interactively run core
    # commands (e.g., "cp", "grep", "ls") with Zeshy functions.
#   [[ -n "${ZESHY_IS_WRAPPING_CORE_COMMANDS-}" ]]

    #FIXME: Hmm; disabling the function makes piped calls such as:
    #cat /proc/cpuinfo|cat
    #...fail, which is clearly undesirable.
# void interactive_alias_of_core_command(string alias_specification)
#
# Declare the passed specification as an interactive alias if .
# See interactive_alias() for further details.
#interactive_alias_of_core_command() {
#    is_zeshy_wrapping_core_commands and
#    interactive_alias ls='list_path_concisely'
#}

# As a convenience, all argument aliases except die_unless_no_args() first
# attempt to read their argument from stdin when the caller passed no explicit
# argument. This implies all functions expanding these aliases implicitly "get"
# piped input support, which is nice.

# Make a string suitable for use as the right-hand side of a "die_unless_*"-
# specific alias statement. This string parses standard input into function
# parameters if such input exists (i.e., if another function piped input to
# this function) and the caller passed insufficient parameters.

#   print --\
#       '[[ -p /dev/stdin && ${#} -eq 0 ]] && '\
#       'set -- "${@}" "$(< /dev/stdin)"'"; (( ${1} )) || die"
    # We can't quite recall why, but double quotes *MUST* be embedded in this
    # expression via "'" rather than the customary \".
#       "is -p /dev/stdin si and not (( ${1} )) and set -- "\

#       typeset command
#       if [[ -o interactive && \${#funcstack} -eq 1 ]]
#       then command=\"${(q)alias_expansion}\"
#       else command=\"${(q)alias_expansion_if_non_interactive}\"
#       fi
#       if is_piped_input
#       then pass_piped_input_to \${command}
#       else                     \${command}
#       fi

#           if is_piped_input
#           then pass_piped_input_to ${alias_expansion}
#           else ${alias_expansion}
#           fi
#       then ${alias_expansion}
#       else ${alias_expansion_if_not_interactive}
# bool is_terminal(void)
#
# Return true if shell output is attached to a terminal device. Specifically,
# return true if the file descriptor for standard output is open and attached to
# a terminal. (Avoid testing standard input, as commands passed piped input may
# still be "attached" to a terminal.) Do not implement this as a function, as a
# functions tests theirs rather than their callers' file descriptors.
#alias is_terminal='is -t ${ZESHY_STDOUT} si'

# bool is_color_terminal(void)
#
# Return true if the current shell is attached to a color-aware terminal device
# supporting at least the customary 8 colors (i.e., black, white, red, green,
# blue, yellow, magenta, and cyan).
#alias is_color_terminal='is_terminal and (( terminfo[colors] >= 8 ))'

#alias die_unless_no_args=die_if_args

# See Zeshy List and Map for functions returning lists and maps, respectively.
# Such functions are rather non-trivial and hence shifted there.

#FIXME: Reads a bit awkwardly, and superfulous. Supplant everywhere with
#"not is_args".

# void prepend_args(string arg1, string arg2, ...)
#
# Prepend the passed arguments to the beginning of the current argument list.
#alias prepend_args='set_args "${@}"'

# Define critical command-specific aliases. Zeshy Process implements similar
# functionality as functions where not implementable here as aliases.
# Define critical boolean-specific aliases. Zeshy Shell implements similar
# functionality as functions where not implementable here as aliases.

    # * If such run throws an exception:
    #   * Catch such exception.
    #   * Reenable this function for subsequent use.
    #   * Rethrow such exception.
    # * Otherwise, reenable this function for subsequent use.

# * O.K.; I've become convinced the "global" global alias is harmful. Why?
#   Because it obfuscates manipulation of files named "global" at the command
#   line. Also, it's non-orthogonal with the "global_alias" global. (Though,
#   technically the two convey completely different options.) In the future, we
#   should clearly minimize the number of global aliases.
# * Ah; I think I've devised a mechanism for accomplishing this sanely. Simply
#   define a function proclaim() (or some other synonym of declare(), but not
#   declare() as that's already a Zsh builtin) aliased as:
#   alias map='proclaim map' 
#   alias string='proclaim string' 
#   And so forth. Then define proclaim() to parse the first argument as the type
#   to be declared, the last argument as the name to be declared, and all
#   intermediate arguments as human-readable options condensed to typeset
#   options: e.g., "global_map const set" expands to
#   "proclaim global_map const set", which eventually... ah, wait. No. That
#   obviously runs up against the classical eval issue, since the executed
#   typeset runs in the local context of proclaim(). *sigh*
# * Right, then. There's no recourse but to manually define the set of all
#   possible aliases: e.g., global_map, global_const_map, etc. For sanity, just
#   define the most commonly used types.
#FIXME: The word "arguments" should probably be truncated to "args", here.
#Rewriting "arguments" every function is slightly silly (and cumbersome).

#       or die "neither \"${alias_name}\" or \"${alias_expansion_if_not_interactive}\" are builtins or commands"
#       alias_expansion_if_not_interactive="${alias_name}"

#   "${alias_expansion_if_not_interactive:c}" == /* or
#   if command_path="$(whence -cp "${command_name}")"; then
#   fi
#   
#   == *': function'
#   not whence -cp "${command_name}"; then
#   fi

    # If the builtin or command to be aliased does not exist, return with error.
    # To avoid costly exception handling on this frequently called helper
    # function, do not throw an exception.
#   if not whence "${command_name}" 1>/dev/null 2>&1; then
#       curse "\"${command_name}\" not a Zsh builtin or command in \$PATH"
#       return_failure
#   fi

# void interactive_alias_if_installed(string alias_specification)
#
# Declare the passed specification as an interactive alias only if the builtin
# or command to be aliased exists. This function is a no-nop if it does not.
#interactive_alias_if_installed() {
#    FIXME: Rewrite. Only call interactive_alias if the passed command is installed.
#    interactive_alias "${@}" 1>/dev/null 2>&1 or true
#}

#   eval "function ${alias_name}() {
#   ${alias_expansion} "\${@}"
#}"
#}
#
#testem() {

#FIXME: No longer convinced these to be necessary. "(( VARNAME1 <= varname2 ))"
#reads much more sensibly than "is ${VARNAME1} deceeds_or_equals ${varname2} si". We
#should probably shift all instances of the latter to the former.
#global_alias equals='-eq'
#global_alias deceeds='-lt'
#global_alias deceeds_or_equals='-le'
#global_alias exceeds='-gt'
#global_alias exceeds_or_equals='-ge'

# ....................{ DECLARATORS ~ modifiers            }....................
# Mark the declared variable as global (i.e., exported). By Zsh convention,
# this and the variable type are ordered opposite to C order: e.g.,
#
#   global_list two_hunters; two_hunters=( "ktulu" "orion" )  # or...
#   local -Ax   two_hunters; two_hunters=( "ktulu" "orion" )  # equivalent!
#global_alias global='-x'

# Mark the declared variable as constant (i.e., read-only). By Zsh convention,
# this and the variable type are ordered opposite to C order: e.g.,
#
#   string const fwtbt="ride the lightning"  # or...
#   local -r     fwtbt="ride the lightning"  # equivalent!
#global_alias const='-r'
