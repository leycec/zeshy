#!/usr/bin/env zsh
# ====================[ alias                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Alias, handling Zeshy aliases. For efficiency, Zeshy is autoload-based.
# Only functions are autoloadable, so aliases are not autoloadable. Only this
# file defines Zeshy aliases.

# ....................{ TYPES ~ aliases                    }....................
# void global_alias(string alias_name, string alias_expansion)
#
# Declare a global alias (i.e., an alias expandable anywhere in an expression
# rather than only in command position).
alias global_alias="alias -g"

# void suffix_alias(string alias_name, string alias_expansion)
#
# Declare a suffix alias (i.e., an alias expandable only at the end of
# expressions, typically for filetypes).
alias suffix_alias="alias -s"

# ....................{ TYPES ~ boolean                    }....................
# void boolean(string variable_name)
#
# Locally declare a boolean. Due to current inadequacies in Zsh, this only
# declares a scalar string local to the current scope. Nonetheless, we
# encourage users use this alias for clarity, forwards compatibility, and
# functional symmetry with the existing integer() and float() built-ins.
alias boolean='local'

# void global_boolean(string variable_name)
#
# Globally declare a boolean.
alias global_boolean='typeset -x'

# ....................{ TYPES ~ integer                    }....................
# Zsh already provides built-in integer() for declaring local integers.

# void integer_in_base(int base, string variable_name)
#
# Locally declare an integer in the passed base (e.g., "16" for hexadecimal).
# Zsh internally retains each integer's base for formatting the string
# representation of each integer in its base when output.
alias integer_in_base='typeset -i'  # yes, "integer" does *NOT* suffice here.

# void global_integer(string variable_name)
#
# Globally declare an integer (i.e., non-fractional number).
alias global_integer='integer -x'

# ....................{ TYPES ~ float                      }....................
# Zsh already provides built-in float() for declaring local floats.

# void float_with_fractional_digit_length(int length, string variable_name)
#
# Locally declare a float (i.e., real number) with exactly the passed number of
# fractional digits.
alias float_with_fractional_digit_length='typeset -F'

# void global_float(string variable_name)
#
# Globally declare a float (i.e., real number).
alias global_float='float -x'

# ....................{ TYPES ~ string                     }....................
# void string(string variable_name)
#
# Locally declare a string.
alias string='local'

# void global_bool(string variable_name)
#
# Globally declare a string.
alias global_string='typeset -x'

# ....................{ TYPES ~ list                       }....................
# Due to current inadequacies in Zsh, lists must be externally initialized:
# e.g.,
#
#   list sequence; sequence=( 'value 1' 'value 2' 'value 3' 'value 4' )

# void list(string variable_name)
#
# Locally declare a list (i.e., sequential array).
alias list='typeset -a'

# void list_set(string variable_name)
#
# Locally declare a list set (i.e., a list ignoring duplicate values).
alias list_set='typeset -Ua'

# void list_tied_string(
#   string text_name, string list_name, string separator = ':')
#
# Declare a string with the passed name "tied" to the list with the passed name.
# This resembles a Perl tie by joining the list's elements with the passed
# separator, defaulting to ":", into a string and updating that string on each
# update (i.e., change) to that list: e.g.,
#
#   list_tied_string arroyo array ' '
#   list array; array=( 'Cuidad' 'Juarez' )
#   print "${arroyo}"  # prints "Cuidad Juarez"
#   array=( 'El' 'Paso' )
#   print "${arroyo}"  # prints "El Paso"
#
# Importantly, note Zsh leaves the list-tied string initially unset -- even if
# the list to which it is tied is set! Hence, list-tied strings should usually
# be declared prior to the list to which they tie. Yes, this is unintuitive.
alias list_tied_string='typeset -T'

# void global_list(string variable_name)
#
# Globally declare a list (i.e., sequential array).
alias global_list='typeset -ax'

# ....................{ TYPES ~ map                        }....................
# Due to current inadequacies in Zsh, maps must be externally initialized: e.g.,
#
#   map hash_map; hash_map=( 'key 1' 'value 1' 'key 2' 'value 2' )

# void map(string variable_name)
#
# Locally declare a map (i.e., associative array).
alias map='typeset -A'

# void map_set(string variable_name)
#
# Locally declare a map set (i.e., a map ignoring duplicate values).
alias map_set='typeset -UA'

# void global_map(string variable_name)
#
# Globally declare a map (i.e., associative array).
alias global_map='typeset -Ax'

# ....................{ GLOBAL ALIASES                     }....................
# bool is(...)
#
# Syntactic sugar signifying the delimiting prefix for a boolean test: e.g.,
#
#   is "PatGoD" == *GoD si and print "Piper methysticum"  # or...
#   [[ "PatGoD" == *GoD ]]  && print "Piper methysticum"  # equivalent!
global_alias is='[['

# void si(void)
#
# Syntactic sugar signifying the delimiting suffix for a boolean test.
global_alias si=']]'

global_alias not='!'
global_alias or='||'
global_alias and='&&'

# ....................{ OPERATORS                          }....................
# void noop(string arg1, string arg2, ...)
#
# Perform parameter expansion on all passed parameters. This alias runs no
# commands and thus always returns successfully.
alias noop=':'

# ....................{ OPTIONS                            }....................
# void localize_zsh_options(string option_name1, string option_name2, ...)
#
# Confine the passed Zsh options to the current context. This is particularly
# helpful for localizing such options to function calls: e.g.,
#
#     risky_non_business() {
#         localize_zsh_options no_warn_create_global
#         a_new_hopelessness="This shall not fail!"
#     }
alias localize_zsh_options='setopt local_options'

# ....................{ PIPES                              }....................
# void close_standard_input(void)
#
# Close the standard input file descriptor (0) and named pipe ("/dev/stdin").
alias close_standard_input='exec 0<&-'

# void close_standard_output(void)
#
# Close the standard output file descriptor (1) and named pipe ("/dev/stdout").
alias close_standard_output='exec 1>&-'

# void close_standard_error(void)
#
# Close the standard error file descriptor (2) and named pipe ("/dev/stderr").
alias close_standard_error='exec 2>&-'

#FIXME: Broken now! Fixup or drop entirely.
# void set_args_to_piped_input(void)
#
# If standard input to the current function or script is a pipe, set the list of
# arguments for such function or script to such input. This is typically used as
# the first function or script line, if expecting piped input.
alias set_args_to_piped_input='is_piped_input and {
    set_args "$(< /dev/stdin)";
    close_standard_input
}'

# ....................{ RETURN VALUES                      }....................
#FIXME: Fix now-broken examples in "README.dev". Also, extend to restore_map().
# void restore_list(void)
#
# Convert the string piped on standard input to a local list named "list",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_list().
alias restore_list='{
    is -p /dev/stdin si or die "\"/dev/stdin\" not a pipe";
    is -n "${list+x}" si or list list;
    list=( ${(z)"$(< /dev/stdin)"} )
}'

# void return_exit_status(void)
#
# Return the exit status of the callable piped into this alias: e.g.,
#
#     # Returns the exit status of one of two randomly selected greps.
#     >>> catamount() {
#     ...     if is_odd $(get_random_number)
#     ...     then grep Panthera /onca | return_exit_status
#     ...     else grep Puma /concolor | return_exit_status
#     ...     fi
#     ... }
#     >>> catamount or print 'Mountain lions abound/Ever abiding onward.'
#     Mountain lions abound/Ever abiding onward.
#
# Do not use the conventional implementation of such logic (e.g., "${?}"). Due
# to our use of TRAPZERR(), such logic does not work as expected: e.g.,
#
#     # Raises exceptions rather than returning false on grep failure.
#     >>> catamount_bad() {
#     ...     if is_odd $(get_random_number)
#     ...     then grep Panthera /onca; return $?
#     ...     else grep Puma /concolor; return $?
#     ...     fi
#     ... }
#     >>> catamount_bad or print 'Tricolor ipomoea and the congress of concolor'
#     catamount_bad: "/onca" not found
alias return_exit_status='true and return ${pipestatus[-2]}'

# ....................{ UI                                 }....................
# string interactively(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command only where the current shell is interactive.
alias interactively='is_interactive and'

# ....................{ ARGUMENTS ~ tests                  }....................
# Define critical argument-specific aliases.

# bool is_no_args(void)
#
# Return true if the caller was called with no arguments.
alias is_no_args='(( # == 0 ))'

# bool is_args(void)
#
# Return true if the caller was called with at least one argument.
alias is_args='(( # > 0 ))'
alias is_at_least_one_arg=is_args

# bool is_one_arg(void)
#
# Return true if the caller was called with exactly one argument.
alias is_one_arg='(( # == 1 ))'

# bool is_two_args(void)
#
# Return true if the caller was called with exactly two arguments.
alias is_two_args='(( # == 2 ))'

# bool is_at_least_two_args(void)
#
# Return true if the caller was called with at least two arguments.
alias is_at_least_two_args='(( # >= 2 ))'

# bool is_at_least_three_args(void)
#
# Return true if the caller was called with at least three arguments.
alias is_at_least_three_args='(( # >= 3 ))'

# bool is_at_most_two_args(void)
#
# Return true if the caller was called with at most two arguments.
alias is_at_most_two_args='(( # <= 2 ))'

# bool is_at_most_three_args(void)
#
# Return true if the caller was called with at most three arguments.
alias is_at_most_three_args='(( # <= 3 ))'

# ....................{ ARGUMENTS ~ exceptions             }....................
# string make_die_unless_alias(string test_condition)
#
# Convert the passed math condition into a die_unless_*() alias expansion.
make_die_unless_alias() {
    print -- "(( ${1} )) || die"
}

# void die_if_args(void)
#
# Die with a canonical message if the caller passed any arguments.
alias die_if_args='is_args and die "expected no arguments"'

# void die_unless_args(string error_message)
#
# Die with the passed message unless the caller passed at least one argument.
alias die_unless_args="$(make_die_unless_alias '# > 0')"

# void die_unless_one_arg(string error_message)
#
# Die with the passed message unless the caller passed exactly one argument.
alias die_unless_one_arg="$(make_die_unless_alias '# == 1')"

# void die_unless_two_args(string error_message)
#
# Die with the passed message unless the caller passed exactly two arguments.
alias die_unless_two_args="$(make_die_unless_alias '# == 2')"

# void die_unless_three_args(string error_message)
#
# Die with the passed message unless the caller passed exactly three arguments.
alias die_unless_three_args="$(make_die_unless_alias '# == 3')"

# void die_unless_four_args(string error_message)
#
# Die with the passed message unless the caller passed exactly four arguments.
alias die_unless_four_args="$(make_die_unless_alias '# == 4')"

# void die_unless_one_or_two_args(string error_message)
#
# Die with the passed message unless the caller passed either one or two
# arguments.
alias die_unless_one_or_two_args="$(make_die_unless_alias '# == 1 || # == 2')"

# void die_unless_two_or_three_args(string error_message)
#
# Die with the passed message unless the caller passed either two or three
# arguments.
alias die_unless_two_or_three_args="$(make_die_unless_alias '# == 2 || # == 3')"

# void die_unless_three_or_four_args(string error_message)
#
# Die with the passed message unless the caller passed either three or four
# arguments.
alias die_unless_three_or_four_args="$(make_die_unless_alias '# == 3 || # == 4')"

# void die_unless_one_to_three_args(string error_message)
#
# Die with the passed message unless the caller passed at least one and at most
# three arguments.
alias die_unless_one_to_three_args="$(make_die_unless_alias '# >= 1 && # <= 3')"

# void die_unless_one_to_four_args(string error_message)
#
# Die with the passed message unless the caller passed at least one and at most
# four arguments.
alias die_unless_one_to_four_args="$(make_die_unless_alias '# >= 1 && # <= 4')"

# void die_unless_at_least_one_arg(string error_message)
#
# Die with the passed message unless the caller passed at least one argument.
alias die_unless_at_least_one_arg="$(make_die_unless_alias '# >= 1')"

# void die_unless_at_least_two_args(string error_message)
#
# Die with the passed message unless the caller passed at least two arguments.
alias die_unless_at_least_two_args="$(make_die_unless_alias '# >= 2')"

# void die_unless_at_least_three_args(string error_message)
#
# Die with the passed message unless the caller passed at least three arguments.
alias die_unless_at_least_three_args="$(make_die_unless_alias '# >= 3')"

# void die_unless_at_most_one_arg(string error_message)
#
# Die with the passed message unless the caller passed at most one argument.
alias die_unless_at_most_one_arg="$(make_die_unless_alias '# <= 1')"

# void die_unless_at_most_two_args(string error_message)
#
# Die with the passed message unless the caller passed at most two arguments.
alias die_unless_at_most_two_args="$(make_die_unless_alias '# <= 2')"

# void die_unless_at_most_three_args(string error_message)
#
# Die with the passed message unless the caller passed at most three arguments.
alias die_unless_at_most_three_args="$(make_die_unless_alias '# <= 3')"

# void die_unless_at_most_four_args(string error_message)
#
# Die with the passed message unless the caller passed at most four arguments.
alias die_unless_at_most_four_args="$(make_die_unless_alias '# <= 4')"

# Delete the temporary function used to construct the above aliases.
unfunction make_die_unless_alias

# ....................{ ARGUMENTS ~ modifiers              }....................
# For clarity, Zeshy uses the verbs "shift" and "pop" in the Perl sense.

# string get_args(void)
#
# Get the current argument list as a concatenated string.
alias get_args='print -r -- ${*}'

# void set_args(string arg1, string arg2, ...)
#
# Set the current argument list to the passed arguments.
alias set_args='set --'

# void append_args(string arg1, string arg2, ...)
#
# Append the passed arguments to the end of the current argument list.
alias append_args='set_args "${@}"'

# void shift_args(int args = 1)
#
# Remove the passed number of arguments (defaulting to 1) from the beginning of
# the current argument list.
alias shift_args='shift'

# void shift_one_arg(void)
#
# Remove the first argument from the current argument list.
alias shift_one_arg='shift 1'

# void shift_two_args(void)
#
# Remove the first two arguments from the current argument list.
alias shift_two_args='shift 2'

# void shift_three_args(void)
#
# Remove the first three arguments from the current argument list.
alias shift_three_args='shift 3'

# void pop_one_arg(void)
#
# Remove the last argument from the current argument list.
alias pop_one_arg='set -- ${@[1,-2]}'
#alias pop_one_arg='@[-1]=()'

# void pop_two_args(void)
#
# Remove the last two arguments from the current argument list.
alias pop_two_args='set -- ${@[1,-3]}'

# void pop_three_args(void)
#
# Remove the last three arguments from the current argument list.
alias pop_three_args='set -- ${@[1,-4]}'

# ....................{ ARGUMENTS ~ parsers                }....................
# void parse_args(string argument_spec1, string argument_spec2, ...)
#
# Parse script (or function) arguments according to the passed zparseopts()-
# style argument specifications into map "ARGS". For details on specification
# format, search "man zshmodules" for "zparseopts". For convenience, "-h" and
# "--help" are always parsed as valid argument options: e.g.,
#
#   # Set fake command-line arguments.
#   >>> set -- -d --ad --crest "glass arm shattering"
#
#   # Parse such arguments as:
#   #
#   # * "--ad", a long option followed by no value.
#   # * "--crest", a long option followed by some value.
#   # * "--wing", a long option optionally followed by some value.
#   >>> parse_args d e -ad -crest: -wing::
#
#   # Validate such parsing.
#   >>> is_map_key 'ARGS' '-d' and print 'option "-d" parsed'
#   option "-d" parsed
#   >>> echo "-d: ${ARGS[-d]}\n--ad: ${ARGS[--crest]}\n--wing: ${ARGS[--wing]}"
#   -d:
#   --crest: glass arm shattering
#   --wing:
alias parse_args='zparseopts -D -E -A ARGS -- h -help'

# --------------------( WASTELANDS                         )--------------------
#FIXME: Not quite right. Should technically read "#funcstack == 1". We
#temporarily permit one additional layer of function calls to permit calls by
#interactive aliases to be considered as "directly." While we should certainly
#revert this back to "#funcstack == 1", doing so requires we leverage function
#aliases rather than interactive aliases: e.g., rather than this
#
#    interactive_alias cd='change_path'
#    change_path() { ... }
#
#we do this:
#
#    change_path cd() { ... }
#
#It's more or less fine for now, but should be looked at.
#FIXME: Actually, this is pretty terrible, and should be excised everywhere
#currently called (which shouldn't be terribly many, by now).

# string is_interactive_directly(string command_name, string option1, string option2, ...)
#
# Return true if:
#
# * The current function was not called by another function (i.e., was called
#   directly by the current user from the command-line interface).
# * The current shell is attached to a terminal device and interactively reading
#   commands from standard input.
#alias is_interactive_directly='(( ${#funcstack} <= 2 )) and is_interactive'

#alias set_args_to_piped_input='is_piped_input and set_args "$(get_piped_input)"'
#FIXME: !!!!!DEPRECATED!!!!! This alias has **SEVERE** fatal errors.
#Necessarily use set_to_piped_input() instead.
# string get_piped_input(void)
#
# Get the standard input piped to the current function or script as a string.
# This is typically used with is_piped_input(): e.g.,
#
#     >>> ska_maria() {
#     ...     if is_piped_input
#     ...     then print -- "$(get_piped_input)"
#     ...     else print -- "${@}"
#     ...     fi
#     ... }
#     >>> print pastora | ska_maria
#     pastora
#     >>> ska_maria pastora
#     pastora
#alias get_piped_input='die "this function should be calling set_to_piped_input(), instead!"'

#FIXME: Sweet; these can *ALL* be made functions. Switch! Awesome.
# boolean die_unless_piped_input(void)
#
# Return true if standard input to the current function or script is a pipe.
#alias is_piped_input='is -p /dev/stdin si'

# boolean is_piped_input(void)
#
# Return true if standard input to the current function or script is a pipe.
#alias is_piped_input='is -p /dev/stdin si'

#alias get_piped_input='< /dev/stdin'
#alias get_piped_input='< /dev/stdin && exec 0<&-'

#string output
#sputter output | set_to_piped_input
#set_to_piped_input output
#alias 'piped_input_string
#alias set_to_piped_input='
#    is -n "${__output__+x}" si or string __output__;
#    __output__="$(< /dev/stdin)";
#    exec 0<&-'

#alias set_output_to_piped_input='
#    is -n "${output+x}" si or string output;
#    output="$(< /dev/stdin)";
#    exec 0<&-'

# ....................{ TYPES ~ interactive aliases        }....................
# Defer defining the following functions until having defined all prior aliases.

#FIXME: This functionality has become a bit... extreme. It's great, but too
#large for a top-level component. Shift into a new "always/shell/interactive" or
#"always/shell/alias/interactive" component; then, manually import such
#component if and only if compiling a new digest. The only catch here is that
#such component *CANNOT* call any functions defined in other components. This
#needs to be explicitly documented, up front.

#FIXME: Clean up documentation everywhere below.
#FIXME: Record each added substitution and abbreviation in respective global
#maps, for use in displaying a dynamically constructed "cheat sheet" of all
#current interactive substitutions and abbreviations.
#FIXME: It would be nice to define interactive substitutions and abbreviations
#together in the same function. While this should only ever be an optional
#convenience not replacing the original functions below, it would enable us (in
#particular) to dynamically search for the "nearest" unclaimed abbreviation. For
#example:
#
#    >>> interactive_substitution [p]rint='print -r --'
#
#Way cool. If passed an alias name containing one "[" preceding one "]",
#interpret the alias name with such characters omitted as the full name and the
#substring of such name embedded in such characters as the abbreviation. If the
#latter name has already been claimed by an existing callable, iteractively try
#"pr", "pri", and "prin" before giving up with a warning (but *NOT* exception).
#
#Let's admit it: this is pretty great. But it's not quite enough. We also need
#to handle discontiguous embedded abbreviations resembling:
#
#    >>> interactive_substitution [m]k[d]ir='mkdir -v --'
#
#This suggests a lexical algorithm as follows:
#
#* If the desired abbreviation already exists, iteratively shift the leftmost
#  "]" right unless already prior to the last character of the alias name, in
#  which case print a warning. Hence, we try the following embeddings:
#
#    >>> interactive_substitution {m}k{d}ir='mkdir -v --'
#    >>> interactive_substitution {mkd}ir='mkdir -v --'
#    >>> interactive_substitution {mkdi}r='mkdir -v --'
#
#I suspect this is efficiently implementable without actually shifting around
#lexical characters. Also, note that the implementation requires *NO* changes
#to the existing interactive_abbreviation() or interactive_alias() commands.
#Such commands should, ideally, be entirely unaware of substitution embeddings.
#function interactive_substitution() {
#    (( ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS )) or return_true
#    string ALIAS_TYPE='substitution'
#    interactive_alias "${@}"
#}

# void interactive_abbreviation(string alias_specification)
#
# If the current user has enabled the configuration global
# ${ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS}, define an interactive
# abbreviation according to the passed "="-delimited alias specification: e.g.,
#
#     >>> interactive_abbreviation p="print Thunnus maccoyii"
#     >>> p
#     Thunnus maccoyii
#     >>> () { p }
#     p: interactive abbreviation "p" cannot be called non-interactively
#     print_stack_trace: "p" failed with exit status 1.
#
# Interactive abbreviations are interactive aliases (and hence intended to be
# called only directly from the command line), such that:
#
# * If the passed alias name has the same name as some existing callable (e.g.,
#   builtin, command), print a warning and return without defining such alias.
#
# Interactive abbreviations *NEVER* replace existing callables, but are
# otherwise identical to interactive aliases.
#function interactive_abbreviation() {
#    (( ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS )) or return_true
#    string ALIAS_TYPE='abbreviation'
#    interactive_alias "${@}"
#}

#FIXME: This still isn't quite right. The reason is subtle:
#    interactive_alias ssh='TERM="xterm" ssh -v'
#See what happens there? We attempt to call a command "TERM=\"xterm\"" when
#non-interactive. Of course, we should be calling "ssh". So, this is subtly
#broken. Fixing it requires ignoring all prefixing words containing a "="
#character if such word is not an extant command. (Since, of course, a command
#basename could contain an "=" character. Highly unlikely, but there you go...)
#   *sigh*

# void interactive_alias(string alias_specification)
#
# Declare the passed specification as an interactive alias, active only when the
# builtin or command to be aliased is run directly from an interactive shell.
# Due to implementation details, functions cannot currently be interactively
# aliased. Interactive aliases are inactive in non-interactive scripts and
# functions, and hence helpful for applying human-readable options on that
# builtin or command when run directly by a human. This function fails if the
# builtin or command to be aliased does not exist. See
# interactive_alias_if_installed() for an alternative not failing in such cases.
#
# The alias specification format is identical to that of normal aliases: e.g.,
#
#   # Alias print() to sort arguments only when called interactively.
#   >>> print T M D
#   T M D
#   >>> interactive_alias print="print -o"
#   >>> print T M D
#   D M T
#   >>> print_indirectly() { print "${@}" }
#   >>> print_indirectly T M D
#   T M D
#function interactive_alias() {
    # Validate passed arguments, splitting the "="-delimited alias name and
    # expansion split from all passed strings. Dismantled, this is:
    #
    # * "${*...}", expanding to all passed strings concatenated together.
    # * "[[:space:]]#", excluding zero or more whitespace characters (e.g.,
    #   tab, space) and hence ignoring whitespace surrounding such delimiter.
#    die_unless_args
#    string\
#        alias_name="${*%%[[:space:]]#\=*}"\
#        alias_expansion="${*#*\=[[:space:]]#}"\
#        alias_name_type command_name\
#        alias_expansion_if_interactive alias_expansion_if_non_interactive\
#        alias_logic_if_interactive alias_logic_if_non_interactive
#   print "args: ${*%%=*}"

    # Type of interactive alias to be defined, defaulting to "alias" if not
    # already set by the caller. Recognized types include:
    #
    # * "substitution", only set by interactive_substitution().
    # * "abbreviation", only set by interactive_abbreviation().
    # * "alias", only set by this function.
#    string ALIAS_TYPE="${ALIAS_TYPE:-alias}"
#   is "${ALIAS_TYPE}" == abbreviation si and print "alias type: ${ALIAS_TYPE}\nalias name: ${alias_name}\nalias expansion: ${alias_expansion}" 1>&2

    # Validate passed arguments.
#    is "${ALIAS_TYPE}" == (substitution|abbreviation|alias) si or
#        die "interactive alias type \"${ALIAS_TYPE}\" unrecognized"
#    is "${alias_name}" == "${alias_expansion}" si and
#        die "interactive ${ALIAS_TYPE} specifier \"${*}\" contains no '=' delimiter"
#    (( ${#alias_name} )) or
#        die "interactive ${ALIAS_TYPE} specifier \"${*}\" contains no '='-suffixed alias name"
#    (( ${#alias_expansion} )) or
#        die "interactive ${ALIAS_TYPE} specifier \"${*}\" contains no '='-prefixed alias expansion"

    # If such alias name contains at least one "{"- and "}"-delimited substring,
    # concatenating all such substrings provides the abbreviation name embedded
    # in such alias name (e.g., abbreviation "ichy" in alias "l{ich}mumm{y}").
    # Parse and possibly define such abbreviation.
#    is "${alias_name}" == *'{'*'}'* si and
#        _parse_embedded_interactive_abbreviation

    # If such alias name is already a declared...
#    if alias_name_type="${$(whence -w -- "${alias_name}")##*: }"; then
        # ...Zsh function, throw an exception. Interactive aliases are
        # themselves implemented as functions and hence cannot replace
        # functions of the same name without destroying such functions. As
        # functions may be implemented to account for interactivity (e.g., by
        # calling is_interactive() or interactively()), there is no compelling
        # reason for interactive aliases to silently (usually, erroneously)
        # replace previously declared functions.
#        if is "${alias_name_type}" == 'function' si and
#        then die "interactive ${ALIAS_TYPE} \"${alias_name}\" already a defined function:\n$(which "${alias_name}")"
        # ...any other callable (e.g., alias, builtin, command) and this is an
        # interactive abbreviation, print a warning indicating such abbreviation
        # could not be defined and immediately return.
#        elif is "${ALIAS_TYPE}" == 'abbreviation' si; then
#            curse "interactive abbreviation \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#            return_true
#        # Otherwise, silently wrap such callable in the passed alias.
#        fi
    # If such alias name is *NOT* already a declared callable and this is an
    # interactive substitution alias, there exists nothing to be substituted.
    # Throw an exception.
#    elif is "${ALIAS_TYPE}" == 'substitution' si; then
#        die "interactive substitution \"${alias_name}\" not a defined command or builtin"
    # Otherwise, declare such callable as the the passed alias.
#    fi
#   is "${ALIAS_TYPE}" == abbreviation si and print "still alias name: ${alias_name}" 1>&2

    # If the command (i.e., the first word) the alias expands to is the same as
    # the alias name but is not an existing callable, assume the caller is
    # attempting to interactively alias a function of the same name: e.g.,
    #
    #  interactive_alias recursion='recursion -not -ok'
    #  function recursion() { print 'does not work as expected'; }
    #
    # While Zsh does permit aliases to functions of the same name, interactive
    # aliases are themselves implemented as functions. Hence, the above
    # definition of "function recursion()" silently destroys the previously
    # defined "interactive_alias recursion". To avoid subtle bugs, explicitly
    # prohibit such situations by throwing an exception here.
#    command_name="${alias_expansion[(w)1]}"
#    is "${alias_name}" == "${command_name}" si and
#        not whence -- "${command_name}" 1>/dev/null 2>&1 and
#        die "interactive alias \"${alias_name}\" recursively expands to undefined command or builtin"
#   command_name_type="${$(whence -w -- "${command_name}")##*: }" or
#   is "${ALIAS_TYPE}" == abbreviation si and print "still alias name: ${alias_name}" 1>&2

    # Interactive logic to be performed by the function definition below.
#    alias_expansion_if_interactive="${alias_expansion} \"\${@}\""
#    alias_logic_if_interactive="
#    if is_piped_input
#    then run_with_piped_input ${alias_expansion_if_interactive}
#    else ${alias_expansion_if_interactive}
#    fi"

    # Non-interactive logic to be performed by the function definition below. If
    # this alias name is not already an existing callable (e.g., as in the case
    # of interactive abbreviations), throw an exception. Otherwise, call this alias
    # name as is without expanding the passed expansion.
#    if is "${alias_name_type}" == 'none' si
#    then alias_logic_if_non_interactive="die 'interactive ${ALIAS_TYPE} \"${alias_name}\" cannot be called non-interactively'"
#    else
#        alias_expansion_if_non_interactive="${alias_name} \"\${@}\""
#        alias_logic_if_non_interactive="
#    if is_piped_input
#    then run_with_piped_input ${alias_expansion_if_non_interactive}
#    else ${alias_expansion_if_non_interactive}
#    fi"
#    fi

    # Define the desired alias as a function of the same name to:
    #
    # * Temporarily disable this function to prevent infinite recursion on
    #   subsequently calling an alias, builtin, or command of the same name.
    # * If:
    #   * This shell is interactive, thus excluding non-interactive scripts.
    #   * Standard output is attached to a terminal, thus excluding all
    #     commands in pipe except the last such command.
    #   * This "alias" was called directly from the command line, thus
    #     excluding non-interactive calls from functions.
    #   * Then run the passed alias expansion.
    # * Else, run the desired non-interactive expansion.
    # * Regardless of whether such run throws an exception, always re-enable
    #   this function for subsequent calling.
#    eval "function ${alias_name}() {
#    {
#        disable -f ${alias_name}
#        if [[ -o interactive && -t ${ZESHY_STDOUT} && \${#funcstack} -eq 1 ]]
#        then ${alias_logic_if_interactive}
#        else ${alias_logic_if_non_interactive}
#        fi
#    } always {
#        enable -f ${alias_name}
#    }
#}"
#   is "${ALIAS_TYPE}" == abbreviation si and print "which alias name: $(which ${alias_name})" 1>&2
#}

# void _parse_embedded_interactive_abbreviation(void)
#
# Parse "{"- and "}"-delimited substrings from the current interactive alias
# name of the current type ("substitution" or "abbreviation") expanding to the
# current alias expansion. Concatenating such substrings gives the interactive
# abbreviation embedded in such name (e.g., alias name "l{ich}mumm{y}" embeds
# abbreviation "ichy"). If such type is:
#
# * An abbreviation, return such abbreviation name.
# * A substitution and:
#   * If all possible extensions of the embedded abbreviation have been claimed
#     by existing callables, print a warning and define no such abbreviation.
#   * Otherwise, define such abbreviation to the passed expansion.
#   * In either case, return such alias name stripped of "{" and "}" characters.
#
# This function is a helper intended to be called only by interactive_alias(),
# thus accepting no arguments and returning no values.
#_parse_embedded_interactive_abbreviation() {
    # Validate sanity.
#    die_if_args

    # If such abbreviation is invalid, throw an exception.
#    is "${ALIAS_TYPE-}" == 'alias' si and
#        die "interactive ${ALIAS_TYPE} \"${alias_name}\" contains a \"{...}\" but is neither an abbreviation or substitution"
#    is "${alias_name}" == \{[^\{\}]#\} si and
#        die "interactive ${ALIAS_TYPE} \"${alias_name}\" contains a full \"{...}\""
#    is "${alias_name}" == *\{\}* si and
#        die "interactive ${ALIAS_TYPE} \"${alias_name}\" contains an empty \"{}\""
#    is "${alias_name}" == *\{[^\}]# si and
###        die "interactive ${ALIAS_TYPE} \"${alias_name}\" contains an unclosed '{'"

    # Copy of the passed alias name.
#    string alias_name_copy="${alias_name}"

    # Abbreviation name parsed from ${alias_name_copy}.
#    string abbre_name

    # Character succeeding the leftmost "}" in ${alias_name_copy}.
#    string abbre_next_char

    # 1-based indices of the characters immediately preceding and succeeding
    # the leftmost "}" in ${alias_name_copy}.
#    integer\
#        abbre_last_char_index\
#        abbre_next_char_index abbre_next_next_char_index

    # Iteratively shift the leftmost "}" in ${alias_name_copy} right one
    # character until either finding an abbreviation name claimed by no
    # existing callable or reaching the end of ${alias_name_copy}.
#    while true; do
#        abbre_name="${alias_name_copy//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
#       sputter_escaped "abbreviation: ${abbre_name}"
        #FIXME: Reenable!
#        whence -- "${abbre_name}" 1>/dev/null 2>&1 or break

        # Find the index of the leftmost "}" in ${alias_name_copy} by
        # matching the first "{..}" in such copy. Dismantled, this is:
        #
        # * "#", matching from the beginning of ${alias_name_copy}.
        # * "(#m)", setting global integer ${MEND}, the 1-based index of
        #   the last character matched -- in this case, the leftmost "{".
#        noop "${alias_name_copy#(#m)[^\{\}]#\{[^\{\}]##\}}"

        # If the index of the leftmost "}" is the last character in
        # ${alias_name_copy}, the prior iteration shifted such "}" to the
        # end of such copy and hence exhausted all characters. Return!
#        (( abbre_next_char_index = MEND + 1 ))
#        (( abbre_next_char_index < ${#alias_name_copy} )) or break

        # Otherwise, get the character succeeding the leftmost "}".
#        (( abbre_last_char_index = MEND - 1 ))
#       sputter "abbre_next_char_index: ${abbre_next_char_index}"
#        abbre_next_char="${alias_name_copy[${abbre_next_char_index}]}"

        # Shift the leftmost "}" in ${alias_name_copy} right one character.
        #
        # If the character succeeding the leftmost "}" is a "{", there exist
        # two adjacent "{..}" expressions (e.g., "{mk}{d}ir"). Do not shift
        # the "}" to the right of the "{" (e.g., "{mk{}d}ir"); rather, merge
        # the two expressions (e.g., "{mkd}ir").
#        if is "${abbre_next_char}" == '{' si; then
#            (( ++abbre_next_char_index ))
#            alias_name_copy="${alias_name_copy[1,${abbre_last_char_index}]}${alias_name_copy[${abbre_next_char_index},-1]}"
        # Otherwise, simply shift the leftmost "}" right one character.
#        else
#            (( abbre_next_next_char_index = abbre_next_char_index + 1 ))
#            alias_name_copy="${alias_name_copy[1,${abbre_last_char_index}]}${abbre_next_char}}${alias_name_copy[${abbre_next_next_char_index},-1]}"
#        fi
#       sputter "new alias name: ${alias_name_copy}"
#    done

    # If all possible abbreviation names have already been claimed by
    # existing callables and:
    #
    # * This is an interactive substitution, print a warning and define no
    #   such abbreviation.
    # * This is an interactive abbreviation, do nothing (i.e., attempt to
    #   use the entire alias name stripped of "{" and "}" characters as the
    #   abbreviation name).
#    if (( abbre_next_char_index == ${#alias_name_copy} )); then
#        if is "${ALIAS_TYPE}" == 'substitution' si; then
#            string abbre_name_type
#            abbre_name="${alias_name//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
#            abbre_name_type="${$(whence -w -- "${abbre_name}")##*: }"
#            curse "abbreviation \"${abbre_name}\" in interactive substitution \"${alias_name}\" already a defined ${abbre_name_type}:\n$(which "${abbre_name}")"
#        fi
    # If this is an interactive substitution, define an interactive
    # abbreviation of the above abbreviation name and same expansion as this
    # substitution. While this does recursively call interactive_alias(), such
    # call *NEVER* performs another recursive call. (Why? Listen closely: such
    # abbreviation name contains no "{" or "}" characters and hence no embedded
    # abbreviation. Since such recursive call never calls this function, the
    # recursion is guaranteed to "bottom out" after the first recursion.)
#    elif is "${ALIAS_TYPE}" == 'substitution' si; then
#       print "abbreviating embedded ${abbre_name}=\"${alias_expansion}\"" 1>&2
#        interactive_abbreviation ${abbre_name}="${alias_expansion}"
    # If this is an interactive abbreviation, set the alias name to be returned
    # to the above abbreviation name.
#    else alias_name="${abbre_name}"
#    fi

    # Strip "{" and "}" characters from the alias name to be returned.
#    alias_name="${alias_name//[\{\}]}"
#}
