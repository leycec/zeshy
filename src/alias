#!/usr/bin/env zsh
# ====================[ alias                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Alias, handling Zeshy aliases. For efficiency, Zeshy is autoload-based.
# Only functions are autoloadable, so aliases are not autoloadable. Only this
# file defines Zeshy aliases.
#
# --------------------( TODO                               )--------------------
# * Technically, we can support interactive aliases on functions -- but only
#   in somewhat roundabout fashion. We would need detect this to be an alias on a
#   function (easy), then define a new function with the same implementation as the
#   function to be replaced by such alias but with a new name, say,
#   "${alias_name}____tmp" (perhaps easy; doesn't "which ${function_name}" provide
#   us a function implementation which we could then eval into a new function with
#   such placeholder name?), then replace the old with the new function name in the
#   alias expansion (easy). It's a bit involved, but nothing too intractable.

# ....................{ TYPES ~ aliases                    }....................
# void global_alias(string alias_name, string alias_expansion)
#
# Declare a global alias (i.e., an alias expandable anywhere in an expression
# rather than only in command position).
alias global_alias="alias -g"

# void suffix_alias(string alias_name, string alias_expansion)
#
# Declare a suffix alias (i.e., an alias expandable only at the end of
# expressions, typically for filetypes).
alias suffix_alias="alias -s"

# ....................{ TYPES ~ boolean                    }....................
# void boolean(string variable_name)
#
# Locally declare a boolean. Due to current inadequacies in Zsh, this only
# declares a scalar string local to the current scope. Nonetheless, we
# encourage users use this alias for clarity, forwards compatibility, and
# functional symmetry with the existing integer() and float() built-ins.
alias boolean='local'

# void global_boolean(string variable_name)
#
# Globally declare a boolean.
alias global_boolean='typeset -x'

# ....................{ TYPES ~ integer                    }....................
# Zsh already provides built-in integer() for declaring local integers.

# void integer_in_base(int base, string variable_name)
#
# Locally declare an integer in the passed base (e.g., "16" for hexadecimal).
# Zsh internally retains each integer's base for formatting the string
# representation of each integer in its base when output.
alias integer_in_base='typeset -i'  # yes, "integer" does *NOT* suffice here.

# void global_integer(string variable_name)
#
# Globally declare an integer (i.e., non-fractional number).
alias global_integer='integer -x'

# ....................{ TYPES ~ float                      }....................
# Zsh already provides built-in float() for declaring local floats.

# void float_with_fractional_digit_length(int length, string variable_name)
#
# Locally declare a float (i.e., real number) with exactly the passed number of
# fractional digits.
alias float_with_fractional_digit_length='typeset -F'

# void global_float(string variable_name)
#
# Globally declare a float (i.e., real number).
alias global_float='float -x'

# ....................{ TYPES ~ string                     }....................
# void string(string variable_name)
#
# Locally declare a string.
alias string='local'

# void global_bool(string variable_name)
#
# Globally declare a string.
alias global_string='typeset -x'

# ....................{ TYPES ~ list                       }....................
# Due to current inadequacies in Zsh, lists must be externally initialized:
# e.g.,
#
#   list sequence; sequence=( 'value 1' 'value 2' 'value 3' 'value 4' )

# void list(string variable_name)
#
# Locally declare a list (i.e., sequential array).
alias list='typeset -a'

# void list_set(string variable_name)
#
# Locally declare a list set (i.e., a list ignoring duplicate values).
alias list_set='typeset -Ua'

# void list_tied_string(
#   string text_name, string list_name, string separator = ':')
#
# Declare a string with the passed name "tied" to the list with the passed name.
# This resembles a Perl tie by joining the list's elements with the passed
# separator, defaulting to ":", into a string and updating that string on each
# update (i.e., change) to that list: e.g.,
#
#   list_tied_string arroyo array ' '
#   list array; array=( 'Cuidad' 'Juarez' )
#   print "${arroyo}"  # prints "Cuidad Juarez"
#   array=( 'El' 'Paso' )
#   print "${arroyo}"  # prints "El Paso"
#
# Importantly, note Zsh leaves the list-tied string initially unset -- even if
# the list to which it is tied is set! Hence, list-tied strings should usually
# be declared prior to the list to which they tie. Yes, this is unintuitive.
alias list_tied_string='typeset -T'

# void global_list(string variable_name)
#
# Globally declare a list (i.e., sequential array).
alias global_list='typeset -ax'

# ....................{ TYPES ~ map                        }....................
# Due to current inadequacies in Zsh, maps must be externally initialized: e.g.,
#
#   map hash_map; hash_map=( 'key 1' 'value 1' 'key 2' 'value 2' )

# void map(string variable_name)
#
# Locally declare a map (i.e., associative array).
alias map='typeset -A'

# void map_set(string variable_name)
#
# Locally declare a map set (i.e., a map ignoring duplicate values).
alias map_set='typeset -UA'

# void global_map(string variable_name)
#
# Globally declare a map (i.e., associative array).
alias global_map='typeset -Ax'

# ....................{ GLOBAL ALIASES                     }....................
# bool is(...)
#
# Syntactic sugar signifying the delimiting prefix for a boolean test: e.g.,
#
#   is "PatGoD" == *GoD si and print "Piper methysticum"  # or...
#   [[ "PatGoD" == *GoD ]]  && print "Piper methysticum"  # equivalent!
global_alias is='[['

# void si(void)
#
# Syntactic sugar signifying the delimiting suffix for a boolean test.
global_alias si=']]'

global_alias not='!'
global_alias or='||'
global_alias and='&&'

# ....................{ OPERATORS                          }....................
# void noop(string arg1, string arg2, ...)
#
# Perform parameter expansion on all passed parameters. This alias runs no
# commands and thus always returns successfully.
alias noop=':'

# ....................{ OPTIONS                            }....................
# void localize_zsh_options(string option_name1, string option_name2, ...)
#
# Confine the passed Zsh options to the current context. This is particularly
# helpful for localizing such options to function calls: e.g.,
#
#     risky_non_business() {
#         localize_zsh_options no_warn_create_global
#         a_new_hopelessness="This shall not fail!"
#     }
alias localize_zsh_options='setopt local_options'

# ....................{ PIPES                              }....................
# bool is_piped_input(void)
#
# Return true if standard input to the current function or script is a pipe.
alias is_piped_input='is -p /dev/stdin si'

# string pass_piped_input_to(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command by piping the standard input piped to the current
# function or script to such command. Typically, this alias is used in concert
# with the is_piped_input() alias to seemlessly propagate input: e.g.,
#
#     >>> salvia() {
#     ...     if is_piped_input
#     ...     then pass_piped_input_to cat
#     ...     else print -- "${@}"     cat
#     ...     fi
#     ... }
#     >>> print  divinorum | salvia
#     divinorum
#     >>> salvia divinorum
#     divinorum
alias pass_piped_input_to='cat /dev/stdin |'

# string get_piped_input(void)
#
# Get the standard input piped to the current function or script as a string.
# This is typically used with is_piped_input(): e.g.,
#
#     >>> ska_maria() {
#     ...     if is_piped_input
#     ...     then print -- "$(get_piped_input)"
#     ...     else print -- "${@}"
#     ...     fi
#     ... }
#     >>> print pastora | ska_maria
#     pastora
#     >>> ska_maria pastora
#     pastora
alias get_piped_input='< /dev/stdin'

# void set_args_to_piped_input(void)
#
# If standard input to the current function or script is a pipe, set the list of
# arguments for such function or script to such input. This is typically used as
# the first function or script line, if expecting piped input.
alias set_args_to_piped_input='is_piped_input and set_args "$(get_piped_input)"'

# ....................{ RETURN VALUES                      }....................
#FIXME: Fix now-broken examples in "README.dev". Also, extend to restore_map().
# void restore_list(void)
#
# Convert the string piped on standard input to a local list named "list",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_list().
alias restore_list='{
    is -p /dev/stdin si or die "\"/dev/stdin\" not a pipe";
    list list; list=( ${(z)"$(< /dev/stdin)"} )
}'

# void return_exit_status(void)
#
# Return the exit status of the callable piped into this alias: e.g.,
#
#     # Returns the exit status of one of two randomly selected greps.
#     >>> catamount() {
#     ...     if is_odd $(get_random_number)
#     ...     then grep Panthera /onca | return_exit_status
#     ...     else grep Puma /concolor | return_exit_status
#     ...     fi
#     ... }
#     >>> catamount or print 'Mountain lions abound/Ever abiding onward.'
#     Mountain lions abound/Ever abiding onward.
#
# Do not use the conventional implementation of such logic (e.g., "${?}"). Due
# to our use of TRAPZERR(), such logic does not work as expected: e.g.,
#
#     # Raises exceptions rather than returning false on grep failure.
#     >>> catamount_bad() {
#     ...     if is_odd $(get_random_number)
#     ...     then grep Panthera /onca; return $?
#     ...     else grep Puma /concolor; return $?
#     ...     fi
#     ... }
#     >>> catamount_bad or print 'Tricolor ipomoea and the congress of concolor'
#     catamount_bad: "/onca" not found
alias return_exit_status='true and return ${pipestatus[-2]}'

# ....................{ UI                                 }....................
# string interactively(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command only where the current shell is interactive.
alias interactively='is_interactive and'

#FIXME: Not quite right. Should technically read "#funcstack == 1". We
#temporarily permit one additional layer of function calls to permit calls by
#interactive aliases to be considered as "directly." While we should certainly
#revert this back to "#funcstack == 1", doing so requires we leverage function
#aliases rather than interactive aliases: e.g., rather than this
#
#    interactive_alias cd='change_path'
#    change_path() { ... }
#
#we do this:
#
#    change_path cd() { ... }
#
#It's more or less fine for now, but should be looked at.

#FIXME: Actually, this is pretty terrible, and should be excised everywhere
#currently called (which shouldn't be terribly many, by now).

# string is_interactive_directly(string command_name, string option1, string option2, ...)
#
# Return true if:
#
# * The current function was not called by another function (i.e., was called
#   directly by the current user from the command-line interface).
# * The current shell is attached to a terminal device and interactively reading
#   commands from standard input.
alias is_interactive_directly='(( ${#funcstack} <= 2 )) and is_interactive'

# ....................{ ARGUMENTS ~ tests                  }....................
# Define critical argument-specific aliases.

# bool is_no_args(void)
#
# Return true if the caller was called with no arguments.
alias is_no_args='(( # == 0 ))'

# bool is_args(void)
#
# Return true if the caller was called with at least one argument.
alias is_args='(( # > 0 ))'
alias is_at_least_one_arg=is_args

# bool is_one_arg(void)
#
# Return true if the caller was called with exactly one argument.
alias is_one_arg='(( # == 1 ))'

# bool is_two_args(void)
#
# Return true if the caller was called with exactly two arguments.
alias is_two_args='(( # == 2 ))'

# bool is_at_least_two_args(void)
#
# Return true if the caller was called with at least two arguments.
alias is_at_least_two_args='(( # >= 2 ))'

# bool is_at_least_three_args(void)
#
# Return true if the caller was called with at least three arguments.
alias is_at_least_three_args='(( # >= 3 ))'

# bool is_at_most_two_args(void)
#
# Return true if the caller was called with at most two arguments.
alias is_at_most_two_args='(( # <= 2 ))'

# bool is_at_most_three_args(void)
#
# Return true if the caller was called with at most three arguments.
alias is_at_most_three_args='(( # <= 3 ))'

# ....................{ ARGUMENTS ~ exceptions             }....................
# string make_die_unless_alias(string test_condition)
#
# Convert the passed math condition into a die_unless_*() alias expansion.
make_die_unless_alias() {
    print -- "(( ${1} )) || die"
}

# void die_if_args(void)
#
# Die with a canonical message if the caller passed any arguments.
alias die_if_args='is_args and die "expected no arguments"'

# void die_unless_args(string error_message)
#
# Die with the passed message unless the caller passed at least one argument.
alias die_unless_args="$(make_die_unless_alias '# > 0')"

# void die_unless_one_arg(string error_message)
#
# Die with the passed message unless the caller passed exactly one argument.
alias die_unless_one_arg="$(make_die_unless_alias '# == 1')"

# void die_unless_two_args(string error_message)
#
# Die with the passed message unless the caller passed exactly two arguments.
alias die_unless_two_args="$(make_die_unless_alias '# == 2')"

# void die_unless_three_args(string error_message)
#
# Die with the passed message unless the caller passed exactly three arguments.
alias die_unless_three_args="$(make_die_unless_alias '# == 3')"

# void die_unless_four_args(string error_message)
#
# Die with the passed message unless the caller passed exactly four arguments.
alias die_unless_four_args="$(make_die_unless_alias '# == 4')"

# void die_unless_one_or_two_args(string error_message)
#
# Die with the passed message unless the caller passed either one or two
# arguments.
alias die_unless_one_or_two_args="$(make_die_unless_alias '# == 1 || # == 2')"

# void die_unless_two_or_three_args(string error_message)
#
# Die with the passed message unless the caller passed either two or three
# arguments.
alias die_unless_two_or_three_args="$(make_die_unless_alias '# == 2 || # == 3')"

# void die_unless_three_or_four_args(string error_message)
#
# Die with the passed message unless the caller passed either three or four
# arguments.
alias die_unless_three_or_four_args="$(make_die_unless_alias '# == 3 || # == 4')"

# void die_unless_one_to_three_args(string error_message)
#
# Die with the passed message unless the caller passed at least one and at most
# three arguments.
alias die_unless_one_to_three_args="$(make_die_unless_alias '# >= 1 && # <= 3')"

# void die_unless_one_to_four_args(string error_message)
#
# Die with the passed message unless the caller passed at least one and at most
# four arguments.
alias die_unless_one_to_four_args="$(make_die_unless_alias '# >= 1 && # <= 4')"

# void die_unless_at_least_one_arg(string error_message)
#
# Die with the passed message unless the caller passed at least one argument.
alias die_unless_at_least_one_arg="$(make_die_unless_alias '# >= 1')"

# void die_unless_at_least_two_args(string error_message)
#
# Die with the passed message unless the caller passed at least two arguments.
alias die_unless_at_least_two_args="$(make_die_unless_alias '# >= 2')"

# void die_unless_at_least_three_args(string error_message)
#
# Die with the passed message unless the caller passed at least three arguments.
alias die_unless_at_least_three_args="$(make_die_unless_alias '# >= 3')"

# void die_unless_at_most_one_arg(string error_message)
#
# Die with the passed message unless the caller passed at most one argument.
alias die_unless_at_most_one_arg="$(make_die_unless_alias '# <= 1')"

# void die_unless_at_most_two_args(string error_message)
#
# Die with the passed message unless the caller passed at most two arguments.
alias die_unless_at_most_two_args="$(make_die_unless_alias '# <= 2')"

# void die_unless_at_most_three_args(string error_message)
#
# Die with the passed message unless the caller passed at most three arguments.
alias die_unless_at_most_three_args="$(make_die_unless_alias '# <= 3')"

# void die_unless_at_most_four_args(string error_message)
#
# Die with the passed message unless the caller passed at most four arguments.
alias die_unless_at_most_four_args="$(make_die_unless_alias '# <= 4')"

# Delete the temporary function used to construct the above aliases.
unfunction make_die_unless_alias

# ....................{ ARGUMENTS ~ modifiers              }....................
# For clarity, Zeshy uses the verbs "shift" and "pop" in the Perl sense.

# void set_args(string arg1, string arg2, ...)
#
# Set the current argument list to the passed arguments.
alias set_args='set --'

# void append_args(string arg1, string arg2, ...)
#
# Append the passed arguments to the end of the current argument list.
alias append_args='set_args "${@}"'

# void shift_args(int args = 1)
#
# Remove the passed number of arguments (defaulting to 1) from the beginning of
# the current argument list.
alias shift_args='shift'

# void shift_one_arg(void)
#
# Remove the first argument from the current argument list.
alias shift_one_arg='shift 1'

# void shift_two_args(void)
#
# Remove the first two arguments from the current argument list.
alias shift_two_args='shift 2'

# void shift_three_args(void)
#
# Remove the first three arguments from the current argument list.
alias shift_three_args='shift 3'

# void pop_one_arg(void)
#
# Remove the last argument from the current argument list.
alias pop_one_arg='set -- ${@[1,-2]}'
#alias pop_one_arg='@[-1]=()'

# void pop_two_args(void)
#
# Remove the last two arguments from the current argument list.
alias pop_two_args='set -- ${@[1,-3]}'

# void pop_three_args(void)
#
# Remove the last three arguments from the current argument list.
alias pop_three_args='set -- ${@[1,-4]}'

# ....................{ ARGUMENTS ~ parsers                }....................
# void parse_args(string argument_spec1, string argument_spec2, ...)
#
# Parse script (or function) arguments according to the passed zparseopts()-
# style argument specifications into map "ARGS". For details on specification
# format, search "man zshmodules" for "zparseopts". For convenience, "-h" and
# "--help" are always parsed as valid argument options: e.g.,
#
#   # Set fake command-line arguments.
#   >>> set -- -d --ad --crest "glass arm shattering"
#
#   # Parse such arguments as:
#   #
#   # * "--ad", a long option followed by no value.
#   # * "--crest", a long option followed by some value.
#   # * "--wing", a long option optionally followed by some value.
#   >>> parse_args d e -ad -crest: -wing::
#
#   # Validate such parsing.
#   >>> is_map_key 'ARGS' '-d' and print 'option "-d" parsed'
#   option "-d" parsed
#   >>> echo "-d: ${ARGS[-d]}\n--ad: ${ARGS[--crest]}\n--wing: ${ARGS[--wing]}"
#   -d:
#   --crest: glass arm shattering
#   --wing:
alias parse_args='zparseopts -D -E -A ARGS -- h -help'

# ....................{ TYPES ~ interactive aliases        }....................
# Defer defining the following functions until having defined all prior aliases.

#FIXME: Clean up documentation everywhere below.
#FIXME: Record each added substitution and abbreviation in respective global
#maps, for use in displaying a dynamically constructed "cheat sheet" of all
#current interactive substitutions and abbreviations.
#FIXME: It would be nice to define interactive substitutions and abbreviations
#together in the same function. While this should only ever be an optional
#convenience not replacing the original functions below, it would enable us (in
#particular) to dynamically search for the "nearest" unclaimed abbreviation. For
#example:
#
#    >>> interactive_substitution [p]rint='print -r --'
#
#Way cool. If passed an alias name containing one "[" preceding one "]",
#interpret the alias name with such characters omitted as the full name and the
#substring of such name embedded in such characters as the abbreviation. If the
#latter name has already been claimed by an existing callable, iteractively try
#"pr", "pri", and "prin" before giving up with a warning (but *NOT* exception).
#
#Let's admit it: this is pretty great. But it's not quite enough. We also need
#to handle discontiguous embedded abbreviations resembling:
#
#    >>> interactive_substitution [m]k[d]ir='mkdir -v --'
#
#This suggests a lexical algorithm as follows:
#
#* If the desired abbreviation already exists, iteratively shift the leftmost
#  "]" right unless already prior to the last character of the alias name, in
#  which case print a warning. Hence, we try the following embeddings:
#
#    >>> interactive_substitution {m}k{d}ir='mkdir -v --'
#    >>> interactive_substitution {mkd}ir='mkdir -v --'
#    >>> interactive_substitution {mkdi}r='mkdir -v --'
#
#I suspect this is efficiently implementable without actually shifting around
#lexical characters. Also, note that the implementation requires *NO* changes
#to the existing interactive_abbreviation() or interactive_alias() commands.
#Such commands should, ideally, be entirely unaware of substitution embeddings.
function interactive_substitution() {
    # Return unless the current user configuration enables substitutions.
    (( ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS )) or return_true

    # ...
    string alias_name="${*%%[[:space:]]#\=*}"
#   noop "${(S)alias_name//*\{(#b)(*?)\}*}"
#   if ; then
#   if is "${alias_name}" == *'{'(#b)(*?)'}'* si; then
#   if is -n "${(MS)alias_name//*\{(#b)(*?)\}*}" si; then
#   sputter "match attempt: ${(SI:1:)alias_name//*\{(#b)(*?)\}*}"
#   sputter "match attempt: ${(SI:1:)alias_name#\{(#b)(*?)\}}"
#   match=()
#   noop "${(SI:1:)alias_name#\{(#b)(*?)\}}"
#   if is -n "${match}" si; then
#       match=()
#       is "${alias_name}" == (#b)[^{}]#'{'([^{}]##)'}'[^{}]# si
#       is "${alias_name}" == ([^{}]#'{'(#b)([^{}]##)'}')## si
#       is "${alias_name}" == (#b)([^{}]#'{'([^{}]##)'}')## si
#       sputter "alias_name: ${alias_name}"
#       print "${alias_name//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
#       sputter "embedding: ${match[*]}"
#       sputter "embedding: ${(S)alias_name//*\{(#b)(*?)\}*/${match[1]}}"
#       sputter "embedding: ${(S)alias_name//*\{(#b)(*?)\}*/${match[1]}}"
#       integer embedded_first_char_index=$(( ${mend[1]} - 1 ))
#       sputter "match: ${match[1]}; mend: ${mend[1]}"

#   string abbre_name="${alias_name//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
#   if is "${abbre_name}" != "${alias_name}" si; then
#       integer alias_name_length="${#alias_name}" abbre_next_char_index
#       sputter_escaped "abbreviation: ${abbre_name}\nmatch[1]: ${match[1]}\nalias name length: ${alias_name_length}"
    if is "${alias_name}" == *'{'*'}'* si; then
#       string alias_name_munge="${alias_name}"
#       sputter_escaped "abbreviation: ${abbre_name}\nmatch[1]: ${match[1]}"

        is "${alias_name}" == *'{}'* si and
            die "interactive substitution \"${alias_name}\" contains an empty '{}'"
        is "${alias_name}" == *'{'[^}]# si and
            die "interactive substitution \"${alias_name}\" contains an unclosed '{'"

        string new_alias_name="${alias_name}" abbre_name abbre_next_char
        integer abbre_last_char_index abbre_next_char_index

#       while whence -- "${abbre_name}" 1>/dev/null 2>&1; do
        while true; do
            abbre_name="${new_alias_name//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
            sputter_escaped "abbreviation: ${abbre_name}"
            whence -- "${abbre_name}" 1>/dev/null 2>&1 or break

            match=()
            noop "${new_alias_name#(#m)[^\{\}]#\{[^\{\}]##\}}"
#           (( abbre_first_char_index = ${mend[1]} - 1 ))
#           (( abbre_right_brace_index = MEND ))
            (( abbre_next_char_index = MEND + 1 ))
            (( abbre_next_char_index < ${#new_alias_name} )) or break
#           (( abbre_next_char_index < 10 )) or break
            (( abbre_last_char_index = MEND - 1 ))
            sputter "abbre_next_char_index: ${abbre_next_char_index}"
            abbre_next_char="${new_alias_name[${abbre_next_char_index}]}"

            if is "${abbre_next_char}" == '{' si; then
                (( ++abbre_next_char_index ))
                #FIXME: Should be handled by the above exception handling, no?
#               (( abbre_next_char_index < alias_name_length )) or
#                   die "interactive substitution \"${alias_name}\" contains an unclosed '{'"
                new_alias_name="${new_alias_name[1,${abbre_last_char_index}]}${new_alias_name[${abbre_next_char_index},-1]}"
            else
                (( abbre_next_next_char_index = abbre_next_char_index + 1 ))
                new_alias_name="${new_alias_name[1,${abbre_last_char_index}]}${abbre_next_char}}${new_alias_name[${abbre_next_next_char_index},-1]}"
            fi
            sputter "new alias name: ${new_alias_name}"
        done

        (( abbre_next_char_index == ${#new_alias_name} )) and {
            abbre_name="${alias_name//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
            curse "embedded abbreviation \"${abbre_name}\" in interactive substitution \"${alias_name}\" already defined:\n$(which "${abbre_name}")"
            return_true
#           string abbre_name_definition
#           abbre_name_definition=""
#           curse "embedded abbreviation interactive substitution \"${alias_name}\" contains an   "
        }
    else
        string interactive_alias_type='substitution'
        interactive_alias "${@}"
    fi
}

# void interactive_abbreviation(string alias_specification)
#
# If the current user has enabled the configuration global
# ${ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS}, define an interactive
# abbreviation according to the passed "="-delimited alias specification: e.g.,
#
#     >>> interactive_abbreviation p="print Thunnus maccoyii"
#     >>> p
#     Thunnus maccoyii
#     >>> () { p }
#     p: interactive abbreviation "p" cannot be called non-interactively
#     print_stack_trace: "p" failed with exit status 1.
#
# Interactive abbreviations are interactive aliases (and hence intended to be
# called only directly from the command line), such that:
#
# * If the passed alias name has the same name as some existing callable (e.g.,
#   builtin, command), print a warning and return without defining such alias.
#
# Interactive abbreviations *NEVER* replace existing callables, but are
# otherwise identical to interactive aliases.
function interactive_abbreviation() {
    # Return unless the current user configuration enables abbreviations.
    (( ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS )) or return_true

    # Abbreviate.
    string interactive_alias_type='abbreviation'
    interactive_alias "${@}"
}

#FIXME: This still isn't quite right. The reason is subtle:
#    interactive_alias ssh='TERM="xterm" ssh -v'
#See what happens there? We attempt to call a command "TERM=\"xterm\"" when
#non-interactive. Of course, we should be calling "ssh". So, this is subtly
#broken. Fixing it requires ignoring all prefixing words containing a "="
#character if such word is not an extant command. (Since, of course, a command
#basename could contain an "=" character. Highly unlikely, but there you go...)
#   *sigh*

# void interactive_alias(string alias_specification)
#
# Declare the passed specification as an interactive alias, active only when the
# builtin or command to be aliased is run directly from an interactive shell.
# Due to implementation details, functions cannot currently be interactively
# aliased. Interactive aliases are inactive in non-interactive scripts and
# functions, and hence helpful for applying human-readable options on that
# builtin or command when run directly by a human. This function fails if the
# builtin or command to be aliased does not exist. See
# interactive_alias_if_installed() for an alternative not failing in such cases.
#
# The alias specification format is identical to that of normal aliases: e.g.,
#
#   # Alias print() to sort arguments only when called interactively.
#   >>> print T M D
#   T M D
#   >>> interactive_alias print="print -o"
#   >>> print T M D
#   D M T
#   >>> print_indirectly() { print "${@}" }
#   >>> print_indirectly T M D
#   T M D
function interactive_alias() {
    # Validate passed arguments.
    die_unless_args
#   print "args: ${*%%=*}"

    # "="-delimited alias name and expansion split from the passed specifier.
    # Dismantled, this is:
    #
    # * "${*...}", expanding to all passed strings concatenated together.
    # * "[[:space:]]#", excluding zero or more whitespace characters (e.g.,
    #   tab, space) and hence ignoring whitespace surrounding such delimiter.
    string\
        interactive_alias_type="${interactive_alias_type:-alias}"\
        alias_name="${*%%[[:space:]]#\=*}"\
        alias_expansion="${*#*\=[[:space:]]#}"\
        alias_name_type command_name\
        alias_expansion_if_interactive alias_expansion_if_non_interactive\
        alias_logic_if_interactive alias_logic_if_non_interactive
#   print "alias_name: ${alias_name}\nalias_expansion: ${alias_expansion}"

    # If such alias name is already a declared...
    if alias_name_type="${$(whence -w -- "${alias_name}")##*: }"; then
        # ...Zsh function, throw an exception. Interactive aliases are
        # themselves implemented as functions and hence cannot replace
        # functions of the same name without destroying such functions. As
        # functions may be implemented to account for interactivity (e.g., by
        # calling is_interactive() or interactively()), there is no compelling
        # reason for interactive aliases to silently (usually, erroneously)
        # replace previously declared functions.
        if is "${alias_name_type}" == 'function' si and
        then die "interactive ${interactive_alias_type} \"${alias_name}\" already a defined function:\n$(which "${alias_name}")"
        # ...any other callable (e.g., alias, builtin, command) and this is an
        # interactive abbreviation, print a warning indicating such abbreviation
        # could not be defined and immediately return.
        elif is "${interactive_alias_type}" == 'abbreviation' si; then
            curse "interactive abbreviation \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
            return_true
        # Otherwise, silently wrap such callable in the passed alias.
        fi
    # If such alias name is *NOT* already a declared callable and this is an
    # interactive substitution alias, there exists nothing to be substituted.
    # Throw an exception.
    elif is "${interactive_alias_type}" == 'substitution' si; then
        die "interactive substitution \"${alias_name}\" not found in \$PATH"
    # Otherwise, declare such callable as the the passed alias.
    fi

    # If the command (i.e., the first word) the alias expands to is the same as
    # the alias name but is not an existing callable, assume the caller is
    # attempting to interactively alias a function of the same name: e.g.,
    #
    #  interactive_alias recursion='recursion -not -ok'
    #  function recursion() { print 'does not work as expected'; }
    #
    # While Zsh does permit aliases to functions of the same name, interactive
    # aliases are themselves implemented as functions. Hence, the above
    # definition of "function recursion()" silently destroys the previously
    # defined "interactive_alias recursion". To avoid subtle bugs, explicitly
    # prohibit such situations by throwing an exception here.
    command_name="${alias_expansion[(w)1]}"
    is "${alias_name}" == "${command_name}" si and
        not whence -- "${command_name}" 1>/dev/null 2>&1 and
        die "interactive alias \"${alias_name}\" defined recursively but not found in \$PATH"
#   command_name_type="${$(whence -w -- "${command_name}")##*: }" or

    # Interactive logic to be performed by the function definition below.
    alias_expansion_if_interactive="${alias_expansion} \"\${@}\""
    alias_logic_if_interactive="
    if is_piped_input
    then pass_piped_input_to ${alias_expansion_if_interactive}
    else ${alias_expansion_if_interactive}
    fi"

    # Non-interactive logic to be performed by the function definition below. If
    # this alias name is not already an existing callable (e.g., as in the case
    # of interactive abbreviations), throw an exception. Otherwise, call this alias
    # name as is without expanding the passed expansion.
    if is "${alias_name_type}" == 'none' si
    then alias_logic_if_non_interactive="die 'interactive ${interactive_alias_type} \"${alias_name}\" cannot be called non-interactively'"
    else
        alias_expansion_if_non_interactive="${alias_name} \"\${@}\""
        alias_logic_if_non_interactive="
    if is_piped_input
    then pass_piped_input_to ${alias_expansion_if_non_interactive}
    else ${alias_expansion_if_non_interactive}
    fi"
    fi

    # Define the desired alias as a function of the same name to:
    #
    # * Temporarily disable this function to prevent infinite recursion on
    #   subsequently calling an alias, builtin, or command of the same name.
    # * If:
    #   * This shell is interactive, thus excluding non-interactive scripts.
    #   * Standard output is attached to a terminal, thus excluding all
    #     commands in pipe except the last such command.
    #   * This "alias" was called directly from the command line, thus
    #     excluding non-interactive calls from functions.
    #   * Then run the passed alias expansion.
    # * Else, run the desired non-interactive expansion.
    # * Regardless of whether such run throws an exception, always re-enable
    #   this function for subsequent calling.
    eval "function ${alias_name}() {
    {
        disable -f ${alias_name}
        if [[ -o interactive && -t ${ZESHY_STDOUT} && \${#funcstack} -eq 1 ]]
        then ${alias_logic_if_interactive}
        else ${alias_logic_if_non_interactive}
        fi
    } always {
        enable -f ${alias_name}
    }
}"
}

# --------------------( WASTELANDS                         )--------------------
#           case "${interactive_alias_type}" in
            # ...this is an interactive substitution alias and the current user
            # prohibits substituting callables with such aliases, return!
#           substitution) return_true;;
#               is -n "${ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS}" si or
#                   return_true
            # ...this an interactive abbreviation alias, return! Also, if the
            # current user prohibits abbreviating callables with such aliases,
            # print a warning indicating such abbreviation could not be defined.
#           elif is "${interactive_alias_type}" == 'abbreviation' si; then
#               is -n "${ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS}" si or
#                   curse "interactive abbreviation \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#               return_true

    #FIXME: Document. I get it. We were trying to make the above
    #'interactive_alias print="print -o"' example work as expected. But, if you
    #think about it, that's pretty much impossible in the general case. For example,
    #'interactive_alias print="run_paged print -o"' pretty much fails under non-
    #interactivity with the naive assumption of the first word being the command to be
    #run. I'd say this needs dramatic generalization. Basically, the function should
    #strictly accept only one or two arguments; if passed, the second argument tells
    #what to run when non-interactive and otherwise defaults to the following:
    #
    #* If the alias name and first word of the alias expansion are the same and:
    #  * Such name is an existing function, throw an exception (as below) when run
    #    non-interactive.
    #  * Default to such name without arguments (as below) when non-interactive.
    #* Otherwise, default to such name without arguments (as below) when non-interactive.
    #
    #Oh, wait. The above FIXME handles such edge cases, so... simply default to:
    #
    #* If the first word of the alias expansion is a non-empty, non-alias, non-function
    #  (i.e., is a command, builtin, or reserved), such word.
    #* Else if the first word of the alias expansion matches the "run_"* glob and the
    #  second word of such expansion is a non-empty, non-alias, non-function, such word.
    #* Else if the alias name is a non-empty, non-alias, non-function, such name.
    #* Otherwise, throw an exception from within such function definition.
    #
    #Note that *': function' erroneously fails to match aliases. So, just glob
    #*': '(builtin|command|reserved) explicitly. *shrug*
    #
    #This default cleanly handles the prior examples. It won't work in all cases, of
    #course, which is why we permit parameters resembling:
    #
    #    interactive_alias print_up="do_something_curious print -o"' 'print'
    #
    #*ACTUALLY*, the more I think about, the more I realize the above heuristics only
    #apply to the case that the alias name is a non-function (e.g., external command);
    #in such case, the above heuristic can be seemlessly reduced to simply calling such
    #name. If, on the other hand, the alias name is an *ABBREVIATION*, then it should
    #*NEVER* be callable non-interactively; an exception should always be thrown. Since
    #this logic biffurcates cleanly between interactive_alias() and
    #interactive_abbreviation()... You know, why do we even have those two functions?
    #Any interactive alias for which the alias name is *NOT* already an existing non-
    #function is implicitly an abbreviation or something similar. I believe we can
    #dispense with interactive_abbreviation(), therefore.

    #FIXUP: We should probably throw an exception under cases such as:
    #
    #  interactive_alias recursive='recursive -not -ok'
    #  function recursive() { print 'uh oh'; }
    #
    #While recursion *USUALLY* works (due to our use of function disabling and
    #enabling below), it fails if the first word of the alias expansion expands
    #to a Zsh function of the same name as the alias. In the case above, such
    #function has yet to be defined. Hence, *UNLESS* such word has a non-empty,
    #non-function type, we assume its type to be function and throw an exception.

    # The command to expand this alias to when called non-interactively. If the
    # the command to expand this alias to when called interactively is a:
    #
    # * Builtin or command, then this is that builtin or command name sans
    #   subsequent arguments.
    # * Alias or function and:
    #   * The original passed alias name is a builtin or command, then this is
    #     that builtin or command name.
    #   * Otherwise, raise an exception.

#   then alias_logic_if_non_interactive="die '\"${alias_name}\" and \"${command_name}\" are neither builtins or commands and hence cannot be called non-interactively'"
#interactive_alias ff="firefox"
    # The string to expand this alias to when called non-interactively.
#   if is "${alias_name}" == "${command_name}" and\
#      "$(whence -w "${command_name}")" == *': function' si
#   then alias_logic_if_non_interactive="die '\"${alias_name}\" and \"${command_name}\" are neither builtins or commands and hence cannot be called non-interactively'"
        #FIXME: Have my doubts about this logic; it feels... dubious. Too
        #clever, and arguably bug-prone. Let's ride bareback for a bit.
#       if is "${alias_name_type}" != 'function' si
#       then alias_expansion_if_non_interactive="${alias_name}"
#       else alias_expansion_if_non_interactive=
#       fi
#   else
#       alias_expansion_if_non_interactive="${command_name} \"\${@}\""
#       alias_logic_if_non_interactive="
#   if is_piped_input
#   then pass_piped_input_to ${alias_expansion_if_non_interactive}
#   else ${alias_expansion_if_non_interactive}
#   fi"
#   fi

#FIXME: Implement me. Basically, disembowel interactive_alias(). ;]
#define_interactive_alias() {
#}

    #SUBSTITUTION
#   if alias_name_type="${$(whence -w -- "${alias_name}")##*: }"; then
#       if is "${alias_name_type}" == 'function' si; then
#           die "interactive substitution \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#       else
#           is -n "${ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS}" si or
#               return_true
#       fi
#   else
#       die "interactive substitution \"${alias_name}\" not found in \$PATH"
#   fi

    #ABBREVIATION
    # If a function, throw an exception. While Zsh does behave sensibly when
    # aliasing functions (e.g., "alias rm='rm -i'" behaves non-recursively),
    # interactive aliases are functions rather than aliases. Defining an
    # interactive alias of the same name as an existing function thus
    # silently overwrites such function, which is never helpful. Prohibit!
    # If anything other than a function (e.g., builtin, command),
    # emit a warning and return without redefining such builtin or command.
#   alias_name_type="${$(whence -w -- "${alias_name}")##*: }" and
#       is "${alias_name_type}" != 'function' si and {
#       curse "interactive abbreviation \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#       return_true
#   }

    # If such alias name is an existing callable, either emit a warning or throw
    # an exception (depending on the type of such callable).
        # Definition of such callable and appropriate error message.
#       string alias_definition error_message
#       alias_definition=""

#FIXME: ${ZESHY_IS_WRAPPING_BUILTINS} is a rather poor name. Globally rename to
#${ZESHY_IS_WRAPPING_BUILTINS_WITH_INTERACTIVE_ALIASES}, please.

    # Alias name type, if the passed alias name is already declared to be an
    # alias, builtin, command, or function.
#   alias_name_type="${$(whence -w -- "${alias_name}")##*: }" and {
        #FIXME: Shouldn't interactive aliases of real aliases be O.K., also? Hmm; no,
        #I suppose not! We don't call eval() in the function definition, and doing so
        #would introduce yet more bizarre edge-casing. Explicitly document why we
        #currently prohibit this. The current logic here suffices, in any case.

        # Die if already declared unless the current user requests wrapping such
        # types with interactive aliases. In particular, replacing a declared
        # Zsh alias or function with an interactive alias is largely senseless;
        # Zsh aliases and functions may always be implemented to account for
        # interactivity (e.g., by calling is_interactive() or interactively()),
        # thus obviating the need for interactive aliases in such cases. Since
        # silently replacing declared Zsh aliases and functions seems an
        # inherently risky (and certainly useless) proposition, disallow it.
#       if   is "${alias_name_type}" == (builtin|reserved) si
#       then is -n "${ZESHY_IS_WRAPPING_BUILTINS-}" si or return_true
#       elif is "${alias_name_type}" == command si
#       then is -n "${ZESHY_IS_WRAPPING_COMMANDS-}" si or return_true
#       else die\
#           "interactive alias \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#       fi
#   }

    #FIXME: Shouldn't interactive aliases of real aliases be O.K., also? Hmm; no,
    #I suppose not! We don't call eval() in the function definition, and doing so
    #would introduce yet more bizarre edge-casing. Explicitly document why we
    #currently prohibit this. The current logic here suffices, in any case.

    #   and functions with interactive aliases is senseless, as the
    #   former may always be implemented to account for
    #   interactivity (e.g., by calling is_interactive() or interactively()),
    #   thus obviating the need for interactive aliases in such cases. Since
    #   silently replacing declared Zsh aliases and functions seems an
    #   inherently risky (and certainly useless) proposition, disallow it.

        #FIXME: Hmm; we can't say whether or not an alias is invalid without
        #expanding it to its expansion and then taking the name of 
    # Non-interactive logic to be performed by the function definition below.
#   if is -n "${alias_expansion_if_non_interactive}" si; then
#       alias_expansion_if_non_interactive+=' "${@}"'
#       alias_logic_if_non_interactive="
#   if is_piped_input
#   then pass_piped_input_to ${alias_expansion_if_non_interactive}
#   else ${alias_expansion_if_non_interactive}
#   fi"
#   else alias_logic_if_non_interactive="die '\"${alias_name}\" and \"${command_name}\" are neither builtins or commands and hence cannot be called non-interactively'"
#   fi

    # Otherwise, such alias name is either an existing Zsh function or has yet
    # to be declared. In the former case, we (optimistically) assume 
#FIXME: In the event of conflict with existing commands or builtins, it'd be
#great to
#FIXME: Excise this everywhere used. Since interactive_alias() now integrates
#such functionality directly, we no longer require this at all.
# bool is_zeshy_wrapping_core_commands(void)
#
# Return true if the current user requests Zeshy wrap interactively run core
# commands (e.g., "cp", "grep", "ls") with Zeshy functions.
#is_zeshy_wrapping_core_commands() {
#    (( # == 0 )) or die 'no arguments expected'
#    [[ -n "${ZESHY_IS_WRAPPING_COMMANDS-}" ]]
#}

    # Die if the passed alias name is already a defined callable.
#   is "$(whence -w "${alias_name}")" == *': '(alias|function) si and
#       die "\"${alias_name}\" already defined as:\n$(which "${alias_name}")"
    # Return true if the current user requests Zeshy wrap interactively run core
    # commands (e.g., "cp", "grep", "ls") with Zeshy functions.
#   [[ -n "${ZESHY_IS_WRAPPING_CORE_COMMANDS-}" ]]

    #FIXME: Hmm; disabling the function makes piped calls such as:
    #cat /proc/cpuinfo|cat
    #...fail, which is clearly undesirable.
# void interactive_alias_of_core_command(string alias_specification)
#
# Declare the passed specification as an interactive alias if .
# See interactive_alias() for further details.
#interactive_alias_of_core_command() {
#    is_zeshy_wrapping_core_commands and
#    interactive_alias ls='list_path_concisely'
#}

# As a convenience, all argument aliases except die_unless_no_args() first
# attempt to read their argument from stdin when the caller passed no explicit
# argument. This implies all functions expanding these aliases implicitly "get"
# piped input support, which is nice.

# Make a string suitable for use as the right-hand side of a "die_unless_*"-
# specific alias statement. This string parses standard input into function
# parameters if such input exists (i.e., if another function piped input to
# this function) and the caller passed insufficient parameters.

#   print --\
#       '[[ -p /dev/stdin && ${#} -eq 0 ]] && '\
#       'set -- "${@}" "$(< /dev/stdin)"'"; (( ${1} )) || die"
    # We can't quite recall why, but double quotes *MUST* be embedded in this
    # expression via "'" rather than the customary \".
#       "is -p /dev/stdin si and not (( ${1} )) and set -- "\

#       typeset command
#       if [[ -o interactive && \${#funcstack} -eq 1 ]]
#       then command=\"${(q)alias_expansion}\"
#       else command=\"${(q)alias_expansion_if_non_interactive}\"
#       fi
#       if is_piped_input
#       then pass_piped_input_to \${command}
#       else                     \${command}
#       fi

#           if is_piped_input
#           then pass_piped_input_to ${alias_expansion}
#           else ${alias_expansion}
#           fi
#       then ${alias_expansion}
#       else ${alias_expansion_if_not_interactive}
# bool is_terminal(void)
#
# Return true if shell output is attached to a terminal device. Specifically,
# return true if the file descriptor for standard output is open and attached to
# a terminal. (Avoid testing standard input, as commands passed piped input may
# still be "attached" to a terminal.) Do not implement this as a function, as a
# functions tests theirs rather than their callers' file descriptors.
#alias is_terminal='is -t ${ZESHY_STDOUT} si'

# bool is_color_terminal(void)
#
# Return true if the current shell is attached to a color-aware terminal device
# supporting at least the customary 8 colors (i.e., black, white, red, green,
# blue, yellow, magenta, and cyan).
#alias is_color_terminal='is_terminal and (( terminfo[colors] >= 8 ))'

#alias die_unless_no_args=die_if_args

# See Zeshy List and Map for functions returning lists and maps, respectively.
# Such functions are rather non-trivial and hence shifted there.

#FIXME: Reads a bit awkwardly, and superfulous. Supplant everywhere with
#"not is_args".

# void prepend_args(string arg1, string arg2, ...)
#
# Prepend the passed arguments to the beginning of the current argument list.
#alias prepend_args='set_args "${@}"'

# Define critical command-specific aliases. Zeshy Process implements similar
# functionality as functions where not implementable here as aliases.
# Define critical boolean-specific aliases. Zeshy Shell implements similar
# functionality as functions where not implementable here as aliases.

    # * If such run throws an exception:
    #   * Catch such exception.
    #   * Reenable this function for subsequent use.
    #   * Rethrow such exception.
    # * Otherwise, reenable this function for subsequent use.

# * O.K.; I've become convinced the "global" global alias is harmful. Why?
#   Because it obfuscates manipulation of files named "global" at the command
#   line. Also, it's non-orthogonal with the "global_alias" global. (Though,
#   technically the two convey completely different options.) In the future, we
#   should clearly minimize the number of global aliases.
# * Ah; I think I've devised a mechanism for accomplishing this sanely. Simply
#   define a function proclaim() (or some other synonym of declare(), but not
#   declare() as that's already a Zsh builtin) aliased as:
#   alias map='proclaim map' 
#   alias string='proclaim string' 
#   And so forth. Then define proclaim() to parse the first argument as the type
#   to be declared, the last argument as the name to be declared, and all
#   intermediate arguments as human-readable options condensed to typeset
#   options: e.g., "global_map const set" expands to
#   "proclaim global_map const set", which eventually... ah, wait. No. That
#   obviously runs up against the classical eval issue, since the executed
#   typeset runs in the local context of proclaim(). *sigh*
# * Right, then. There's no recourse but to manually define the set of all
#   possible aliases: e.g., global_map, global_const_map, etc. For sanity, just
#   define the most commonly used types.
#FIXME: The word "arguments" should probably be truncated to "args", here.
#Rewriting "arguments" every function is slightly silly (and cumbersome).

#       or die "neither \"${alias_name}\" or \"${alias_expansion_if_not_interactive}\" are builtins or commands"
#       alias_expansion_if_not_interactive="${alias_name}"

#   "${alias_expansion_if_not_interactive:c}" == /* or
#   if command_path="$(whence -cp "${command_name}")"; then
#   fi
#   
#   == *': function'
#   not whence -cp "${command_name}"; then
#   fi

    # If the builtin or command to be aliased does not exist, return with error.
    # To avoid costly exception handling on this frequently called helper
    # function, do not throw an exception.
#   if not whence "${command_name}" 1>/dev/null 2>&1; then
#       curse "\"${command_name}\" not a Zsh builtin or command in \$PATH"
#       return_failure
#   fi

# void interactive_alias_if_installed(string alias_specification)
#
# Declare the passed specification as an interactive alias only if the builtin
# or command to be aliased exists. This function is a no-nop if it does not.
#interactive_alias_if_installed() {
#    FIXME: Rewrite. Only call interactive_alias if the passed command is installed.
#    interactive_alias "${@}" 1>/dev/null 2>&1 or true
#}

#   eval "function ${alias_name}() {
#   ${alias_expansion} "\${@}"
#}"
#}
#
#testem() {

#FIXME: No longer convinced these to be necessary. "(( VARNAME1 <= varname2 ))"
#reads much more sensibly than "is ${VARNAME1} deceeds_or_equals ${varname2} si". We
#should probably shift all instances of the latter to the former.
#global_alias equals='-eq'
#global_alias deceeds='-lt'
#global_alias deceeds_or_equals='-le'
#global_alias exceeds='-gt'
#global_alias exceeds_or_equals='-ge'

# ....................{ DECLARATORS ~ modifiers            }....................
# Mark the declared variable as global (i.e., exported). By Zsh convention,
# this and the variable type are ordered opposite to C order: e.g.,
#
#   global_list two_hunters; two_hunters=( "ktulu" "orion" )  # or...
#   local -Ax   two_hunters; two_hunters=( "ktulu" "orion" )  # equivalent!
#global_alias global='-x'

# Mark the declared variable as constant (i.e., read-only). By Zsh convention,
# this and the variable type are ordered opposite to C order: e.g.,
#
#   string const fwtbt="ride the lightning"  # or...
#   local -r     fwtbt="ride the lightning"  # equivalent!
#global_alias const='-r'
