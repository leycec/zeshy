#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *screenshotters* (i.e., functions capturing screenshots of some or all of
the screen currently displayed by the window manager).
/---

#FIXME: Also support "KScreenshot" under KDE and "gnome-screenshot" under GNOME.
#FIXME: Although it doesn't pertain to this particular parcel, the following URL
#contains a veritable treasure-trove of single command-line commands for
#performing common tasks under various desktop environments (e.g., KDE, GNOME),
#including setting the background image, primary foreground color, and so on:
#    http://bobotig.fr/index.php?c=documents/fond-ecran-cli/
#FIXME: Interestingly, it's possible to take a pseudo-screenshot of terminal
#output via the "script" command. Running "script" enters a subshell under which
#all output is redirected to file "typescript", which is then convertable into
#an HTML file by installing and running command "ansi2html" on such file. zeshy
#should support such functionality *WITHOUT* use of "script" (but still using
#"ansi2html") -- probably through the customary
#:redirect_stdout_to_file_start() and
#:redirect_stdout_to_file_stop() approach.

# ....................{ SCREENSHOTTERS                     }....................
#FIXME: Replicate such implementation approach below.

# If the current display server supports the X11 protocol, define such function
# in terms of the preferred pathable for such protocol.
if { :is_display_server_trait_x } {
    :declare_func_if_pathable_in_list_order_or_noop\
        ':void :screenshot_screen_to_file(:str filename)'\
        ''\
        import      'command import -window root "${1}"'\
        scrot       'command scrot "${1}"'\
        imlib2_grab 'command imlib2_grab "${1}"'\
        'xwd and xwdtopnm' ':screenshot_xwd_with_options_to_file -root "${1}"'\
        ZESHY_ALTERNATIVES_SCREENSHOT_IF_DISPLAY_SERVER_TRAIT_X <<'/---'
Capture a screenshot of the screen currently displayed by the window manager to
the passed image file. Such file *must* be suffixed by an image-specific
filetype supported by the underlying screenshot command -- commonly either
`.jpg` or `.png` (e.g., `screen.jpg`, `screenshot.png`).
/---
}

#FIXME: Refactor so below as above.

:func.doc <<'/---'
void :screenshot_window_to_file(int window_id, string filename)

Capture a screenshot of the window with the passed ID under the current window
manager to the passed image file. See :screenshot_screen_to_file() for further
details.
/---
# If ImageMagick is pathable, prefer "import".
if { is_pathable import } {
    function :screenshot_window_to_file() {
        die_unless_args_2 'Expected one window ID and one filename.'
        :str window_id="${1}" filename="${2}"
        :int.die_unless_nonnegative "${window_id}"
        command import -window "${window_id}" "${filename}"
    }
# Else if "imlib2_grab" is pathable, fallback to such command. (Interestingly,
# "scrot" simply defers to "imlib2_grab" but fails to provide a corresponding
# option.)
} elif { is_pathable imlib2_grab } {
    function :screenshot_window_to_file() {
        die_unless_args_2 'Expected one window ID and one filename.'
        :str window_id="${1}" filename="${2}"
        :int.die_unless_nonnegative "${window_id}"
        command imlib2_grab -id "${window_id}" "${filename}"
    }
# Else if "xwd" *AND* "xwdtopnm" are both pathable, defer to such commands.
} elif { is_pathables xwd xwdtopnm } {
    function :screenshot_window_to_file() {
        die_unless_args_2 'Expected one window ID and one filename.'
        :str window_id="${1}" filename="${2}"
        :int.die_unless_nonnegative "${window_id}"
        :screenshot_xwd_with_options_to_file -id "${window_id}" "${filename}"
    }
}

:func.doc <<'/---'
void :screenshot_region_to_file(string filename)

Capture a screenshot of the *region* (i.e., rectangular area within the screen
currently displayed by the window manager interactively selected by the current
user) to the passed image file.  See :screenshot_screen_to_file() for further
details.
/---
# If ImageMagick is pathable, prefer "import".
if { is_pathable import } {
    function :screenshot_region_to_file() {
        die_unless_arg 'Expected one filename.'
        command import "${filename}"
    }
# Else if "scrot" is pathable, fallback to such command. (Interestingly,
# "imlib2_grab" fails to provide a corresponding option.)
} elif { is_pathable scrot } {
    function :screenshot_region_to_file() {
        die_unless_arg 'Expected one filename.'
        command scrot -s "${filename}"
    }
# Else if "xwd" *AND* "xwdtopnm" are both pathable, defer to such commands.
} elif { is_pathables xwd xwdtopnm } {
    function :screenshot_region_to_file() {
        die_unless_arg 'Expected one filename.'
        :screenshot_xwd_with_options_to_file "${filename}"
    }
}

# ....................{ SCREENSHOTTERS ~ xwd               }....................
# If both "xwd" *AND* "xwdtopnm" are installed, the Netpbm package and associate
# commands have *PROBABLY* been installed on the current system. In such case,
# define a helper function called above.
#
# Such package tends to be bundled with most X11 installations. "xwd" outputs
# only in the X11-specific XY and Z formats; "xwdtopnm" latter converts such
# output to the intermediate PNM format, which may then be converted to standard
# image formats via other Netpbm commands (e.g., "pnmtopng"). Somewhat insane,
# of course, but widely supported insanity.
if { is_pathable xwd xwdtopnm } {
    :func.doc <<'/---'
[stdout: string, stderr: string, status: int] :screenshot_xwd_with_options_to_file(
    string xwd_option1?, ..., string filename)

Run `xwd` with the passed options, capturing the specified region of the current
X11 display to the passed image file. This function supports arbitrary image
formats (e.g., JPEG, PNG) by piping from `xwd` to `xwdtopnm` to
`pnmto$(get_file_type "${filename}")`. If the last command does not exist, such
image type is unsupported and an exception is thrown. The Netpbm package
installs commands supporting many common image types.
/---
    function :screenshot_xwd_with_options_to_file() {
        # Validate sanity.
        die_unless_args 'Expected optional options and one filename.'
        :str filename="${@[-1]}" filetype pnmto_command
        pop_arg

        # Get such filename's type.
        :set_string_to_file_type filetype "${filename}"

        # Set the "pnmto*" command to call specific to such type if such command
        # exists or throw an exception otherwise. Since there exists no "pnmtojpg"
        # command, handle such case specifically.
        if is "${filetype}" == 'jpg' si {
            pnmto_command='pnmtojpeg'
        } else {
            pnmto_command="pnmto${filetype}"
            die_unless_pathable "File \"${filename}\" type ${filetype} unsupported (i.e., command \"${pnmto_command}\" not found.)"
        }

        # Run "xwd", passing all remaining arguments as presumed options to
        # such command.
        command xwd "${@}" | command xwdtopnm | command "${pnmto_command}" >\
            "${filename}"
    }
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: O.K.; the existing approach to defining pathable-conditional function
#implementations is both crude *AND* non-configurable. The former is fine; the
#latter most definitely is not. Correcting this will require a host of
#improvements to the codebase, which is all to the better. The most significant
#change is probably low-level @{src/compile} support for ordered suboverlays.
#(See such parcel for details.) After implementing such change, we'll then need
#to define two functions :declare_function_if_pathable() and
#:define_func_if_pathable(), the former calling the latter and the latter
#calling ::define_func(). The function signature for the former may resemble:
#
#void :declare_function_if_pathable[
#    args: (
#        string function_prototype,
#        string pathables_list_name,
#        string function_definition_start,
#        string function_definition_stop,
#        string pathable_name1, string function_definition1, ...),
#    stdin: string function_documentation]
#
#Hence, after shifting the first four arguments from the argument list, the
#remaining argument list should be of even size. (Validate this, please!)
#
#That's quite a lot to take it. Here's how such function is called,
#reimplementing the first function below as example:
#
#* First, we need to add a new configuration file
#  @{src/if_config/00-core/alternatives} and this list global to such file:
#
#    :list.global ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN <<'/---'
#    List of all possible pathables to implement :screenshot_screen_to_file() with
#    (in descending order of preference).
#    /---
#    ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN=( import scrot imlib2_grab xwd/xwdtopnm )
#
#  The '/' delimiter is used to signify an *AND* relationship (i.e., all such
#  pathables must exist). "/" is, of course, an ideal pathable delimiter due to
#  its prohibition in basenames. (While null is also applicable, such character
#  is considerably more cumbersome to both write and read.) Note that, although
#  we don't require an *OR* relationship yet, such a relationship could
#  certainly be implemented by simply doubling such delimiter (e.g.,
#  "xwd//xwdtopnm", signifying that at least one but not necessarily all such
#  pathables must exist). In any case, the syntax stands! (We hope.)
#
#  Hmmm; however, note that it *WOULD* be nice to have a syntax also usable
#  under @{src/if_pathable}, for defining parcels requiring more than one
#  pathable: e.g.,
#
#  * @{src/if_pathable/xwd + xwdtopnm}.
#  * @{src/if_pathable/xwd && xwdtopnm}.
#
#  So, perhaps one of the prior syntaxes would be more appropriate. It seems
#  quite unlikely that any pathable would ever embed shell-reserved characters
#  such as "&&" in its basename, given the probable chaos that would ensue, so
#  either such choice is not unreasonable. Indeed, the latter is probably the
#  better, both as it resembles zsh *AND* as it leads to the orthogonal syntax:
#  @{src/if_pathable/xwd || xwdtopnm}.
#
#  Right. Adopting "&&", the prior list definition would resemble:
#
#    ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN=(
#        import scrot imlib2_grab 'xwd && xwdtopnm' )
#
#* Then, we call :declare_function_if_pathable() in this parcel at the top-level
#  like so:
#
#  :declare_function_if_pathable ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN\
#      'void :screenshot_screen_to_file(string filename)'\
#      'die_unless_arg "Expected one filename."' ''\
#      'import'          'command import -window root "${1}"'\
#      'scrot'           'command scrot "${1}"'\
#      'imlib2_grab'     'command imlib2_grab "${1}"'\
#      'xwd && xwdtopnm' ':screenshot_xwd_with_options_to_file -root "${1}"'
#
#  What :define_func_if_pathable() must then do is iterate through
#  ${ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN[@]} and for each item therein:
#
#  * If the passed argument list contains an argument with even index equalling
#    such item (...suggesting that it would probably be most efficient to
#    collect all such arguments into a temporary local map for ease of lookup)
#    *AND* is currently pathable, such function should be defined as (in order):
#    * The passed common definition start.
#    * The passed argument immediately following the current pathable name.
#    * The passed common definition stop.
#
#Compare the compact declaration above with the voluminous declaration below.
#Clearly, we have an obsequious winner. (Let's be honest: this is pretty hot.)

#   'xwd and xwdtopnm' import scrot imlib2_grab )

# # If ImageMagick is pathable, prefer "import".
# if { is_pathable import } {
#     function :screenshot_screen_to_file() {
#         die_unless_arg 'Expected one filename.'
#         command import -window root "${1}"
#     }
# # Else if "scrot" is pathable, fallback to such command.
# } elif { is_pathable scrot } {
#     function :screenshot_screen_to_file() {
#         die_unless_arg 'Expected one filename.'
#         command scrot "${1}"
#     }
# # Else if "imlib2_grab" is pathable, fallback to such command.
# } elif { is_pathable imlib2_grab } {
#     function :screenshot_screen_to_file() {
#         die_unless_arg 'Expected one filename.'
#         command imlib2_grab "${1}"
#     }
# # Else if "xwd" *AND* "xwdtopnm" (and hence all other Netpbm commands,
# # hopefully) are both pathable, defer to such commands. Such commands tend to be
# # bundled with most Linux distributions providing X.org. The former outputs only
# # in the X11-specific XY and Z formats; the latter converts such output to the
# # intermediate PNM format, which may then be converted to standard image formats
# # with other Netpbm commands (e.g., "pnmtopng"). Somewhat insane, of course, but
# # reasonably well-supported.
# } elif { is_pathables xwd xwdtopnm } {
#     function :screenshot_screen_to_file() {
#         die_unless_arg 'Expected one filename.'
#         :screenshot_xwd_with_options_to_file -root "${1}"
#     }

# # If ImageMagick is pathable, prefer "import".
# if { is_pathable import } {
#     function :screenshot_screen_to_file() {
#         die_unless_arg 'Expected one filename.'
#         command import -window root "${1}"
#     }
# # Else if "scrot" is pathable, fallback to such command.
# } elif { is_pathable scrot } {
#     function :screenshot_screen_to_file() {
#         die_unless_arg 'Expected one filename.'
#         command scrot "${1}"
#     }
# # Else if "imlib2_grab" is pathable, fallback to such command.
# } elif { is_pathable imlib2_grab } {
#     function :screenshot_screen_to_file() {
#         die_unless_arg 'Expected one filename.'
#         command imlib2_grab "${1}"
#     }
# # Else if "xwd" *AND* "xwdtopnm" (and hence all other Netpbm commands,
# # hopefully) are both pathable, defer to such commands. Such commands tend to be
# # bundled with most Linux distributions providing X.org. The former outputs only
# # in the X11-specific XY and Z formats; the latter converts such output to the
# # intermediate PNM format, which may then be converted to standard image formats
# # with other Netpbm commands (e.g., "pnmtopng"). Somewhat insane, of course, but
# # reasonably well-supported.
# } elif { is_pathables xwd xwdtopnm } {
#     function :screenshot_screen_to_file() {
#         die_unless_arg 'Expected one filename.'
#         :screenshot_xwd_with_options_to_file -root "${1}"
#     }

# Run "xwd", passing all arguments except the last as options, in a Netpbm-
# based pipeline capturing such screenshot to the passed file.

# All list items except the last imply that a single external command with such
# name implements
# 
# The last item of such list specifies
# 
# whose functionality could suffice to implement such functions.
# 
# external commands
# 
# Each list of command alternatives specifies all external commands that some
# `zeshy` function could be implemented in terms of.

# This parcel does *NOT* support "xwd", bundled with X.org but outputting files
# only in the X11-specific XY and Z formats. While such files are convertable
# to standard image formats with ImageMagick's "convert" command, ImageMagick
# already provides the "import" command for capturing images directly to such
# formats. Since a hypothetical "xwd"-based screenshotter would need to call
# "convert" and hence depend on ImageMagick, there appears to be little
# incentive not to simply call "import" instead.
#
# For posterity, a hypothetical "xwd"-based screenshotter of the passed window
# ID would perform the following:
#
#     >>> command xwd -id "${window_id}" | command convert xwd:- "${filename}"

        # :str filename="${1}" filetype pnmto_command

        # # Get such filename's type.
        # :set_string_to_file_type filetype "${filename}"

        # # Set the "pnmto*" command to call specific to such type if such command
        # # exists or throw an exception otherwise. Since there exists no "pnmtojpg"
        # # command, handle such case specifically.
        # if is "${filetype}" == 'jpg' si {
        #     pnmto_command='pnmtojpeg'
        # } else {
        #     pnmto_command="pnmto${filetype}"
        #     die_unless_pathable "File \"${filename}\" type ${filetype} unsupported (i.e., command \"${pnmto_command}\" not pathable.)"
        # }

        # command xwd -root | command xwdtopnm | command "${pnmto_command}" >\
        #     "${filename}"

        # command scrot -c -d 3 -m "${1}"
#FUXME: Also support "xwd", seemingly bundled with X.org. Since "xwd" only
#outputs in the X11-specific XY and Z formats, however, doing so sanely will
#require following up calls to "xwd" with calls to another command converting
#such output to sane PNG or JPG image formats. (No idea which command converts!)
