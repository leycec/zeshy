#!/usr/bin/env zsh
# ====================[ alias                              ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# ZeshyInit Alias, implementing core Zeshy aliases.
#
# --------------------( TODO                               )--------------------
# * O.K.; I've become convinced the "global" global alias is harmful. Why?
#   Because it obfuscates manipulation of files named "global" at the command
#   line. Also, it's non-orthogonal with the "global_alias" global. (Though,
#   technically the two convey completely different options.) In the future, we
#   should clearly minimize the number of global aliases.
# * Ah; I think I've devised a mechanism for accomplishing this sanely. Simply
#   define a function proclaim() (or some other synonym of declare(), but not
#   declare() as that's already a Zsh builtin) aliased as:
#   alias map='proclaim map' 
#   alias string='proclaim string' 
#   And so forth. Then define proclaim() to parse the first argument as the type
#   to be declared, the last argument as the name to be declared, and all
#   intermediate arguments as human-readable options condensed to typeset
#   options: e.g., "global_map const set" expands to
#   "proclaim global_map const set", which eventually... ah, wait. No. That
#   obviously runs up against the classical eval issue, since the executed
#   typeset runs in the local context of proclaim(). *sigh*
# * Right, then. There's no recourse but to manually define the set of all
#   possible aliases: e.g., global_map, global_const_map, etc. For sanity, just
#   define the most commonly used types.

# ....................{ TYPES ~ aliases                    }....................
# void global_alias(char *name, char *value)
#
# Declare a so-called "global alias" (i.e., an alias expandable anywhere in an
# expression, rather than merely in command position).
alias global_alias="alias -g"

# void suffix_alias(char *name, char *value)
#
# Declare a so-called "suffix alias" (i.e., an alias expandable by matching
# against the end of commands).
alias suffix_alias="alias -s"

# ....................{ TYPES ~ integer                    }....................
# void bool(char *name)
#
# Locally declare a boolean. Due to current inadequacies in Zsh, this only
# declares a scalar string local to the current scope. Nonetheless, we
# encourage users use this alias for clarity, forwards compatibility, and
# functional symmetry with the existing integer() and float() built-ins.
alias bool='typeset'

# void global_bool(char *name)
#
# Globally declare a boolean.
alias global_bool='typeset -x'

# ....................{ TYPES ~ integer                    }....................
# Zsh already provides built-in integer() for declaring local integers.

# void global_integer(char *name)
#
# Globally declare an integer (i.e., non-real number).
alias global_integer='integer -x'

# ....................{ TYPES ~ float                      }....................
# Zsh already provides built-in float() for declaring local floats.

# void global_float(char *name)
#
# Globally declare a float (i.e., real number).
alias global_float='float -x'

# ....................{ TYPES ~ string                     }....................
# void string(char *name)
#
# Locally declare a string.
alias string='typeset'

# void global_bool(char *name)
#
# Globally declare a string.
alias global_string='typeset -x'

# ....................{ TYPES ~ list                       }....................
# Due to current inadequacies in Zsh, lists must be externally initialized:
# e.g.,
#
#   list sequence; sequence=( 'value 1' 'value 2' 'value 3' 'value 4' )

# void global_list(char *name)
#
# Globally declare a list (i.e., sequential array).
alias global_list='typeset -ax'

# void list(char *name)
#
# Locally declare a list (i.e., sequential array).
alias list='typeset -a'

# void list_set(char *name)
#
# Locally declare a list set (i.e., a list ignoring duplicate values).
alias list_set='typeset -Ua'

# void list_tied_string(
#   char *string_name, char *list_name, char *separator = ':')
#
# Declare a string with the passed name "tied" to the list with the passed name.
# This resembles a Perl tie by joining the list's elements with the passed
# separator, defaulting to ":", into a string and updating that string on each
# update (i.e., change) to that list: e.g.,
#
#   list_tied_string arroyo array ' '
#   list array; array=( 'Cuidad' 'Juarez' )
#   print "${arroyo}"  # prints "Cuidad Juarez"
#   array=( 'El' 'Paso' )
#   print "${arroyo}"  # prints "El Paso"
#
# Importantly, note Zsh leaves the list-tied string initially unset -- even if
# the list to which it is tied is set! Hence, list-tied strings should usually
# be declared prior to the list to which they tie. Yes, this is unintuitive.
alias list_tied_string='typeset -T'

# ....................{ TYPES ~ map                        }....................
# Due to current inadequacies in Zsh, maps must be externally initialized: e.g.,
#
#   map hash_map; hash_map=( 'key 1' 'value 1' 'key 2' 'value 2' )

# void global_map(char *name)
#
# Globally declare a map (i.e., associative array).
alias global_map='typeset -Ax'

# void map(char *name)
#
# Locally declare a map (i.e., associative array).
alias map='typeset -A'

# void map_set(char *name)
#
# Locally declare a map set (i.e., a map ignoring duplicate values).
alias map_set='typeset -UA'

# ....................{ GLOBAL ALIASES                     }....................
# bool is(...)
#
# Syntactic sugar signifying the delimiting prefix for a boolean test: e.g.,
#
#   is "PatGoD" == *GoD si and print "Piper methysticum"  # or...
#   [[ "PatGoD" == *GoD ]]  && print "Piper methysticum"  # equivalent!
global_alias is='[['

# void si(void)
#
# Syntactic sugar signifying the delimiting suffix for a boolean test.
global_alias si=']]'

global_alias not='!'
global_alias or='||'
global_alias and='&&'

# ....................{ OPERATORS                          }....................
# void noop(...)
#
# Perform parameter expansion on all passed parameters. This alias runs no
# commands and thus always returns successfully.
alias noop=':'

# ....................{ ARGUMENTS ~ tests                  }....................
# Define critical argument-specific aliases prior to defining functions
# expanding these aliases. Otherwise, error ensues.

#FIXME: The word "arguments" should probably be truncated to "args", here.
#Rewriting "arguments" every function is slightly silly (and cumbersome).
#Also, rewrite the implementations with "((" rather than "is".

# bool is_no_arguments(void)
#
# Return true only if the caller was called with no arguments.
alias is_no_arguments='(( # == 0 ))'

# bool is_arguments(void)
#
# Return true only if the caller was called with at least one argument.
alias is_arguments='(( # > 0 ))'
alias is_at_least_one_argument=is_arguments

# bool is_at_least_two_arguments(void)
#
# Return true only if the caller was called with at least two arguments.
alias is_at_least_two_arguments='(( # >= 2 ))'

# bool is_one_argument(void)
#
# Return true only if the caller was called with exactly one argument.
alias is_one_argument='(( # == 1 ))'

# bool is_two_arguments(void)
#
# Return true only if the caller was called with exactly two arguments.
alias is_two_arguments='(( # == 2 ))'

# ....................{ ARGUMENTS ~ exceptions             }....................
# As a convenience, all argument aliases except die_unless_no_arguments() first
# attempt to read their argument from stdin when the caller passed no explicit
# argument. This implies all functions expanding these aliases implicitly "get"
# piped input support, which is nice.

# char *make_die_unless_alias(char *test_condition)
#
# Make a string suitable for use as the right-hand side of a "die_unless_*"-
# specific alias statement. This string parses standard input into function
# parameters if such input exists (i.e., if another function piped input to
# this function) and the caller passed insufficient parameters.
make_die_unless_alias() {
    print "is -p /dev/stdin si and not (( ${1} )) and set -- "'"$(< /dev/stdin)"'"; (( ${1} )) or die"
}

# void die_unless_no_arguments(void)
#
# Die with a canonical message unless the caller passed no arguments.
alias die_unless_no_arguments='is_no_arguments or die "expected no arguments"'

# void die_unless_arguments(char *error_message)
#
# Die with the passed message unless the caller passed at least one argument.
alias die_unless_arguments="$(make_die_unless_alias '# > 0')"

# void die_unless_one_argument(char *error_message)
#
# Die with the passed message unless the caller passed exactly one argument.
alias die_unless_one_argument="$(make_die_unless_alias '# == 1')"

# void die_unless_two_arguments(char *error_message)
#
# Die with the passed message unless the caller passed exactly two arguments.
alias die_unless_two_arguments="$(make_die_unless_alias '# == 2')"

# void die_unless_three_arguments(char *error_message)
#
# Die with the passed message unless the caller passed exactly three arguments.
alias die_unless_three_arguments="$(make_die_unless_alias '# == 3')"

# void die_unless_four_arguments(char *error_message)
#
# Die with the passed message unless the caller passed exactly four arguments.
alias die_unless_four_arguments="$(make_die_unless_alias '# == 4')"

# void die_unless_one_or_two_arguments(char *error_message)
#
# Die with the passed message unless the caller passed either one or two
# arguments.
alias die_unless_one_or_two_arguments="$(make_die_unless_alias '# == 1 or # == 2')"

# void die_unless_two_or_three_arguments(char *error_message)
#
# Die with the passed message unless the caller passed either two or three
# arguments.
alias die_unless_two_or_three_arguments="$(make_die_unless_alias '# == 2 or # == 3')"

# void die_unless_at_least_one_argument(char *error_message)
#
# Die with the passed message unless the caller passed at least one argument.
alias die_unless_at_least_one_argument="$(make_die_unless_alias '# >= 1')"

# void die_unless_at_least_two_arguments(char *error_message)
#
# Die with the passed message unless the caller passed at least two arguments.
alias die_unless_at_least_two_arguments="$(make_die_unless_alias '# >= 2')"

# void die_unless_at_least_three_arguments(char *error_message)
#
# Die with the passed message unless the caller passed at least three arguments.
alias die_unless_at_least_three_arguments="$(make_die_unless_alias '# >= 3')"

# void die_unless_at_most_one_argument(char *error_message)
#
# Die with the passed message unless the caller passed at most one argument.
alias die_unless_at_most_one_argument="$(make_die_unless_alias '# <= 1')"

# void die_unless_at_most_two_arguments(char *error_message)
#
# Die with the passed message unless the caller passed at most two arguments.
alias die_unless_at_most_two_arguments="$(make_die_unless_alias '# <= 2')"

# void die_unless_at_most_three_arguments(char *error_message)
#
# Die with the passed message unless the caller passed at most three arguments.
alias die_unless_at_most_three_arguments="$(make_die_unless_alias '# <= 3')"

# Delete the temporary function used to construct the above aliases.
unfunction make_die_unless_alias

# ....................{ ARGUMENTS ~ parsing                }....................
# void parse_arguments(char *argument_spec1, char *argument_spec2, ...)
#
# Parse script (or function) arguments according to the passed zparseopts()-
# style argument specifications into map "ARGS". For details on specification
# format, search "man zshmodules" for "zparseopts". For convenience, "-h" and
# "--help" are always parsed as valid argument options: e.g.,
#
#   # Set fake command-line arguments.
#   >>> set -- -d --ad --crest "glass arm shattering"
#
#   # Parse such arguments as:
#   #
#   # * "--ad", a long option followed by no value.
#   # * "--crest", a long option followed by some value.
#   # * "--wing", a long option optionally followed by some value.
#   >>> parse_arguments d e -ad -crest: -wing::
#
#   # Validate such parsing.
#   >>> is_map_key 'ARGS' '-d' and print 'option "-d" parsed'
#   option "-d" parsed
#   >>> echo "-d: ${ARGS[-d]}\n--ad: ${ARGS[--crest]}\n--wing: ${ARGS[--wing]}"
#   -d:
#   --crest: glass arm shattering
#   --wing:
alias parse_arguments='zparseopts -D -E -A ARGS -- h -help' 

#FIXME: Obsolete.
#FIXME: No longer convinced these to be necessary. "(( VARNAME1 <= varname2 ))"
#reads much more sensibly than "is ${VARNAME1} deceeds_or_equals ${varname2} si". We
#should probably shift all instances of the latter to the former.
#global_alias equals='-eq'
#global_alias deceeds='-lt'
#global_alias deceeds_or_equals='-le'
#global_alias exceeds='-gt'
#global_alias exceeds_or_equals='-ge'

# ....................{ DECLARATORS ~ modifiers            }....................
# Mark the declared variable as global (i.e., exported). By Zsh convention,
# this and the variable type are ordered opposite to C order: e.g.,
#
#   global_list two_hunters; two_hunters=( "ktulu" "orion" )  # or...
#   local -Ax   two_hunters; two_hunters=( "ktulu" "orion" )  # equivalent!
#global_alias global='-x'

# Mark the declared variable as constant (i.e., read-only). By Zsh convention,
# this and the variable type are ordered opposite to C order: e.g.,
#
#   string const fwtbt="ride the lightning"  # or...
#   local -r     fwtbt="ride the lightning"  # equivalent!
#global_alias const='-r'

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
