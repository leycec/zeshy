#!/usr/bin/env zsh
# ====================[ core                               ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# ZeshyInit Process, implementing core process functionality.

# ....................{ MAIN                               }....................
_zeshy_process() {
    die_unless_no_arguments

    #FIXME: Zsh-ify these matches, using the above match_multiline() function.
    # Determine whether or not this process is running is a cronjob. This is
    # adapted from this itworld.com article, "Am I being run by cron?":
    #        http://www.itworld.com/Comp/3380/nls_unixcron041209/index.html
    # 
    # Do this prior to uttering imports, as the utter() function requires this.
    string cron_pids="$(pgrep -x cron)"
    integer grandparent_pid="$(ps -eo ppid,pid= | grep " ${PPID}$" | awk '{print $1}')"
    ZESHY_IS_CRONJOB="$(one_if match_multiline "^${cron_pids}$" "${grandparent_pid}")"
#   echo "cron: ${ZESHY_IS_CRONJOB}; cron_pids: ${cron_pids}; gpid: ${grandparent_pid}"

    # Set the default script name prior to all other logic, as any logic
    # raising an error requires this name for logging that error. Only do this
    # if the current process is not an interactive Zsh shell as, in that case,
    # the get_script_name() function dynamically inspects the script name from
    # the function call stack.
    if is_empty "${ZESHY_SCRIPT_NAME}" and not is_shell_interactive; then
        # Import Zeshy components required below.
        zimport zeshy/os
        
        # Strip the filetype from the script name, if present.
        ZESHY_SCRIPT_NAME="$(get_current_process_basename)"
        ZESHY_SCRIPT_NAME="${ZESHY_SCRIPT_NAME%%.*}"

        # Default the script name to "zeshy", if "zsh".
        is "${ZESHY_SCRIPT_NAME}" == zsh si and ZESHY_SCRIPT_NAME=zeshy
    fi
}

_zeshy_process
unfunction _zeshy_process

#FIXME: Obsolete.
    # Import all non-dotfiles in this directory with the "(^D)" modifier (i.e.,
    # all files and directories *NOT* prefixed by a "."). Since Zeshy scripts
    # explicitly import dependencies, order of import is mostly insignificant.

#   if is -z\
#       "${ZESHY_IMPORTED_PATH_TO_MTIME[(I)"${zeshy_script_path}"]}" or
#       "${ZESHY_IMPORTED_PATH_TO_MTIME["${zeshy_script_path}"]}" -ne\
#       "${zeshy_script_mtime}" si; then

# This glob expression matches the basename of all non-executable readable
# files residing under every path in the function path list, "${fpath}". Via
# Zsh mandate, every such file basename corresponds to the autoloadable
# function name defined in the file. Thus, matching these basenames also
# matches all autoloadable function names.
#
# * "-.x" ignores non-executable files. While not strictly necessary, forum
# posters suggest this beneficially permits you to ignore undesirable autoloads
# by chmodding away their executable bit.  * "-.r" ignores non-readable files.
# This is strictly necessary.  * ":t" extracts the "tail" (i.e., basename) of
# the current file. This is a history modifier extracting each file's filename
# sans absolute path.
# 
#for autoload_function_name in ${^fpath}/*(N-.r:t); do

#FIXME: I suppose I don't quite understand why we can't simply implement this as
#some variant of '"${@}" 1>/dev/null 2>&1'. Doesn't that work as is?
#quietly() { run "${(q)@}" 1>/dev/null 2>&1 }

#   is "${#command}" exceeds 0 si or die 'expected exactly one command'
#
#global_alias to='|'

    # Decompacted:
    # 
    # * "1", the passed name.
    # * "(P)", the variable the passed name refers to.
    # * "-", the value to expand this variable to if unset:
    #   in this case, simply the empty string.
    # * "-z", true only if this variable is the empty string and hence unset.
#    is -z "${(P)1-}" si

# ....................{ COMMANDS ~ return codes            }....................
# void try_as_superuser(char *command)
#
# Run the passed command as the superuser and, if it fails with error,
# terminate the current execution environment with the same error.
#try_as_superuser() {
#    run_as_superuser "${@}" or die
#}

# int get_last_exit_status(void)
# 
# Return the return code returned by the previous command.
#alias get_last_exit_status='is_ok'

# bool is_ok(void)
#
# Return success if the previous command succeeded. Otherwise, return failure.
#is_ok() {
#    # Cache the prior command's return code, as our initial sanity check on
#    # arguments replaces this code with its own.
#    integer prior_command_exit_status=${?}
#    die_unless_no_arguments
#    return ${prior_command_exit_status}
#}

# bool is_error(void)
#
# Return success if the previous command failed. Otherwise, return failure.
#is_error() {
#    # Cache the prior command's return code, as our initial sanity check on
#    # arguments replaces this code with its own.
#    integer prior_command_exit_status=${?}
#    die_unless_no_arguments
#    is ${prior_command_exit_status} -ne ${ZESHY_SUCCESS_CODE} si
#}

# char *canonicalize_path_nonfatal(char *pathname)
#
# Get the canonicalized form of the passed absolute path. Unlike the
# canonicalize_path() function, this function does not raise an exception when
# the passed path does not exist; it simply canonicalizes as much of this path
# as exists.
#canonicalize_path_nonfatal() {
#    die_unless_one_argument 'expected exactly one pathname'
#    readlink --canonicalize-missing "${1}"
#}

#FIXME: This and try() now obsolete by TRAPZERR(). Excise everywhere.
# void try_quietly_as(char *username, char *command)
#
# Run the passed command as the passed user quietly and, if it fails with error,
# terminate the current execution environment with the same error.
#try_as() {
#    die_unless_at_least_two_arguments\
#        'expected exactly one username and one command'
#
#    # Locally set "${ZESHY_RUN_AS}". The run() function notes this variable as
#    # set and behaves accordingly...
#    string ZESHY_RUN_AS="${1}"; shift
#
#    # Call try() with all remaining arguments: the command to be run.
#    try "${(q)@}"
#}

# void try(char *command)
#
# Run the passed command and, if it fails with error, terminate the current
# execution environment with the same error.
#try() {
#    run "${(q)@}" or die "\"${@}\" returned error code ${?}"
#}

# void try_quietly(char *command)
#
# Run the passed command quietly and, if it fails with error, terminate the
# current execution environment with the same error.
#try_quietly() {
#    quietly try "${@}" or die "\"${@}\" returned error code ${?}"
#}

# void try_quietly_as(char *username, char *command)
#
# Run the passed command as the passed user quietly and, if it fails with error,
# terminate the current execution environment with the same error.
#try_quietly_as() {
#    quietly try_as "${@}" or die "\"${@}\" returned error code ${?}"
#}

# bool or(...)
#
# Return true if at least one of the passed command's returned successfully.
#global_alias or='||'

# bool and(...)
#
# Return true if both of the passed command's returned successfully.
#global_alias and='&&'

# bool not(...)
#
# Negate the passed command's return code.
#alias not='!'

#FIXME: This function appears to be functionally obsolete now. If so, kill and
#rename which_command() to this.
# Aliases.
#alias which_binary="which_command"
#alias which_binary_nonfatal="which_command"

# char *which_command(char *command)
#
# Print the absolute path to the passed command: e.g.,
#
#     >>> which_command zsh /bin/zsh
#
# If the passed command is a string, all but the first whitespace-delimited word
# of the string is ignored: e.g.,
#
#     >>> which_command "zsh -x -o shwordsplit scr" /bin/zsh
#
# If the passed command is not found, if multiple binaries are passed, or if no
# command is passed, prints an error and dies.
#which_command() {
#Call the whence() built-in outside of "local" so as to retain the return
    # code. (ZSH == FAIL on that one.) 
#    string command_path; command_path="$(which_command "${@}")"
#    die_unless_ok "\"${1}\" not found"
#    print "${command_path}"
#}
#
# Identical to the which_command() function except that, if the passed command
# does not exist, returns nothing rather than dies.

#FIXME: No longer meaningful under TRAPZERR(); excise.
# void die_unless_ok(char *error_message)
#
# Die with the passed error message unless the previous command succeeded.
#die_unless_ok() {
#    # Cache the prior command's return code, as our initial sanity check on
#    # arguments replaces this code with its own.
#    integer prior_command_exit_status=${?}
#    die_unless_one_argument 'expected exactly one error message'
#    is ${prior_command_exit_status} -eq ${ZESHY_SUCCESS_CODE} si or die "${1}"
#}

# void utter_import(char *script_name)
#
# Echo a message informing the user that the passed script name is being
# imported. This function should be called prior to actually importing that
# script if feasible.
#utter_import() {
#    die_unless_one_argument 'expected exactly one script name'
#
#    utter "loading \"${1}\"..."
#}

    # If the caller has supplied no explicit "${ZESHY_SCRIPT_NAME}", supply a
    # default.  Failing to do this encourages the utter() function to use the
    # name of this function as its script name, producing unaesthetic results.
#   "${ZESHY_SCRIPT_NAME:=zeshy}"

        # Print the passed error message followed by a complete backtrace.
#   curse "${@}"
#   print_stack_trace
 #
    # Shells differentiate
    # fatal from non-fatal errors by setting the high bit (i.e., 2^7 = 128).
    # According to "zshbuiltins", this forces Zsh to continue handling the
    # signal as if untrapped and hence returning the same exit status. Having no
    # arcanely carnal knowledge of the Linux signal implementation, it's unclear
    # why setting the high bit 

    #FIXME: Old.
    # If the passed path is a directory, only import filename
    # "${ZESHY_MAIN_SCRIPT_BASENAME}" in this directory.
#   is -d "${zeshy_script_path}" si and
#       zeshy_script_path="${zeshy_script_path}/${ZESHY_MAIN_SCRIPT_BASENAME}"
    
    # If this path does not exist, die.
#   is -f "${zeshy_script_path}" si or die "\"${zeshy_script_path}\" not found"
 #
#FIXME: Impossible to remember, I'm afraid. Perhaps "fail_if_error", instead?
# int fail_if_previous_command_failed(void)
# 
# Return from the current function with failure if the previous command or
# function also returned with failure.
#alias fail_if_previous_command_failed="is_ok || return ${ZESHY_FAILURE_CODE}"

#; ZESHY_IMPORTED_PATH_TO_MTIME=( )
#   typeset -Ax ZESHY_IMPORTED_PATH_TO_MTIME; ZESHY_IMPORTED_PATH_TO_MTIME=( )
 # The "-Ax" option to the "typeset" commands defines each such variable as an
# [A]ssociative array (i.e., a dictionary) and e[x]ported to the global
# environment for later access.

# Ascertain whether we are running as a cronjob and, if so, alter output
# appropriately. In particular, print the current date as a timestamp prior to
# printing all other output.

#   die_unless_at_least_one_argument 'expected at least one string'

#   # If no string was passed, attempt to read "stdin" for piped input.
#   if is_one_argument; then
#       set -- "${1}" "$(< /dev/stdin)"
#   fi

#   pcre_compile "${1}" || die "\"${1}\" not a valid regular expression"
#   pcre_match "${2}" || return ${?}
#   return ${ZESHY_SUCCESS_CODE}

# This function returns success 
# If this regular expression matched at least one group, this function returns
# this group as a string for caller convenience... Else, this function returns
# nothing. In the former case, callers may retrieve the set of all groups via
# the global "${match}" array. (See above.)

    # When the whence() built-in fails, it prints the name of the passed command
    # followed by "not found". Thus, if it prints such a message, the passed
    # command does not exist. Note that testing the return code is problematic
    # here, since setting a local variable always forces the return code to 0
    # (i.e., success). 
#   if [[ "${command_path}" == *" not found" ]]; then
#       return ${ZESHY_FAILURE_CODE}
#   else
#       echo "${command_path}"
#       return ${ZESHY_SUCCESS_CODE}
#   fi

    # O.K., this is tricksy: if the eventual caller explicitly quote-protected
    # the passed command name, there exists another "layer" of quote-protection
    # to unravel. Do so, alas.
#   if ! is_installed "${command_name}" && is_installed "${(Q)command[1]}"; then
#       command_name="${(Q)command[1]}"
#   fi

    #echo "PID: $$"
    #echo "current_process_basename:"
    #get_current_process_basename
    #echo "current_process_command_line:"
    #get_current_process_command_line

# ....................{ GLOB EXPRESSIONS                   }....................
# char **glob_non_dotfiles_in(char *dirname)
#
# Glob all non-dotfiles (i.e., all files and directories whose first character
# is not a '.' dot) in the passed directory.
#glob_non_dotfiles_in() {
#    [[ ${#} -eq 1 ]] || die "expected exactly one directory name"
#    local dirname="${1}"
#    [[ -d "${dirname}" ]] || "\"${dirname}\" not a directory"
#
#    # Glob all non-dotfiles via the "(^D)" modifier.
#    echo "${dirname}"/*(^D)
#}

 # Enable variable substitution in prompt expansions in a "synchronous" fashion.
# Enabling this re-evaluates each prompt expansion after perform each
# interactive command with the current values of those variables without
# having to manually recreate the prompt each time.
#setopt promptsubst

#The existence of this variable also
# serves to inform callers as to whether or not this script has been imported
# yet and, when it has, to avoid reimporting it.

# Directory above the directory having the current script. This environment
# variable should have been permanently added to the current system as well.
#[[ -n "${ZESHY_ROOT}" ]] ||  
#    export ZESHY_ROOT=$(readlink --canonicalize-existing "${ZESHY_HOME}/..")

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
