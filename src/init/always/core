#!/usr/bin/env zsh
# ====================[ core                               ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# ZeshyInit Core, bootstrapping core Zeshy functionality.
#
# --------------------( SEE ALSO                           )--------------------
# http://zsh.sourceforge.net/Doc/Release/Functions.html
#   Detailed description of trap functions.
# http://www.bash2zsh.com/essays/essay1_file_manager.html
#   Concise introduction to suffix aliases, mime types, and file magic.
#
# --------------------( TODO                               )--------------------
# * Use the "vcs_info" Zsh module for displaying VCS-specific metadata in a VCS-
#   agnostic fashion.
# * Incorporate ZSH-lovers fixes, including:
#   * Use suffix aliases.
# * The new trap support obsoletes an astonishing quantity of prior
#   functionality (e.g., try()). Such functionality should be retained (???...
#   perhaps not), but exported out of this component into a new component: say,
#   "zeshy/shell/job".
# * zimport() can profitably be renamed require(). The latter captures the
#   intent and implementation much more succinctly and without the awkward
#   prefixing 'z'.
# * We only call a match_*() function once in this file. It's absurd to maintain
#   such complexity here; offload all match_*() functionality to
#   "zeshy/type/regex" and, if still required here, simply inline. I believe we
#   can use simple glob-style matching, instead.
# * Ultimately, Zeshy should auto-compile the recursive entirety of all Zeshy
#   function definitions into a single so-called "digest" file at, say,
#   "~/.zeshy/digest.zwc". Such a file is autoloadable by:
#       
#       # ...implicitly autoloading such digest.
#       fpath=( "~/.zeshy/digest.zwc" "${fpath[@]}" )
#
#       # ...explicitly autoloading such digest.
#       autoload -Uw "~/.zeshy/digest.zwc"
#
#   I'm unsure if the former supercedes the latter. (Probably not, no.) Both
#   required, perhaps.
#
#   What's nice about this is that such a digest file appears to come prepended
#   with a list of all functions defined by such digest, thus rendering
#   autoloading of digest files terrifically fast. Auto-generating such a digest
#   on any change to any Zeshy file or directory is, unfortunately, not quite so
#   easy. We'll need to write something resembling:
#
#       if is "$(get_path_mtime "~/.zeshy/digest.zwc") equals SOMETHING si; then
#           zcompile "~/.zeshy/digest.zwc" "${ZESHY_HOME}/src/"**/*(.)
#       fi
#
#   However, it's unclear just how aggregating multiple files into one handles
#   initialization code. Clearly, it either doesn't or does but simply lumps all
#   initialization together. Either case is bad. We'll need to rewrite Zeshy to:
#
#   * Perform all non-costly initialization up-front in Zeshy .main or core.
#   * Perform all costly initialization in the functions requiring such
#     initialization as the first line of such functions. You know that grind...

# ....................{ PATHS                              }....................
# Absolute path to the current script.
local zeshy_core_path=$(readlink --canonicalize-existing "${0}")

# Directory having the current script. This environment variable should have
# been permanently added to the current system on Zeshy installation. If it was
# not, however, ensure that it at least temporarily exists now.
[[ -n "${ZESHY_HOME}" ]] ||
    export ZESHY_HOME=$(readlink --canonicalize-existing $(dirname "${zeshy_core_path}")"/../..")

# ....................{ RETURN VALUES                      }....................
# Success code, as returned by successful processes on process completion.
export ZESHY_SUCCESS_CODE=0

# Failure code, as returned by failed processes on process completion. Note
# that, technically, any return code greater than or equal to this value
# constitutes a process failure.
export ZESHY_FAILURE_CODE=1

# void return_success(void)
#
# Return from the current function with success.
alias return_success="return ${ZESHY_SUCCESS_CODE}"

# void return_failure(void)
#
# Return from the current function with failure.
alias return_failure="return ${ZESHY_FAILURE_CODE}"

# ....................{ TESTS                              }....................
# bool is_shell_interactive(void)
#
# Return true if the current shell is interactive or is a login shell.
is_shell_interactive() {
    [[ ${#} -eq 0 ]] || die 'expected no arguments'
    [[ -o interactive || -o login ]]
}

# ....................{ CALL STACK                         }....................
# For safety, trap functions and functions transitively called by such functions
# require only Zsh functionality (i.e., no Zeshy-specific syntactic sugar). This
# comprises all functions defined up to and including the "TRAPS" section.

# char *get_script_name(void)
#
# Get the script name for the current script. This is a string succinctly
# describing the script under execution, typically of one to two words.
#
# Scripts may safely redefine this function to return another name; in this
# case, scripts called by the script redefining this function will still call
# this original definition (since functions are not inherited via script
# calls).
get_script_name() {
    [[ ${#} -eq 0 ]] || die 'expected no arguments'

    if [[ -n  "${ZESHY_SCRIPT_NAME}" ]]; then
        print "${ZESHY_SCRIPT_NAME}"
    # If the current process is an interactive shell, then return the name of
    # the function that called this function excluding all intermediary I/O-
    # and error handling-specific function calls. Typically, that function is
    # the function that called the function that called this function (i.e.,
    # the function two calls earlier in the function callstack). Insert magical
    # handwaving here.
    elif is_shell_interactive; then
        # Ignore all intermediary I/O- and error handling-specific function
        # calls. Skip the first stack frame corresponding to the current
        # function by starting at the second stack frame.
        typeset -i funcstack_size=${#funcstack}
        for (( i = 2; i <= funcstack_size; i++ )); do
            # Order ignorable function names by likelihood, for "efficiency."
            case "${funcstack[${i}]}" in
                try*|run*|die*|utter*|mutter*|curse*|ask_*) continue ;;
                *) break ;;
            esac
        done
         
        # If after ignoring non-relevant functions there still exists at least
        # one function on the callstack, return that function's name.
        if [[ ${i} -le ${funcstack_size} ]]
        then print "${funcstack[${i}]}"
        # Otherwise, return the default name.
        else print 'zeshy'
        fi
    # Otherwise, return the default name.
    else print 'zeshy'
    fi
}

# char *print_stack_trace(void)
#
# Print a stack trace of the current call stack (i.e., the sequence of all stack
# frames, excluding the call to this function). Each such frame signifies a
# previously called function, sourced file, or evaluated "eval". Each call
# stack of such frames signifies a stack trace of the complete code path from
# the most to least recently called function, source file, or evaluated "eval".
print_stack_trace() {
    [[ ${#} -eq 0 ]] || die 'expected no arguments'
 
    typeset -i funcstack_size=${#funcstack} i 
    local frame_prefix='    \\_' string funcname filename fileline

    # Omit the current function call by starting from the second stack frame.
    # If there exists no such frame, curse a warning.
    if [[ ${funcstack_size} -le 1 ]]; then
        curse 'call stack empty'
        return 1
    fi

    # Print a prefixing empty header.
    print
    utter

    # Print the current call stack.
    for (( i = 2; i <= funcstack_size; i++ )); do
        # Split the current stack frame's funcfiletrace entry on the last colon
        # in that entry into that frame's filename and line number, thus
        # accounting for possible colons in filenames (e.g., from "colon:blow:7"
        # to filename "colon:blow" and line number 7).
        funcname="${funcstack[${i}]}"
        filename="${funcfiletrace[${i}]%:*}"
        fileline="${funcfiletrace[${i}]##*:}"

        # Print the current stack frame.
#       if "${funcstack[${i}]}" == "${funcfiletrace[${i}]}"
        print "${frame_prefix} ${funcname}() { ${filename}: ${fileline} }"
#       print "${frame_prefix} ${funcname}() {${filename}:${fileline}}"

        # Indent the next stack frame one space to the right.
        frame_prefix=" ${frame_prefix}"
    done
}

# ....................{ MESSAGES                           }....................
#FIXME: Add ANSI coloring to uttered messages if on an ANSI-capable terminal.
#Also, consider prefixing messages under cron with: "["$(date +'%F %T')"]

# void utter(char *message = '')
#
# Print the passed message suffixed by a trailing newline to the notice stream
# of the cron logging facility if a cron-job and to the standard output stream
# otherwise.
utter() {
    # Message to utter. (Yes, its definition must be in a separate command.)
    local message; message="$(get_script_name): ${@}"
    
    if [[ -n "${ZESHY_IS_CRONJOB}" ]]
    then logger -p cron.notice -- "${message}"
    else echo "${message}"
    fi
}

# void mutter(char *message = '')
#
# Print the passed message suffixed by no trailing newline to the notice stream
# of the cron logging facility if a cron-job and to the standard output stream
# otherwise.
mutter() {
    # Message to mutter. (Yes, its definition must be in a separate command.)
    local message; message="$(get_script_name): ${@}"
    
    if [[ -n "${ZESHY_IS_CRONJOB}" ]]
    then logger -p cron.notice -- "${message}"
    else echo -n "${message}"
    fi
}

# void curse(char *message = '')
#
# Echo the passed message to the standard error stream. Specifically:
#
# * If a cronjob, echo to the error stream of the cron logging facility.
# * Otherwise, to "stderr".
curse() {
    #FIXME: Given the new stack trace facilities, this probably no longer applies.
    # Unset the script name, if set. This forces the get_script_name() function
    # to obtain the name of the most recently called non-trivial function, which
    # is of considerably more assistance when an error occurs.
#   local ZESHY_SCRIPT_NAME=

    # Message to curse. (Yes, its definition must be in a separate command.)
    local message; message="$(get_script_name): ${@}"
    
    if [[ -n "${ZESHY_IS_CRONJOB}" ]]
    then logger -p cron.err -- "${message}"
    else echo "${message}" 1>&2
    fi
}

# ....................{ ERRORS                             }....................
# void die_with(int exit_status = 1)
#
# Exit the currently executed script or function with the passed return code.
die_with() {
    # If the current context is a function called from an interactive and/or
    # login shell, unwind the call stack; otherwise, kill the current process.
    if is_shell_interactive
    then throw ZeshyException
    else exit ${1:-${ZESHY_FAILURE_CODE}}
    fi
}

# ....................{ TRAPS                              }....................
# int TRAPINT(int signal_number = SIGINT)
#
# Trap SIGINT (i.e., signal interrupt, as after a user-driven <Ctrl-C> event).
TRAPINT() {
    print_stack_trace

    # Store the interrupted line in the history. By default, Zsh omits such
    # lines -- somewhat unhelpfully. Dismantled, this is:
    #
    # * "zle", true only if the history is currently active.
    # * "-s", output the interrupted line to the history rather than stdout.
    # * "-r", preserve escapes from "echo" command manipulation.
    # * "--", prevent dash prefixes in the interrupted line from being
    #   misinterpreted as "print" command options.
    # * "${BUFFER}", the interrupted line.
    zle && print -sr -- "${BUFFER}"
    
    # Arcane bit-munging. Exit codes are of size "char" (i.e., a single byte).
    # Non-zero exit statuss with high bit set signify signal-driven fatal errors
    # and with high bit unset signify command-specific fatal errors. In the
    # former case, all bits excluding the high bit signify the signal number.
    # Hence, signal-driven exit statuss are constructable by adding 128 to the
    # signal number.
    #
    # SIGINT signifies fatal error of signal number 2. Rather than hard-code
    # that constant, we note:
    #
    # * Zsh passes the signal number as the first argument to trap functions.
    # * Zsh continues handling trap function-trapped signals as if untrapped
    #   when receiving non-zero exit statuss from such functions. In such cases,
    #   Zsh returns this exit status as the signal result to calling processes.
    # 
    # Since we prefer Zsh handle the actual interrupt as such with the same
    # exit status as it would customarily return, the result follows.
    return $(( 128+${1} ))
}

# int TRAPZERR(int signal_number = SIGZERR)
#
# Trap SIGZERR (i.e., signal error, as after Zsh functions or non-Zsh commands
# returning non-zero exit statuss). This signal is Zsh-specific, as the function
# name directly implies.
TRAPZERR() {
    # Save the return code of the prior command prior to overwriting this code
    # by printing a stack trace.
    typeset -i exit_status=${?}
    print_stack_trace

    # Terminate the current shell, returning the non-zero exit status of the prior
    # command. This effectively enables "set -e" (i.e., the ERR_EXIT option,
    # terminating the current shell on SIGZERR signals).
    die_with ${exit_status}
}

# ....................{ EXCEPTIONS                         }....................
# void die(char *error_message = '')
#
# Print the passed text to standard error and:
#
# * exit the current script with error.
die() {
    # If the exit status of the prior command signified an error, exit with that
    # status; otherwise, exit with the normal error status (i.e., 1).
    integer exit_status=${?}
    (( ${exit_status} == ${ZESHY_SUCCESS_CODE} )) and
       exit_status=${ZESHY_FAILURE_CODE}
    
    # Print the passed error message and a complete stack trace.
    curse "${@}"
    print_stack_trace

    # Die with the prior return code.
    die_with ${exit_status}
}

# ....................{ TESTS                              }....................
# bool is_set_nonempty(char *variable_name)
#
# Return true if the variable with the passed name is set and non-empty.
is_set_nonempty() {
    die_unless_one_argument 'expected exactly one variable name'
    is -n "${(P)1-}" si    # See below.
}

# bool is_set(char *variable_name)
#
# Return true if the variable with the passed name is set (i.e., declared).
is_set() {
    die_unless_one_argument 'expected exactly one variable name'

    # Dismantled, this is:
    # 
    # * "1", the passed name.
    # * "(P)", the variable the passed name refers to.
    # * "+x", the value to expand this variable to if set. Since any non-empty
    #   value will do, arbitrarily use "x".
    # * "-n", true only if this variable is "x" and hence set.
    is -n "${(P)1+x}" si
}

# bool is_unset(char *string)
#
# Return true if the  variable with the passed name is unset (i.e., undeclared).
is_unset() {
    die_unless_one_argument 'expected exactly one variable name'
    is -z "${(P)1+x}" si  # negate the condition is_set() tests for
}

#FIXME: Rename is_nonzero(), in keeping with Zsh nomenclature.
# bool is_nonempty(char *string)
#
# Return true if the passed string is non-empty (i.e., not "").
is_nonempty() {
    die_unless_one_argument 'expected exactly one string'
    is -n "${1}" si
}

#FIXME: Rename is_zero(), in keeping with Zsh nomenclature.
# bool is_empty(char *string)
#
# Return true if the passed string is empty (i.e., "").
is_empty() {
    die_unless_one_argument 'expected exactly one string'
    is -z "${1}" si
}

# ....................{ IMPORTS                            }....................
# void zimports(char *script_name1, ..., char *script_nameN)
# 
# Import all passed scripts.
zimports() {
    die_unless_at_least_one_argument 'expected at least one script name'
    for script_name in "${@}"; do zimport "${script_name}"; done
}

# void zimport(char *pathname, char *arguments)
# 
# Conditionally import the passed file or directory, if not previously imported
# by this function or externally modified since such import. We pass the passed
# arguments to all files imported in this manner.
# 
# If the passed path is relative, we look for such path first under the current
# working directory and then Zeshy's root directory (e.g., "/usr/share/zeshy/").
# We then resolve the exact Zeshy script(s) to be imported as follows:
#
# * If the passed path is an existing file, import such file.
# * If the passed path is an existing directory:
#   * Containing a file named "${ZESHY_MAIN_SCRIPT_BASENAME}", import such file.
#   * Otherwise, import all files such directory contains.
# * Otherwise, die.
#
# This function mimics the import() built-in of most high-level languages. To
# avoid conflict with ImageMagick's "import" command, we prefer "zimport".
#
# --------------------( VARIABLES                          )--------------------
# This function defines local variables, which imported scripts may safely
# access for informative path metadata: namely,
#
# * "zeshy_script_name", having the relative path to the imported script under
#   "${ZESHY_HOME}/src".
# * "zeshy_script_path", having the absolute path to the imported script.
# * "zeshy_script_mtime", having the modification time of the imported script.
#
# --------------------( EXAMPLES                           )--------------------
#     # Implicitly imports the Zeshy script "zeshy/os/.main".
#     >>> zimport zeshy/os
zimport() {
    die_unless_at_least_one_argument\
        'expected one pathname and optional script options'
#   utter "zimporting ${1}..."

    # Passed script name. Shift it off the argument stack, to allow us to pass
    # this script the set of all remaining arguments on sourcing it below.
    string zeshy_script_name="${1}"; shift

    # Absolute path to this script.
    string zeshy_script_path 
    
    # If the passed script name is either an absolute path or existing relative
    # path, try to import it as is.
    if is "${zeshy_script_name[1]}" == '/' or -e "${zeshy_script_name}" si
    then zeshy_script_path="${zeshy_script_name}"
    #FIXME: Actually, first try the current working directory.
    # Otherwise, try to import a Zeshy component having that script name.
    else zeshy_script_path="${ZESHY_HOME}/src/${zeshy_script_name}"
    fi
    
    # Delegate to helper functions depending on path type.
    if is_dir "${zeshy_script_path}"
    then zimport_dir  "${zeshy_script_path}" "${@}"
    else zimport_file "${zeshy_script_path}" "${@}"
    fi
}

# void zimport_dir(char *dirname, char *arguments)
# 
# Conditionally import the passed directory. See zimport() for details.
zimport_dir() {
    die_unless_at_least_one_argument\
        'expected one dirname and optional import options'
    string zeshy_script_dir="${1}"; shift
    is_dir "${zeshy_script_dir}" or
        die "\"${zeshy_script_dir}\" not a directory or not found"
    string zeshy_main_script="${zeshy_script_dir}/${ZESHY_MAIN_SCRIPT_BASENAME}"

    # If this directory contains a main script, import only such script;
    # otherwise, import all children of such directory.
    if is_file "${zeshy_main_script}"
    then zimport_file         "${zeshy_main_script}" "${@}"
    else zimport_dir_children "${zeshy_script_dir}" "${@}"
    fi
}

# void zimport_dir_children(char *dirname, char *arguments)
# 
# Conditionally import all files and directories under the passed directory.
zimport_dir_children() {
    die_unless_at_least_one_argument\
        'expected one dirname and optional import options'
    string zeshy_script_dir="${1}"; shift
    is_dir "${zeshy_script_dir}" or
        die "\"${zeshy_script_dir}\" not a directory or not found"

    # Dismantled, this imports all files in this directory subject to:
    #
    # * "(^D@)", excluding dotfiles and symbolic links.
    # * "~*.(swp|zwc)", excluding files with filetype "swp" or "zwc".
    for zeshy_script_dir_child in "${zeshy_script_dir}"/*(^D@)~*.(swp|zwc); do
        zimport "${zeshy_script_dir_child}" "${@}"
    done
}

#global_string ZESHY_CACHE_COMPILATION_DIR="${ZESHY_CACHE_DIR}/compilation"
#FIXME: Add support for zcompile(). Pass "-M" if the passed file matches
# */zeshy/src/* and "-R" otherwise.
# void zimport_file(char *filename, char *arguments)
# 
# Conditionally import the passed file. See zimport() for details.
zimport_file() {
    die_unless_at_least_one_argument\
        'expected one filename and optional import options'
    string zeshy_script_path="${1}"; shift
    die_unless_file "${zeshy_script_path}"
   
    # Canonicalize the path so as to ensure the dictionary lookup below
    # successfully compares it against a previously canonicalized path.
    zeshy_script_path="$(canonicalize_path "${zeshy_script_path}")"

    #FIXME: Hmm; this should be an integer, but Zsh is currently hassling me. *sigh*
    # Modification time of this script.
    string zeshy_script_mtime
    zeshy_script_mtime=$(get_path_mtime "${zeshy_script_path}")
    
    # If this script has not yet been imported or has been but has changed since
    # being imported, (re)import this script.
    if is -z\
        "${ZESHY_IMPORTED_PATH_TO_MTIME[(I)"${zeshy_script_path}"]}" or
        "${ZESHY_IMPORTED_PATH_TO_MTIME["${zeshy_script_path}"]}" -ne\
        "${zeshy_script_mtime}" si; then
        # If the script corresponds to a command-specific script under
        # "zeshy/command" excluding the top-level ".main" script, ensure this
        # command is actually installed.
        if is "${zeshy_script_path}" == */zeshy/command/* si; then
            string command_name="${zeshy_script_path#*/zeshy/command/}"
            is "${command_name}" == "${ZESHY_MAIN_SCRIPT_BASENAME}" si or
                die_unless_installed "${command_name}"
        fi

        # Record this script as being imported prior to doing so, thus
        # preventing infinitely recursive reimportation should this or another
        # script imported by this script attempt to import this script again.
        ZESHY_IMPORTED_PATH_TO_MTIME["${zeshy_script_path}"]="${zeshy_script_mtime}"

        #FIXME: Technically, this works. Sadly, Zsh exposes no explicit
        #mechanism for sourcing zcompiled scripts. (Odd, we know.) Rather, one
        #can only use such scripts with the fpath-enabled autoload mechanism.
        # Absolute path to the file caching the compilation of this script.
#       string zeshy_script_compiled_path="${ZESHY_CACHE_COMPILATION_DIR}${zeshy_script_path}.zwc"

        # If this script has not yet been compiled or has been but has changed since
        # being compiled, (re)compile this script.
#       if is not -f "${zeshy_script_compiled_path}" or\
#           ${zeshy_script_mtime} -ne\
#           $(get_path_mtime "${zeshy_script_compiled_path}") si; then
#           # zcompile() refuses to create directory structure, so do so for it.
#           make_directory_if_not_found "$(dirname "${zeshy_script_compiled_path}")"

#           utter "compiling \"${zeshy_script_path}\" to \"${zeshy_script_compiled_path}\"..."
#           utter "compiling \"${zeshy_script_path}\"..."
#           zcompile "${zeshy_script_compiled_path}" "${zeshy_script_path}"

            # Set the mtime of the compiled script to that of the uncompiled
            # script to ensure the above conditional fails on future imports.
#           set_path_mtime "${zeshy_script_compiled_path}" ${zeshy_script_mtime}
#       fi
#       source "${zeshy_script_compiled_path}" "${@}"

        # Do so.
        utter "requiring \"${zeshy_script_path}\"..."
        source "${zeshy_script_path}" "${@}"
    fi
}

# void zeshy_initialize_imports(void)
#
# Initialize the imports dictionary, used by the zimport() function. This is a
# global dictionary mapping from imported script name to the mtime (i.e.,
# modification time) of the script at the time of importation. The zimport()
# function adds script names to this dictionary on importing those scripts so
# as to record having done so. This record keeping allows that function to
# avoid importing already imported scripts.
#
# Zeshy Shell requires we separate this initialization into a distinct function,
# for hitherto inexplicable reasons. (There be subtle dragons aboot.)
zeshy_initialize_imports() {
    die_unless_no_arguments
    
    # Explicitly empty the dictionary. This is irrelevant on the first call to
    # this function, but definitely matters on subsequent calls!
    global_map ZESHY_IMPORTED_PATH_TO_MTIME; ZESHY_IMPORTED_PATH_TO_MTIME=( )
}

# ....................{ MAIN                               }....................
_zeshy_core() {
    die_unless_no_arguments

    # Initialize the imports dictionary used by the zimport() function.
    zeshy_initialize_imports
    
    # Inform the user that this script is being imported. This script is usually
    # sourced via the Zsh source() built-in rather than the Zeshy zimport()
    # function; thus, our failure to do this here would require callers do this
    # there, prior to their sourcing this script.
    #
    # Distinguish the former from the latter by noting whether the
    # "${zeshy_script_mtime}" variable has been set or not; if it has, this script
    # was sourced via zimport() rather than source().
    is_unset 'zeshy_script_mtime' or utter "loading \"${zeshy_core_path}\"..."
    
    # Make cache directories, if not already made.
    make_directory_if_not_found "${ZESHY_CACHE_DIR}" 
}

# Call and then immediately unset (i.e., delete) _zeshy_core().
_zeshy_core
unfunction _zeshy_core

#FIXME: Obsolete.
    # Import all non-dotfiles in this directory with the "(^D)" modifier (i.e.,
    # all files and directories *NOT* prefixed by a "."). Since Zeshy scripts
    # explicitly import dependencies, order of import is mostly insignificant.

#   if is -z\
#       "${ZESHY_IMPORTED_PATH_TO_MTIME[(I)"${zeshy_script_path}"]}" or
#       "${ZESHY_IMPORTED_PATH_TO_MTIME["${zeshy_script_path}"]}" -ne\
#       "${zeshy_script_mtime}" si; then

# This glob expression matches the basename of all non-executable readable
# files residing under every path in the function path list, "${fpath}". Via
# Zsh mandate, every such file basename corresponds to the autoloadable
# function name defined in the file. Thus, matching these basenames also
# matches all autoloadable function names.
#
# * "-.x" ignores non-executable files. While not strictly necessary, forum
# posters suggest this beneficially permits you to ignore undesirable autoloads
# by chmodding away their executable bit.  * "-.r" ignores non-readable files.
# This is strictly necessary.  * ":t" extracts the "tail" (i.e., basename) of
# the current file. This is a history modifier extracting each file's filename
# sans absolute path.
# 
#for autoload_function_name in ${^fpath}/*(N-.r:t); do

#FIXME: I suppose I don't quite understand why we can't simply implement this as
#some variant of '"${@}" 1>/dev/null 2>&1'. Doesn't that work as is?
#quietly() { run "${(q)@}" 1>/dev/null 2>&1 }

#   is "${#command}" exceeds 0 si or die 'expected exactly one command'
#
#global_alias to='|'

    # Decompacted:
    # 
    # * "1", the passed name.
    # * "(P)", the variable the passed name refers to.
    # * "-", the value to expand this variable to if unset:
    #   in this case, simply the empty string.
    # * "-z", true only if this variable is the empty string and hence unset.
#    is -z "${(P)1-}" si

# ....................{ COMMANDS ~ return codes            }....................
# void try_as_superuser(char *command)
#
# Run the passed command as the superuser and, if it fails with error,
# terminate the current execution environment with the same error.
#try_as_superuser() {
#    run_as_superuser "${@}" or die
#}

# int get_last_exit_status(void)
# 
# Return the return code returned by the previous command.
#alias get_last_exit_status='is_ok'

# bool is_ok(void)
#
# Return success if the previous command succeeded. Otherwise, return failure.
#is_ok() {
#    # Cache the prior command's return code, as our initial sanity check on
#    # arguments replaces this code with its own.
#    integer prior_command_exit_status=${?}
#    die_unless_no_arguments
#    return ${prior_command_exit_status}
#}

# bool is_error(void)
#
# Return success if the previous command failed. Otherwise, return failure.
#is_error() {
#    # Cache the prior command's return code, as our initial sanity check on
#    # arguments replaces this code with its own.
#    integer prior_command_exit_status=${?}
#    die_unless_no_arguments
#    is ${prior_command_exit_status} -ne ${ZESHY_SUCCESS_CODE} si
#}

# char *canonicalize_path_nonfatal(char *pathname)
#
# Get the canonicalized form of the passed absolute path. Unlike the
# canonicalize_path() function, this function does not raise an exception when
# the passed path does not exist; it simply canonicalizes as much of this path
# as exists.
#canonicalize_path_nonfatal() {
#    die_unless_one_argument 'expected exactly one pathname'
#    readlink --canonicalize-missing "${1}"
#}

#FIXME: This and try() now obsolete by TRAPZERR(). Excise everywhere.
# void try_quietly_as(char *username, char *command)
#
# Run the passed command as the passed user quietly and, if it fails with error,
# terminate the current execution environment with the same error.
#try_as() {
#    die_unless_at_least_two_arguments\
#        'expected exactly one username and one command'
#
#    # Locally set "${ZESHY_RUN_AS}". The run() function notes this variable as
#    # set and behaves accordingly...
#    string ZESHY_RUN_AS="${1}"; shift
#
#    # Call try() with all remaining arguments: the command to be run.
#    try "${(q)@}"
#}

# void try(char *command)
#
# Run the passed command and, if it fails with error, terminate the current
# execution environment with the same error.
#try() {
#    run "${(q)@}" or die "\"${@}\" returned error code ${?}"
#}

# void try_quietly(char *command)
#
# Run the passed command quietly and, if it fails with error, terminate the
# current execution environment with the same error.
#try_quietly() {
#    quietly try "${@}" or die "\"${@}\" returned error code ${?}"
#}

# void try_quietly_as(char *username, char *command)
#
# Run the passed command as the passed user quietly and, if it fails with error,
# terminate the current execution environment with the same error.
#try_quietly_as() {
#    quietly try_as "${@}" or die "\"${@}\" returned error code ${?}"
#}

# bool or(...)
#
# Return true if at least one of the passed command's returned successfully.
#global_alias or='||'

# bool and(...)
#
# Return true if both of the passed command's returned successfully.
#global_alias and='&&'

# bool not(...)
#
# Negate the passed command's return code.
#alias not='!'

#FIXME: This function appears to be functionally obsolete now. If so, kill and
#rename which_command() to this.
# Aliases.
#alias which_binary="which_command"
#alias which_binary_nonfatal="which_command"

# char *which_command(char *command)
#
# Print the absolute path to the passed command: e.g.,
#
#     >>> which_command zsh /bin/zsh
#
# If the passed command is a string, all but the first whitespace-delimited word
# of the string is ignored: e.g.,
#
#     >>> which_command "zsh -x -o shwordsplit scr" /bin/zsh
#
# If the passed command is not found, if multiple binaries are passed, or if no
# command is passed, prints an error and dies.
#which_command() {
#Call the whence() built-in outside of "local" so as to retain the return
    # code. (ZSH == FAIL on that one.) 
#    string command_path; command_path="$(which_command "${@}")"
#    die_unless_ok "\"${1}\" not found"
#    print "${command_path}"
#}
#
# Identical to the which_command() function except that, if the passed command
# does not exist, returns nothing rather than dies.

#FIXME: No longer meaningful under TRAPZERR(); excise.
# void die_unless_ok(char *error_message)
#
# Die with the passed error message unless the previous command succeeded.
#die_unless_ok() {
#    # Cache the prior command's return code, as our initial sanity check on
#    # arguments replaces this code with its own.
#    integer prior_command_exit_status=${?}
#    die_unless_one_argument 'expected exactly one error message'
#    is ${prior_command_exit_status} -eq ${ZESHY_SUCCESS_CODE} si or die "${1}"
#}

# void utter_import(char *script_name)
#
# Echo a message informing the user that the passed script name is being
# imported. This function should be called prior to actually importing that
# script if feasible.
#utter_import() {
#    die_unless_one_argument 'expected exactly one script name'
#
#    utter "loading \"${1}\"..."
#}

    # If the caller has supplied no explicit "${ZESHY_SCRIPT_NAME}", supply a
    # default.  Failing to do this encourages the utter() function to use the
    # name of this function as its script name, producing unaesthetic results.
#   "${ZESHY_SCRIPT_NAME:=zeshy}"

        # Print the passed error message followed by a complete backtrace.
#   curse "${@}"
#   print_stack_trace
 #
    # Shells differentiate
    # fatal from non-fatal errors by setting the high bit (i.e., 2^7 = 128).
    # According to "zshbuiltins", this forces Zsh to continue handling the
    # signal as if untrapped and hence returning the same exit status. Having no
    # arcanely carnal knowledge of the Linux signal implementation, it's unclear
    # why setting the high bit 

    #FIXME: Old.
    # If the passed path is a directory, only import filename
    # "${ZESHY_MAIN_SCRIPT_BASENAME}" in this directory.
#   is -d "${zeshy_script_path}" si and
#       zeshy_script_path="${zeshy_script_path}/${ZESHY_MAIN_SCRIPT_BASENAME}"
    
    # If this path does not exist, die.
#   is -f "${zeshy_script_path}" si or die "\"${zeshy_script_path}\" not found"
 #
#FIXME: Impossible to remember, I'm afraid. Perhaps "fail_if_error", instead?
# int fail_if_previous_command_failed(void)
# 
# Return from the current function with failure if the previous command or
# function also returned with failure.
#alias fail_if_previous_command_failed="is_ok || return ${ZESHY_FAILURE_CODE}"

#; ZESHY_IMPORTED_PATH_TO_MTIME=( )
#   typeset -Ax ZESHY_IMPORTED_PATH_TO_MTIME; ZESHY_IMPORTED_PATH_TO_MTIME=( )
 # The "-Ax" option to the "typeset" commands defines each such variable as an
# [A]ssociative array (i.e., a dictionary) and e[x]ported to the global
# environment for later access.

# Ascertain whether we are running as a cronjob and, if so, alter output
# appropriately. In particular, print the current date as a timestamp prior to
# printing all other output.

#   die_unless_at_least_one_argument 'expected at least one string'

#   # If no string was passed, attempt to read "stdin" for piped input.
#   if is_one_argument; then
#       set -- "${1}" "$(< /dev/stdin)"
#   fi

#   pcre_compile "${1}" || die "\"${1}\" not a valid regular expression"
#   pcre_match "${2}" || return ${?}
#   return ${ZESHY_SUCCESS_CODE}

# This function returns success 
# If this regular expression matched at least one group, this function returns
# this group as a string for caller convenience... Else, this function returns
# nothing. In the former case, callers may retrieve the set of all groups via
# the global "${match}" array. (See above.)

    # When the whence() built-in fails, it prints the name of the passed command
    # followed by "not found". Thus, if it prints such a message, the passed
    # command does not exist. Note that testing the return code is problematic
    # here, since setting a local variable always forces the return code to 0
    # (i.e., success). 
#   if [[ "${command_path}" == *" not found" ]]; then
#       return ${ZESHY_FAILURE_CODE}
#   else
#       echo "${command_path}"
#       return ${ZESHY_SUCCESS_CODE}
#   fi

    # O.K., this is tricksy: if the eventual caller explicitly quote-protected
    # the passed command name, there exists another "layer" of quote-protection
    # to unravel. Do so, alas.
#   if ! is_installed "${command_name}" && is_installed "${(Q)command[1]}"; then
#       command_name="${(Q)command[1]}"
#   fi

    #echo "PID: $$"
    #echo "current_process_basename:"
    #get_current_process_basename
    #echo "current_process_command_line:"
    #get_current_process_command_line

# ....................{ GLOB EXPRESSIONS                   }....................
# char **glob_non_dotfiles_in(char *dirname)
#
# Glob all non-dotfiles (i.e., all files and directories whose first character
# is not a '.' dot) in the passed directory.
#glob_non_dotfiles_in() {
#    [[ ${#} -eq 1 ]] || die "expected exactly one directory name"
#    local dirname="${1}"
#    [[ -d "${dirname}" ]] || "\"${dirname}\" not a directory"
#
#    # Glob all non-dotfiles via the "(^D)" modifier.
#    echo "${dirname}"/*(^D)
#}

 # Enable variable substitution in prompt expansions in a "synchronous" fashion.
# Enabling this re-evaluates each prompt expansion after perform each
# interactive command with the current values of those variables without
# having to manually recreate the prompt each time.
#setopt promptsubst

#The existence of this variable also
# serves to inform callers as to whether or not this script has been imported
# yet and, when it has, to avoid reimporting it.

# Directory above the directory having the current script. This environment
# variable should have been permanently added to the current system as well.
#[[ -n "${ZESHY_ROOT}" ]] ||  
#    export ZESHY_ROOT=$(readlink --canonicalize-existing "${ZESHY_HOME}/..")

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
