#!/usr/bin/env zsh
# ====================[ file                               ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# ZeshyInit File, implementing core file handling.

# ....................{ EXCEPTIONS                         }....................
# void die_if_file(char *filename, char *error_message = 'is a file')
#
# Raise an exception if the passed file exists.
die_if_file() {
    die_unless_one_or_two_arguments\
        'expected filename and optional error message'
    string filename="${1}"
    is_file "${filename}" and die "${2:-\"${filename}\" is an existing file}"
}

# void die_unless_dir(char *dirname, char *error_message = 'not a directory')
#
# Raise an exception unless the passed directory exists.
die_unless_dir() {
    die_unless_one_or_two_arguments\
        'expected dirname and optional error message'
    string dirname="${1}"
    is_dir "${dirname}" or
        die "${2:-\"${dirname}\" not found or not a directory}"
}

# void die_unless_file(char *filename, char *error_message = 'not a file')
#
# Raise an exception unless the passed file exists.
die_unless_file() {
    die_unless_one_or_two_arguments\
        'expected filename and optional error message'
    string filename="${1}"
    is_file "${filename}" or die "${2:-\"${filename}\" not found or not a file}"
}

# void die_unless_found(char *pathname, char *error_message = 'not found')
#
# Raise an exception unless the passed path exists.
die_unless_found() {
    die_unless_one_or_two_arguments\
        'expected pathname and optional error message'
    string pathname="${1}"
    is_found "${pathname}" or die "${2:-\"${pathname}\" not found}"
}

# void die_unless_installed(
#   char *command_name, char *error_message = 'not found in $PATH')
#
# Raise an exception unless the passed command exists.
die_unless_installed() {
    die_unless_one_or_two_arguments 'expected exactly one command name'
    string dirname="${1}"
    is_installed "${dirname}" or die "${2:-\"${dirname}\" not found in \$PATH}"
}

# ....................{ TESTS                              }....................
# bool is_absolute_pathname(char *pathname)
#
# Return true if the passed path is absolute (i.e., begins with an "/"),
# regardless of whether it actually exists.
is_absolute_pathname() {
    die_unless_one_argument 'expected exactly one path'
    is "${1[1]}" == '/' si
}

# bool is_dir(char *pathname)
# 
# Return true if the passed path is an existing directory.
is_dir() {
    die_unless_one_argument 'expected exactly one pathname'
    is -d "${1}" si
}

# bool is_file(char *pathname)
# 
# Return true if the passed path is an existing file.
is_file() {
    die_unless_one_argument 'expected exactly one pathname'
    is -f "${1}" si
}

# bool is_found(char *pathname)
# 
# Return true if the passed path exists.
is_found() {
    die_unless_one_argument 'expected exactly one pathname'
    is -e "${1}" si
}

# bool is_installed(char *command_name)
#
# Return true if the command with the passed name is currently installed.
is_installed() {
    # Do not call the quietly() function, as that calls the run() function which
    # calls *THIS* function which induces an infinitely recursive loop. Agathoth 
    # and Memnon!
    which_command "${@}" 1>/dev/null 2>&1
}

# bool is_symbolic_link(char *pathname)
# 
# Return true if the passed path is an existing symbolic link.
is_symbolic_link() {
    die_unless_one_argument 'expected exactly one pathname'
    is -L "${1}" si
}

# ....................{ GETTERS                            }....................
# int get_path_mtime(char *pathname)
#
# Get the mtime (i.e., modification time) of the passed path in Unix time,
# reflecting the most recent time of path creation or change of path content
# (i.e., file content for files and the list of files and subdirectories for
# directories), filename, or permissions. For directories, mtime does *NOT*
# reflect change of file or subdirectory content or permissions.
get_path_mtime() {
    die_unless_one_argument 'expected exactly one pathname'
    zstat +mtime "${1}"
}

# int get_path_mtime_recursive(char *pathname)
#
# Get the recursive mtime (i.e., modification time) of the passed path in Unix
# time. For files, this is the same time as returned by the non-recursive
# get_path_mtime() function. For directories, this reflects the most recent time
# of recursive path creation or change of path content, filename, or
# permissions. This function is considerably more costly than get_path_mtime().
get_path_mtime_recursive() {
    die_unless_one_argument 'expected exactly one pathname'
    string pathname="${1}"

    if is_file "${pathname}"; then
        get_path_mtime "${pathname}"
    elif is_dir "${pathname}"; then
        # Dismantled, this is:
        #
        # * "${pathname}"/**/*, all files and subdirectories of this directory.
        # * "om", such files and subdirectories in ascending order by mtime.
        # * "[1]", the first and hence newest such file or subdirectory.
        get_path_mtime "${pathname}"/**/*(om[1])
#           "$(find "${pathname}" -type f -printf '%A@\t%p\n' | sort -r -k1 | head -n1 | cut -f2)"
    else
        die "\"${pathname}\" not a file or directory or not found"
    fi
}

# ....................{ SETTERS                            }....................
# void set_path_mtime(char *pathname, int mtime)
#
# Set the mtime (i.e., modification time) of the passed path in Unix time.
set_path_mtime() {
    die_unless_two_arguments 'expected exactly one pathname and one mtime'
    string pathname="${1}"
    integer mtime="${2}"
    die_unless_found "${pathname}"
    touch -m --date=@"${mtime}" "${pathname}"
}

# ....................{ FINDERS                            }....................
# char *canonicalize_pathname(char *pathname)
#
# Get the canonicalized form of the passed absolute path. Canonicalization
# reduces this path to standard form, such that two canonical paths are equal
# if and only if they represent the same file. Note that this is not
# necessarily the case with non-canonical paths (e.g., "/tmp" and
# "/tmp/../tmp/./" are not equal but represent the same directory).
# Specifically, canonicalization:
#
# * Expands every pseudo-directory component (e.g., "./", "../") iteratively,
#   until the resulting path contains no pseudo-directory components.
# * Expands every symlink in every component of the passed path recursively,
#   until the resulting path contains no symlinks.
canonicalize_pathname() {
    die_unless_one_argument 'expected exactly one pathname'
    readlink --canonicalize-existing "${1}"
}

# char *which_command(char *command_name)
#
# If found, print the absolute path to the command with the passed name;
# otherwise, return false. All but the first whitespace-delimited word of this
# string is ignored: e.g.,
#
#     >>> which_command zsh
#     /bin/zsh
#     >>> which_command "zsh -x -o shwordsplit scr"
#     /bin/zsh
which_command() {
    die_unless_one_argument 'expected exactly one command name'
    string command_path command_name="${1[(w)1]}"

    # If no command has the passed name, print an error message and return
    # failure. To permit the caller to recover, do not raise a fatal error.
    if not command_path="$(whence -cp "${command_name}")"; then
        curse "\"${command_name}\" not found"
        return_failure
    fi

    # Otherwise, print the discovered absolute path to this command.
    print "${command_path}"
}

# ....................{ WRITERS                            }....................
# void make_directory_if_not_found(char *dirname1, char *dirname2, ...)
#
# Examine each of the passed absolute paths and, for each non-existant path,
# make that path and all non-existant parent paths of that path.
make_directory_if_not_found() {
    die_unless_one_argument 'expected exactly one dirname'

    # While there are more paths to consider, shift the current path to be
    # considered to a local variable "new_path" and make it when not found.
    string new_path
    while is_arguments; do
        new_path="${1}"; shift

        if is_file "${new_path}"; then
            die "\"${new_path}\" already a file"
        elif not is_dir "${new_path}"; then
#           utter "making \"${new_path}\"..."
            mkdir --parents "${new_path}"
        fi
    done
}

# void make_symbolic_link(char *source_pathname, *target_filename)
#
# Symbolically link the former passed path to the latter passed file. If such
# file already exists and is a symbolic link, replace such file without error;
# otherwise, raise an error if such file already exists.
make_symbolic_link() {
    die_unless_two_arguments\
        'expected exactly one source pathname and one target filename'
    string source_pathname="${1}" target_filename="${2}"
    die_unless_exists "${source_pathname}"

    if is_symbolic_link "${target_filename}"; then
        ln -sf "${source_pathname}" "${target_filename}"
    else
        die_if_exists "${target_filename}"
        ln -s  "${source_pathname}" "${target_filename}"
    fi
}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
