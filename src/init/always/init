#!/usr/bin/env zsh
# ====================[ all                                ]====================
#                     [ Time-stamp: "2009-04-18 19:29:36 leycec" ]
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy All. This Zeshy components imports all other Zeshy dependencies in a
# "system-sensitive" manner: i.e., importing only specific dependencies
# relevant to the current system.
#
# --------------------( TODO                               )--------------------
# * All binary-specific functions (e.g., screenify()) should be moved into a new
#   "zeshy/command/" directory, with one file under that directory per binary:
#   "zeshy/command/screen", "zeshy/command/mysql", and so forth. Then, the
#   "zeshy/command/main" dynamically imports all scripts in that directory
#   (ignoring itself, of course) which are also installed on the current system.
#   Bloody sweet, no? Though one could quite see that becoming expensive
#   quickly. Long-term, an autoload solution is far more elegant.

# ....................{ PREAMBLE                           }....................
# Zeshy home directory, if not already set.
[[ -n "${ZESHY_HOME}" ]] ||
    export ZESHY_HOME=$(readlink --canonicalize-existing "$(dirname "${0}")/../..")

# Import Zeshy Core defining import() prior to importing other dependencies.
[[ $(whence -w zimport) =~ ': function' ]] ||
    source "${ZESHY_HOME}/src/init/core"

# ....................{ PATHS                         }....................
global_string ZESHY_DIGEST_DIR="${ZESHY_CACHE_DIR}/digest"
global_string ZESHY_DIGEST_FILE="${ZESHY_CACHE_DIR}/digest.zwc"
global_string ZESHY_AUTOLOAD_ALWAYS_DIR="${ZESHY_HOME}/src/auto/always"
global_string ZESHY_AUTOLOAD_IF_INSTALLED_DIR="${ZESHY_HOME}/src/auto/if_installed"

# ....................{ IMPORTS                       }....................
# void _zeshy_init(void)
#
# Import all Zeshy dependencies relevant for the current system. Typically, this
# means:
#
# * All scripts immediately under "zeshy/".
# * All scripts under "zeshy/distro" corresponding to the current distribution
#   (e.g., "zeshy/distro/exherbo" on Exherbo systems).
_zeshy_init() {
    #     zrecompile -p\
    #         -R ~/.zshrc --\
    #         -M ~/.zcompdump --\
    #         ~/zsh/comp.zwc ~/zsh/Completion/*/_*
    #
    #This does everything for us. Swag, no? Memory map everything, of course.
    #Oh, and the latter line is the one that applies to us. To quote: "re-create
    #the file ~/zsh/comp.zwc if any of the files matching the given pattern is
    #newer than it." We'll need to dynamically construct the arguments to be
    #passed for the command-specific directories. Shouldn't be hard:
    #
    #     list zrecompile_args
    #     zrecompile_args=( "${generic_dir}.zwc" "${generic_dir}"/**/*(.) )
    #     for command_dir in "src/auto/command"/*(/); do
    #         zrecompile_args+=( "${command_dir}.zwc" "${command_dir}"/**/*(.) )
    #     done
    #     print "za: ${zrecompile_args[@]}"

    integer zeshy_mtime=$(get_path_mtime_recursive "${ZESHY_SRC_HOME}")

    utter "detecting \"${ZESHY_DIGEST_DIR}\"..."
    if not is_dir "${ZESHY_DIGEST_DIR}" or
        (( zeshy_mtime != $(get_path_mtime "${ZESHY_DIGEST_DIR}") )); then
        utter "compiling \"${ZESHY_DIGEST_FILE}\"..."

        for autoload_function_file in\
            "${ZESHY_AUTOLOAD_ALWAYS_DIR}"/**/*~*.(swp)(.); do
            make_symbolic_link "${autoload_function_file}" "${ZESHY_DIGEST_DIR}"
        done

        # Set the mtime of the compiled script to that of the uncompiled
        # script to ensure the above conditional fails on future imports.
        set_path_mtime "${ZESHY_DIGEST_DIR}" "${zeshy_mtime}"
    fi

    utter "detecting \"${ZESHY_DIGEST_FILE}\"..."
    if not is_file "${ZESHY_DIGEST_FILE}" or
        (( zeshy_mtime != $(get_path_mtime "${ZESHY_DIGEST_FILE}") )); then
        utter "compiling \"${ZESHY_DIGEST_FILE}\"..."
        zcompile "${ZESHY_DIGEST_FILE}" "${ZESHY_DIGEST_DIR}"/**/*(@)

        # Set the mtime of the compiled script to that of the uncompiled
        # script to ensure the above conditional fails on future imports.
        set_path_mtime "${ZESHY_DIGEST_FILE}" "${zeshy_mtime}"
    fi

    # Declare all functions provided by the digest file to be autoloadable.
    autoload -w "${ZESHY_DIGEST_FILE}"

    # Prefix "${FPATH}" with the absolute path to the digest file, ensuring Zsh
    # searches such file for the definition of such functions first. Oddly, Zsh
    # has no means of directly associating the two.
    fpath=( "${ZESHY_DIGEST_FILE}" "${fpath[@]}" )
}

#FIXME: Harvest comments from the now-dead portion of zimport_file().
#
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#O.K.; the game plan:
#* Separate each function into a separate file. No symlinks. I know; I know.
#  This is awful. But Zsh is as it is on this score. There's no fixing that.
#* Initialization needs to be centralized into a set of core files. Here's
#  what I'm thinking, now: cleave the "src/" directory into:
#  * "src/root", containing "zprofile", "zlogin", and "zshrc".
#  * "src/main", containing this file, "core", and all other initialization as
#    perhaps another file or two ("globals"? bah!). All global variable
#    declarations need to be shifted here.
#  * "src/auto/generic", containing the bulk of Zeshy as such autoloadable function
#    files. All such functions are safely applicable to all systems.
#  * "src/auto/command", allowing for conditionally autoloaded command-specific
#    function directories (e.g., "src/auto/command/ssh").
# * We need one digest for all of "generic" and one digest for each immediate
#   subdirectory of "src/auto/command", the latter conditionally autoloaded if
#   such command exists.
# * This scheme clearly allows for things like "src/auto/os", should we require
#   it. I'm currently considering trashing that... just assume GNU/Linux, for
#   the moment. (Time!)
# * Hmm; perhaps?:
#   "src/catabolize/".
#   "src/initialize/".
#   "src/bootstrap/".
#   "src/framework/".
#   "src/profile/".
#   "src/context/".
# * Ah; O.K.; how about just:
#   "src/construct/".
#   "src/bootstrap/".
#   "src/autoload/always".
#   "src/autoload/if_installed".
# * Or mayhap:
#   "src/boot/".
#   "src/init/".
#   "src/auto/always".
#   "src/auto/if_installed".
#
#Yes, it's lame. But our hands are really constrained, here.
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!
_zeshy_autoload_digest_old() {
    #FIXME: This only applies to developer systems. In production, Zeshy
    #requires only one initial compilation, thus eliminating the cost of such
    #recompilation. Ah; I wonder. Wouldn't a "zrecompile -p" immediately after
    #declaring the "fpath" do this, assuming we'd first compiled all necessary
    #digests? If so, that would suggest we'd only need a simple test for
    #
    #    if not is_file "${ZESHY_DIGEST_FILE}"; then
    #       # Compile everything anew here! Don't bother checking mtimes.
    #    fi
    #
    #Then, a zrecompile should handle the rest, yes? That would be considerably
    #more efficient, given Zsh's C-backed implementation. Ah; O.K., it gets even
    #better. We can entirely reduce this if-conditional to a zrecompile() call
    #resembling the given example:
    #
    #     zrecompile -p\
    #         -R ~/.zshrc --\
    #         -M ~/.zcompdump --\
    #         ~/zsh/comp.zwc ~/zsh/Completion/*/_*
    #
    #This does everything for us. Swag, no? Memory map everything, of course.
    #Oh, and the latter line is the one that applies to us. To quote: "re-create
    #the file ~/zsh/comp.zwc if any of the files matching the given pattern is
    #newer than it." We'll need to dynamically construct the arguments to be
    #passed for the command-specific directories. Shouldn't be hard:
    #
    #     list zrecompile_args
    #     zrecompile_args=( "${generic_dir}.zwc" "${generic_dir}"/**/*(.) )
    #     for command_dir in "src/auto/command"/*(/); do
    #         zrecompile_args+=( "${command_dir}.zwc" "${command_dir}"/**/*(.) )
    #     done
    #     print "za: ${zrecompile_args[@]}"
    utter "detecting \"${ZESHY_DIGEST_FILE}\"..."
    integer zeshy_mtime=$(get_path_mtime_recursive "${ZESHY_SRC_HOME}")
    if not is_file "${ZESHY_DIGEST_FILE}" or
        (( zeshy_mtime != $(get_path_mtime "${ZESHY_DIGEST_FILE}") )); then
        utter "compiling \"${ZESHY_DIGEST_FILE}\"..."
        # ...the "-." matches all files and symbolic links to files.
        zcompile "${ZESHY_DIGEST_FILE}" "${ZESHY_SRC_HOME}"/**/*~*.(swp|zwc)(-.)

        # Set the mtime of the compiled script to that of the uncompiled
        # script to ensure the above conditional fails on future imports.
        set_path_mtime "${ZESHY_DIGEST_FILE}" "${zeshy_mtime}"
    fi

    # Declare all functions provided by the digest file to be autoloadable.
    autoload -w "${ZESHY_DIGEST_FILE}"

    # Prefix "${FPATH}" with the absolute path to the digest file, ensuring Zsh
    # searches such file for the definition of such functions first. Oddly, Zsh
    # has no means of directly associating the two.
    fpath=( "${ZESHY_DIGEST_FILE}" "${fpath[@]}" )
}

# ....................{ OPTIONS                            }....................
# Permit input and output of meta characters (i.e., characters having the eighth
# bit set). Do not do this in Zeshy Core (although that would be preferable), as
# that appears to add these arguments to the current argument list "${@}".
set meta-flag    on
set input-meta   on
set output-meta  on
set convert-meta off

# ....................{ MAIN                               }....................
# Call and then immediately unset (i.e., delete) _zeshy_main().
_zeshy_init
unfunction _zeshy_init

#FIXME: Obsolete.
    # Add Zeshy's "site-functions/" to the function path, if that directory exists.
#   is_dir "${ZESHY_HOME}/site-functions" and
#       fpath=( "${ZESHY_HOME}/site-functions" "${fpath[@]}" )

    #FIXME: Old.
    # Match all non-dotfiles in the current directory via the "(^D)" modifier:
    # i.e., all files and directories except this one. Since Zeshy components 
    # explicitly import dependencies, importation order is *NOT* important.
#   string import_script_path
#   for import_script_path in "${ZESHY_HOME}/src/zeshy"/*(^D); do
#       zimport "${import_script_path}"
#   done
#       [[ $(basename "${import_script_path}") =~\
#           "^(\..*|${ZESHY_MAIN_SCRIPT_BASENAME})$" ]] ||

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
