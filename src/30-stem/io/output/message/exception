#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *exception printers* (i.e., functions printing exceptions typically
consisting of error messages, exit statuses, and call stacks specific to such
exceptions).
/---

#FIXME: Shift all other related parcels here (e.g.,
#@{00-core/runnable/call_stack/output}). This will probably necessitate
#prefixing parcels here with appropriate ordering indices as under @{00-core},
#which (of course!) is no great trouble.

#FIXME: Provide support for
#${ZY_IS_PRINTING_EXCEPTION_UNCAUGHT_CALL_SOURCE}. We couldn't genuinely do
#so before, due to zsh eccentricities: namely, zsh internally stores function
#definations as post- rather than pre-compilation strings *BUT* paradoxically
#only provides pre-compilation line numbers in both exception stack traces and
#elsewhere (e.g., canonical integer global ${LINENO}). So how do we bridge the
#gap? With obscene cleverness is my clarion call!
#
#Dynamically redefine *ALL* functions to be compiled into the current digest file
#immediately before compiling such file in @{compile}. Specifically, reduce all
#such function definitions to the current expansion of
#"${functions[${function_name}]}", guaranteeing ${LINENO} to always correspond
#to such expansion.
#FIXME: Fantastic! Function reduction is as simple as performing the identity
#mapping on ${functions}: e.g.,
#
#    # This actually works. Yay! Absurd efficiency for the win.
#    functions[lam]="${functions[lam]}"
#
#This implies *ALL* functions may be reduced with the following single
#function:
#
#    # This actually works, too. It's noticably slow (say, a full second), but
#    # the payoff is absolutely worth it. It's also worth noting that this is
#    # pretty much guaranteed to be the most efficient means of doing so,
#    # implying that individually reducing functions could be even slower.
#    functions=( "${functions[@]}" )
#FIXME: In summary:
#
#* Add a single line 'functions=( "${functions[@]}" )' to
#  @{zz-end/zz-precompile}.
#* Add support for boolean global
#  ${ZY_IS_PRINTING_EXCEPTION_UNCAUGHT_CALL_SOURCE} here.
#FIXME: Note the following excellent documentation we've already written on the
#same (well, *MOSTLY*) subject:
    # Declare such function identified by the previously registered function
    # prototype and defined by the previously registered function body.
    #
    # Technically, doing so redefines such function at least twice:
    #
    # 1. As placeholder function ::func(). This is the pre-compiled definition
    #    of such function (i.e., the original definition of such function prior
    #    to internal compilation stripping all ignorable lexical constructs,
    #    including comments and negligible whitespace). Hence, such function
    #    retains all original comments and whitespace.
    # 2. As the one or more function names declared by such prototype. Since
    #    "${functions[::func]}" expands to the post-compiled definition of such
    #    function (i.e., the final definition of such function subsequent to
    #    internal compilation stripping all ignorable lexical constructs,
    #    including comments and negligible whitespace)), all such functions
    #    omit all original comments and whitespace.
    #
    # Hence, functions defined by this function fundamentally differ to
    # those defined by builtin function(). The former omits all ignorable
    # lexical constructs internally preserved by the latter. This has a number
    # of interesting side effects that may not be immediately apparent:
    #
    # * While the pre- and post-compiled definitions for functions defined by
    #   builtin function() almost always differ, the pre- and post-compiled
    #   definitions for functions defined by this function are guaranteed to
    #   *NEVER* differ.
    # * Canonical integer global ${LINENO} corresponds to the current line
    #   number of the current function or script's pre-compiled definition.
    # * Similarly, line numbers suffixing canonical list global ${functrace}
    #   correspond to the line number of the listed function or script's
    #   pre-compiled definition on which the "next" function or script in the
    #   call stack was called.
    # * There currently exists no generally reliably means of accessing the
    #   pre-compiled definition of *ANY* function or script -- particularly if
    #   such function derives from a digest file, as all zeshy functions do.
    # * The prior observations directly imply that the definitions of functions
    #   defined by this function (but *NOT* by builtin function()) may be
    #   correlated with line numbers: both the current line number and the line
    #   numbers recorded on the call stack (e.g., due to thrown exceptions).
    # * The prior implication itself implies that functions defined by this
    #   function (but *NOT* by builtin function()) may support otherwise
    #   unsupportable functionality, including:
    #   * On detecting an uncaught exception, printing the lines of the
    #     function responsible for initially throwing such exception.
#FIXME: Actually, :func_() now necessarily performs such redefinition
#as a beneficial side effect of implementing prototype validation. That said,
#that still leaves the subset of all functions defined *BEFORE* the definition
#of :func_() -- which, of course, will *NOT* have been redefined. The
#question then arises: how do we determine which functions were defined (and
#hence redefined) via :func_() and which were not? Fortunately, there's
#a comparatively efficient and reasonable means of doing so:
#
#* In @{*-start/*-declare/*-func}, implement in an anonymous function --
#  *BEFORE* defining :func_() and related functionality -- the
#  following simple functionality:
#
#    () {
#        typeset -ga ZY_FUNC_UNREDEFINED_NAMES
#        ZY_FUNC_UNREDEFINED_NAMES=( "${(M)${(k@)functions}:#:*}" )
#    }
#
#Such logic sets such list global to the set of all function names prefixed
#by a colon and hence (more or less) guaranteed to be previously defined zeshy
#functions, which (uncoincidentally) have yet to be redefined. Done!

#FIXME: In lieu of unit tests, demonstrating the above reduction...
# function lam() {
#     # Hello.
#     print -P "${LINENO} %i %I"
#     lino
# 
#     # Yumyum.
#     print -P "${LINENO} %i %I"
#     lino
# }
# function lino() {
#     print "functrace: ${functrace[1]}"
#     print "funcfiletrace: ${funcfiletrace[1]}"
# }
# functions[lam]="${functions[lam]}"

# ....................{ GETTERS                            }....................
:func.doc <<'/---'
int get_exception_message_width()

Get the maximum number of characters on each line of exception messages
available for textual content (i.e., excluding non-textual border characters),
specific to the current terminal and user-configurable styles for such messages.
See get_string_titled_width_body_in_style() for further details.
/---
function get_exception_message_width() {
    get_string_titled_content_width_in_style 'print_exception.'
}

# ....................{ PRINTERS                           }....................
#FIXME: Correct documentation.
:func.doc <<'/---'
[stderr: string] print_exception()

Print the passed strings (defaulting to the empty string) as an error entitled
under the basename of the runnable at the call stack root (i.e., as returned by
output_call_stack_root_in_style()). See print_message() for further details.

Print a description of the passed non-zero exit status to standard error. This
function is intended to be called only by ::exception.print_uncaught(), whose
implementation guarantees state assumed by this function (e.g., a call stack
containing at least three callers).

Print a trace of the call stack for the currently thrown exception to standard
output. See output_call_stack_with_lists() for further details.
/---
function print_exception() {
    # Validate sanity.
    die_if_args
    :str\
        failure_name\
        failure_text\
        failure_status\
        failure_status_suffix\
        exception_message\
        exception_title\
        style_prefix_status="${0}.failure."
    :int failure_index

    # If any global previously set by ::exception.store() has since
    # been unset or changed to an unexpected type, throw an exception. See
    # is_string(), :int.is(), and :List.is() for further details.
    is "${(t)EXCEPTION-}" == 'scalar'* si or :die\
         "\${EXCEPTION} undefined or not a scalar variable."
    is "${(t)ZY__EXCEPTION_STATUS-}" == 'integer'* si or :die\
         "\${ZY__EXCEPTION_STATUS} undefined or not an integer variable."
    is "${(t)ZY__EXCEPTION_FUNCSTACK-}" == 'array'* si or :die\
         "\${ZY__EXCEPTION_FUNCSTACK} undefined or not a list."
    is "${(t)ZY__EXCEPTION_FUNCFILETRACE-}" == 'array'* si or :die\
         "\${ZY__EXCEPTION_FUNCFILETRACE} undefined or not a list."
    is "${(t)ZY__EXCEPTION_FUNCSOURCETRACE-}" == 'array'* si or :die\
         "\${ZY__EXCEPTION_FUNCSOURCETRACE} undefined or not a list."

    # If such exception's call stack is empty, throw an exception.
    (( ${#ZY__EXCEPTION_FUNCSTACK} )) or :die\
        "Exception call stack \${ZY__EXCEPTION_FUNCSTACK} empty."

    # Find the index of the runnable directly responsible for such exception
    # (i.e., either running the command returning unhandled nonzero exit status
    # or calling the :die*() or throw_exception*() function throwing such
    # exception). See output_call_stack_lists_in_style() for further
    # details and related logic.
    failure_index=1
    while (( failure_index <= ${#ZY__EXCEPTION_FUNCSTACK} )) and
        is "${ZY__EXCEPTION_FUNCSTACK[${failure_index}]}" ==\
            ('TRAPZERR'|'die'(|'_'*)|'throw_exception') si {
        failure_index+=1
    }

    # If such index exceeds the last valid index, arbitrarily revert such index
    # to the first valid index.
    if (( failure_index > ${#ZY__EXCEPTION_FUNCSTACK} )) {
          failure_index=1
    }

    # Substrings to be printed below.
    set_string_to_call_stack_lists_index_in_style\
        failure_name\
        ZY__EXCEPTION_FUNCSTACK\
        ZY__EXCEPTION_FUNCSOURCETRACE\
        ${failure_index}\
        "${style_prefix_status}runnable."
    failure_text="${ZY_STYLE_TO_COLOR[${style_prefix_status}text]-} failed with exit status "
    failure_status="${ZY_STYLE_TO_COLOR[${style_prefix_status}status]-}${ZY__EXCEPTION_STATUS}"
    failure_status_suffix="${ZY_STYLE_TO_COLOR[${style_prefix_status}status_suffix]-}${ZY_STYLE_TO_TEXT[${style_prefix_status}status_suffix]-.}"

    # Exception message, prefixed by a synopsis of such exception's exit status.
    exception_message="${failure_name}${failure_text}${failure_status}${failure_status_suffix}"

    # If such exception was thrown with a nonempty error message, suffix such
    # synopsis with such a line spanning the width available for exception
    # content succeeded by such error message.
    if is -n "${EXCEPTION}" si {
        # Strip such message of delimiting whitespace.
        EXCEPTION="${${EXCEPTION##[[:space:]]##}%%[[:space:]]##}"

        # Suffix such message to such synopsis.
        exception_message+="
$(output_line_of_length_in_style\
    "$(get_exception_message_width)" "${style_prefix_status}footing.")${ZY_STYLE_TO_COLOR[print_exception.content.text]-}${EXCEPTION}"
    }

    # Exception title.
    exception_title="$(output_call_stack_lists_title_in_style_caller\
        ZY__EXCEPTION_FUNCSTACK\
        ZY__EXCEPTION_FUNCSOURCETRACE) Exception"

    # Redirect all following output to standard error.
    {
        #FIXME: Call start_stderr() and stop_stderr() instead! Which, of course,
        #have yet to be defined. *sigh*

        # Prepare standard output for printing.
        :print_stdout_separated_start

        # Print such exception's message with such title.
        :output_string_titled_in_style_caller\
            "${exception_message}" "${exception_title}"

        # If the current zeshy configuration instructs stack traces to be
        # printed with exceptions *OR* zeshy is currently being debugged, print
        # such trace. See ::exception.print_uncaught() for related logic.
        if (( ${ZY_ERROR_HANDLER_IS_PRINTING_CALL_STACK-0} )) or\
            { is_alias :debug.is and :debug.is } {
            output_call_stack_lists_in_style_caller\
                ZY__EXCEPTION_FUNCSTACK\
                ZY__EXCEPTION_FUNCFILETRACE\
                ZY__EXCEPTION_FUNCSOURCETRACE
        }

        # Prepare standard output for subsequent printing.
        :print_stdout_separated_stop
    } :=stderr
}

#FIXME: In lieu of unit tests...
#function yolm() {
#    function yolmyolmyolmyolmyolmyolm() {
#        :die '"I put in 35 years..."
#"It ain''t right..."
#"I don''t know what to do..."
#They never pay the slaves enough so they can get free, just enough so they can stay alive and come back to work.'
#    }
#    yolmyolmyolmyolmyolmyolm
#}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Nonsense. Now that we've properly generalized this parcel, simply
    #call canonical zeshy functions (e.g., :Int.die_unless()).

#FUXME: Woops. I now concede that our current approach to defining an exception
#handler *COMPLETELY* missed the mark. It's effectively impossible to define an
#aesthetic exception handler mid-digest compilation, as we currently do. It's
#simple to demonstrate this fact: just try embedding the following code at a
#place in the main zeshy codebase guaranteed to be sourced *AFTER* this parcel:
#
#    declare_global_with_stdin :yummuy OH_GOLLY='it begins' <<'/---'
#    The dead yet lie.
#    /---
#
#Bad things then occur on zeshy startup. We can continue to try playing whack-a-
#mole with this, iteratively inlining all function and alias calls in *ANY*
#function transitively called by print_exception() -- but, it's basically
#futile. As the scope and aesthetics of such function continue expanding, it's
#begun to pull in the *ENTIRE* codebase as a dependency.
#
#Which is fine, if such function were defined only *AFTER* sourcing the main
#zeshy codebase. But it's not. It's defined during such sourcing, which is where
#the trouble erupts. To correct this, we'll need to shift this parcel in
#particular to a new subdirectory guaranteed to be sourced *AFTER* the main
#zeshy codebase -- say, something like @{src/always/zz-cleanup}. We're unsure
#about how exactly zsh collates paths, but that should suffice. Of course, it's
#odd (as well as depending on possible locale-specific collation, which is
#terrible), but it should suffice as a short-term solution.
#
#But why settle for short-term solutions? We need to nip this issue in the bud.
#It's time, in other words, for:
#
#  src/
#    always_before/
#      00-declare/
#      05-help/
#      10-global/
#      15-alias/
#      20-function/
#      glob/
#      hook/
#      io/
#      ...
#    always/
#      ...
#    always_after/
#      zsh/
#        exception
#
#We've toyed with the concept long enough to know both the worth and simplicity
#of its implementation. So do it. We finally have reason enough, and the reason
#is ineluctably sound. There's no negating or avoiding this: this parcel *MUST*
#be sourced only after the main codebase.
#FUXME: Incidentally, when we do restructure the tree, note that we really never
#required any subdirectory of @{00-core/20-function} to be in such directory.
#As the above example tree demonstrates, consider moving all subdirectories in
#@{00-core/20-function} directly under @{00-core} except for
#@{00-core/20-function/00-core}, whose contents should be moved directly into
#@{00-core/20-function} and empty directory @{00-core/20-function/00-core} then
#removed. It's a slight simplification, but has the dramatic benefit of
#rendering the @{always_before} and @{always} trees orthogonal.

#       print_exception.failure.nonempty.suffix          " ${parens_right}${parens_right}${parens_right}${ZY_ASCII_NEWLINE}"
    # Name of the runnable directly responsible for such exception.
#   failure_status_suffix="${ZY_STYLE_TO_COLOR[${style_prefix_status}status_suffix]-}${ZY_STYLE_TO_TEXT[${style_prefix_status}status_suffix]-.}"
#       print_exception.failure.status_suffix            yellow
#       print_exception.failure.status_suffix            '.'
#               "${0}.stack."
            #FUXME: Excise such function. It's nonsensically silly. Replace with
            #a simple call as follows:
#            output_call_stack_lists\
#                ZY__EXCEPTION_FUNCSTACK\
#                ZY__EXCEPTION_FUNCFILETRACE\
#                ZY__EXCEPTION_FUNCSOURCETRACE

        #FUXME: Given our calling of :print_stdout_separated_stop() below, we should be calling
        #:print_stdout_separated_start() followed by :output_string_titled() here instead. Create
        #the latter if nonextant, naturally.
        # Reset terminal attributes in preparation for subsequent output.

        #FUXME: Rename print_string_titled_in_style_caller() to
        #print_string_titled_in_style_caller_in_style_caller(), to reflect the true nature of
        #such function.
        # Line spanning the width of such exception content.
#        string line
#        output_line_of_length_in_style\
#            line\
#            "$(get_exception_message_width)"\
#            "${style_prefix_status}footing."

        #FUXME: Print a footing constrained to such width. We'll need a new
        #function, I'm afraid. *sigh*
        #FUXME: O.K.; we've implemented it. Just uncomment the following line:
#       output_line_of_length_in_style\
#           "$(get_exception_message_width)"\
#           "${style_prefix_status}footing."
#       exception_message+=$'\n'"${ZY_STYLE_TO_COLOR[print_exception.content.text]-}${EXCEPTION}"

#┋«————————————————————————————————————————————————————————————————————————————————————————————» ┋
#
#┎┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈• yolm() Exception •┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┒
#┋yolmyolmyolmyolmyolmyolm() failed with exit status 1.                                          ┋
#┋┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ ┋
#┋"I put in 35 years..."                                                                         ┋
#┋    "It ain't right..."                                                                        ┋
#┋    "I don't know what to do..."                                                               ┋
#┋        They never pay the slaves enough so they can get free, enough so they can stay alive   ┋
#┋and come back to work.                                                                         ┋
#┠┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┚
    # Else, such message is empty. Suffix such synopsis with a sane delimiter.
#    } else {
#        exception_message+="${ZY_STYLE_TO_COLOR[${style_prefix_status}suffix_empty]-}${ZY_STYLE_TO_TEXT[${style_prefix_status}suffix_empty]-.}"
#    }

# See output_call_stack_root_in_style() for
    # further details.
#    runnable_name="$(\
#        output_call_stack_lists_index_in_style\
#        ZY__EXCEPTION_FUNCSTACK\
#        ZY__EXCEPTION_FUNCSOURCETRACE\
#        ${runnable_index}\
#        'print_exception.failure.runnable.')"

    # If any global expanded below is undefined, throw an exception. See
    # is_exception() for further details.
#    (( ${+EXCEPTION} +\
#       ${+ZY__EXCEPTION_STATUS} +\
#       ${+ZY__EXCEPTION_FUNCSTACK} +\
#       ${+ZY__EXCEPTION_FUNCFILETRACE} +\
#       ${+ZY__EXCEPTION_FUNCSOURCETRACE} == 5 )) or
#        :die '${EXCEPTION}, ${ZY__EXCEPTION_STATUS}, ${ZY__EXCEPTION_FUNCSTACK}, ${ZY__EXCEPTION_FUNCFILETRACE}, and/or ${ZY__EXCEPTION_FUNCSOURCETRACE} undefined.'

    # If such exception's call stack is undefined or not a list, fail. See :List.is() for
    # further details. Since other functions called below (e.g.,
    # set_string_to_call_stack_lists_index_in_style()) validate the
#    is "${(tP)funcstack_name__ocsl-}~~~${(tP)funcfiletrace_name__ocsl-}~~~${(tP)funcsourcetrace_name__ocsl-}" ==\
#       'array'*'~~~array'*'~~~array'* si or :die\
#        "\${${funcstack_name__ocsl}\}, \${${funcfiletrace_name__ocsl}\}, and/or \${${funcsourcetrace_name__ocsl}\} undefined or not lists."

    # If any function called below is undefined, throw an exception. For
    # resilience, minimize the set of such functions.
#    { typeset -f\
#        output_call_stack_lists_index_in_style\
#        output_call_stack_lists } silent or :die\
#       'output_call_stack_lists_index_in_style() and/or output_call_stack_lists() undefined.'

#FUXME: Ugh. The current implementation is atrociously terrible. It should:
#
#* Leverage ${ZY_STYLE_TO_TEXT}.
#* Leverage ${ZY_STYLE_TO_COLOR} styles that *ACTUALLY* exist.
#* Be *MUCH* better integrated into the printed exception message. Ideally,
#  shouldn't messages just resemble:
#
#  /----------------- rsync_safely ----------------------\
#  | mount_disk() failed with exit status 1:             |
#  | Expected one device filename and one mount dirname. |
#  \-----------------------------------------------------/
#
#  # Then, print the current call stack here!
#FUXME: Right. All of this was pretty much extreme overkill. Define a new
#parcel @{message/exception} with function ::exception.print_uncaught()
#accepting a string message and integer status and printing:
#
#* Such message and status in a single box, as above. We'll probably need a call resembling:
#   print_string_titled_in_style_caller_in_style\
#       "$(output_call_stack_root_in_style)" "${*}" 1>&2
#* 
#FUXME: The whole "$(output_call_stack_root_in_style)" jazz isn't quite right. Such
#text should be semantically embellished with a new getter appropriate to output
#-- say, output_call_stack_root_in_style() -- as follows:
#
#* If output_call_stack_root_in_style() is a file, such basename should be double-
#  quoted. For aesthetics, we really want to use the UTF-8-encoded “ and ”
#  characters. To do so, add new entries "text.quote_double_left" and
#  "text.quote_double_left" to ${ZY_STYLE_TO_TEXT_UTF8}. ('K: done!)
#* If output_call_stack_root_in_style() is a function, such basename should be
#  suffixed by "()".
#
#Come to think, such functionality is probably the *EXACT* same as that already
#performed by output_call_stack(), yes? In such case, extract such functionality
#into a new function -- how about, say, output_runnable_name_in_style()?
#Such function should accept a runnable name and optional style prefix and adorn
#such name with both context-dependent text *AND* colors. Such function should be
#defined under @{15-function}, somewhere, to render it accessible to
#output_call_stack(). Note that, when we call it here, such function should
#probably be called *WITHOUT* a style prefix; ideally, we want such function to
#*NOT* adorn such runnable name with colors here, since we do that ourselves
#already.

    # If list global ${ZY__EXCEPTION_FUNCSTACK} still exists, ...
#    if { :List.is ZY__EXCEPTION_FUNCSTACK } {
#        # Index of the last runnable in such exception's call stack matching an
#        # exception handler or 0 if no such runnable exists.
#        frame_index_handler_last="${ZY__EXCEPTION_FUNCSTACK[(I)(TRAPZERR|die(|_*)|throw_exception)]}"
#    }

    #FUXME: Actually, this is terrible. For too many fragile assumptions that
    #just don't pan out in reality. The simplest fix is to simply search the
    #call stack from the caller of this function up the call stack until finding
    #a caller *NOT* matching the following glob:
    #
    #    ('TRAPZERR'|'die'('_'*|))
    #
    #Such caller is basically guaranteed to be as close to the desired runnable
    #name as we can get, and should suffice for 99% of cases. It's also rather
    #efficient to do, given list index flags. I'm dead certain we perform a
    #similar search on the call stack elsewhere, as well. Grep us up!

    # Get the caller's caller's name (i.e., the name of the runnable running the
    # runnable calling this function). Assuming this function to have been
    # called by ::exception.print_uncaught() as is typically the case, the current
    # call stack contains at least three and typically four stack frames:
    #
    # * ${funcstack[1]}, this function.
    # * ${funcstack[2]}, the ::exception.print_uncaught() function.
    # * ${funcstack[3]}, the caller. This is typically either the
    #   intermediate zeshy-specific TRAPZERR() or :die() functions.
    # * ${funcstack[4]}, the caller's caller. Assuming ${funcstack[3]} to be
    #   either TRAPZERR() or :die(), this is the actual "caller."
    #
    # If this is the case, the fourth stack frame identifies the desired caller.
#    if (( ${#funcstack} >= 4 )) {
#        caller_caller_name="${funcstack[4]}"
#    # Else, the call stack contains three or fewer stack frames. While
#    # unexpected, this is certainly permissible (e.g., to avoid recursively
#    # throwing exceptions from exception handlers). Arbitrarily select the last
#    # such frame to identify the desired caller.
#    } else {
#        caller_caller_name="${funcstack[-1]}"
#    }

    #FUXME: Style names are no longer quite right (e.g., "print_exception.colon").
    #Define new "print_exception_status."-prefixed styles specific to this
    #function.
    #FUXME: Clearly, only output "()" if such caller is a function rather than
    #script. It would be foolish to duplicate the similar functionality of
    #output_call_stack() already doing so; hence, abstract such functionality
    #into a new function print_runnable_name() to be called both here and in
    #output_call_stack(). Nice!

    # Print such status. Avoid redirecting to standard error, as the caller
    # (typically ::exception.print_uncaught()) is assumed to already do so.
#   :stdout.echo "${ZY_STYLE_TO_COLOR[print_exception.caller]-}${caller_caller_name}${ZY_STYLE_TO_COLOR[print_exception.colon]-}() ${ZY_STYLE_TO_COLOR[print_exception.message]-}failed with exit status ${exit_status}"

    #FUXME: Prefix with such exception's status.
    #FUXME: If such exception is empty, change the status message accordingly.

# See :str.is_nonempty() for further details.
    # If all lists encapsulating such exception's call stack are still defined,
    # print such stack given such lists.
#    if (( ${+ZY__EXCEPTION_FUNCSTACK} +\
#          ${+ZY__EXCEPTION_FUNCFILETRACE} +\
#          ${+ZY__EXCEPTION_FUNCSOURCETRACE} == 3 )) {
    # Else, print a nonfatal warning.
#    } else {
#    }

#FUXME: In lieu of unit tests...
#function erro() {
#    print_exception "I'm in control of the infinite mind, and I control infinite power. When? Every black minute. And self-control is something I've learned."
#}

    #FUXME: Only call output_call_stack_root_in_style() if defined. *sigh*
        #FUXME: Insufficient. *ONLY* skip the first adjacent such 
#    :print_stdout_separated_start
#    :print_stdout_separated_stop
#}

#, differing from print_exception() styles in only the
        # substyle ".footing.corner_left".

#:func.doc <<'/---'
#[stderr: string] print_exception_status(integer exit_status)
#
#Print a description of the passed non-zero exit status to standard error. This
#function is intended to be called only by ::exception.print_uncaught(), whose
#implementation guarantees state assumed by this function (e.g., a call stack
#containing at least three callers).
#/---
#function print_exception_status() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one exit status'
#    string exit_status="${1}" caller_caller_name
#    :int.die_unless_nonnegative "${exit_status}"
#
#    #FUXME: Actually, this is terrible. For too many fragile assumptions that
#    #just don't pan out in reality. The simplest fix is to simply search the
#    #call stack from the caller of this function up the call stack until finding
#    #a caller *NOT* matching the following glob:
#    #
#    #    ('TRAPZERR'|'die'('_'*|))
#    #
#    #Such caller is basically guaranteed to be as close to the desired runnable
#    #name as we can get, and should suffice for 99% of cases. It's also rather
#    #efficient to do, given list index flags. I'm dead certain we perform a
#    #similar search on the call stack elsewhere, as well. Grep us up!
#
#    # Get the caller's caller's name (i.e., the name of the runnable running the
#    # runnable calling this function). Assuming this function to have been
#    # called by ::exception.print_uncaught() as is typically the case, the current
#    # call stack contains at least three and typically four stack frames:
#    #
#    # * ${funcstack[1]}, this function.
#    # * ${funcstack[2]}, the ::exception.print_uncaught() function.
#    # * ${funcstack[3]}, the caller. This is typically either the
#    #   intermediate zeshy-specific TRAPZERR() or :die() functions.
#    # * ${funcstack[4]}, the caller's caller. Assuming ${funcstack[3]} to be
#    #   either TRAPZERR() or :die(), this is the actual "caller."
#    #
#    # If this is the case, the fourth stack frame identifies the desired caller.
#    if (( ${#funcstack} >= 4 )) {
#        caller_caller_name="${funcstack[4]}"
#    # Else, the call stack contains three or fewer stack frames. While
#    # unexpected, this is certainly permissible (e.g., to avoid recursively
#    # throwing exceptions from exception handlers). Arbitrarily select the last
#    # such frame to identify the desired caller.
#    } else {
#        caller_caller_name="${funcstack[-1]}"
#    }
#
#    #FUXME: Style names are no longer quite right (e.g., "print_exception.colon").
#    #Define new "print_exception_status."-prefixed styles specific to this
#    #function.
#    #FUXME: Clearly, only output "()" if such caller is a function rather than
#    #script. It would be foolish to duplicate the similar functionality of
#    #output_call_stack() already doing so; hence, abstract such functionality
#    #into a new function print_runnable_name() to be called both here and in
#    #output_call_stack(). Nice!
#
#    # Print such status. Avoid redirecting to standard error, as the caller
#    # (typically ::exception.print_uncaught()) is assumed to already do so.
#    :print_stdout_separated_start
#    :stdout.echo "${ZY_STYLE_TO_COLOR[print_exception.caller]-}${caller_caller_name}${ZY_STYLE_TO_COLOR[print_exception.colon]-}() ${ZY_STYLE_TO_COLOR[print_exception.message]-}failed with exit status ${exit_status}"
#    :print_stdout_separated_stop
#}

#available to the textual content of each line of
#exception messages on the current terminal under user-configurable styles
#specific to such messages. See get_string_titled_width_body_in_style()
#for further details.

#Get the maximum number of characters in the body of each line of output (i.e.,
#excluding width of visual borders on such lines) wrapped to the current terminal
#under the user-configurable styles prefixed by the passed prefix.

#Since such messages are often
#embedded within a visual box, this number is often slightly less than that
#returned by get_terminal_width().
#Print the passed strings (defaulting to the empty string) suffixed by a newline
#and decorated by user-configured colors to standard error as an error message.
#See print_message() for further details.

#   :stdout.echo "${ZY_STYLE_TO_COLOR[print_exception.caller]-}$(output_call_stack_root_in_style)${ZY_STYLE_TO_COLOR[print_exception.colon]-}: ${ZY_STYLE_TO_COLOR[print_exception.message]-}${*}" 1>&2

#FUXME: The current overly simplistic get_print_message_prefix()-based approach
#should be jettisoned in favor of a Unicode box-drawing based approach: e.g.,
#
#/------------------------------[ zsh_gone_bad() ]-----------------------------\
#| An error has been thrown. It is a horrible error, but others are probably   |
#| worse.                                                                      |
#\-----------------------------------------------------------------------------/
#
#What's particularly nice about such an approach is that it inherently delimits
#prior from subsequent output. Indeed, we needn't even prefix such output with
#delimiting whitespace anymore, which is particularly nice.

    # Size of the current call stack, including the call to this function.
    # Avoid calling :call_stack.get_size(), which tends to behave erratically
    # when called from within an exception handler.
#   integer call_stack_size=${#funcstack}

#   if (( call_stack_size >= 4 )) {
#       if is "${funcstack[3]}" == ('TRAPZERR'|'die') si {
#           caller_caller_name="${funcstack[4]}"
#       } else {
#           #FUXME: Doesn't this also constitute an error condition?
#           print "caller caller name: ${funcstack[3]}\ncaller caller caller name: ${funcstack[4]}"
#           caller_caller_name="${funcstack[3]}"
#       }
#   #FUXME: Doesn't this also constitute an error condition?
#   } elif (( call_stack_size == 3 )) {
#       caller_caller_name="${funcstack[3]}"
#   } elif (( call_stack_size == 2 )) {
#       :die "print_exception_status() called by ${funcstack[2]}() rather than ::exception.print_uncaught()"
#   } else {  # elif (( call_stack_size == 1 )) {
#       print "call stack size: ${#funcstack}; ${call_stack_size}\nfuncstack[2]: ${funcstack[2]}"
#       :die "print_exception_status() not callable directly from the CLI"
#   }

#; call_stack_size="$(:call_stack.get_size)"
#:func.doc <<'/---'
#string print_warning_sans_newline_suffix(
#    string message1 = "", string message2, ...)
#
#Print the passed strings (defaulting to the empty string) suffixed by no newline
#and decorated by user-configured colors to standard error as a warning message.
#See :warning.print() for further details.
#/---
#function print_warning_sans_newline_suffix() {
#    print_string_sans_newline_suffix "$(:warning.print "${@}" 2>&1)" 1>&2
#}

