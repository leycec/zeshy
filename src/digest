#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle the current digest file.

#FIXME: Add support for zeshy upgrading: namely, if upgrading zeshy, have
#:is_zeshy_digest_outdated() immediately report success.
#FIXME: The obvious question then becomes: how do we reliably detect upgrades?
#The answer is equally obvious:
#
#* Define a new global ${ZESHY_VERSION} in @{main}.
#* Redefine (or ideally remove) get_zeshy_version() in terms of such global.
#* Cache such global to ${ZESHY_USER_DIGEST_DEPENDENCIES_FILENAME} under the
#  name ${ZESHY_VERSION_PRIOR}, to avoid conflicts with the existing global of
#  the same name when sourcing such file. (See @{compile} function
#  ::precompile_zeshy_cache().)
#* Have :is_zeshy_digest_outdated() do the following:
#  * After sourcing such file, append the following math comparison to the
#    existing early test of whether or not core zeshy-specific files exist:
#    (( ZESHY_VERSION == ZESHY_VERSION_PRIOR ))
#  * This will induce such function to immediately report success, triggering
#    immediate digest recompilation.
#FIXME: O.K.; great! But we want to permit a second sort of upgrade path as
#well: github-based updates. Indeed, if github activity is any indicator, this
#will (at least initially) be the primary way that initial users interact with
#zeshy. So we need to support that. But how? It's not quite so simple, of
#course. But it shouldn't be *HIDEOUSLY* infeasible. Succinctly:
#
#* Add a new string global ${ZESHY_GIT_REVISION} to @{main}.
#* Add a new git commit hook on commits to branch "master". (Important! Only for
#  commits to such branch.) To do so both portably and reliably, we'll probably
#  want to implement such hook as a low-level zsh script performing the
#  following actions:
#  * Get the revision of such commit to string local ${current_revision}. (No
#    idea; git must supply such metadata to commit hooks, yes? Perhaps as passed
#    arguments or environment variables?)
#  * Run:
#    sed -ie 's~^\(ZESHY_GIT_REVISION=\)~\1'${current_revision} src/main
#  Indeed, such script appears simple enough to perhaps be a Bourne shell
#  script. *shrug*
#* Cache such global to ${ZESHY_USER_DIGEST_DEPENDENCIES_FILENAME} under the
#  name ${ZESHY_GIT_REVISION_PRIOR}.
#* Have :is_zeshy_digest_outdated() perform the following comparison:
#    [[ "${ZESHY_VERSION}${ZESHY_GIT_REVISION}" ==\
#       "${ZESHY_VERSION_PRIOR}${ZESHY_GIT_REVISION_PRIOR}" ]]
#  Note the single efficient comparison, which is nice.
#
#O.K.; so, that gets us all of the way. It still requires users to manually
#update git... but, hey! It works, anyway. As a first-draft implementation, we
#could certainly do worse.
#FIXME: Wait! We neither need nor want ${ZESHY_GIT_REVISION_PRIOR} and hence the
#above alteration, since :is_zeshy_digest_outdated() already (reasonably
#efficiently) tests the current zeshy codebase for changes. Indeed, the whole
#${ZESHY_GIT_REVISION_PRIOR} concept is fairly poor once you realize that zeshy
#developers will often be working on feature branches.
#FIXME: Fortunately, there *IS* a dramatically improved solution for
#accomplishing automatic git-based updates. We'll want to eventually have zeshy
#check at least daily (well, on a user-configurable schedule anyway) for
#updates. The first question that needs to be resolved before even *GETTING* to
#update automation and scheduling, however, is how to actually non-interactively
#update the git repository containing ${ZESHY_HOME}. While simple in the common
#case of the user *NOT* having made changes to such repository, in the general
#case such repository's "master" branch may have diverged from "origin/master".
#In such case, it would be incredibly rude to overwrite the former with the
#latter. The following google search terms were helpful in researching this:
#
#    "git check shell script update"
#
#Naturally, stackoverflow.com answers appear to be the most helpful. We want to
#adopt the solution minimizing the number of subshells required to (ideally)
#only one command substitution. The canonical answer appears to have been
#provided in 2010:
#
#    http://stackoverflow.com/questions/3258243/git-check-if-pull-needed
#
#The solution (which isn't precisely spelled out, as different scripts have
#different requirements) is as follows:
#
#* Temporarily "cd" to such such repository.
#* Run "command git fetch origin". This is *GUARANTEED* to be non-destructive;
#  it only fetches (*NOT* pulls, which both fetches and merges) remote changes
#  into the remote tracking branch "origin/master".
#* Save the name of the current local branch, as we're about to change it! We
#  have existing functionality to get such name, happily.
#* Switch to local branch "master", if not already. This shouldn't be terribly
#  hard; if we recall correctly, this should do it: command git checkout -b master
#* Capture the output of "command git status -s -u no". This is also
#  non-destructive. It simply prints a single line of output if and only if the
#  current and remote branches have diverged, requiring only a simple test for
#  emptiness.
#* Revert back to the prior branch. We stored the name above, so this is simple.
#
#So that gets us half the way there. If the "git status" command above succeeds,
#there's no need for a merge. Great! Else, we need to merge. I'm a bit fuzzier
#here on what the best way to proceed then is. More research, alas.
#FIXME: We might be able to avoid all of the branch switching for merely
#checking branch status with the following:
#
#    :string git_log
#    :store_dir "${ZESHY_HOME:h}"
#    :try {
#        :die_unless_git
#        # Note that "git remote update origin/master" and "git fetch origin master" are
#        # functionally synonymous, but that the former is increasingly
#        # considered obsolete, now that the latter subsumes all functionality
#        # previously relegated to the former. In any case, just use "fetch". :)
#        command git fetch origin master
#        git_log="$(command git log HEAD..origin/master --oneline)"
#        if { :is_string_nonempty "${git_log}" } {
#            # Temporarily switch to "master" here.
#            ...
#
#            # Test whether "master" is fast-forwardable.
#            :string revision_master revision_origin_master
#            revision_master="$(git rev-parse master)"
#
#            # If "master" is fast-forwardable, do so silently. This will be the
#            # common case for non-developers. Basically, this tests whether or
#            # the current local revision is a direct ancestor of the current
#            # remote revision.
#            if is "$(command git merge-base origin/master "${revision_master}")" ==\
#                "${revision_master}" si {
#                #FIXME: Actually, print out a message notifying the user that
#                #we're successfully upgrading zeshy.
#                command git merge
#            # Else, the local and remote repositories have diverged. Ask the
#            # the current user whether a merge should be attempted.
#            } elif { :is_query\
#                "Upgrade available, but zeshy has been changed locally. Merge such changes?" } {
#                #FIXME: So far so good, but how do we respond if such changes
#                #require manual merging? In such case, we should probably
#                #inform the user of a simple zeshy function to be called that
#                #destructively erases all changes and reverts HEAD to the HEAD
#                #of the remote tracking branch. (Useful for users who
#                #accidentally touch the zeshy codebase and need to get back to
#                #a working version.)
#                command git merge
#            }
#        }
#    } always :{
#       :restore_dir
#    }:
#
#We'll want to define a new :is_query() function, reporting success if the
#current user responds affirmatively. Dead simple! Probably just rename
#:is_query_char_yes() to :is_query(), we should think. Yes?
#
#Yes! The contents of the "if" is where things get tricky; that's where we'll
#need to temporarily switch branches (possibly?), run "command git merge", and
#go from there. But everything else above should work reliably. Ya! We should
#note that all the above functionality within the ":try {...}" should be shifted
#into a single new function :merge_git_origin_master().
#FIXME: [Ed. note: the method below is *GREAT* and should certainly be
#abstracted into a new function :is_git_mergeable_sans_conflict(), but really
#doesn't apply to the current situation. Why? Because developers should only
#ever work on feature branches -- *NEVER* on "master". That means that if we
#ever detect a situation in which the zeshy codebase has changed but the changes
#are not fast-forwardable, we should basically throw a fatal exception and
#inform the user that they're doing something terrible that's likely to result
#in merge conflicts and hence an unusable zeshy.]
#
#Sweet, as for the interior code above, we've obtained a concised method
#for determining whether a non-fast-forwardable merge is likely to produce
#conflicts. Check this awesomeness, run *AFTER* performing the fetch:
#
#    # If conflicts exist, print a warning.
#    :string revision_common
#    revision_common="$(git merge-base FETCH_HEAD master)"
#    if is "$(command git merge-tree "${revision_common}" FETCH_HEAD master)" ==\
#        (|*"${ZESHY_ASCII_NEWLINE}")"changed in both"* si {
#        print_warning "Found merge conflicts! Really merge changes? If "yes", such conflicts must be manually resolved before restarting zeshy. If you are not a zeshy developer, consider responding \"no\" here and immediately running the following command:
#    :revert_zeshy_changes"
#    # Else, go ahead with the merge silently.
#    } else {
#        command git merge
#    }
#
#"git merge-tree" runs a non-destructive merge *IN MEMORY* and outputs a diff of
#all prospective changes to be applied. Awesome, no? Apparently, git prefixes
#all conflicting code with the canonical string "changed in both". Excellent.
#FIXME: Completely unrelated, but consider renaming ${ZESHY_ASCII_NEWLINE} to
#${Znewline}. Likewise for the other character constants.
#FIXME: Implement a new :is_string_line_prefix() function. Given that, then the
#above could be implemented as:
#
#    if { :is_string_line_prefix\
#        "$(command git merge-tree "${revision_common}" FETCH_HEAD master)"\
#        "changed in both" } {
#FIXME: Oh! Actually, it appears git outputs "changed in both" on a distinct
#line, reducing such conditional to:
#
#    if { :is_string_line\
#        "$(command git merge-tree "${revision_common}" FETCH_HEAD master)"\
#        "changed in both" } {
#FIXME: Incidentally, we probably want a new :is_zeshy_git() function reporting
#success if ${ZESHY_HOME} resides in a git repository. To implement this, recall
#that we've already implemented :is_path_git(), so just call:
#
#    function :is_zeshy_git() {
#        :is_path_basename_equals "${ZESHY_HOME}" src and
#           :is_path_git "${ZESHY_HOME}"
#    }
#
#Naturally, we'll need to implement :is_path_basename_equals(). Simple, though.

#FIXME: It's not *IMMEDIATELY* pressing, but there probably exist race
#conditions in the event two zeshy shells startup at a similar time and the
#digest file requires recompilation. We should probably perform advisory file
#locking (see "path/database/kvs/dir", I believe, for relevant documentation) on
#the *DIGEST FILE* itself. Basically, if such file is locked, then some other
#zeshy shell is (hopefully) compiling zeshy. Such file should be locked... when?
#Well, for true atomicity, we'd probably need each zeshy shell to lock the
#digest immediately before calling :is_zeshy_digest_outdated() and unlock the
#digest immediately after either compiling such digest (or if not compiling such
#digest immediately after calling :is_zeshy_digest_outdated()). This effectively
#serves as a critical section -- and, yes, if you think about it, we do need to
#lock before calling :is_zeshy_digest_outdated(). Why? Because if the digest is
#in fact locked, we must check for such lock and hence determine whether or not
#the digest is currently locked and hence being compiled *BEFORE* testing such
#digest's mtime. (Fairly obvious, I suppose.)
#FIXME: Naturally, only lock the digest file if it actually exists. If it
#doesn't exist, then it's effectively "unlocked."
#FIXME: This means we'll need to shift file locking functionality to parcel
#"digest". *shrug*

#FIXME: The resolution of ${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME}
#should be improved from seconds to nanoseconds on systems supporting the latter
#(e.g., BSD, Linux). Happily, this can be efficiently obtained as a float from
#"date" with the command:
#
#   >>> date +'%s.%N'
#   1369342075.472940831
#
#Naturally, this is sufficiently useful to be generalized into a new function
#get_time_second_nanosecond() (whose name complies with "os/time" nomenclature).
#FIXME: Retrieving file modification time denominated in nanoseconds isn't quite
#as simple, unfortunately. We have an algorithm for doing so at "path/time",
#which we'll need to move here. Both implementations are (probably) Linux-
#specific. So, we'll also need to move the is_pathable_gnu() function here. I
#know, I know; but it's really quite unavoidable.
#FIXME: *UGH*. We *ALREADY* have the current time as a float in global
#${ZESHY_TIME_START}. Hence, replace our current calling of "date"
#below with simple expansion of such global.
#FIXME: We already implement get_time() to return fractional seconds, so no
#additional work needed there.
#FIXME: We will still need to shift functionality here for getting fractional
#file time. However, since zsh will (eventually) obsolete such functionality by
#improving zstat(), this isn't really a significant long-term concern.
#FIXME: Actually, it's sort of important. Who knows when, if ever, zsh will
#officially add such functionality. Shift such fuctionality into the new
#@{inspect} parcel.

# ....................{ GLOBALS                            }....................
typeset -g\
    ZESHY_USER_DIGEST_FILENAME\
    ZESHY_USER_CONFIG_DIRNAME\
    ZESHY_USER_DIGEST_DEPENDENCIES_FILENAME
typeset -gUa ZESHY_USER_DIGEST_DEPENDENCY_PATHNAMES

# ....................{ ADDERS                             }....................
# void add_zeshy_digest_dependency_path(string pathname1, ...)
function add_zeshy_digest_dependency_path() {
    (( # )) || die 'Expected one or more paths.'
    ZESHY_USER_DIGEST_DEPENDENCY_PATHNAMES+=( "${@}" )
}

# ....................{ TESTERS                            }....................
# [status: bool] :is_zeshy_digest_outdated(void)
#
# Previously, this function implicitly set global
# ${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME} to the modification time of
# the newest path the current digest file depends upon. ::digest_zeshy_compile()
# then explicitly changed the modification time of such digest file after
# compiling such file. Why? We mistakenly believed that if the modification time
# of such file is *NOT* the exact modification time of the newest path such file
# depends upon, then :is_zeshy_digest_outdated() would report such file to be
# outdated. However, a cursory read of :is_zeshy_digest_outdated() shows this
# *NOT* to be the case. To ensure such function reports recently compiled digest
# files to be up-to-date, it merely suffices to ensure that the modification
# times of such files are as or more recent than those of their dependencies.
#
# However, assuming system time and such modification times to be sane, this is
# *ALWAYS* already the case. Compiling a digest file either creates a new file
# or modifies the contents of an existing file. In either case, the modification
# time of such file will effectively be the current system time and hence almost
# always more recent than those of its dependencies. Where this is *NOT* the
# case, either the current system was installing or uninstalling software *OR*
# the current user was editing one or more configuration files during digest
# compilation. In either case, such behavior will induce two unavoidably
# consecutive digest recompilations. Since this is hardly the worst thing that
# could happen and -- all things considered -- probably the best, current edge-
# case behavior is altogether acceptable.
#
# In summary: the best thing to do with respect to digest file modification time
# is nothing.
function :is_zeshy_digest_outdated() {
    # Validate sanity.
    (( # == 0 )) || die 'Expected no arguments.'
    local   digest_dependency_mtimes
    integer digest_dependency_newest_mtime digest_file_mtime

    # List of modification times of paths on which such digest depends.
    local -a digest_dependency_pathnames

    # If the current digest file or one or more zeshy-specific files or
    # directories such file depends upon does *NOT* exist, report such digest
    # file to be outdated. This is *NOT* merely an optimization. In the latter
    # case, such missing files or directories will be implicitly recreated as a
    # beneficial side effect of digest compilation.
    #
    # To ensure empty configuration directories trigger recompilation, test for
    # the existence of a well-known non-optional subdirectory of the current
    # configuration directory rather than merely such directory.
    [[  -f "${ZESHY_USER_DIGEST_FILENAME}" &&
        -f "${ZESHY_USER_DIGEST_DEPENDENCIES_FILENAME}" &&
        -d "${ZESHY_USER_CONFIG_DIRNAME}/00-core" ]] || {
        digest_dependency_newest_mtime="$(command date +'%s')"
        return 0
    }

    # Append all directories in the current user's ${PATH}, triggering
    # recompilation on installation and uninstallation of commands.
    digest_dependency_pathnames+=( "${path[@]}" )

    # Source the file to which zeshy previously cached the list of all
    # extraneous files and directories other parcels insist the current digest
    # file depends upon.
    source -- "${ZESHY_USER_DIGEST_DEPENDENCIES_FILENAME}"

    # Append all such files and directories, triggering recompilation on
    # modification to such paths.
    digest_dependency_pathnames+=(
        "${ZESHY_USER_DIGEST_DEPENDENCY_PATHNAMES[@]}" )

    # Append the newest file or subdirectory of the current configuration
    # directory, triggering recompilation on configuration changes. Dismantled,
    # this is:
    #
    # * "${...}"/**/*, matching all configuration files and directories.
    # * "(#qom...)", sorting such files and directories by descending mtime.
    # * "[1]", expanding to only the first and hence newest such path.
    digest_dependency_pathnames+=(
        "${ZESHY_USER_CONFIG_DIRNAME}"/**/*(#qom[1]) )

    # If CLI option "--compile-digest-if-zeshy-changed" was passed, append the
    # path of the newest file or subdirectory of the topmost directory
    # containing the current zeshy codebase. See above for further details.
    if (( ZESHY_USER_DIGEST_FILE_IS_DEPENDENT_ON_ZESHY_HOME )) {
        digest_dependency_pathnames+=( "${ZESHY_HOME}"/**/*(#qom[1]) )
    }

    # Filter nonextant files and directories from such list. To preserve path
    # quoting, such operation *MUST* be performed in a list context and hence
    # *NOT* inlined below. Note such operation implicitly preserves path quoting
    # without requiring double quoting here.
    digest_dependency_pathnames=( ${^digest_dependency_pathnames}(#q) )

    # Newline-delimited string list of the modification times of all such
    # dependencies (in arbitrary order). Dismantled, this is:
    #
    # * "-N", outputting only modification times. By default, zstat() outputs a
    #   human-readable two-column table when passed multiple files: e.g.,
    #   "inconceivable        1386576475
    #    dread_pirate_roberts 1368426799"
    #   Passing this option reduces the above output to:
    #   "1386576475
    #    1368426799"
    digest_dependency_mtimes="$(zstat +mtime -N\
        "${digest_dependency_pathnames[@]}")"

    # Modification time of the newest such dependency. Dismantled, this is:
    #
    # * "(Onf)", splitting such string list on newline and sorting the resulting
    #   words numerically in descending order.
    # * "(w)1", expanding to the first such word.
    #
    # While sorting such list is technically O(n lg(n)), such sort should be
    # approximately O(n) assuming non-pathological edge cases (e.g., ${PATH}
    # containing an absurd number of entries).
    digest_dependency_newest_mtime="${${(Onf)digest_dependency_mtimes}[(w)1]}"

    # Modification time of such digest file, ensured to exist by above. To
    # minimize race conditions, delay such operation as long as possible.
    digest_file_mtime="$(zstat +mtime "${ZESHY_USER_DIGEST_FILENAME}")"

    # If either the current digest file or its newest dependency is newer than
    # the current time, print a nonfatal warning and (for safety) signify such
    # digest file to be outdated by reporting success. This usually only occurs
    # under hardware malfunction (e.g., lightning-based CMOS resets).
    if (( digest_file_mtime > EPOCHREALTIME ||\
          digest_dependency_newest_mtime > EPOCHREALTIME )) {
        # Print such warning depending on which error condition occurred.
        {
            if (( digest_file_mtime > EPOCHREALTIME )) {
                print "zeshy: Digest modification time ${digest_file_mtime}s newer than current time ${EPOCHREALTIME}s."
            } else {
                print "zeshy: Newest digest dependency modification time ${digest_dependency_newest_mtime}s newer than current time ${EPOCHREALTIME}s."
            }

            print "zeshy: Consider calling set_time_with_ntp() to properly set the current time."
        } 2>&1

        # Since the current time is in an indeterminate state, force digest
        # recompilation by reporting such digest file to be outdated.
        return 0
    }

    # If debugging, output such modification times.
    :output_line_if_debugging "Current digest mtime:                   ${digest_file_mtime}"
    :output_line_if_debugging "Current digest newest dependency mtime: ${digest_dependency_newest_mtime}"

    # Such digest file is outdated if older than its newest dependency.
    (( digest_file_mtime < digest_dependency_newest_mtime ))
}

# ....................{ SETUP                              }....................
# void :digest_zeshy(void)
function :digest_zeshy() {
    # Validate sanity.
    (( # == 0 )) || die 'Expected no arguments.'

    # Inspect the current system for high-level metadata on which the choice of
    # current digest file depends (e.g., operating system, display server).
    ::digest_zeshy_inspect

    # If the current digest file is outdated or the caller demands recompiling
    # such file regardless of whether it's outdated or not, compile all zeshy
    # functions applicable to the current user into such digest and render such
    # functions autoloadable. See "main" for declaration of the latter
    # condition, ${ZESHY_USER_DIGEST_FILE_IS_INDEPENDENT}.
#   print "detecting \"${ZESHY_USER_DIGEST_FILENAME}\"..."
    if { :is_zeshy_digest_outdated ||
        (( ZESHY_USER_DIGEST_FILE_IS_INDEPENDENT )) } {
        ::digest_zeshy_compile
    # Else, attempt to autoload the previously compiled digest for the current
    # user. If this fails, (re)compile such digest and try again.
    } elif ! { autoload -w -- "${ZESHY_USER_DIGEST_FILENAME}" } {
        ::digest_zeshy_compile
#       print "autoloading \"${ZESHY_USER_DIGEST_FILENAME}\"..."
    }

    # Prefix the function path with the absolute path to such digest, ensuring
    # zsh searches such file first for definitions of undefined functions.
    fpath=( "${ZESHY_USER_DIGEST_FILENAME}" "${fpath[@]}" )
}

# void ::digest_zeshy_inspect(void)
function ::digest_zeshy_inspect() {
    # Validate sanity.
    (( # == 0 )) || die 'Expected no arguments.'
    local digest_dirname

    # Set globals describing the current system (e.g., ${ZESHY_SYSTEM_ID}).
    source -- "${ZESHY_HOME}/inspect"

    #FIXME: Technically, such directory could also depend on whether this is a
    #debug or release build. We'll probably want that -- but for now this
    #suffices.

    # System-specific directory containing the current configuration. To allow
    # such configuration to be shared without modification across machines of
    # the system setup, such directory is host-agnostic (i.e., does *NOT* embed
    # the current value of ${HOST}).
    ZESHY_USER_CONFIG_DIRNAME="${ZESHY_USER_CONFIG_ROOT_DIRNAME}/${ZESHY_SYSTEM_ID}"

    # System-specific directory containing the current digest file. Unlike
    # system-specific configuration directories, such directory is *ALSO* host-
    # specific, guaranteeing digest recompilation on migration to new machines.
    digest_dirname="${ZESHY_USER_DIGEST_ROOT_DIRNAME}/${HOST}.${ZESHY_SYSTEM_ID}"

    # The absolute paths of the current digest file depends on whether this is a
    # debug or release build of zeshy. Why? :run_line_if_debugging() expands to
    # the passed code in the former case and to the comment prefix ignoring such
    # code in the latter. In either case, such alias' expansion directly depends
    # on corresponding CLI options. Since functions expand aliases at function
    # definition rather than call time, all functions expanding such alias
    # compiled into the current digest file (and hence such file itself) depend
    # on the exact same CLI options.
    #
    # Such complexity demonstrates why defining aliases in terms of CLI options
    # is generally a terrible idea. In this case, however, such aliases are
    # essential to optimizing away debug logic from release code.
    if { :is_debugging } {
        ZESHY_USER_DIGEST_FILENAME="${digest_dirname}/debug.zwc"
    } else {
        ZESHY_USER_DIGEST_FILENAME="${digest_dirname}/release.zwc"
    }

    # System-specific file caching the list of all extraneous files and
    # directories such digest file depends upon.
    ZESHY_USER_DIGEST_DEPENDENCIES_FILENAME="${digest_dirname}/dependencies.zsh"
}

# void ::digest_zeshy_compile(void)
function ::digest_zeshy_compile() {
    # Validate sanity.
    (( # == 0 )) || die 'Expected no arguments.'

    # Compile the current digest file.
    source -- "${ZESHY_HOME}/compile"

    # Declare all functions defined by such digest to be autoloadable.
#   print "autoloading \"${ZESHY_USER_DIGEST_FILENAME}\"..."
    autoload -w -- "${ZESHY_USER_DIGEST_FILENAME}" ||
        die "Digest \"${ZESHY_USER_DIGEST_FILENAME}\" not found or not autoloadable."
}

# ....................{ MAIN                               }....................
:digest_zeshy

# --------------------( WASTELANDS                         )--------------------
#FUXME: Don't forget to perform advisory locking on digest files before and
#during digest compilation! (We probably document this elsewhere, yes?) Ah, yes:
#   print "mtimes: ${dependency_mtimes[@]}"
#   print "digest file: \"${ZESHY_USER_DIGEST_FILENAME}\""
#   print "digest: ${digest_file_mtime}"
#   print "newest: ${digest_dependency_newest_mtime}"
    # If debugging zeshy, output useful digest metadata.
    # :run_line_if_debugging ::output_digest_metadata

# void ::output_digest_metadata(void)
# function ::output_digest_metadata() {
#     # Validate sanity.
#     (( # == 0 )) || die 'Expected no arguments.'
# 
#     # Describe such digest.
#     :output_line_if_debugging "Compiled digest metadata..."
#     :output_line_if_debugging "   mtime (file):              $(zstat +mtime "${ZESHY_USER_DIGEST_FILENAME}")"
#     :output_line_if_debugging "   mtime (newest dependency): ${digest_dependency_newest_mtime}"
# }

    # If such digest is outdated, this is the modification time of the newest
    # path such digest depends on; else 0. While this function itself does not
    # refer to this variable, explicitly declare this variable here to provide
    # shared access to this variable by functions this function calls. (Subtle!)
    #
    # Avoid declaring such integer as type "integer".
    # local -i ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME

#(The latter omits lines passed to either
    # :run_line_if_debugging() or :output_line_if_debugging().)
    # Such path depends on whether zeshy is currently being debugged or not. If
    # zeshy is being debugged, is_zeshy_debug_and() expands to a command running
    # the passed command; else, to a command ignoring such command. In either case,
    # the expansion for such alias directly depends on CLI option "--verbose". Since
    # functions expand aliases at function definition rather than call time, zeshy
    # functions expanding such alias compiled into zeshy's user digest file and
    # hence such file itself transitively depends on the same CLI option.
    #
    # This complexity demonstrates why aliases that depend on CLI options are
    # generally a bad idea. In this case, however, such alias is essential to
    # optimizing away debug logic from release code.

# To minimize race conditions, delay
    # such operation as long as possible.
    # If the file to which zeshy previously cached the list of all paths other
    # parcels insist such digest depends on (${ZESHY_USER_DIGEST_DEPENDENCY_PATHNAMES}),
    # such file (thus defining such list) and append such paths.

    #FUXME: Such file should be moved into the digest directory containing the
    #current digest file, permitting different digest files to depend on
    #different external paths.

#FUXME: Minor but annoying bug: if ${ZESHY_USER_CONFIG_DIRNAME} is empty at the
#time of the call to this function, such directory will subsequently be created
#with an mtime newer than that of
#${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME}, guaranteeing a subsequent
#annoying recompilation. This is readily fixed as follows:
#
#* When zeshy depends on a *ZESHY*-specific path that does not exist (but will
#  presumably be subsequently created by @{compile}),
#  :is_zeshy_digest_outdated() should report success *WITHOUT* setting
#  ${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME}.
#* The following code should be shifted from :is_zeshy_digest_outdated() to
#  ::digest_zeshy_compile():
#    (( ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME )) ||
#       ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME="$(command date +'%s')"
#
#Since ${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME} defaults to 0 as an
#integer, this ensures the current digest file will be set to the current time
#if no more appropriate time was found.
#FUXME: *WAIT*. Face palm. Why are we even setting such variable in the first
#place?  No, really. It doesn't make sense. In reflection, it *NEVER* made
#sense. I mean, why do it in the first place? Why not simply always set the
#newly compiled digest file to the current time? This has the profound benefit
#of eliminating a huge amount of seemingly unnecessary complexity as well as
#allowing us to run non-GNU versions of "touch". *sigh*
#
#We've more-or-less verified, after a fairly exhaustive run through the
#codebase, that (indeed) there exists no compelling reason to perform the
#current complex of ${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME}
#contusions. Why, oh why? Well... at least we can dramatically improve this, eh?
#FUXME: Wooh. Wow. We don't even *HAVE* to touch such file, since we've either
#just created or overwritten it. SUPERFACEPALM.
#FUXME: Ah. Right. Such simplification only applies under the condition
#ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME <= EPOCHREALTIME. We currently
#check such condition and simply print a nonfatal warning. That will need to
#change; we'll need to throw an exception, in such case. (Or perhaps manually
#set EPOCHREALTIME=${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME}? Ideally,
#zsh would permit such operation and confine its scope to the current shell.
#That would probably be the ideal case. No *WAY* it works, though. Give it a
#go nonetheless, eh? Ah. Wait. Either it works and hence fails to apply to
#"touch", in which it doesn't *REALLY* work, or it works by globally changing
#the current system time, which would probably be bad. So, just throw an
#exception and get us out of here! Ah. Actually, *ONLY* throw an exception if
#no such digest file already exists, in which case we truly are hosed. Actually,
#no: there's little point in throwing an exception. By printing a nonfatal
#error, we both inform the current user *AND* permit zeshy to be used, albeit at
#a cost of recompiling zeshy on every startup until the current system time is
#corrected. But that's a small cost.)
#
#Right! No change to the warning, then.

    # ZESHY_USER_DIGEST_DEPENDENCIES_FILENAME="${ZESHY_USER_CACHE_DIR}/digest_dependencies.zsh"
    # If the file to which zeshy previously cached the list of all paths other
    # parcels insist such digest depends on (${ZESHY_USER_DIGEST_DEPENDENCY_PATHNAMES}),
    # source such file (thus defining such list) and append such paths.

    # If the current configuration directory exists, append the path of the
    # newest file or subdirectory of such directory. Test for a well-known
    # non-optional subdirectory of such directory rather than merely such
    # directory to ensure empty configuration directories trigger recompilation.
    # Generally, this conditional triggers recompilation on edits to user-
    # specific configuration files. Dismantled, this is:

    # # If the caller failed to declare such integer, do so locally. Ideally, the
    # # caller declares such integer to subsequently set such file's modification
    # # time using such integer. See ::digest_zeshy_compile() for further details.
    # #
    # # Avoid declaring such integer as type "integer".
    # [[     "${(t)ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME-}" == 'integer'* ]] ||
    #     local -i ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME

    # # If the current digest file does *NOT* exist, set
    # # ${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME} to the current time and
    # # report such file to be outdated. Since the current time will typically be
    # # more recent than that of the newest digest dependency (e.g., command in
    # # the current ${PATH}), this ensures the modification time for such digest
    # # file will be set to a time more recent than that of the newest digest
    # # dependency, in turn ensuring that such file will *NOT* be recompiled until
    # # the next change to such a dependency (as desired).
    # [[  -f "${ZESHY_USER_DIGEST_FILENAME}" ]] || {
    #     ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME="$(command date +'%s')"

    # If such digest no longer exists (despite having just compiled such
    # digest), throw an exception. However unlikely, such edge cases remain
    # feasible and must be guarded against.
    # [[ -f "${ZESHY_USER_DIGEST_FILENAME}" ]] ||
    #     die "Digest \"${ZESHY_USER_DIGEST_FILENAME}\" not found or not a file."

    # Source all applicable zeshy scripts and hence functions.

    # Unless the modification time of the newest path zeshy's user digest file
    # depends on was previously set, throw an exception.
    # (( ${+ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME} )) ||
    #     die '${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME} unset.'

    # Set the modification time of such digest to that of the newest
    # modification time to avoid recompilation on the next zeshy run.
    # command touch -m\
    #     --date=@${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME}\
    #     -- "${ZESHY_USER_DIGEST_FILENAME}"

    # The newest modification time of all dependencies of zeshy's digest.
    # Sorting such list is technically O(n lg(n)) but should approximate O(n)
    # assuming a sufficiently small number of dependencies (particularly a small
    # ${PATH}). Dismantled, this is:
    #
    # * "(On@)", numerically sorting such list in descending order.
    # * "[1]", the first and hence newest such time.
    # ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME="${${(On@)digest_dependency_mtimes}[1]}"

    # If CLI option "--compile-digest-if-zeshy-changed" was passed, obtain the last modification time of the
    # zeshy codebase by sorting the set of all last modification times of all
    # files and directories in this codebase and selecting the largest such
    # time. This is at best an O(n*lg(n)) operation and hence (usually) confined
    # to developers. Dismantled, this is:
    #
    # * "${...}"/**/*, all files and directories of this codebase.
    # * "om", sorting such files and directories by descending mtime.
    # * "[1]", the first and hence newest such file or directory.

        #FUXME: Totally incorrect. If the configuration directory is empty, for
        #example, this logic effectively guarantees such digest will be
        #unnecessarily recompiled again on the next zeshy startup. Why? Because
        #the current time at this point (and hence the time such digest file's
        #mtime will be set to) will be older than the mtime of such directory
        #when @{compile} subsequently creates such directory.
        #FUXME: However, that's hardly the worst thing that can happen. Consider
        #what occurs when the current digest file does not exist. In this case,
        #setting such digest file's mtime when we create it below to the current
        #time at this point makes it likely that such time will be *NEWER* than
        #that of the newest command in the current ${PATH}. If this is the
        #case... Hmm. Actually, that's quite alright. Then, it's principally the
        #latter two tests that induce issues. Here's what we should probably do:
        #
        #* Reduce this conditional test to *ONLY*, documenting what will
        #  probably happen on subsequent calls to this function (namely, such
        #  digest will be reported as up-to-date until the next installation or
        #  uninstallation of a command):
        #
        #    if ! [[ -f "${ZESHY_USER_DIGEST_FILENAME}" ]] {
        #        ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME="$(command date +'%s')"
        #        return 0
        #    }
        #
        #* Then, guard the logic requiring specific files or directories below
        #  with appropriate conditionals.

    # If neither the current digest file, the file caching digest dependencies,
    # *OR* a well-known non-optional subdirectory of the current configuration
    # directory exist, report such digest file to be outdated. (Test for the
    # existence of a subdirectory of such configuration directory rather than
    # merely such configuration directory to ensure that empty configuration
    # directories trigger digest recompilation.)

    # Append the following paths:
    #
    # * zeshy's user configuration directory, ensuring digest recompilation on
    #   addition or deletion of configuration files.
    # * zeshy's newest user configuration file, ensuring digest recompilation on
    #   changes to such files (e.g., edits to interactive alias names
    #   necessitating redefinition of the functions implementing such aliases).
    #
    # While getting such times is mildly expensive, the alternative cost of
    # redefining user-configured interactive aliases on each zeshy startup
    # outweighs such expense. See discussion below for implementation details.

    # Append to such list the modification times of all such dependencies in
    # arbitrary order. Dismantled, this is:
    #
    # * "-N", outputting only modification times. By default, zstat() outputs a
    #   human-readable two-column table when passed multiple files: e.g.,
    #   "inconceivable        1386576475
    #    dread_pirate_roberts 1368426799"
    #   Passing this option reduces the above output to:
    #   "1386576475
    #    1368426799"
    # * "${path[@]}", testing all directories on the current user's ${PATH}.
    # * "${ZESHY_USER_DIGEST_DEPENDENCY_PATHNAMES[@]}", testing all paths other parcels
    #   insist such digest depends on. Note that if the file caching such list
    #   did *NOT* exist above, such list remains empty. This is perfectly fine.
    # * "(@f)", splitting such output on newlines.
    #
    # Such expansion *MUST* be both double-quoted and explicitly expanded as a
    # list with parameter expansion flag "@". See set_list_to_string_lines()
    # for further details.
    # digest_dependency_mtimes+=(
    #     "${(@f):-$(zstat +mtime -N\
    #         "${path[@]}" "${ZESHY_USER_DIGEST_DEPENDENCY_PATHNAMES[@]}")}" )
        # digest_dependency_mtimes+="$(zstat +mtime "${ZESHY_USER_CONFIG_DIRNAME}"/**/*(om[1]))"
        # digest_dependency_mtimes+="$(zstat +mtime "${ZESHY_HOME}"/**/*(om[1]))"
#       print "adding zeshy codebase \"${ZESHY_HOME}\" as a digest dependency..."

    #FUXME: Wait! Clearly, we can optimize this from multiple to a single
    #subshell by instead creating a list of all paths to be passed to zstat().
    #Indeed, this should permit us to entirely excise
    #${digest_dependency_mtimes}.

    # digest_dependency_mtimes="$(zstat +mtime -N\
    #     "${path[@]}" "${ZESHY_USER_DIGEST_DEPENDENCY_PATHNAMES[@]}")"

    # # Get the modification times of the newest such dependency. Dismantled, this
    # # is:
    # #
    # # * "=", splitting such output on whitespace.
    # # * "(On)", sorting the resulting words numerically in descending order.
    # # * "(w)1", expanding to the first such word.
    # digest_dependency_mtimes+="${${(On)=digest_dependency_mtimes}[(w)1]}"
    # digest_dependency_mtimes+=(

    # If the file caching the latter list exists, get all such times.
    # Else, only get times for all directories on the current user's ${PATH}.
    # } else {
# the list of all paths on which such
    # digest depends, thus defining ${ZESHY_USER_DIGEST_DEPENDENCY_PATHNAMES}.

    # Append to such list the modification time of each existing directory
    # listed by the current user's ${PATH}, ensuring digest recompilation on
    # (un)installation of commands. The implementation below is hardly ideal,
    # given that zsh provides builtin glob qualifier "(#qom[1])" expanding to
    # the newest path in the current filename list. Frustratingly, zsh ignores
    # such qualifier unless preceded by a "*" operator: e.g.,
    #
    #     # None of the following behave as expected.
    #     >>> print ${path}(#qom[1])
    #     >>> print ${path[@]}(#qom[1])
    #     >>> print ${^path}(#qom[1])
    #     >>> print (${~${(j:|:)${(q@)path}}})(#qom[1])
    #     zsh: bad pattern: (/opt/bin|...)(#qom[1])
    #
    # We attempted all reasonable permutations of such examples without success.
    # Sadly, a comment in "man zshall" exposes the culprit:
    #
    #   "Note that grouping cannot extend over multiple directories: it is an
    #    error to have  a  `/'  within a group (this only applies for patterns
    #    used in filename generation)."
    #
    # Such comment suggests such constraint to be intentional. We have no clear
    # idea why, given that such constraint is easily circumventable by creating
    # one temporary symbolic link in the current directory to each such
    # directory, replacing such directories with such symbolic links in such
    # list, prefixing "-" to such glob qualifiers, globbing, and then removing
    # such links: e.g.,
    #
    #     # Bizarrely, this behaves as expected.
    #     >>> ln -s /opt/bin t1
    #     >>> ln -s /usr/bin t2
    #     >>> touch /usr/bin
    #     >>> list files; files=( t1 t2 )
    #     >>> readlink (${~${(j:|:)${(q@)files}}})(#q-om[1])
    #     /usr/bin
    #     >>> rm t1 t2
    #
    # WHAT THE BLOODY HECK. It's hard to regard this as anything but a blatant
    # bug. It's not, of course. zsh developers explicitly forbid the directory
    # separator in pattern groups. We intuitively suspect the zsh mailing list
    # would not be receptive to the above circumvention -- even though it
    # exposes the inanity of such arbitrary constraints. Sadly, implementing
    # such circumvention would still require iteration and hence likely be no
    # more efficient than the current implementation. (Filesystem operations are
    # both notoriously expensive and error-prone.)
#     local dependency_pathname
#     for   dependency_pathname (
#         # All directories on the current user's ${PATH}.
#         "${path[@]}"
# 
#         # All paths other zeshy components insist such digest depends on.
#         "${ZESHY_USER_DIGEST_DEPENDENCY_PATHNAMES[@]}"
#     ) {
# #       print "adding mtime for dependency \"${dependency_pathname}\"..."
#         if [[ -e "${dependency_pathname}" ]] {
#             digest_dependency_mtimes+="$(zstat +mtime "${dependency_pathname}")"
#         }
#     }

    #FUXME: Interestingly, GNU-specific external command "du" provides option
    #"--time", which, when coupled with option "--summary" (e.g.,
    #"du --time --summary"), efficiently recursively prints the modification
    #time of the newest file or subdirectory of the passed directory. This
    #*SHOULD* be quite a bit more efficient than the general approach used
    #below, but also a bit more fragile: after all, it only applies to GNU!

    #FUXME: Actually, the circumvention we discuss below should be *MUCH*
    #simpler. The reason why, of course, is subshells: the current approach
    #requires one subshell *PER* path, whereas the circumvention approach
    #requires only one subshell for *ALL* such paths. In fact, we can readily
    #extend the same circumvention to avoid other subshells below. We should
    #only do so where the number of required temporary symlinks is likely to be
    #sufficiently small (i.e., less than 10).
    #FUXME: Hmmm. Perhaps not. Filesystem operations are notoriously expensive
    #and error-prone. Hmm. Or, perhaps. The only way to decidably know will be
    #to implement and profile both approaches. We can't quite be bothered, at
    #the moment, so the simpler and less error-prone approach prevails.
    #FUXME: Woops! A significantly better approach presents itself. Basically,
    #we just pass all such paths to zstat():
    #
    #    >>> zstat +mtime _git type
    #    _git 1386576475
    #    type 1368426799
    #
    #Sweet. Only one subshell. No iteration required. (No idea why we didn't
    #contemplate that sooner. But in classic fashion, we didn't. But now we did!
    #Take that, inner regret.) Then, we just need to sort such lines by the
    #second column.

    # local digest_dependency_mtimes
    # local -a digest_dependency_mtimes_lines

    # Get the modification time of the newest Dismantled, this is:
    #
    # * "${path[@]}", testing all directories on the current user's ${PATH}.
    # * "${ZESHY_USER_DIGEST_DEPENDENCY_PATHNAMES[@]}", testing all paths other parcels
    #   insist such digest depends on.
    #
    # Such expansion *MUST* be both double-quoted and explicitly expanded as a
    # list with parameter expansion flag "@". See set_list_to_string_lines()
    # for further details.
#     digest_dependency_mtimes_lines=(
#         "${(@f):-$(zstat +mtime\
#             "${path[@]}" "${ZESHY_USER_DIGEST_DEPENDENCY_PATHNAMES[@]}")}"
#     )
# 
#     local dependency_pathname
#     for   dependency_pathname (
# #       print "adding mtime for dependency \"${dependency_pathname}\"..."
#         if [[ -e "${dependency_pathname}" ]] {
#             digest_dependency_mtimes+=
#         }
#     }

    # Append to such list the modification times of the following paths:
    #
    # * zeshy's user configuration directory, ensuring digest recompilation on
    #   addition or deletion of configuration files.
    # * zeshy's newest user configuration file, ensuring digest recompilation on
    #   changes to such files (e.g., edits to interactive alias names
    #   necessitating redefinition of the functions implementing such aliases).
    #
    # While getting such times is mildly expensive, the alternative cost of
    # redefining user-configured interactive aliases on each zeshy startup
    # outweighs such expense. See discussion below for implementation details.
    # if [[ -d "${ZESHY_USER_CONFIG_DIRNAME}" ]] {
    #     #FIXME: Actually, now that all configuration files guaranteeably reside
    #     #in subdirectories of such directory, this is meaningless.
    #     zeshy_dependency_mtimes+="$(zstat +mtime "${ZESHY_USER_CONFIG_DIRNAME}")"

# Given that
    # example, we could circumvent the constraints by temporarily making and
    # then removing one symbolic link for each directory in the current ${path}.
    # The last example *SHOULD* work. It works on files but not directories,
    # suggesting an internal zsh bug: e.g.,
    #
    #     # This behaves as expected.
    #     >>> list files; files=( ~/.zeshy/config/zeshy ~/.zeshy/config/zsh )
    #     >>> print (${~${(j:|:)${(q@)files}}})(#qom[1])
    #     /home/leycec/.zeshy/config/zeshy
    #
    # or not much more efficient, anyway.
    #
    # Until zsh support improves in this respect, this loop remains.

#exist *AND* the latter contains at least one directory or file (i.e., is
    # non-empty)
    # if ! {
    #     [[ -f "${ZESHY_USER_DIGEST_FILENAME}" &&\
    #        -f "${ZESHY_USER_DIGEST_DEPENDENCIES_FILENAME}" &&\
    #        -d "${ZESHY_USER_CONFIG_ROOT_DIRNAME}/00-core" ]] &&
    #     {
    #         local -a zeshy_dot_config_dir_if_nonempty
    #         zeshy_dot_config_dir_if_nonempty=( "${ZESHY_USER_CONFIG_ROOT_DIRNAME}"(/F) )
    #         (( ${#zeshy_dot_config_dir_if_nonempty} ))
    #     }
    # } {

#-n "${ZESHY_DOT_DIR}" &&\
# Do *NOT* return silently if ignoring zeshy's user
    # directory, both as all functions called below already do so and as the
    # logic below defines core globals required in either case.
    # If ignoring zeshy's user directory, manually source all applicable zeshy
    # scripts and hence functions without autoloading zeshy's user digest file.
    # if ! [[ -n "${ZESHY_DOT_DIR}" ]] {
    #     digest_zeshy_sans_dot_dir
    #     return 0
    # }

# ZESHY_CORE_HELP_FUNCTIONS+='
# void digest_zeshy_sans_dot_dir(void)
# 
# Source all `zeshy` scripts and hence functions applicable to the current user
# without reading to or writing from such user''s `zeshy` dot directory.
# '
# function digest_zeshy_sans_dot_dir() {
#     # Validate sanity.
#     (( # == 0 )) || die 'Expected no arguments.'
# 
#     # Source such scripts.
#     source -- "${ZESHY_HOME}/compile"
# 
#     # Delete zsh-specific globals possibly referencing such directory.
#     unset -- HISTFILE
# }

#       print 'localizing ${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME}...'
#   if ! [[ ${+ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME} -eq 1 &&
#        "${(t)ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME}" == 'integer'* ]] {
#   [[    ${+ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME} -eq 1 &&
#      "${(t)ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME}" == 'integer'* ]] || {

#FUXME: There exists a subtle race condition that will (probably) become
#increasingly less subtle as zeshy development proceeds. If a second zeshy shell
#is run while the first is still compiling its digest file, the second could
#conceivably attempt to k
#FUXME: Rename ${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME} to
#${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME}. Even the latter's longer than
#I'd like, but at least it's not *OBSCENELY* long, as the former is. Consider
#renaming "_modification_time" to "_mtime" everywhere, as well. As with "args",
#"stdin", etc., "mtime" is a commonly recognized abbreviation. We just *CAN'T*
#keep writing "_modification_time" everywhere. It's equally annoying to write
#and read.
    # Prepare for such compilation.
#   digest_zeshy_compile_setup
#FUXME: Shift remaining functionality into above function.
#set_function_documentation digest_zeshy_compile_setup '
#void digest_zeshy_setup(void)
#
#Assuming Zeshy''s user digest file to be outdated, implement aliases and
#functions required only for compiling an outdated digest file.
#'
#function digest_zeshy_compile_setup() {
#    # Validate sanity.
#    (( # == 0 )) || die 'Expected no arguments.'
#}

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #FUXME: *THIS IS ABSURD*. It's currently working, yes. But there's no
    #reason to perform such heavy-weight functionality here. Shift *ALL* such
    #documentation functionality to "always/00-setup/00-document/document".
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #FUXME: Define a new document_function_glob() or
    #document_function_sans_filename_globbing() or
    #document_function_and_disable_filename_globbing(). Yes, the latter. While
    #verbose, that's not necessarily a bad thing in this case, as such function
    #dramatically alters function parsing. In any case, such function should
    #define a new alias of the same name expanding as follows:
    #    alias ${function_name}="noglob ${function_name}"
    #
    #Test if such alias already exists before doing so, in which case throw an
    #exception or perhaps merely print a warning. (Nah, exception!)

    # ------------------< FUNCTIONS                          >------------------
    # Define document_function() before document_alias(), which documents itself
    # with the former function.
#   function document_function() {
        # Validate passed arguments.
#       (( # == 1 )) || die 'expected one documentation string'
#       local documentation="${1}" function_name
#       local -a function_names

        # If such documentation is prefixed by a function prototype, match the
        # relevant function name from such prototype. zsh permissively allows
        # function name declarations to be quoted and hence contain arbitrary
        # characters, necessitating a more lenient glob expression than liked.
        # Dismantled, this is:
        #
        # * "(#b)", capturing match groups into global list ${match}.
        # * "[[:space:]]#", matching optional whitespace.
        # * "[^[:space:]]##", matching the function return type.
        # * "[[:space:]]##", matching mandatory whitespace.
        # * "([^'(']##)", matching the function name into ${match[1]}.
        # * '(', matching the beginning of the function argument list.
#       if [[ "${documentation}" ==\
#           (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'(']##)'('* ]]; then
#           # Attempt to split such function name on " [or] " delimiters.
#           function_name="${match[1]}"
#           function_names=( "${(s: [or] :)function_name}" )

            # If such function name contains no such delimiters, document as is.
#           if (( ${#function_names} == 1 ))
#           then ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name}]="${documentation}"
            # Else, such function name contains at least one such delimiter.
            # Document each split function name with such documentation.
#           else
#               for function_name_split ("${function_names[@]}") {
#                   print "function name split: ${function_name_split}"
#                   ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name_split}]="${documentation}"
#               }
#           fi
#           print "function name: ${match[1]}"
        # Else, throw an exception with a portion of such documentation.
#       else die "help string \"${documentation[1,40]}...\" not prefixed by a function prototype"
#       fi
#   }

    # ------------------< ALIASES                            >------------------
#   function document_alias() {
        # Validate passed arguments.
#       (( # == 1 )) || die 'expected one documentation string'
#       local documentation="${1}"

        # If such documentation is prefixed by an alias prototype, match the
        # relevant alias name from such prototype. While zsh permissively allows
        # alias name declarations to be quoted and hence contain arbitrary
        # characters as with functions, such aliases are not runnable: e.g.,
        #
        #   >>> alias "o w s"="print 'revolt is dead; long live revolt'"
        #   >>> o\ w\ s
        #   zsh: command not found: o w s
        #
        # For simplicity, use a similar glob expression as document_function().
#       if [[ "${documentation}" ==\
#           (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'<']##)'<'* ]]
#       then ZESHY_ALIAS_NAME_TO_DOCUMENTATION[${match[1]}]="${documentation}"
#           print "function name: ${match[1]}"
        # Else, throw an exception with a portion of such documentation.
#       else die "help string \"${documentation[1,40]}...\" not prefixed by an alias prototype"
#       fi
#   }

    # ------------------< GLOBALS                            >------------------
#   set_global_documentation ZESHY_GLOBAL_TYPE_TO_DECLARATOR '
#ap ZESHY_GLOBAL_TYPE_TO_DECLARATOR

#ap variable type to the command prefix exporting globals of such type.
#'
#    typeset -Agx ZESHY_GLOBAL_TYPE_TO_DECLARATOR
#    ZESHY_GLOBAL_TYPE_TO_DECLARATOR=(
#        # Scalar types.
#        string    'export'
#        boolean   'export'
#        character 'export'
#        integer   'export -i'
#        float     'export -F'
#
        # Non-scalar types.
#        list     'export -a'
#        list_set 'export -Ua'

        # While "export -a" succeeds (as above), "export -A" fails with error.
        # Hence, revert to builtin typeset().
#        map 'typeset -Agx'
#    )

#    alias document_global='
#    {
#        # Localize the passed herestring.
#        local documentation__dg="$(< /dev/stdin)"

        # If such documentation is prefixed by a function prototype, match the
        # relevant function name from such prototype. zsh permissively allows
        # function name declarations to be quoted and hence contain arbitrary
        # characters, necessitating a more lenient glob expression than liked.
        # Dismantled, this is:
        #
        # * "(#b)", capturing match groups into global list ${match}.
        # * "[[:space:]]#", matching optional whitespace.
        # * "([^[:space:]]##)", matching the variable type into ${match[1]}.
        # * "[[:space:]]##", matching mandatory whitespace.
        # * "([[:IDENT:]]##)", matching the variable name into ${match[2]}.
        #
        # Else throw an exception with a portion of such documentation.
#        [[ "${documentation__dg}" ==\
#            (#b)[[:space:]]#([^[:space:]]##)[[:space:]]##([[:IDENT:]]##)* ]] ||
#            die "help string \"${documentation__dg[1,40]}...\" not prefixed by a variable declaration"

        #FUXME: If such global has been declared, we should probably print a
        #warning to standard error if its declared type differs from the
        #documentation-declared type. The implementation is a bit tedious,
        #however, requiring a new map ZESHY_GLOBAL_DECLARATOR_TO_TYPE
        #dynamically constructed from its converse for performing efficient
        #lookups. Clearly, not a priority for the moment.

        # If such global has not yet been declared, do so. Prefer globals
        # "${match[1]}" and "${match[2]}" to human-readable local variables to
        # avoid polluting the local shell environment any further. See
        # is_variable() for implementation details.
#        [[ -n "${(P)match[2]+x}" ]] || {
            # If such global''s type is not a Zeshy-specific type, throw an
            # exception. See is_map_key() for implementation details.
#            (( ${+ZESHY_GLOBAL_TYPE_TO_DECLARATOR[${match[1]}]} )) ||
#                die "\"${match[1]}\" not a zeshy type"

            # Declare such global.
#           ${(z)ZESHY_GLOBAL_TYPE_TO_DECLARATOR[${match[1]}]} "${match[2]}"
#       }

        # Document such global.
#       ZESHY_GLOBAL_NAME_TO_DOCUMENTATION[${match[2]}]="${documentation__dg}"
    #   print "function name: ${match[1]}"
#   } <<<'

# Undefine lower-level documentators, hereafter replaced by the previously
# defined higher-level documentators. Do so here for code convenience rather
# than necessity.
#unfunction\
#    set_alias_documentation\
#    set_function_documentation\
#    set_global_documentation

# ....................{ ALIASES                            }....................
# Define aliases subsequently expanded by Zeshy's user configuration files,
# defined here rather than in "config" to avoid excessive global variables.
# (Namely, a new global boolean ${ZESHY_USER_DIGEST_FILE_IS_OUTDATED} would be
# required for tracking such state.)

#ZESHY_CORE_HELP_FUNCTIONS+='
#void document_alias(string documentation)
#
#If called when recompiling Zeshy''s user digest file, document the alias
#prefixing the passed string with such string; else, do nothing.
#'
#FUXME: Document prototype syntax, including "[or]" delimiters.
#set_function_documentation document_function '
#void document_function(string documentation)
#
#If called when recompiling Zeshy''s user digest file, document the function
#prefixing the passed string with such string; else, do nothing.
#'
#set_alias_documentation document_global '
#void document_global<string documentation>
#
#If called when recompiling Zeshy''s user digest file, globally export the global
#prefixing the passed string with the Zeshy-specific type (e.g., "list", "float")
#prefixing the passed string *AND* document such global with such string; else,
#do nothing.
#'
## For efficiency when not recompiling Zeshy's user digest file, default such
# runnables to noop. When recompiling such file, redefine such runnables to
# actually document the passed object.
#alias document_alias=':' document_function=':' document_global=':'

#FUXME: It's not difficult to see the list of dependency pathnames growing over
#time, possibly in OS- and distro-specific directions. (It's unclear whether BSD
#also uses "/etc/mailcap", for example.) In any case, it'd be nice to enable
#individual components (e.g., "path/file/mime") to append arbitrary paths to
#such dependency list. To do so, we'll need the customary adder function and
#corresponding global (e.g., add_zeshy_digest_dependency_path() and
#${ZESHY_USER_DIGEST_DEPENDENCY_PATHNAMES}). But that won't be enough. This function
#is called before digest autoloading and hence requires... unconventional access
#to such global. The simplest and sanest approach is as follows:
#
#* Immediately before *OR* after digest compilation but certainly after calling
#  precompile_zeshy() and before calling startup_zeshy(), cache the contents of
#  ${ZESHY_USER_DIGEST_DEPENDENCY_PATHNAMES} to a new user-specific dotfile -- say,
#  "~/.zeshy/cache/digest.paths".
#* In :is_zeshy_digest_outdated(), if such dotfile does *NOT* exist, Zeshy cannot
#  have been compiled before, so the digest file is outdated (test this at the
#  very front of the function as usual); else, source such
#  dotfile and interpolate the resulting global into the list of iterated
#  dependency paths. We probably should *NOT* inject the current user's ${PATH}
#  into such list, to avoid synchronicity issues; it's no less efficient (and is
#  certainly safer) to simply reinterpolate the ${path} on each call to this
#  function: e.g.,
#
#      for dependency_pathname ("${path[@]}" "${ZESHY_USER_DIGEST_DEPENDENCY_PATHNAMES[@]}") {
#
#Should be reasonably efficient, all things considered. In fact, it might
#eventually be *MORE* efficient than the current approach. Why? Because
#the add_zeshy_digest_dependency_path() function can internally test whether or
#not such path actually exists -- and, if not... Oh, wait. *DON'T* do that. The
#path could be added later, at which point we'd want to consider that. O.K.; so,
#it'll never be more efficient. But, hey: can't have everything.

#FUXME: Actually, let's just centralize everything in "compile". Much more
#intelligible, particularly after we've also shifted out the existing
#documentation stuff!
#FUXME: This file needs a bit of work. First, *NO* alias defined below should
#induce a fatal error at Zeshy startup, even if the corresponding command does
#not exist on the current system: print a warning and move. Currently, my whole
#setup is dying because "lsmod" no longer exists due to the "kmod" switch; ugh.
#FUXME: Second, I suddenly conceived this morning of why startup has become so
#hideously slow. We're actually reparsing *ALL* such aliases on each Zeshy
#startup. This is, to put it bluntly, insanity. We need instead to shift the
#current startup function iteratively defining such aliases into precompile_zeshy(),
#thus confining such definition to digest recompilation. Ideally, this should
#see a significant improvement in runtime efficiency.

    # If true, recompile Zeshy's user digest file. If already set, inherit such
    # variable's value from the caller (e.g., component "main").
#   local ZESHY_USER_DIGEST_FILE_IS_COMPILING="${ZESHY_USER_DIGEST_FILE_IS_COMPILING-}"

    # If Zeshy's user digest file is outdated, record such fact.
#   :is_zeshy_digest_outdated &&
#       ZESHY_USER_DIGEST_FILE_IS_COMPILING=${ZESHY_BOOLEAN_TRUE}

    # If compiling such file, prepare for such compilation.
#   [[ -n "${ZESHY_USER_DIGEST_FILE_IS_COMPILING}" ]] &&

#FUXME: This isn't right. *sigh* We need to do this *BEFORE* sourcing
#configuration files, which call documentation methods. Unfortunately, that
#breeds a circularity conflict: configuration sources must be sourced *BEFORE*
#calling :is_zeshy_digest_outdated(). The solution is clear: retain the new
#calling order, which is demonstrably superior; to solve the documentation
#issue, simply define... Wait. That's not quite it. O.K.; here goes: the check
#in :is_zeshy_digest_outdated shouldn't depend on configuration file values. If
#you think about it, this makes both inherent sense and improves the robustness
#of the whole process (by eliminating yet-another-obscure-dependency). So:
#
#* Revert to the prior calling order. We *NEED* to determine whether or not the
#  digest is outdated *BEFORE* sourcing configuration files in order to define
#  documentation aliases properly. (So, shift us back! Sorry, sorry.)
#* Change the test in :is_zeshy_digest_outdated() from expanding to
#  is_zeshy_debug_and() to... well, what? How about this:
#  * Check whether or not the parent directory of ${ZESHY_HOME} contains a
#    ".git" directory; if it does, consider that equivalent to "debugging."
#FUXME: Nope! Nix all that. This is actually the way to go. So how do we enable
#documentation in config files then? Pretty simple, and, if you consider it, the
#only reasonable way it can be done. Consider this: after upgrading Zeshy or
#perhaps simply deleting existing config files, sourcing such files only once
#prior to copying such files back during digest recompilation guarantees that
#Zeshy will *NEVER* document globals in such files. In other words,
#the way we were doing it could *NEVER* have reasonably worked. So what to do?
#Simple: just source all config files *AT ONCE* by re-calling
#source_zeshy_configuration() immediately *AFTER* compiling Zeshy's digest but
#*BEFORE* calling precompile_zeshy() (for obvious reasons). The easiest way to
#accomplish this, of course, is simply to prepend "source_zeshy_configuration"
#to the beginning of global list ${ZESHY_COMMANDS_TO_MAKE_ZESHY}. Brilliant --
#but should be voluminously documented, of course. It's *INCREDIBLY* subtle.
#Not sure how I ever even caught on to all this...
#FUXME: This suggests a few optimizations:
#
#* There's actually *NO* point to sourcing configuration files before
#  recompiling the digest aside from ensuring ${ZESHY_IS_DEBUG} is set and
#  debug messages are printed during such recompilation. To put it bluntly,
#  there *MUST* be a simpler, faster way of ensuring the same functionality.
#  Again, the simplest way is probably testing *ONCE* up-front for a sibling
#  directory ".git" of the parent of "${ZESHY_HOME}"; it's a fast test: cache it
#  *ONLY* if recompiling Zeshy and we move on. (If not recompiling Zeshy, we
#  shouldn't need such shennanigans.)
#* Given that, *STOP* sourcing configuration files as the first action performed
#  on Zeshy startup. Instead:
#  * If such digest is outdated, prepend "source_zeshy_configuration" to
#    ${ZESHY_COMMANDS_TO_MAKE_ZESHY} as discussed above.
#  * Else, call source_zeshy_configuration() manually. Hmm. We *could* simply
#    prepend "source_zeshy_configuration" to ${ZESHY_COMMANDS_TO_STARTUP_ZESHY}.
#    That has the sole downside of causing such configuration to be sourced twice
#    when recompiling such digest. On the other hand, it's probably more readable.
#    *shrug* It doesn't particularly matter which we adopt, honestly.
#* Rename "setup" to "config". (See such component for details). That implies that
#  we call "source_zeshy_component config" rather than "source_zeshy_configuration"
#  above, in which case I don't really see the benefit to prepending such command
#  to arrays. Just call "source_zeshy_component config" as is exactly where we
#  require it.
#* Shift source_zeshy_component() to "always/zeshy/zeshy". (Extremely silly to
#  have such febrile functionality at the top-level, wasn't it?)
#* Add new command-line option "-v, --verbose" and remove existing configuration
#  option ${ZESHY_IS_DEBUG}. The latter turns out to have been a *REALLY*
#  bad idea that's just not needed anymore and couldn't really be reliably
#  supported in any case.
#* Rename is_zeshy_debug_and<> to is_zeshy_debug_and<>.
#Phew! That's quite a lot of requisite changes, but... well, we'll be
#demonstrably better for each one.
    # If true, Zeshy''s user digest file is outdated. Defaults to false.
#   local ZESHY_USER_DIGEST_FILE_IS_OUTDATED=${ZESHY_BOOLEAN_FALSE}

#FUXME: Third, :is_zeshy_digest_outdated() needs to recursively depend on the
#newest config file. Make it so, aye!

    # The former contain commands and the latter define globals on which Zeshy's
    # digest compilation depends. The current implementation is hardly ideal,
    # Append to such list the modification time of Zeshy's newest user
    # configuration file, ensuring digest recompilation on changes to such files
    # (especially changes to interactive alias names necessitating redefinition
    # of the functions implementing such aliases). While this is a non-
# Explicitly define such globals to default values. When not doing so, such
# globals erroneously inherit their default values from the parent shell,
# typically resulting in Zeshy recompiling its user digest file on each startup.

#FUXME: Pretty sure we don't need these anymore, now that we've glued this file
#back together. Phew!

    # Oddly, zsh has no means of directly associating the two.
        #FUXME: Hmmmm; I reckon we can remove the same line in "compile" by
        #shifting this line *UP* out of this conditional. Source such config
        #files immediately after calling digest_setup_digest() and we should be
        #good to go whether or not the digest is outdated, yes?

        # Source Zeshy's user configuration files. It doesn't particularly
        # matter whether we do so before or after autoloading Zeshy's user
        # digest file, simply that we do so.
#       source -- "${ZESHY_HOME}/config"

#Prepare Zeshy for subsequent startup and possible user digest file compilation.
#Specifically, ascertain whether such file requires compilation and source all
#applicable user configuration files.
#
#Render all Zeshy functions applicable to the current user autoloadable after
#recompiling such functions into the Zeshy digest file for such user.

    # If true, Zeshy''s user digest file was outdated at Zeshy startup. See
#   boolean ZESHY_USER_DIGEST_FILE_IS_OUTDATED=${ZESHY_BOOLEAN_TRUE}

    # Unless Zeshy's user digest file is outdated, immediately return.
#   :is_zeshy_digest_outdated || return 0

#FUXME: Rename to :digest_zeshy() after shifting. (Yes, use "digest" as a verb.
#It's a well-established verb and much better explains the function's purpose.)
        #FUXME: I''m no longer convinced such implicit declarations are a good
        #thing. In fact, the harder I look at the issue, the more clearly I see
        #that it''s probably a bad idea likely to blow up at some future point.
        #There are a few issues here:
        #
        #* It''s odd that a documentation-specific runnable declares objects.
        #  It shouldn''t. That''s not the expectation. Certainly, neither
        #  document_alias() or document_function() behave that way.
        #* It doesn''t really gain us anything... except brevity. *ALOT* of
        #  brevity. Hmm.
#set_global_documentation ZESHY_USER_DIGEST_FILE_IS_OUTDATED '
#boolean ZESHY_USER_DIGEST_FILE_IS_OUTDATED
#
#If true, Zeshy''s user digest file was outdated at Zeshy startup. See
#:is_zeshy_digest_outdated() for further details.
#'
#export ZESHY_USER_DIGEST_FILE_IS_OUTDATED=${ZESHY_BOOLEAN_FALSE}

#document_function '
#void autoload_zeshy(void)
#
#Autoload Zeshy functions and functions and variables defined by zsh modules.
#'
#function autoload_zeshy() {
#    (( # == 0 )) || die 'Expected no arguments.'
#    autoload_zeshy_zsh_modules
#    autoload_zeshy_functions
#}

#Render all Zeshy functions applicable to the current user autoloadable after
#recompiling such functions into the Zeshy digest file for such user, setting
#the modification time of such file to global ${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME}

#FUXME: This could be a nice opportunity to truncate "main" a bit. I'd
#specifically like to see get_script_name() shifted into "shell/shell" and
#say() and cry() shifted into "shell/output".

#   zmodload -abi zsh/datetime strftime
    #   never profile in the intended manner.
    #   such profiling is both wasteful where not immediately
    #   utilized and not cost-free and could in the
    #   amortization of all such costs become prohibitively expensive.
#   zmodload -abi zsh/zprof zprof
    # If ignoring Zeshy's user directory, pretend the digest file under such
    # directory to be outdated. This induces Zeshy to source all appropriate
    # scripts manually, below.
#   [[ -n "${ZESHY_DOT_DIR}" ]] || return 0

    # Validate passed arguments.
#   (( # == 1 )) || die 'expected one integer'
#   string digest_mtime="${1}"
#   [[ "${digest_mtime}" == <-> ]] ||
#       die "\"${digest_mtime}\" not a nonnegative integer"

    # Otherwise, source all user configuration files. Since the above condition
    # implicitly sources such files already, do so when not recompiling here.
#   else
        # If the current user's Zeshy configuration dir exists but is empty,
        # throw an exception. Despite having previously tested for this, do so
        # again in the unlikely event of a race condition in which such user
        # deleted such files in between the prior and current tests. If such an
        # event occurs and we fail to throw an exception here, calling "source"
        # below with no arguments results in an undecipherable error resembling
        # "source: not enough arguments".
#       list user_config_filenames
#       user_config_filenames=( "${ZESHY_USER_CONFIG_ROOT_DIRNAME}/"* )
#       (( #user_config_filenames )) or
#           die "configuration dir \"${ZESHY_USER_CONFIG_ROOT_DIRNAME}\" empty"

        # Otherwise, source the current user's Zeshy configuration files.
#       source -- "${user_config_filenames[@]}"
#   fi

#   if [[ -d "${ZESHY_USER_CONFIG_ROOT_DIRNAME}" ]]; then
#   source -- "${user_config_filenames[@]}"
#       list zeshy_user_config_dir_if_nonempty
#       zeshy_user_config_dir_if_nonempty=( "${ZESHY_USER_CONFIG_ROOT_DIRNAME}"(/F) )
#       (( #zeshy_user_config_dir_if_nonempty )) or
#           die "zeshy configuration dir \"${ZESHY_USER_CONFIG_ROOT_DIRNAME}\" empty"

        #FUXME: O.K.; the dir could exist but have no files, in which case
        #source() spits out an error. Test this and die ourselves, since this
        #should never happen here! Test this here to avoid race conditions, in
        #case such files have been deleted since the similar test above.
#       source "${ZESHY_USER_CONFIG_ROOT_DIRNAME}/"*
    #FUXME: Is ${ZESHY_USER_CONFIG_ROOT_DIRNAME} guaranteed to exist at this point? If
    #not, returning true if such directory does not exist also seems sane.

    # ~~~~~~~~~~~~~~~~< ZSH                                >~~~~~~~~~~~~~~~~~~~~
    # ~~~~~~~~~~~~~~~~< ZESHY                              >~~~~~~~~~~~~~~~~~~~~
# Source (i.e., load) zsh modules and autoload Zeshy functions.
#       is -d '/bin'     si and digest_dependent_mtimes+=$(zstat +mtime '/bin')
#       is -d '/usr/bin' si and digest_dependent_mtimes+=$(zstat +mtime '/usr/bin')

#   is -f "${ZESHY_USER_CONFIG_FILE}" si and
#       digest_dependent_mtimes+=$(zstat +mtime "${ZESHY_USER_CONFIG_FILE}")
#        is -f "${ZESHY_USER_DIGEST_FILENAME}" si and
#        (( newest_mtime == $(zstat +mtime "${ZESHY_USER_DIGEST_FILENAME}") )); then
#to synchronize function definitions
    # with current system and user state
        # Find the maximum of this and the prior modification time.
#       (( zeshy_dev_mtime > zeshy_mtime )) and zeshy_mtime="${zeshy_dev_mtime}"

    #FUXME: Hmmmm; O.K.; I have a dramatic improvement here, but I'm simply too
    #lazy to implement it. Not hard; just lazy. Under the current approach, we
    #technically should also be considering the mtimes of "/etc/zsh/zshrc" and
    #"~/.zshrc", as both files may define a $PATH different from the last time
    #Zeshy was invoked. But, if you think about it, this run_quickly regresses into
    #insanity, because *ANY* profile script (e.g., "/etc/profile.env") could
    #conceivably set or augment $PATH (and probably does). So, we instead need
    #to simply test the following two things:
    #
    #* If no cache file exists or such a file exists but with insufficient or
    #  erroneous content, forego the tests below and *JUST* recompile.
    #* The current (if undefined, default to empty string) against the cached
    #  value of $ZESHY_THEME.
    #* The current (if undefined, default to empty string) against the cached
    #  value of $PATH. This requires a cache file containing sourceable values,
    #  which we declare to be local prior to sourcing: say,
    #
    #       last_ZESHY_THEME="..."
    #       last_PATH="..."
    #
    #Simple. The catch is: when do we create this file? I'm beginning to
    #suspect that our definition of $PATH for interactive shells in
    #"always/shell/profile" may obstruct things a bit, here. Oh; no. That
    #doesn't work. It must be late. Clearly, that fails to account for... well,
    #pretty much everything. Back to le drawing board.

    # If the digest file does not exist or does but is older than Zeshy's last
    # modification time, recompile this file to synchronize compiled function
    # definitions with newer Zeshy changes.
#   integer\
#         zeshy_mtime=$(zstat +mtime "${ZESHY_USER_CONFIG_ROOT_DIRNAME}")\
#         zeshy_mtime=$(zstat +mtime "${ZESHY_USER_CONFIG_FILE}")\
#           bin_mtime=$(zstat +mtime '/bin')\
#       usr_bin_mtime=$(zstat +mtime '/usr/bin')
#   ((     bin_mtime > zeshy_mtime )) and zeshy_mtime="${bin_mtime}"
#   (( usr_bin_mtime > zeshy_mtime )) and zeshy_mtime="${usr_bin_mtime}"
