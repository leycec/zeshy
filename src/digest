#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle zeshy's user digest file.

# ....................{ GLOBALS                            }....................
ZESHY_CORE_HELP_GLOBALS+='
string ZESHY_USER_DIGEST_DEPENDENCIES_FILE

Absolute path of the file to which `zeshy` caches the list of all paths
`zeshy`\''s user digest file depends on. See
${ZESHY_DIGEST_DEPENDENCY_PATHS} for further details.
'
typeset -g ZESHY_USER_DIGEST_DEPENDENCIES_FILE="${ZESHY_USER_CACHE_DIR}/digest.dependencies"

ZESHY_CORE_HELP_GLOBALS+='
list ZESHY_DIGEST_DEPENDENCY_PATHS

List of absolute paths `zeshy`\''s user digest file depends on. Before compiling
such file, precompile_zeshy_digest_dependency_paths() serializes this list to a
user-specific dotfile to be sourced by is_zeshy_digest_outdated() on subsequent
`zeshy` startup.
'
typeset -ga ZESHY_DIGEST_DEPENDENCY_PATHS

# ....................{ ADDERS                             }....................
ZESHY_CORE_HELP_FUNCTIONS+='
void add_zeshy_digest_dependency_path(string pathname1, string pathname2, ...)

Add the passed paths to the list of paths `zeshy`\''s user digest file depends
on. See ${ZESHY_DIGEST_DEPENDENCY_PATHS} for further details.
'
function add_zeshy_digest_dependency_path() {
    (( # )) || die 'expected at least one path'
    ZESHY_DIGEST_DEPENDENCY_PATHS+=( "${@}" )
}

# ....................{ TESTERS                            }....................
#FIXME: The resolution of ${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME}
#should be improved from seconds to nanoseconds on systems supporting the latter
#(e.g., BSD, Linux). Happily, this can be efficiently obtained as a float from
#"date" with the command:
#
#   >>> date +'%s.%N'
#   1369342075.472940831
#
#Naturally, this is sufficiently useful to be generalized into a new function
#get_time_second_nanosecond() (whose name complies with "os/time" nomenclature).
#FIXME: Retrieving file modification time denominated in nanoseconds isn't quite
#as simple, unfortunately. We have an algorithm for doing so at "path/time",
#which we'll need to move here. Both implementations are (probably) Linux-
#specific. So, we'll also need to move the is_pathable_gnu() function here. I
#know, I know; but it's really quite unavoidable.
#FIXME: *UGH*. We *ALREADY* have the current time as a float in global
#${ZESHY_STARTUP_TIME_SECONDS}. Hence, replace our current calling of "date"
#below with simple expansion of such global.
#FIXME: We already implement get_time() to return fractional seconds, so no
#additional work needed there.
#FIXME: We will still need to shift functionality here for getting fractional
#file time. However, since zsh will (eventually) obsolete such functionality by
#improving zstat(), this isn't really a significant long-term concern.
#FIXME: Update documentation, now significantly outdated. (The irony.)

ZESHY_CORE_HELP_FUNCTIONS+='
[status: boolean] is_zeshy_digest_outdated(void)

Return success if `zeshy`\''s user digest file is outdated and requires
recompilation. This is the case when such file either does not exist or does but
is older than the newest of:

* The main user-specific `zeshy` configuration file. This file contains theme
  settings, which when edited require recompiling theme autoloads.
* The main system-wide command directories (e.g., `/bin`, `/usr/bin`).
  Installing or uninstalling commands requires recompiling command autoloads.

For convenience, set integer global
${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME} to the modification
time of the newest path such digest depends upon.
'
function is_zeshy_digest_outdated() {
    # Validate sanity.
    (( # == 0 )) || die 'expected no arguments'

    #FIXME: Add support for zeshy upgrading: namely, if upgrading zeshy,
    #immediately return 0 (i.e., true).

    # Unless loading zeshy's user directory *AND* zeshy's user digest file and
    # configuration directory both exist *AND* the latter contains at least one
    # directory or file (i.e., is non-empty), return such digest to be outdated.
    [[ -n "${ZESHY_DOT_DIR}" &&\
       -d "${ZESHY_USER_CONFIG_DIR}" &&\
       -f "${ZESHY_USER_DIGEST_FILE}" &&\
       -f "${ZESHY_USER_DIGEST_DEPENDENCIES_FILE}" ]] && {
        local -a zeshy_dot_config_dir_if_nonempty
        zeshy_dot_config_dir_if_nonempty=( "${ZESHY_USER_CONFIG_DIR}"(/F) )
        (( ${#zeshy_dot_config_dir_if_nonempty} ))
    } || {
        # Before returning, set global
        # ${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME} as
        # required by this function's definition to the current time. This
        # guarantees the modification time for zeshy's user digest file will be
        # coerced to the current time.
        ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME="$(date +'%s')"
        return 0
    }

    # Source the file to which zeshy caches the list of all paths on which such
    # digest depends, thus defining ${ZESHY_DIGEST_DEPENDENCY_PATHS}.
    source -- "${ZESHY_USER_DIGEST_DEPENDENCIES_FILE}"

    # List of modification times of paths on which such digest depends.
    local -a zeshy_dependency_mtimes

    # Append to such list the modification time of each existing directory
    # listed by the current user's ${PATH}, ensuring digest recompilation on
    # (un)installation of commands. The implementation below is hardly ideal,
    # given that zsh provides builtin glob qualifier "(#qom[1])" expanding to
    # the newest path in the current filename list. Frustratingly, zsh ignores
    # such qualifier unless preceded by a "*" operator: e.g.,
    #
    #     # None of the following behave as expected.
    #     >>> print ${path}(#qom[1])
    #     >>> print ${path[@]}(#qom[1])
    #     >>> print ${^path}(#qom[1])
    #     >>> print (${~${(j:|:)${(q@)path}}})(#qom[1])
    #     zsh: bad pattern: (/opt/bin|...)(#qom[1])
    #
    # We attempted all reasonable permutations of such examples without success.
    # The last example *SHOULD* work. It works on files but not directories,
    # suggesting an internal zsh bug: e.g.,
    #
    #     # This behaves as expected.
    #     >>> list files; files=( ~/.zeshy/config/zeshy ~/.zeshy/config/zsh )
    #     >>> print (${~${(j:|:)${(q@)files}}})(#qom[1])
    #     /home/leycec/.zeshy/config/zeshy
    #
    # We tracked the culprit to a comment in "man zshall" reading:
    #
    #   "Note that grouping cannot extend over multiple directories: it is an
    #    error to have  a  `/'  within a group (this only applies for patterns
    #    used in filename generation)."
    #
    # Such comments suggests such constaint to be intentional. We have no clear
    # idea why, given that grouping does extend over multiple directories when
    # the target is a file rather than directory. Stupidly, creating a temporary
    # symbolic link to such directories and replacing such directories with such
    # symbolic links in such list and prefixing "-" to such glob qualifiers
    # produces the expected behavior: e.g.,
    #
    #     # Bizarrely, this behaves as expected.
    #     >>> ln -s /opt/bin t1
    #     >>> ln -s /usr/bin t2
    #     >>> touch /usr/bin
    #     >>> list files; files=( t1 t2 )
    #     >>> print (${~${(j:|:)${(q@)files}}})(#q-om[1])
    #     t2
    #
    # WHAT THE BLOODY HECK. It's hard to regard this as anything but a blatant
    # bug. I intuitively suspect that the zsh mailing list would not be
    # receptive to such arguments -- even given the obscene above symbolic link
    # example, exposing the inanity of such arbitrary constraints. Given that
    # example, we could circumvent the constraints by temporarily making and
    # then removing one symbolic link for each directory in the current ${path}.
    # This requires iteration and hence is likely to be no more efficient than
    # the current implementation... or not much more efficient, anyway.
    #
    # Until zsh support improves in this respect, this loop remains.
    local dependency_pathname
    for   dependency_pathname (
        # All directories on the current user's ${PATH}.
        "${path[@]}"

        # All paths other zeshy components insist such digest depends on.
        "${ZESHY_DIGEST_DEPENDENCY_PATHS[@]}"
    ) {
#       print "adding mtime for dependency \"${dependency_pathname}\"..."
        [[ -e "${dependency_pathname}" ]] &&
            zeshy_dependency_mtimes+="$(zstat +mtime "${dependency_pathname}")"
    }

    #FIXME: Interestingly, GNU-specific external command "du" provides option
    #"--time", which, when coupled with option "--summary" (e.g.,
    #"du --time --summary"), efficiently recursively prints the modification
    #time of the newest file or subdirectory of the passed directory. This
    #*SHOULD* be quite a bit more efficient than the general approach used
    #below, but also a bit more fragile: after all, it only applies to GNU!

    # Append to such list the modification times of the following paths:
    #
    # * zeshy's user configuration directory, ensuring digest recompilation on
    #   addition or deletion of configuration files.
    # * zeshy's newest user configuration file, ensuring digest recompilation on
    #   changes to such files (e.g., edits to interactive alias names
    #   necessitating redefinition of the functions implementing such aliases).
    #
    # While getting such times is mildly expensive, the alternative cost of
    # redefining user-configured interactive aliases on each zeshy startup
    # outweighs such expense. See discussion below for implementation details.
    if [[ -d "${ZESHY_USER_CONFIG_DIR}" ]] {
        zeshy_dependency_mtimes+="$(zstat +mtime "${ZESHY_USER_CONFIG_DIR}")"
        zeshy_dependency_mtimes+="$(zstat +mtime "${ZESHY_USER_CONFIG_DIR}"/**/*(om[1]))"
    }

    # If the current user is a zeshy developer, obtain the last modification
    # time of the zeshy codebase by sorting the set of all last modification
    # times of all files and directories in this codebase and selecting the
    # largest such time. This is at best an O(n*lg(n)) operation, and hence
    # confined to developers. Dismantled, this is:
    #
    # * "${...}"/**/*, all files and directories of this codebase.
    # * "om", sorting such files and directories by descending mtime.
    # * "[1]", the first and hence newest such file or directory.
    if [[ -n "${ZESHY_USER_DIGEST_FILE_IS_DEPENDENT_ON_ZESHY_HOME-}" ]] {
#       print "adding zeshy codebase \"${ZESHY_HOME}\" as a digest dependency..."
        zeshy_dependency_mtimes+="$(zstat +mtime "${ZESHY_HOME}"/**/*(om[1]))"
    }

    # The newest modification time of all dependencies of zeshy's digest.
    # Technically, sorting such list is technically O(n lg(n)). Assuming a
    # sufficiently small ${PATH}, sorting is nearly O(n). Dismantled, this is:
    #
    # * "(nO@)", numerically sorting such list in descending order.
    # * "[1]", the first and hence newest such time.
    #
    # If the caller failed to declare such integer, do so locally. Ideally, the
    # caller declares such integer to subsequently set such file's modification
    # time using such integer. See digest_zeshy_compile() for further details.
    [[ ${+ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME} -eq 1 &&
       "${(t)ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME}" == 'integer'* ]] || {
#       print 'localizing ${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME}...'
        local -i ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME
    }
    ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME="${${(nO@)zeshy_dependency_mtimes}[1]}"

    # The modification time of zeshy's digest.
    integer zeshy_digest_mtime
    zeshy_digest_mtime="$(zstat +mtime "${ZESHY_USER_DIGEST_FILE}")"

    # If zeshy's digest is older than its newest dependency, signify such digest
    # to be outdated by returning true.
#   print "mtimes: ${dependency_mtimes[@]}"
#   print "newest: ${ZESHY_NEWEST_DEPENDENCY_MTIME}"
#   print "digest: ${zeshy_digest_mtime}"
#   print "digest file: \"${ZESHY_USER_DIGEST_FILE}\""
    (( zeshy_digest_mtime <\
        ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME ))
}

# ....................{ SETUP                              }....................
ZESHY_CORE_HELP_FUNCTIONS+='
void digest_zeshy(void)

If `zeshy`\''s user digest file is *outdated* (i.e., older than such file''s
newest dependency), recompile such file. In either case, source `zeshy`\''s user
configuration files and autoload all functions defined by such digest.
'
function digest_zeshy() {
    # Validate sanity. Do *NOT* return silently if ignoring zeshy's user
    # directory, both as all functions called below already do so and as the
    # logic below defines core globals required in either case.
    (( # == 0 )) || die 'expected no arguments'

    # If ignoring zeshy's user directory, manually source all applicable zeshy
    # scripts and hence functions without autoloading zeshy's user digest file.
    [[ -n "${ZESHY_DOT_DIR}" ]] || {
        digest_zeshy_without_dot_dir
        return 0
    }

    # If such digest is outdated, this is the modification time of the newest
    # path such digest depends on; else 0. While this function itself does not
    # refer to this variable, explicitly declare this variable here to provide
    # shared access to this variable by functions this function calls. (Subtle!)
    local -i ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME

    # If zeshy's user digest file is outdated or the caller demands recompiling
    # such file regardless of whether it's outdated or not, compile all zeshy
    # functions applicable to the current user into such digest and render such
    # functions autoloadable. See "main" for declaration of the latter
    # condition, "${ZESHY_USER_DIGEST_FILE_IS_COMPILING}".
#   print "detecting \"${ZESHY_USER_DIGEST_FILE}\"..."
    if { is_zeshy_digest_outdated ||
        [[ -n "${ZESHY_USER_DIGEST_FILE_IS_COMPILING-}" ]] } {
        digest_zeshy_compile
    # Otherwise, attempt to autoload the previously compiled digest for the
    # current user. If such autoload fails, (re)compile such digest and try
    # again.
    } else {
        autoload -w -- "${ZESHY_USER_DIGEST_FILE}" || digest_zeshy_compile
#       print "autoloading \"${ZESHY_USER_DIGEST_FILE}\"..."
    }

    # Prefix the function path with the absolute path to the digest file to
    # ensure zsh searches such file for the definition of such functions first.
    fpath=( "${ZESHY_USER_DIGEST_FILE}" "${fpath[@]}" )
}

ZESHY_CORE_HELP_FUNCTIONS+='
void digest_zeshy_without_dot_dir(void)

Source all `zeshy` scripts and hence functions applicable to the current user
without reading to or writing from such user''s `zeshy` dot directory.
'
function digest_zeshy_without_dot_dir() {
    # Validate sanity.
    (( # == 0 )) || die 'expected no arguments'

    # Source such scripts.
    source -- "${ZESHY_HOME}/compile"

    # Delete zsh-specific globals possibly referencing such directory.
    unset -- HISTFILE
}

ZESHY_CORE_HELP_FUNCTIONS+='
void digest_zeshy_compile(void)

Compile `zeshy`\''s user digest file, coerce the modification time of such file
to the modification time of the newest path such file depends on, and autoload
all functions compiled into such file.
'
function digest_zeshy_compile() {
    # Validate sanity. Unless the modification time of the newest path zeshy's
    # user digest file depends on was previously set, throw an exception.
    (( # == 0 )) || die 'expected no arguments'
    (( ${+ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME} )) ||
        die '"ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME" not set'

    # If debugging zeshy, print modification times for zeshy's user digest file
    # and the newest path such file depends upon.
    is_zeshy_verbose_and {
        [[ -f "${ZESHY_USER_DIGEST_FILE}" ]] &&
            print "zeshy: digest mtime:                   $(zstat +mtime "${ZESHY_USER_DIGEST_FILE}")"
            print "zeshy: digest newest dependency mtime: ${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME}"
    }

    # Source all applicable zeshy scripts and hence functions.
    source -- "${ZESHY_HOME}/compile"

    # Set the modification time of such digest to that of the newest
    # modification time to avoid recompilation on the next zeshy run.
    touch -m\
        --date=@${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME}\
        -- "${ZESHY_USER_DIGEST_FILE}"

    # Declare all functions defined by such digest to be autoloadable.
#   print "autoloading \"${ZESHY_USER_DIGEST_FILE}\"..."
    autoload -w -- "${ZESHY_USER_DIGEST_FILE}" ||
        die "\"${ZESHY_USER_DIGEST_FILE}\" cannot be compiled"
}

# ....................{ MAIN                               }....................
digest_zeshy

# --------------------( WASTELANDS                         )--------------------
#FUXME: There exists a subtle race condition that will (probably) become
#increasingly less subtle as zeshy development proceeds. If a second zeshy shell
#is run while the first is still compiling its digest file, the second could
#conceivably attempt to k
#FUXME: Rename ${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME} to
#${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME}. Even the latter's longer than
#I'd like, but at least it's not *OBSCENELY* long, as the former is. Consider
#renaming "_modification_time" to "_mtime" everywhere, as well. As with "args",
#"stdin", etc., "mtime" is a commonly recognized abbreviation. We just *CAN'T*
#keep writing "_modification_time" everywhere. It's equally annoying to write
#and read.
    # Prepare for such compilation.
#   digest_zeshy_compile_setup
#FUXME: Shift remaining functionality into above function.
#set_function_documentation digest_zeshy_compile_setup '
#void digest_zeshy_setup(void)
#
#Assuming Zeshy''s user digest file to be outdated, implement aliases and
#functions required only for compiling an outdated digest file.
#'
#function digest_zeshy_compile_setup() {
#    # Validate sanity.
#    (( # == 0 )) || die 'expected no arguments'
#}

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #FUXME: *THIS IS ABSURD*. It's currently working, yes. But there's no
    #reason to perform such heavy-weight functionality here. Shift *ALL* such
    #documentation functionality to "always/00-setup/00-document/document".
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #FUXME: Define a new document_function_glob() or
    #document_function_sans_filename_globbing() or
    #document_function_and_disable_filename_globbing(). Yes, the latter. While
    #verbose, that's not necessarily a bad thing in this case, as such function
    #dramatically alters function parsing. In any case, such function should
    #define a new alias of the same name expanding as follows:
    #    alias ${function_name}="noglob ${function_name}"
    #
    #Test if such alias already exists before doing so, in which case throw an
    #exception or perhaps merely print a warning. (Nah, exception!)

    # ------------------< FUNCTIONS                          >------------------
    # Define document_function() before document_alias(), which documents itself
    # with the former function.
#   function document_function() {
        # Validate passed arguments.
#       (( # == 1 )) || die 'expected one documentation string'
#       local documentation="${1}" function_name
#       local -a function_names

        # If such documentation is prefixed by a function prototype, match the
        # relevant function name from such prototype. zsh permissively allows
        # function name declarations to be quoted and hence contain arbitrary
        # characters, necessitating a more lenient glob expression than liked.
        # Dismantled, this is:
        #
        # * "(#b)", capturing match groups into global list ${match}.
        # * "[[:space:]]#", matching optional whitespace.
        # * "[^[:space:]]##", matching the function return type.
        # * "[[:space:]]##", matching mandatory whitespace.
        # * "([^'(']##)", matching the function name into ${match[1]}.
        # * '(', matching the beginning of the function argument list.
#       if [[ "${documentation}" ==\
#           (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'(']##)'('* ]]; then
#           # Attempt to split such function name on " [or] " delimiters.
#           function_name="${match[1]}"
#           function_names=( "${(s: [or] :)function_name}" )

            # If such function name contains no such delimiters, document as is.
#           if (( ${#function_names} == 1 ))
#           then ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name}]="${documentation}"
            # Else, such function name contains at least one such delimiter.
            # Document each split function name with such documentation.
#           else
#               for function_name_split ("${function_names[@]}") {
#                   print "function name split: ${function_name_split}"
#                   ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name_split}]="${documentation}"
#               }
#           fi
#           print "function name: ${match[1]}"
        # Else, throw an exception with a portion of such documentation.
#       else die "help string \"${documentation[1,40]}...\" not prefixed by a function prototype"
#       fi
#   }

    # ------------------< ALIASES                            >------------------
#   function document_alias() {
        # Validate passed arguments.
#       (( # == 1 )) || die 'expected one documentation string'
#       local documentation="${1}"

        # If such documentation is prefixed by an alias prototype, match the
        # relevant alias name from such prototype. While zsh permissively allows
        # alias name declarations to be quoted and hence contain arbitrary
        # characters as with functions, such aliases are not runnable: e.g.,
        #
        #   >>> alias "o w s"="print 'revolt is dead; long live revolt'"
        #   >>> o\ w\ s
        #   zsh: command not found: o w s
        #
        # For simplicity, use a similar glob expression as document_function().
#       if [[ "${documentation}" ==\
#           (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'<']##)'<'* ]]
#       then ZESHY_ALIAS_NAME_TO_DOCUMENTATION[${match[1]}]="${documentation}"
#           print "function name: ${match[1]}"
        # Else, throw an exception with a portion of such documentation.
#       else die "help string \"${documentation[1,40]}...\" not prefixed by an alias prototype"
#       fi
#   }

    # ------------------< GLOBALS                            >------------------
#   set_global_documentation ZESHY_GLOBAL_TYPE_TO_DECLARATOR '
#ap ZESHY_GLOBAL_TYPE_TO_DECLARATOR

#ap variable type to the command prefix exporting globals of such type.
#'
#    typeset -Agx ZESHY_GLOBAL_TYPE_TO_DECLARATOR
#    ZESHY_GLOBAL_TYPE_TO_DECLARATOR=(
#        # Scalar types.
#        string    'export'
#        boolean   'export'
#        character 'export'
#        integer   'export -i'
#        float     'export -F'
#
        # Non-scalar types.
#        list     'export -a'
#        list_set 'export -Ua'

        # While "export -a" succeeds (as above), "export -A" fails with error.
        # Hence, revert to builtin typeset().
#        map 'typeset -Agx'
#    )

#    alias document_global='
#    {
#        # Localize the passed herestring.
#        local documentation__dg="$(< /dev/stdin)"

        # If such documentation is prefixed by a function prototype, match the
        # relevant function name from such prototype. zsh permissively allows
        # function name declarations to be quoted and hence contain arbitrary
        # characters, necessitating a more lenient glob expression than liked.
        # Dismantled, this is:
        #
        # * "(#b)", capturing match groups into global list ${match}.
        # * "[[:space:]]#", matching optional whitespace.
        # * "([^[:space:]]##)", matching the variable type into ${match[1]}.
        # * "[[:space:]]##", matching mandatory whitespace.
        # * "([[:IDENT:]]##)", matching the variable name into ${match[2]}.
        #
        # Else throw an exception with a portion of such documentation.
#        [[ "${documentation__dg}" ==\
#            (#b)[[:space:]]#([^[:space:]]##)[[:space:]]##([[:IDENT:]]##)* ]] ||
#            die "help string \"${documentation__dg[1,40]}...\" not prefixed by a variable declaration"

        #FUXME: If such global has been declared, we should probably print a
        #warning to standard error if its declared type differs from the
        #documentation-declared type. The implementation is a bit tedious,
        #however, requiring a new map ZESHY_GLOBAL_DECLARATOR_TO_TYPE
        #dynamically constructed from its converse for performing efficient
        #lookups. Clearly, not a priority for the moment.

        # If such global has not yet been declared, do so. Prefer globals
        # "${match[1]}" and "${match[2]}" to human-readable local variables to
        # avoid polluting the local shell environment any further. See
        # is_variable() for implementation details.
#        [[ -n "${(P)match[2]+x}" ]] || {
            # If such global''s type is not a Zeshy-specific type, throw an
            # exception. See is_map_key() for implementation details.
#            (( ${+ZESHY_GLOBAL_TYPE_TO_DECLARATOR[${match[1]}]} )) ||
#                die "\"${match[1]}\" not a zeshy type"

            # Declare such global.
#           ${(z)ZESHY_GLOBAL_TYPE_TO_DECLARATOR[${match[1]}]} "${match[2]}"
#       }

        # Document such global.
#       ZESHY_GLOBAL_NAME_TO_DOCUMENTATION[${match[2]}]="${documentation__dg}"
    #   print "function name: ${match[1]}"
#   } <<<'

# Undefine lower-level documentators, hereafter replaced by the previously
# defined higher-level documentators. Do so here for code convenience rather
# than necessity.
#unfunction\
#    set_alias_documentation\
#    set_function_documentation\
#    set_global_documentation

# ....................{ ALIASES                            }....................
# Define aliases subsequently expanded by Zeshy's user configuration files,
# defined here rather than in "config" to avoid excessive global variables.
# (Namely, a new global boolean ${ZESHY_USER_DIGEST_FILE_IS_OUTDATED} would be
# required for tracking such state.)

#ZESHY_CORE_HELP_FUNCTIONS+='
#void document_alias(string documentation)
#
#If called when recompiling Zeshy''s user digest file, document the alias
#prefixing the passed string with such string; else, do nothing.
#'
#FUXME: Document prototype syntax, including "[or]" delimiters.
#set_function_documentation document_function '
#void document_function(string documentation)
#
#If called when recompiling Zeshy''s user digest file, document the function
#prefixing the passed string with such string; else, do nothing.
#'
#set_alias_documentation document_global '
#void document_global<string documentation>
#
#If called when recompiling Zeshy''s user digest file, globally export the global
#prefixing the passed string with the Zeshy-specific type (e.g., "list", "float")
#prefixing the passed string *AND* document such global with such string; else,
#do nothing.
#'
## For efficiency when not recompiling Zeshy's user digest file, default such
# runnables to noop. When recompiling such file, redefine such runnables to
# actually document the passed object.
#alias document_alias=':' document_function=':' document_global=':'

#FUXME: It's not difficult to see the list of dependency pathnames growing over
#time, possibly in OS- and distro-specific directions. (It's unclear whether BSD
#also uses "/etc/mailcap", for example.) In any case, it'd be nice to enable
#individual components (e.g., "path/file/mime") to append arbitrary paths to
#such dependency list. To do so, we'll need the customary adder function and
#corresponding global (e.g., add_zeshy_digest_dependency_path() and
#${ZESHY_DIGEST_DEPENDENCY_PATHS}). But that won't be enough. This function
#is called before digest autoloading and hence requires... unconventional access
#to such global. The simplest and sanest approach is as follows:
#
#* Immediately before *OR* after digest compilation but certainly after calling
#  precompile_zeshy() and before calling startup_zeshy(), cache the contents of
#  ${ZESHY_DIGEST_DEPENDENCY_PATHS} to a new user-specific dotfile -- say,
#  "~/.zeshy/cache/digest.paths".
#* In is_zeshy_digest_outdated(), if such dotfile does *NOT* exist, Zeshy cannot
#  have been compiled before, so the digest file is outdated (test this at the
#  very front of the function as usual); else, source such
#  dotfile and interpolate the resulting global into the list of iterated
#  dependency paths. We probably should *NOT* inject the current user's ${PATH}
#  into such list, to avoid synchronicity issues; it's no less efficient (and is
#  certainly safer) to simply reinterpolate the ${path} on each call to this
#  function: e.g.,
#
#      for dependency_pathname ("${path[@]}" "${ZESHY_DIGEST_DEPENDENCY_PATHS[@]}") {
#
#Should be reasonably efficient, all things considered. In fact, it might
#eventually be *MORE* efficient than the current approach. Why? Because
#the add_zeshy_digest_dependency_path() function can internally test whether or
#not such path actually exists -- and, if not... Oh, wait. *DON'T* do that. The
#path could be added later, at which point we'd want to consider that. O.K.; so,
#it'll never be more efficient. But, hey: can't have everything.

#FUXME: Actually, let's just centralize everything in "compile". Much more
#intelligible, particularly after we've also shifted out the existing
#documentation stuff!
#FUXME: This file needs a bit of work. First, *NO* alias defined below should
#induce a fatal error at Zeshy startup, even if the corresponding command does
#not exist on the current system: print a warning and move. Currently, my whole
#setup is dying because "lsmod" no longer exists due to the "kmod" switch; ugh.
#FUXME: Second, I suddenly conceived this morning of why startup has become so
#hideously slow. We're actually reparsing *ALL* such aliases on each Zeshy
#startup. This is, to put it bluntly, insanity. We need instead to shift the
#current startup function iteratively defining such aliases into precompile_zeshy(),
#thus confining such definition to digest recompilation. Ideally, this should
#see a significant improvement in runtime efficiency.

    # If true, recompile Zeshy's user digest file. If already set, inherit such
    # variable's value from the caller (e.g., component "main").
#   local ZESHY_USER_DIGEST_FILE_IS_COMPILING="${ZESHY_USER_DIGEST_FILE_IS_COMPILING-}"

    # If Zeshy's user digest file is outdated, record such fact.
#   is_zeshy_digest_outdated &&
#       ZESHY_USER_DIGEST_FILE_IS_COMPILING=${ZESHY_BOOLEAN_TRUE}

    # If compiling such file, prepare for such compilation.
#   [[ -n "${ZESHY_USER_DIGEST_FILE_IS_COMPILING}" ]] &&

#FUXME: This isn't right. *sigh* We need to do this *BEFORE* sourcing
#configuration files, which call documentation methods. Unfortunately, that
#breeds a circularity conflict: configuration sources must be sourced *BEFORE*
#calling is_zeshy_digest_outdated(). The solution is clear: retain the new
#calling order, which is demonstrably superior; to solve the documentation
#issue, simply define... Wait. That's not quite it. O.K.; here goes: the check
#in is_zeshy_digest_outdated shouldn't depend on configuration file values. If
#you think about it, this makes both inherent sense and improves the robustness
#of the whole process (by eliminating yet-another-obscure-dependency). So:
#
#* Revert to the prior calling order. We *NEED* to determine whether or not the
#  digest is outdated *BEFORE* sourcing configuration files in order to define
#  documentation aliases properly. (So, shift us back! Sorry, sorry.)
#* Change the test in is_zeshy_digest_outdated() from expanding to
#  is_zeshy_verbose_and() to... well, what? How about this:
#  * Check whether or not the parent directory of ${ZESHY_HOME} contains a
#    ".git" directory; if it does, consider that equivalent to "debugging."
#FUXME: Nope! Nix all that. This is actually the way to go. So how do we enable
#documentation in config files then? Pretty simple, and, if you consider it, the
#only reasonable way it can be done. Consider this: after upgrading Zeshy or
#perhaps simply deleting existing config files, sourcing such files only once
#prior to copying such files back during digest recompilation guarantees that
#Zeshy will *NEVER* document globals in such files. In other words,
#the way we were doing it could *NEVER* have reasonably worked. So what to do?
#Simple: just source all config files *AT ONCE* by re-calling
#source_zeshy_configuration() immediately *AFTER* compiling Zeshy's digest but
#*BEFORE* calling precompile_zeshy() (for obvious reasons). The easiest way to
#accomplish this, of course, is simply to prepend "source_zeshy_configuration"
#to the beginning of global list ${ZESHY_COMMANDS_TO_MAKE_ZESHY}. Brilliant --
#but should be voluminously documented, of course. It's *INCREDIBLY* subtle.
#Not sure how I ever even caught on to all this...
#FUXME: This suggests a few optimizations:
#
#* There's actually *NO* point to sourcing configuration files before
#  recompiling the digest aside from ensuring ${ZESHY_IS_DEBUG} is set and
#  debug messages are printed during such recompilation. To put it bluntly,
#  there *MUST* be a simpler, faster way of ensuring the same functionality.
#  Again, the simplest way is probably testing *ONCE* up-front for a sibling
#  directory ".git" of the parent of "${ZESHY_HOME}"; it's a fast test: cache it
#  *ONLY* if recompiling Zeshy and we move on. (If not recompiling Zeshy, we
#  shouldn't need such shennanigans.)
#* Given that, *STOP* sourcing configuration files as the first action performed
#  on Zeshy startup. Instead:
#  * If such digest is outdated, prepend "source_zeshy_configuration" to
#    ${ZESHY_COMMANDS_TO_MAKE_ZESHY} as discussed above.
#  * Else, call source_zeshy_configuration() manually. Hmm. We *could* simply
#    prepend "source_zeshy_configuration" to ${ZESHY_COMMANDS_TO_STARTUP_ZESHY}.
#    That has the sole downside of causing such configuration to be sourced twice
#    when recompiling such digest. On the other hand, it's probably more readable.
#    *shrug* It doesn't particularly matter which we adopt, honestly.
#* Rename "setup" to "config". (See such component for details). That implies that
#  we call "source_zeshy_component config" rather than "source_zeshy_configuration"
#  above, in which case I don't really see the benefit to prepending such command
#  to arrays. Just call "source_zeshy_component config" as is exactly where we
#  require it.
#* Shift source_zeshy_component() to "always/zeshy/zeshy". (Extremely silly to
#  have such febrile functionality at the top-level, wasn't it?)
#* Add new command-line option "-v, --verbose" and remove existing configuration
#  option ${ZESHY_IS_DEBUG}. The latter turns out to have been a *REALLY*
#  bad idea that's just not needed anymore and couldn't really be reliably
#  supported in any case.
#* Rename is_zeshy_verbose_and<> to is_zeshy_verbose_and<>.
#Phew! That's quite a lot of requisite changes, but... well, we'll be
#demonstrably better for each one.
    # If true, Zeshy''s user digest file is outdated. Defaults to false.
#   local ZESHY_USER_DIGEST_FILE_IS_OUTDATED=${ZESHY_BOOLEAN_FALSE}

#FUXME: Third, is_zeshy_digest_outdated() needs to recursively depend on the
#newest config file. Make it so, aye!

    # The former contain commands and the latter define globals on which Zeshy's
    # digest compilation depends. The current implementation is hardly ideal,
    # Append to such list the modification time of Zeshy's newest user
    # configuration file, ensuring digest recompilation on changes to such files
    # (especially changes to interactive alias names necessitating redefinition
    # of the functions implementing such aliases). While this is a non-
# Explicitly define such globals to default values. When not doing so, such
# globals erroneously inherit their default values from the parent shell,
# typically resulting in Zeshy recompiling its user digest file on each startup.

#FUXME: Pretty sure we don't need these anymore, now that we've glued this file
#back together. Phew!

    # Oddly, zsh has no means of directly associating the two.
        #FUXME: Hmmmm; I reckon we can remove the same line in "compile" by
        #shifting this line *UP* out of this conditional. Source such config
        #files immediately after calling digest_setup_digest() and we should be
        #good to go whether or not the digest is outdated, yes?

        # Source Zeshy's user configuration files. It doesn't particularly
        # matter whether we do so before or after autoloading Zeshy's user
        # digest file, simply that we do so.
#       source -- "${ZESHY_HOME}/config"

#Prepare Zeshy for subsequent startup and possible user digest file compilation.
#Specifically, ascertain whether such file requires compilation and source all
#applicable user configuration files.
#
#Render all Zeshy functions applicable to the current user autoloadable after
#recompiling such functions into the Zeshy digest file for such user.

    # If true, Zeshy''s user digest file was outdated at Zeshy startup. See
#   boolean ZESHY_USER_DIGEST_FILE_IS_OUTDATED=${ZESHY_BOOLEAN_TRUE}

    # Unless Zeshy's user digest file is outdated, immediately return.
#   is_zeshy_digest_outdated || return 0

#FUXME: Rename to digest_zeshy() after shifting. (Yes, use "digest" as a verb.
#It's a well-established verb and much better explains the function's purpose.)
        #FUXME: I''m no longer convinced such implicit declarations are a good
        #thing. In fact, the harder I look at the issue, the more clearly I see
        #that it''s probably a bad idea likely to blow up at some future point.
        #There are a few issues here:
        #
        #* It''s odd that a documentation-specific runnable declares objects.
        #  It shouldn''t. That''s not the expectation. Certainly, neither
        #  document_alias() or document_function() behave that way.
        #* It doesn''t really gain us anything... except brevity. *ALOT* of
        #  brevity. Hmm.
#set_global_documentation ZESHY_USER_DIGEST_FILE_IS_OUTDATED '
#boolean ZESHY_USER_DIGEST_FILE_IS_OUTDATED
#
#If true, Zeshy''s user digest file was outdated at Zeshy startup. See
#is_zeshy_digest_outdated() for further details.
#'
#export ZESHY_USER_DIGEST_FILE_IS_OUTDATED=${ZESHY_BOOLEAN_FALSE}

#document_function '
#void autoload_zeshy(void)
#
#Autoload Zeshy functions and functions and variables defined by zsh modules.
#'
#function autoload_zeshy() {
#    (( # == 0 )) || die 'expected no arguments'
#    autoload_zeshy_zsh_modules
#    autoload_zeshy_functions
#}

#Render all Zeshy functions applicable to the current user autoloadable after
#recompiling such functions into the Zeshy digest file for such user, setting
#the modification time of such file to global ${ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MTIME}

#FUXME: This could be a nice opportunity to truncate "main" a bit. I'd
#specifically like to see get_script_name() shifted into "shell/shell" and
#say() and cry() shifted into "shell/output".

#   zmodload -abi zsh/datetime strftime
    #   never profile in the intended manner.
    #   such profiling is both wasteful where not immediately
    #   utilized and not cost-free and could in the
    #   amortization of all such costs become prohibitively expensive.
#   zmodload -abi zsh/zprof zprof
    # If ignoring Zeshy's user directory, pretend the digest file under such
    # directory to be outdated. This induces Zeshy to source all appropriate
    # scripts manually, below.
#   [[ -n "${ZESHY_DOT_DIR}" ]] || return 0

    # Validate passed arguments.
#   (( # == 1 )) || die 'expected one integer'
#   string digest_mtime="${1}"
#   [[ "${digest_mtime}" == <-> ]] ||
#       die "\"${digest_mtime}\" not a nonnegative integer"

    # Otherwise, source all user configuration files. Since the above condition
    # implicitly sources such files already, do so when not recompiling here.
#   else
        # If the current user's Zeshy configuration dir exists but is empty,
        # throw an exception. Despite having previously tested for this, do so
        # again in the unlikely event of a race condition in which such user
        # deleted such files in between the prior and current tests. If such an
        # event occurs and we fail to throw an exception here, calling "source"
        # below with no arguments results in an undecipherable error resembling
        # "source: not enough arguments".
#       list user_config_filenames
#       user_config_filenames=( "${ZESHY_USER_CONFIG_DIR}/"* )
#       (( #user_config_filenames )) or
#           die "configuration dir \"${ZESHY_USER_CONFIG_DIR}\" empty"

        # Otherwise, source the current user's Zeshy configuration files.
#       source -- "${user_config_filenames[@]}"
#   fi

#   if [[ -d "${ZESHY_USER_CONFIG_DIR}" ]]; then
#   source -- "${user_config_filenames[@]}"
#       list zeshy_user_config_dir_if_nonempty
#       zeshy_user_config_dir_if_nonempty=( "${ZESHY_USER_CONFIG_DIR}"(/F) )
#       (( #zeshy_user_config_dir_if_nonempty )) or
#           die "zeshy configuration dir \"${ZESHY_USER_CONFIG_DIR}\" empty"

        #FUXME: O.K.; the dir could exist but have no files, in which case
        #source() spits out an error. Test this and die ourselves, since this
        #should never happen here! Test this here to avoid race conditions, in
        #case such files have been deleted since the similar test above.
#       source "${ZESHY_USER_CONFIG_DIR}/"*
    #FUXME: Is ${ZESHY_USER_CONFIG_DIR} guaranteed to exist at this point? If
    #not, returning true if such directory does not exist also seems sane.

    # ~~~~~~~~~~~~~~~~< ZSH                                >~~~~~~~~~~~~~~~~~~~~
    # ~~~~~~~~~~~~~~~~< ZESHY                              >~~~~~~~~~~~~~~~~~~~~
# Source (i.e., load) zsh modules and autoload Zeshy functions.
#       is -d '/bin'     si and digest_dependent_mtimes+=$(zstat +mtime '/bin')
#       is -d '/usr/bin' si and digest_dependent_mtimes+=$(zstat +mtime '/usr/bin')

#   is -f "${ZESHY_USER_CONFIG_FILE}" si and
#       digest_dependent_mtimes+=$(zstat +mtime "${ZESHY_USER_CONFIG_FILE}")
#        is -f "${ZESHY_USER_DIGEST_FILE}" si and
#        (( newest_mtime == $(zstat +mtime "${ZESHY_USER_DIGEST_FILE}") )); then
#to synchronize function definitions
    # with current system and user state
        # Find the maximum of this and the prior modification time.
#       (( zeshy_dev_mtime > zeshy_mtime )) and zeshy_mtime="${zeshy_dev_mtime}"

    #FUXME: Hmmmm; O.K.; I have a dramatic improvement here, but I'm simply too
    #lazy to implement it. Not hard; just lazy. Under the current approach, we
    #technically should also be considering the mtimes of "/etc/zsh/zshrc" and
    #"~/.zshrc", as both files may define a $PATH different from the last time
    #Zeshy was invoked. But, if you think about it, this run_quickly regresses into
    #insanity, because *ANY* profile script (e.g., "/etc/profile.env") could
    #conceivably set or augment $PATH (and probably does). So, we instead need
    #to simply test the following two things:
    #
    #* If no cache file exists or such a file exists but with insufficient or
    #  erroneous content, forego the tests below and *JUST* recompile.
    #* The current (if undefined, default to empty string) against the cached
    #  value of $ZESHY_THEME.
    #* The current (if undefined, default to empty string) against the cached
    #  value of $PATH. This requires a cache file containing sourceable values,
    #  which we declare to be local prior to sourcing: say,
    #
    #       last_ZESHY_THEME="..."
    #       last_PATH="..."
    #
    #Simple. The catch is: when do we create this file? I'm beginning to
    #suspect that our definition of $PATH for interactive shells in
    #"always/shell/profile" may obstruct things a bit, here. Oh; no. That
    #doesn't work. It must be late. Clearly, that fails to account for... well,
    #pretty much everything. Back to le drawing board.

    # If the digest file does not exist or does but is older than Zeshy's last
    # modification time, recompile this file to synchronize compiled function
    # definitions with newer Zeshy changes.
#   integer\
#         zeshy_mtime=$(zstat +mtime "${ZESHY_USER_CONFIG_DIR}")\
#         zeshy_mtime=$(zstat +mtime "${ZESHY_USER_CONFIG_FILE}")\
#           bin_mtime=$(zstat +mtime '/bin')\
#       usr_bin_mtime=$(zstat +mtime '/usr/bin')
#   ((     bin_mtime > zeshy_mtime )) and zeshy_mtime="${bin_mtime}"
#   (( usr_bin_mtime > zeshy_mtime )) and zeshy_mtime="${usr_bin_mtime}"
